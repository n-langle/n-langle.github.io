<!DOCTYPE html>
<html>

<head>
	<meta name="viewport" content="initial-scale=1.0,maximum-scale=1.0,user-scalable=no" />
	<meta charset="utf-8">
	<link rel="icon" type="image/png"
		href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAMAAAAoyzS7AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyhpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTQwIDc5LjE2MDQ1MSwgMjAxNy8wNS8wNi0wMTowODoyMSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTggKE1hY2ludG9zaCkiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6NjI2QjdCNzk5MzA5MTFFOEFERERDQ0U0Njc3NUIzODciIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6NjI2QjdCN0E5MzA5MTFFOEFERERDQ0U0Njc3NUIzODciPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo2MjZCN0I3NzkzMDkxMUU4QURERENDRTQ2Nzc1QjM4NyIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo2MjZCN0I3ODkzMDkxMUU4QURERENDRTQ2Nzc1QjM4NyIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/Ppp54RwAAAAGUExURf///wAAAFXC034AAAAMSURBVHjaYmAACDAAAAIAAU9tWeEAAAAASUVORK5CYII=" />
	<style>
		.obj-interface .ctn-wagon .wagon .icon svg,
		.obj-interface .title .icon svg {
			fill: #666
		}

		a,
		abbr,
		acronym,
		address,
		applet,
		article,
		aside,
		audio,
		b,
		big,
		blockquote,
		body,
		canvas,
		caption,
		center,
		cite,
		code,
		dd,
		del,
		details,
		dfn,
		div,
		dl,
		dt,
		em,
		embed,
		fieldset,
		figcaption,
		figure,
		footer,
		form,
		h1,
		h2,
		h3,
		h4,
		h5,
		h6,
		header,
		hgroup,
		html,
		i,
		iframe,
		img,
		ins,
		kbd,
		label,
		legend,
		li,
		mark,
		menu,
		nav,
		object,
		ol,
		output,
		p,
		pre,
		q,
		ruby,
		s,
		samp,
		section,
		small,
		span,
		strike,
		strong,
		sub,
		summary,
		sup,
		table,
		tbody,
		td,
		tfoot,
		th,
		thead,
		time,
		tr,
		tt,
		u,
		ul,
		var,
		video {
			margin: 0;
			padding: 0;
			border: 0;
			font: inherit;
			vertical-align: baseline
		}

		.obj-banner,
		.obj-header {
			box-sizing: border-box;
			font-family: Helvetica, Arial, sans-serif
		}

		article,
		aside,
		details,
		figcaption,
		figure,
		footer,
		header,
		hgroup,
		menu,
		nav,
		section {
			display: block
		}

		body {
			-webkit-user-select: none;
			-moz-user-select: none;
			-ms-user-select: none;
			user-select: none;
			line-height: 1
		}

		ol,
		ul {
			list-style: none
		}

		blockquote,
		q {
			quotes: none
		}

		blockquote:after,
		blockquote:before,
		q:after,
		q:before {
			content: '';
			content: none
		}

		table {
			border-collapse: collapse;
			border-spacing: 0
		}

		@font-face {
			font-family: Dimbo;
			src: url('data:application/x-font-woff;charset=utf-8;base64,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') format('woff2');
			font-weight: 400;
			font-style: normal
		}

		button {
			-webkit-appearance: none;
			-moz-appearance: none;
			appearance: none;
			background: 0 0;
			border: 0;
			padding: 0
		}

		.button {
			background: #ff5151;
			border-radius: 5px;
			color: #fff;
			cursor: pointer;
			display: inline-block;
			font-size: .625em;
			font-weight: 700;
			padding: 1em
		}

		#App,
		body,
		html {
			background-color: #dfdfdf;
			background-position: center center;
			background-repeat: no-repeat;
			background-size: cover;
			height: 100%;
			overflow: hidden;
			width: 100%
		}

		.obj-banner::before,
		.obj-header::before {
			background: #000;
			height: 100%;
			opacity: .5;
			content: ""
		}

		#App>svg:first-child {
			left: -10000px;
			position: absolute;
			top: -10000px
		}

		#App {
			position: relative;
			z-index: 0
		}

		#App canvas {
			height: 100%;
			width: 100%
		}

		.obj-banner {
			bottom: 0;
			color: #fff;
			display: table;
			left: 0;
			padding: 1em 1.5em;
			position: fixed;
			text-align: center;
			-webkit-transition: -webkit-transform .25s ease-out;
			transition: transform .25s ease-out;
			width: 100%;
			z-index: 100
		}

		.obj-banner::before {
			left: 0;
			position: absolute;
			top: 0;
			width: 100%
		}

		.obj-banner>div {
			display: table-cell;
			position: relative;
			vertical-align: middle;
			z-index: 2
		}

		.obj-banner h1 br,
		.obj-header {
			display: none
		}

		.obj-banner>div:first-child {
			width: 3em
		}

		.obj-banner>div:nth-child(2) {
			line-height: 1em;
			padding: 0 1em;
			text-align: left
		}

		.obj-banner small {
			font-size: .75em;
			font-weight: 700
		}

		.obj-banner img {
			border-radius: .25em;
			vertical-align: text-bottom;
			width: 100%
		}

		#App[data-current-screen=end] .obj-banner {
			-webkit-transform: translateY(100%);
			-ms-transform: translateY(100%);
			transform: translateY(100%)
		}

		.obj-header {
			left: 0;
			padding: 1em 1.5em;
			position: fixed;
			text-align: center;
			top: 0;
			-webkit-transition: -webkit-transform .25s ease-out;
			transition: transform .25s ease-out;
			width: 100%;
			z-index: 100
		}

		.obj-header::before {
			left: 0;
			position: absolute;
			top: 0;
			width: 100%
		}

		.obj-header.is-visible {
			display: block
		}

		.obj-header p {
			color: #fff;
			font-size: 1em;
			font-weight: 900;
			position: relative;
			z-index: 1
		}

		#App[data-current-screen=end] .obj-header {
			-webkit-transform: translateY(-100%);
			-ms-transform: translateY(-100%);
			transform: translateY(-100%)
		}

		.obj-interface {
			color: red
		}

		.obj-interface .title {
			font-size: 4em;
			left: 50%;
			margin: -2em 0 0;
			position: absolute;
			top: 50%;
			white-space: nowrap;
			width: auto
		}

		.obj-interface .title span {
			display: inline-block;
			vertical-align: middle
		}

		.obj-interface .title .icon {
			width: .5em
		}

		.obj-interface .title .icon:first-child {
			-webkit-transform: scale(-1, 1);
			-ms-transform: scale(-1, 1);
			transform: scale(-1, 1)
		}

		.obj-interface .ctn-score {
			left: 1em;
			position: absolute;
			text-align: left;
			top: 2em
		}

		.obj-interface .ctn-score .score {
			text-shadow: .05em -.05em 0 rgba(0, 0, 0, .3), .05em -.05em 0 currentColor;
			font-size: 2.5em
		}

		.obj-interface .ctn-score .best-score {
			color: #fff;
			font-size: 1.5em
		}

		.obj-interface .ctn-wagon {
			position: absolute;
			right: 1em;
			text-align: right;
			top: 2.25em;
			width: 10em
		}

		.obj-interface .ctn-wagon .wagon {
			font-size: 1.5em;
			text-shadow: .07em .07em 0 rgba(0, 0, 0, .15)
		}

		.obj-interface .ctn-wagon .wagon .icon {
			display: inline-block;
			width: 1em
		}

		.obj-interface .ctn-wagon .best-wagon {
			color: #fff
		}

		.obj-interface .ctn-instruction {
			left: 10%;
			margin: 2em 0 0;
			position: absolute;
			top: 50%;
			text-align: center;
			width: 80%
		}

		.obj-interface .ctn-instruction p {
			display: inline-block;
			font-size: 1.5em;
			max-width: 4em
		}

		.obj-interface .ctn-instruction p+p {
			margin-left: 2em
		}

		.obj-interface .ctn-instruction .icon {
			display: block;
			margin: 0 auto .5em;
			width: 3em
		}

		.obj-interface .ctn-instruction .icon svg {
			fill: currentColor;
			width: 100%
		}

		.obj-interface .title {
			opacity: 0;
			-webkit-transform: translateX(-50%) scale(.5);
			-ms-transform: translateX(-50%) scale(.5);
			transform: translateX(-50%) scale(.5);
			-webkit-transition: -webkit-transform .4s cubic-bezier(.175, .885, .32, 1.275);
			transition: transform .4s cubic-bezier(.175, .885, .32, 1.275)
		}

		.is-visible .obj-interface .title {
			opacity: 1;
			-webkit-transform: translateX(-50%) scale(1);
			-ms-transform: translateX(-50%) scale(1);
			transform: translateX(-50%) scale(1)
		}

		.obj-loader {
			-webkit-animation: loader 1s infinite ease-in-out;
			animation: loader 1s infinite ease-in-out;
			border: 6px solid #fff;
			border-radius: .75em;
			height: 2em;
			margin: 0 auto;
			width: 2em
		}

		@-webkit-keyframes loader {
			0% {
				opacity: .25;
				-webkit-transform: rotate(0);
				transform: rotate(0)
			}

			50% {
				opacity: 1
			}

			100% {
				opacity: .25;
				-webkit-transform: rotate(360deg);
				transform: rotate(360deg)
			}
		}

		@keyframes loader {
			0% {
				opacity: .25;
				-webkit-transform: rotate(0);
				transform: rotate(0)
			}

			50% {
				opacity: 1
			}

			100% {
				opacity: .25;
				-webkit-transform: rotate(360deg);
				transform: rotate(360deg)
			}
		}

		.screen-container {
			color: red;
			font-family: Dimbo
		}

		.obj-screen {
			left: -100%;
			opacity: 0;
			position: absolute;
			text-align: center;
			width: 100%;
			z-index: 2
		}

		.obj-screen.is-visible {
			left: 0;
			opacity: 1
		}

		.obj-screen.is-hidden {
			display: block;
			left: -100%;
			opacity: 0
		}

		.obj-screen .v-align-center {
			position: absolute;
			top: 50%;
			-webkit-transform: translateY(-50%);
			-ms-transform: translateY(-50%);
			transform: translateY(-50%);
			width: 100%
		}

		.background-before::before {
			background-color: #000;
			background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR4AWNwL/BhAAADCQEEiiqnjQAAAABJRU5ErkJggg==);
			background-repeat: repeat;
			background-size: auto;
			content: "";
			height: 100%;
			left: 0;
			opacity: .3;
			position: absolute;
			top: 0;
			width: 100%
		}

		.background-before>* {
			position: relative
		}

		.screen-container.perspective-enabled {
			-webkit-perspective: 500px;
			perspective: 500px
		}

		.screen-container.perspective-enabled>* {
			-webkit-transform: translateY(-5em) rotateY(20deg) rotateX(45deg) rotateZ(-10deg);
			transform: translateY(-5em) rotateY(20deg) rotateX(45deg) rotateZ(-10deg)
		}

		.obj-screen.screen-end-of-level {
			background: rgba(0, 0, 0, .3);
			height: 100%
		}

		.obj-screen.screen-end-of-level .title {
			color: #fff;
			font-size: 3em
		}

		.obj-screen.screen-end-of-level .title strong {
			font-size: 1.5em;
			text-shadow: .05em -.05em 0 #666
		}

		.obj-screen.screen-end-of-level .title .icon {
			width: 1em
		}

		.obj-screen.screen-end {
			color: #fff;
			height: 100%;
			line-height: 2em;
			width: 100%
		}

		.obj-screen.screen-end.background-before::before {
			opacity: .75
		}

		.obj-screen.screen-end .landscape {
			font-size: .5em
		}

		.obj-screen.screen-end img {
			border-radius: 1em;
			margin-bottom: .75em;
			width: 5em
		}

		.obj-screen.screen-end h2 {
			font-size: 1.5em;
			font-weight: 700;
			margin-bottom: .5em
		}

		.obj-screen.screen-end h2 span {
			display: none
		}

		.obj-screen.screen-end h2 span.is-visible {
			display: block
		}

		.obj-screen.screen-end .txt {
			line-height: 1.1em;
			margin-bottom: 1em
		}

		.obj-screen.screen-end .button {
			background: 0 0;
			border-radius: 0;
			font-size: 1em;
			line-height: 1em;
			margin: .75em 0;
			padding: .5em 2em;
			-webkit-perspective: 500px;
			perspective: 500px
		}

		.obj-screen.screen-end .button::before {
			-webkit-transform: translateZ(-40px) translateX(-5%) rotateY(-30deg);
			transform: translateZ(-40px) translateX(-5%) rotateY(-30deg)
		}

		.obj-screen.screen-end .button~.button {
			margin-bottom: 0
		}

		.obj-screen.screen-end .button~.button::before {
			-webkit-transform: translateZ(-40px) translateX(5%) rotateY(30deg);
			transform: translateZ(-40px) translateX(5%) rotateY(30deg)
		}

		.obj-screen.screen-end .v-align-center>* {
			opacity: 0;
			-webkit-transform: translateY(100px);
			-ms-transform: translateY(100px);
			transform: translateY(100px);
			-webkit-transition: -webkit-transform .25s ease-out, opacity .25s ease-out;
			transition: transform .25s ease-out, opacity .25s ease-out
		}

		.obj-screen.screen-end .v-align-center .txt {
			-webkit-transition-delay: .1s;
			transition-delay: .1s
		}

		.obj-screen.screen-end .v-align-center .button {
			-webkit-transition-delay: .2s;
			transition-delay: .2s
		}

		.obj-screen.screen-end .v-align-center .or {
			-webkit-transition-delay: .3s;
			transition-delay: .3s
		}

		.obj-screen.screen-end .v-align-center .or+.button {
			-webkit-transition-delay: .4s;
			transition-delay: .4s
		}

		.obj-screen.screen-end.is-visible .v-align-center>* {
			opacity: 1;
			-webkit-transform: translateY(0);
			-ms-transform: translateY(0);
			transform: translateY(0)
		}

		.obj-screen.screen-loading {
			background: #000;
			color: #fff;
			height: 100%;
			text-align: center;
			width: 100%;
			z-index: 200
		}

		.obj-screen.screen-loading h1 {
			font-weight: 900;
			margin: 0 0 1em;
			text-transform: uppercase
		}

		.obj-screen.screen-start {
			height: 100%
		}
	</style>
	<style type='text/css'>
		/**/
		#App {
			font-family: Helvetica;
		}


		/**/
		.obj-screen.screen-loading {
			background-color: #000000;
			background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR4AWNwL/BhAAADCQEEiiqnjQAAAABJRU5ErkJggg==');
			background-position: center center;
			background-repeat: repeat;
			background-size: auto;
		}


		/**/
		.obj-screen.screen-loading h1 {
			color: #ffFFFf;
			font-size: 1em;
			font-weight: 900;
			text-transform: uppercase;
		}


		/**/
		.obj-header::before {
			background-color: #000000;
			background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR4AWNwL/BhAAADCQEEiiqnjQAAAABJRU5ErkJggg==');
			background-position: center center;
			background-repeat: repeat;
			background-size: auto;
			opacity: 0.5;
		}


		/**/
		.obj-header p {
			color: #ffffff;
			font-size: 1em;
			text-align: center;
		}


		/**/
		.obj-interface {
			color: #ff0000;
		}

		/**/
		.obj-banner::before {
			background-color: #000000;
			background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR4AWNwL/BhAAADCQEEiiqnjQAAAABJRU5ErkJggg==');
			background-position: center center;
			background-repeat: repeat;
			background-size: auto;
			opacity: 0.5;
		}


		/**/
		.obj-screen.screen-end.background-before::before {
			background-color: #000000;
			background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR4AWNwL/BhAAADCQEEiiqnjQAAAABJRU5ErkJggg==');
			background-position: center center;
			background-repeat: repeat;
			background-size: auto;
			opacity: 0.5;
		}


		/**/
		.obj-screen.screen-end {
			color: #ffffff;
		}


		/**/
		.obj-screen.screen-end .retry {
			color: #ffffff;
			font-size: 1em;
			font-weight: 700;
			text-transform: uppercase;
		}


		/**/
		.obj-screen.screen-end .retry::before {
			background-color: #ff0000;
			background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR4AWNwL/BhAAADCQEEiiqnjQAAAABJRU5ErkJggg==');
			background-position: center center;
			background-repeat: repeat;
			background-size: auto;
			opacity: 1;
		}


		/**/
		.obj-screen.screen-end .download {
			color: #ffffff;
			font-size: 1em;
			font-weight: 700;
			text-transform: uppercase;
		}


		/**/
		.obj-screen.screen-end .download::before {
			background-color: #ccc;
			background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR4AWNwL/BhAAADCQEEiiqnjQAAAABJRU5ErkJggg==');
			background-position: center center;
			background-repeat: repeat;
			background-size: auto;
			opacity: 1;
			cursor: default;
		}


		/**/
		.obj-banner::before {
			background-color: #000000;
			background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR4AWNwL/BhAAADCQEEiiqnjQAAAABJRU5ErkJggg==');
			background-position: center center;
			background-repeat: repeat;
			background-size: auto;
			opacity: 0.5;
		}


		/**/
		.obj-banner {
			color: #ffffff;
		}


		/**/
		.obj-banner .button {
			background-color: #ccc;
			background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR4AWNwL/BhAAADCQEEiiqnjQAAAABJRU5ErkJggg==');
			background-position: center center;
			background-repeat: repeat;
			background-size: auto;
			border-radius: 0.5em;
			color: #ffffff;
			font-size: 0.75em;
			font-weight: 700;
			text-transform: uppercase;
			cursor: default;
		}

	</style>

	<script type='text/javascript'>
		window._voodooProvider = 'applovin'
	</script>
</head>

<body>

	<div id="App">

		<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
			<symbol viewBox="0 0 28.97 25.62" id="arrow-flip" xmlns="http://www.w3.org/2000/svg">
				<path
					d="M27.54 18.54l-4.13-4.13-1.43 1.4 3.21 3.21a21 21 0 0 1-10-2c6.74-4.61 6.14-7.11 6.31-9.5S19.49-.11 14.71.01 6.49 3.87 6.49 7.74c0 3.23 1.35 6.57 5.09 9.29C4.97 20.34 0 19.81 0 19.81v1.88a24.91 24.91 0 0 0 13.33-3.54l.79.43a24.89 24.89 0 0 0 11.07 2.3l-3.31 3.31 1.43 1.43 4.23-4.22 1.43-1.43zM8.38 7.86a6.18 6.18 0 0 1 6.33-5.92c4.57 0 4.8 4.63 4.8 6.15s-.26 4.48-6 7.89c-4.85-3.56-5.13-6.12-5.13-8.12z">
				</path>
			</symbol>
			<symbol viewBox="0 0 28.97 16.38" id="arrow-speed" xmlns="http://www.w3.org/2000/svg">
				<path
					d="M23.79 3.55l-1.34 1.33 2.85 2.85H0v1.99h25.3l-2.94 2.95 1.33 1.34 3.94-3.95 1.34-1.33-5.18-5.18z">
				</path>
				<path
					d="M16.95 11.15l-.66.67 1.42 1.42H5.06v1h12.65l-1.47 1.47.66.67 1.98-1.97.66-.67-2.59-2.59zM11.7 0l-.72.72 1.53 1.53H0v1.07h12.51L10.93 4.9l.72.72 2.12-2.12.71-.71L11.7 0z">
				</path>
			</symbol>
			<symbol viewBox="0 0 12.2 29.16" id="triangles" xmlns="http://www.w3.org/2000/svg">
				<path
					d="M0 5.81L5.04 0l1.28 1.93L0 5.81zM3.79 15.77l8.41-1.81v2.87l-8.41-1.06zM.46 24.05l2.63 5.11 2.77-1.23-5.4-3.88z">
				</path>
			</symbol>
			<symbol viewBox="0 0 29.37 25.61" id="wagon" xmlns="http://www.w3.org/2000/svg">
				<path
					d="M0 .92L29.37 0v4.68L0 5.6V.92zM4.5 6.7H1.56l1.47 11.84h21.85L26.62 6.7h-3.67l-.74 9.18H5.14L4.5 6.7z">
				</path>
				<circle cx="7.43" cy="22.67" r="2.94"></circle>
				<circle cx="20.38" cy="22.67" r="2.94"></circle>
			</symbol>
		</svg>

		<div class="obj-header">
			<p>Text for your header</p>
		</div>

		<div class="screen-container">
			<div class="obj-screen screen-loading is-visible">
				<div class="v-align-center">
					<h1>Tiny loops</h1>
					<div class="obj-loader"></div>
				</div>
			</div>

			<div class="obj-screen screen-start">
				<div class="obj-interface">
					<h1 class="title">
						<span class="icon"><svg viewBox="0 0 12.2 29.16">
								<use xlink:href="#triangles"></use>
							</svg></span>
						<span>Tiny Loops</span>
						<span class="icon"><svg viewBox="0 0 12.2 29.16">
								<use xlink:href="#triangles"></use>
							</svg></span>
					</h1>

					<div class="ctn-score">
						<p class="score">3338</p>
						<p class="best-score">
							<span>Best</span>
							<span>25610</span>
						</p>
					</div>

					<div class="ctn-wagon">
						<p class="wagon">
							<span class="icon"><svg viewBox="0 0 29.37 25.61">
									<use xlink:href="#wagon"></use>
								</svg></span>x<span>22</span>
						</p>
						<p class="best-wagon">
							<span>Best x</span>
							<span>59</span>
						</p>
					</div>

					<div class="ctn-instruction">
						<p class="speed">
							<span class="icon"><svg viewBox="0 0 28.97 16.38">
									<use xlink:href="#arrow-speed"></use>
								</svg></span>
							Hold to speed up
						</p>
						<p class="flip">
							<span class="icon"><svg viewBox="0 0 28.97 25.62">
									<use xlink:href="#arrow-flip"></use>
								</svg></span>
							Holdin air to flip
						</p>
					</div>
				</div>
			</div>

			<div class="obj-screen screen-game">
				<div class="obj-interface">
					<div class="ctn-score">
						<p class="score">3338</p>
						<p class="best-score">
							<span>Best</span>
							<span>25610</span>
						</p>
					</div>

					<div class="ctn-wagon">
						<p class="wagon">
							<span class="icon"><svg viewBox="0 0 29.37 25.61">
									<use xlink:href="#wagon"></use>
								</svg></span>x<span>22</span>
						</p>
						<p class="best-wagon">
							<span>Best x</span>
							<span>59</span>
						</p>
					</div>
				</div>
			</div>

			<div class="obj-screen screen-end-of-level">
				<div class="obj-interface">
					<h2 class="title">
						<span class="icon"><svg viewBox="0 0 12.2 29.16">
								<use xlink:href="#triangles"></use>
							</svg></span>
						<span><strong>Level</strong> <br />Complete!</span>
						<span class="icon"><svg viewBox="0 0 12.2 29.16">
								<use xlink:href="#triangles"></use>
							</svg></span>
					</h2>

					<div class="ctn-score">
						<p class="score">3338</p>
						<p class="best-score">
							<span>Best</span>
							<span>25610</span>
						</p>
					</div>

					<div class="ctn-wagon">
						<p class="wagon">
							<span class="icon"><svg viewBox="0 0 29.37 25.61">
									<use xlink:href="#wagon"></use>
								</svg></span>x<span>22</span>
						</p>
						<p class="best-wagon">
							<span>Best x</span>
							<span>59</span>
						</p>
					</div>
				</div>
			</div>

			<div class="obj-screen screen-end background-before">
				<div class="v-align-center">
					<img src="data:image/png;base64,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"
						alt="" />

					<h2>
						<span class="txt-loose">You loose</span>
						<span class="txt-win">You win</span>
					</h2>

					<p class="txt">
						<span>First game?</span><br />
						<span>Compete online</span><br />
						<span>Many skins available</span>
					</p>

					<div class="retry-container">
						<span class="button retry background-before"><span>RETRY</span></span>
						<p class="or">Or</p>
					</div>

					<span class="button download background-before"><span>DOWNLOAD</span></span>
				</div>
			</div>
		</div>

		<div class="obj-banner">
			<div>
				<img src="data:image/png;base64,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"
					alt="" />
			</div>
			<div>
				<small>Voodoo</small>
				<h1>Tiny loops</h1>
			</div>
			<div>
				<span class="button download">DOWNLOAD</span>
			</div>
		</div>

		<canvas id="canvas"></canvas>
	</div>

	<script type='text/javascript'>
		window._voodooIOS = "https://itunes.apple.com/us/app/tiny-loops/id1450489562?mt=8";
		window._voodooANDROID = "";


		var _gameplay = {
			maxRetry: Infinity,
			maxGameDuration: Infinity,
			railwayColor1: '#ff0000',
			railwayColor2: '#666666',
			persoColor: '#ff0000',
			wagonColor: '#ff0000',
			rockColor: '#ffffff',
			fogColor: '#aaaaaa',
			ambientLightColor: '#ffffff',
			ambientLightIntensity: 0.6,
			directionalLightColor: '#ffffff',
			directionalLightIntensity: 0.4,
			points: [
				'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAEACAMAAABrrFhUAAACkVBMVEVHcEz+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v51mrCpAAAA23RSTlMAEzhZa36Ai3tmSiEBKHCv5f/ts2oZEJrw4NHQxsC6sKCTkD962Py0Q1boJJ/6xTceDpL7/pULA/RI1TDLhwqJYLL2QkXevjkVowbB6l+nxwW9XnN591A0LdIH1798TRHjHM8C8p1HIoRAlyeMceba046FMshbJlMgBGnChoKoTorO31L94jwWGsQUvEwjqVRofxKtNqEuH9xL+AjJRtZkgzGYyp4M74H5UdQ6wyk96Qk78+zu2dt9YzNJq0+PbHS4WOQbbpRElo2cDaZXpQ+q3XXhtpnxri9hzDVXTz53AAAGA0lEQVR4AezBwwHEAAAAsLPNWvsP2W8XqJMs6AgAAAAAAAAAAAAAAAAAAAAAAAAsV+vNdrffHY6n82UxM9fb/fFseL0/38Vo/f7BKwzDKI6TNM3y/F4URVlVNTv3uCBJEkZh+KzVOjPTNWyMbdu2bdu2bdu2bdu8mTGqK7/IiqhVRu4+f4v5ppkVCvHZstMpR85csFPuPBTFQJQ3X34qFCgI+xTKSRoEKFykKNWKFS8Bu5SMKUWTAKXj6K5MNGxSthzVfnPmKs+w0mWFNSpUzEEXlRzvr0wNVarCEtWqkyYBCteglio1YYNatUmjAHXqUlO9QvC8qPqpaBYgqgG1NWwEj8vbmOE1QbCmNPAzPK1Rs+bU0AJBWhalgaKt4GEFW5OmAdq0pZF28KzCRYrRPEB7GuoAj+rYiTQP0Lk5DXWJgjd17RZJgO409js8KpG6euCLnjlorDE8qhd19cYXfRiBvvCm380DdKzCCPSDN31nHqA/IzGgK7xpoHGAQYxIVXhTbWrKik/KMjKD4U1pqKksPhnCyLSFNw01DdCWSsOG9x0xMpEKo+BJo6uYBRhFpfZRrgvJMfCmsWYBKlFlHD4bT9EE/DMm5meI/BPhYpJZgGQqlBuNz0ZPpmTKPzf8RgWmMoVpYxNdN+WmU2EGvupB0Uz8ExIoSIDaLAaZ/dscxFA0yn0RMBdBulAyz5MBgsbpgPHzAbgHaEEHYeh+o2S8RwMs4EftFjbCR4vcAiymrF5JBFlSlIKlHg2wrCGZf/kKfFHJLcBSyoojhXYUtPZoAKD34llAuAAr8cEqylYjhfYUrOnqwQACRYAAAKwtRlH+EkhhBiV/2BFgpEuAvpStQ0oVplHQw44ALVwCrKesCEJsoGCj/QE2UtbEuWoR/GRHgIkuATZRthkhxDdusSNAb5cAyRRNW6u1JK1sf4CcFKXX+5Kt9gfIRFENhOord7IiwPcuAdpStA2htlOww44AZSlqBAB5KNoJh+Z0mmZ1AHywi6JFcBhAwXbbA4ymbDcc9lAwy4oA89UBApTthcM+CqLx16pTmZEbA4VR5gH2w6ExBWU9MPxCAf0AtSiLh0PSPxCgLP+U9JAVosilDdfCoQEFB6wIEDAPAKdkCnr7NEC6/3qAg7oB1lsR4JBxgPS6AXpYEQDqAEsoGuivWQDG2wEZNQP8H+CwHQGOKAOs1Q/QwN4NIaRTBkBR7QBJfgswDR8c1Q5Qg4JoOwIcU2/sVKdkEJwKUBBvR4D06gBdtL+pLQWHrA+QQMlROB2kU35YHyCWkipwKkqnepYEOK4OsIWiQwi1hIITlgTIqA5wkqLOCNWKgob2BzhF0WmEOkPBWVhxSMwtQGmKzuldgnweVhwUdQvQiqILCJWFgot2nBjBPnWAAKk3ai9RcNmSAAnqAMhDySWEEt932AcBEii5ghBXKVnigwB99E4MjKTgICwJ0M4lwDW9k4PXKUiwJUCSS4AbFN1ESicoKO6HAIFilEyJQrDNlKTxQwBs0Dk/fIuS074IcJui5QiyPR0FpUbbEuCsW4CNFOVfGfbxAo1hS4BkCo7gk2jKzuKrzkcoGW93AOKzKZQ1CfeAnVw+CVCEsvwL8dGd1BSla+STAOupcrZaoFHPC1MouwtrAtx0DdDmCCNyz54AWVwD4D4jseuBbwL0YCQewjcBuqZnBM74JwCa0dyjroA37x0WjA8T4LtSNHYNgDfvHhf8HCYAztPU0RKwgHaA+FI09Bi+CoBeNPPkEGzyU9gAJTrRSG5YJSZsALSgiafwQ4AKCLac+lJd9UWAAILdaUttHeDDANi/g5pOwjZpdALgQBVqeQbrVNIKgKpaBZ6V9G0A1KzHsMZFwb8BsLIh3T3PDfg5ABot3kUXiaNgpdyqAIK+L6iSfSEs1UIdQPCydnMKZuceDVsVmq4OIHnw6sUOBtuV0Gw+bNZ5IMkjA46/TkiqfbPiyZhKI9fvbdUVLqL2L/z15tmkuUlL026q/6YObFeicwDv2oNjAQAAAIBB/tZz2F1xAAAAAAAAAAAAAAAAAAAAAAAAEHQGZOXTWJDdAAAAAElFTkSuQmCC',
				'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAEACAMAAABrrFhUAAAC1lBMVEVHcEz+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v47ZKiRAAAA8nRSTlMADxAXIC8wN0BQWGBweICQmKCwuMDQkgMbTnORr8bd4NHJrpNyRBbS8Pf/pQhSnubenFcO5E0h7qk+GfrHP/YBZ6cTEbHlCSRcLuplJ+z9VPQrvNUHam/4HkKFBvkUVXR8zmR5ZqTZjNa3qJmKe2wYvfGbgu0K380s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',
				'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAEACAMAAABrrFhUAAAC3FBMVEVHcEz+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v5qkGAEAAAA9HRSTlMADxAXIC8wN0BQWGBweICQmKCwuMDQkgPS8Pf/pRM4WWt+i3tmSiEB5E0or+Xts2oZetj8tEP2JJ/6xQ77/pULCUjVhz8bCrJCvjkuBsHqHqfHBXM0LQfXVXwcz2edIr2XJxGM1reomYpsXD4YceYC00Ge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',
				'data:image/png;base64,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',
				'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAEACAMAAABrrFhUAAAC91BMVEVHcEz+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v5ftRgTAAAA/XRSTlMACjhkg6G8yNDf1cGpjW9AEAwvUGZ5gGNEHjHM/f/YlVIJFmCg2f7prWESBs3zMg83WXKFkIRrTCEIXcD5qDQB3bktXNzqpld4sSYkvvyP+u+IXub4A1PR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'
			]
		}
	</script>
	<script type='text/javascript'>
		! function (i) {
			var n = {};

			function r(t) {
				if (n[t]) return n[t].exports;
				var e = n[t] = {
					i: t,
					l: !1,
					exports: {}
				};
				return i[t].call(e.exports, e, e.exports, r), e.l = !0, e.exports
			}
			r.m = i, r.c = n, r.d = function (t, e, i) {
				r.o(t, e) || Object.defineProperty(t, e, {
					enumerable: !0,
					get: i
				})
			}, r.r = function (t) {
				"undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, {
					value: "Module"
				}), Object.defineProperty(t, "__esModule", {
					value: !0
				})
			}, r.t = function (e, t) {
				if (1 & t && (e = r(e)), 8 & t) return e;
				if (4 & t && "object" == typeof e && e && e.__esModule) return e;
				var i = Object.create(null);
				if (r.r(i), Object.defineProperty(i, "default", {
						enumerable: !0,
						value: e
					}), 2 & t && "string" != typeof e)
					for (var n in e) r.d(i, n, function (t) {
						return e[t]
					}.bind(null, n));
				return i
			}, r.n = function (t) {
				var e = t && t.__esModule ? function () {
					return t.default
				} : function () {
					return t
				};
				return r.d(e, "a", e), e
			}, r.o = function (t, e) {
				return Object.prototype.hasOwnProperty.call(t, e)
			}, r.p = "", r(r.s = 0)
		}([function (t, e, i) {
			"use strict";
			i.r(e);
			var n = i(1),
				r = i.n(n),
				a = i(2);
			window.addEventListener("load", function () {
				new r.a({
					voodooANDROID: window._voodooANDROID,
					voodooIOS: window._voodooIOS,
					onReady: function (t) {
						window.game = new a.default(t, window._gameplay)
					}
				})
			})
		}, function (t, e, i) {
			var n;
			n = function () {
				"use strict";

				function n(t, e) {
					var i = function () {};
					this._settings = Object.assign({
							onReady: i
						}, e), this._name = t, this._api = null, this._buildId = void 0, this
						._isObjectiveComplete = !1, this._isGameplayFinished = !1, this._canShowEndCard = !1, this
						._isDonwloadButtonClicked = !1, this._isGameStarted = !1, this._times = {
							playableStart: null,
							gameplayFinished: null,
							objectiveComplete: null
						}, window._voodooExit = function () {}
				}

				function r(t, e) {
					n.call(this, t, e), this._api = null, this.setVoodooExit(function(){}), this.startGame()
				}

				function a(t, e) {
					n.call(this, t, e);
					var i = this;
					this.setVoodooExit(function(){}), this.startGame()
				}

				function o(t, e) {
					n.call(this, t, e), this.setVoodooExit(function(){}), this.startGame()
				}

				function s(t, e) {
					n.call(this, t, e), this._api = FbPlayableAd, this.setVoodooExit(function(){}), this.startGame()
				}

				function c(t, e) {
					n.call(this, t, e), this._api = dapi, this._api.isReady() ? i.call(this) : dapi
						.addEventListener("ready", i.bind(this))
				}

				function i() {
					dapi.getScreenSize(), dapi.getAudioVolume();
					dapi.addEventListener("audioVolumeChange", function (t) {}), dapi.removeEventListener(
						"ready"), this.setVoodooExit(function () {
							dapi.openStoreUrl()
						}), dapi.isViewable() && t.call(this, {
							isViewable: !0
						}), dapi.addEventListener("viewableChange", t.bind(this)), dapi.addEventListener(
							"adResized", e.bind(this))
				}

				function t(t) {
					t.isViewable && this.startGame()
				}

				function e(t) {}

				function h(t, e) {
					n.call(this, t, e);
					var i = this;
					this._api = window.TJ_API, this.setVoodooExit(function () {
						i._api.click()
					}), this.startGame()
				}

				function l(t, e) {
					n.call(this, t, e);
					var i = this;
					this.setVoodooExit(/android/i.test(navigator.userAgent) ? function () {
						window.mraid.open(i._settings.voodooANDROID)
					} : function () {
						window.mraid.open(i._settings.voodooIOS)
					}), this.startGame()
				}

				function u(t, e) {
					n.call(this, t, e), this._api = null, this._sessionId = Date.now() + "-" + Math.random()
						.toString(36).substr(2, 9), this._postUrls = {
							dev: "https://data-collector.vc-dev.com",
							preprod: "https://data-collector.va-stagging.com",
							prod: "https://data-collector.voodoo-ads.io"
						}, this._random = Math.random(), this._trackOptions = {
							postUrl: "dev",
							enabled: !0,
							endDate: 1 / 0,
							trackRandomUser: !1,
							randomUser: 1 / 3
						}, this.setVoodooExit(function () {
							"undefined" != typeof VAPlayableAds ? VAPlayableAds.voodooAdsExit() :
								_voodooAdsExit()
						}), this.startGame()
				}

				function p(t, e) {
					n.call(this, t, e);
					var i = this;
					this._api = window.parent, this.setVoodooExit(function () {
						i._api.postMessage("download", "*")
					}), this.startGame()
				}

				function d(t) {
					var e = {
							adwords: r,
							applovin: a,
							editor: o,
							facebook: s,
							ironsource: c,
							tapjoy: h,
							unityads: l,
							voodooads: u,
							vungle: p
						},
						i = (window._voodooProvider || "editor").toLowerCase();

					window.provider = new e[i](i, t);
				}
				return n.prototype = {
						getName: function () {
							return this._name
						},
						setVoodooExit: function (t) {
							return window._voodooExit = t, this
						},
						startGame: function () {
							return this._isGameStarted || (this._times.playableStart = performance.now(), this
								._isGameStarted = !0, this._settings.onReady(this)), this
						},
						getCurrentTime: function () {
							return (performance.now() - this._times.playableStart) / 1e3
						},
						setTrackingOptions: function () {
							return this
						},
						track: function () {
							return this
						},
						getAdInfo: function () {
							return this
						},
						canShowEndCard: function () {
							return this._canShowEndCard
						},
						gameplayFinished: function () {
							return this._isGameplayFinished = !0, this._canShowEndCard = !0, this._times
								.gameplayFinished = performance.now(), this
						},
						objectiveComplete: function () {
							return this._isObjectiveComplete = !0, this
						},
						setPlayableBuild: function (t) {
							return this._buildId = t, this
						},
						setPlayableAPI: function (t) {
							return this
						},
						error: function (t) {
							return console.log("[Provider Abstract] error : ", error), this
						}
					}, Object.assign(r.prototype, n.prototype, {}), Object.assign(a.prototype, n.prototype, {}),
					Object.assign(o.prototype, n.prototype, {}), Object.assign(s.prototype, n.prototype, {}),
					Object.assign(c.prototype, n.prototype, {}), Object.assign(h.prototype, n.prototype, {
						getAdInfo: function () {
							var t = this._api.adInfo;
							return console.log("[TapJoy Provider] getAdInfo : ", t.reward, t
								.currencyName), this
						},
						canShowEndCard: function () {
							return this._api.directives.showEndCard
						},
						gameplayFinished: function () {
							return n.prototype.gameplayFinished.call(this), this._api.gameplayFinished(),
								this
						},
						objectiveComplete: function () {
							return n.prototype.gameplayFinished.call(this), this._api.objectiveComplete(),
								this
						},
						setPlayableBuild: function (t) {
							return n.prototype.setPlayableBuild.call(this, t), this._api.setPlayableBuild(
								t), this
						},
						setPlayableAPI: function (t) {
							return n.prototype.setPlayableAPI.call(this), this._api.setPlayableAPI(t),
								this
						},
						error: function (t) {
							return n.prototype.error.call(this, error), this._api.error(t), this
						}
					}), Object.assign(l.prototype, n.prototype, {}), Object.assign(u.prototype, n.prototype, {
						setTrackingOptions: function (t) {
							return Object.assign(this._trackOptions, t), this
						},
						track: function (t, e) {
							var i, n, r = this._trackOptions,
								a = !r.trackRandomUser || r.randomUser <= this._random;
							return r.enabled && Date.now() <= r.endDate && a && (e = e || {}, n = Object
								.assign(e, {
									playable_build_id: this._buildId,
									session_id: this._sessionId,
									game_time: this.getCurrentTime(),
									name: t
								}), (i = new XMLHttpRequest).open("POST", this._postUrls[this
									._trackOptions.postUrl]), i.setRequestHeader("Content-Type",
									"application/json"), i.send(JSON.stringify(n)), console.log(
									"%c  VOODOO AD  %c  Provider " + this._name + ", track : ",
									"background:darkslateblue;color:white",
									"background:white;color:darkslateblue;", n)), this
						},
						objectiveComplete: function () {
							return n.prototype.objectiveComplete.call(this), this.track("player-has-won"),
								this
						},
						gameplayFinished: function () {
							return n.prototype.gameplayFinished.call(this), this.track(
								"playable-finished"), this
						}
					}), Object.assign(p.prototype, n.prototype, {}), d
			}, t.exports = n()
		}, function (t, e, i) {
			"use strict";
			i.r(e);
			var o = i(3),
				s = i(4),
				c = (i(6), i(7)),
				h = i(18);

			function n(t, e) {
				var i, n = this,
					r = document.getElementsByTagName("canvas")[0],
					a = [10, 25, 50, 100, 200];
				this._settings = e, this._providerApi = t, this._states = {
						start: performance.now(),
						retry: 0
					}, this._interface = new s.default({
						onResize: l.bind(this),
						onClickRetry: function (t) {
							n._states.retry++, n._pointer.isDown = !1, n._objects.levels.reset(), n._objects
								.player.reset(), n._interface.reset(), n.initPlayerPosition(), n._interface
								.switchScreen("end", "start")
						},
						onClickStartScreen: function (t) {
							n._interface.switchScreen("start", "game")
						},
						onClickEndOfLevelScreen: function (t) {
							n._objects.levels.generate(), n._objects.player.replace(), n._interface
								.switchScreen("end-of-level", "game")
						},
						onShowScreen: function (t) {
							"end" === t && (n.isRetryEnabled() || n._interface.hideRetry(), n._interface
								.showFinalTxt(!n._objects.player.isDead()))
						}
					}), i = this._interface.getEvents(), this._renderer = new o.WebGLRenderer({
						canvas: r,
						context: r.getContext("webgl"),
						antialias: !0
					}), this._renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)), this._scene = new o.Scene,
					this._scene.fog = new o.Fog(this._settings.fogColor, 100, 180), this._objects = {
						ambLight: new o.AmbientLight(this._settings.ambientLightColor, this._settings
							.ambientLightIntensity),
						dirLight: new o.DirectionalLight(this._settings.directionalLightColor, this._settings
							.directionalLightIntensity),
						player: new h.default({
							persoColor: this._settings.persoColor,
							wagonColor: this._settings.wagonColor,
							points: this._settings.points,
							onAddWagon: function (t, e) {
								n._interface.updateScore((t - 1) * a[e - 1]).updateWagon(t)
							}
						}),
						levels: new c.default({
							railwayColor1: this._settings.railwayColor1,
							railwayColor2: this._settings.railwayColor2,
							rockColor: this._settings.rockColor
						})
					}, this._objects.dirLight.position.set(10, 10, 10), this.initPlayerPosition(), this._scene.add(
						this._objects.ambLight, this._objects.dirLight, this._objects.levels.getObject(), this
						._objects.player.getObject()), this._interface.triggerResize(), this.startRender(), this
					._interface.switchScreen("loading", "start"), this._debug = {
						prevTime: 0
					}, this._pointer = {
						isDown: !1
					}, r.addEventListener(i.pointerdown, function (t) {
						t.preventDefault(), t.stopImmediatePropagation(), n._pointer.isDown = !0
					}), r.addEventListener(i.pointerup, function (t) {
						t.preventDefault(), t.stopImmediatePropagation(), n._pointer.isDown = !1
					})
			}

			function l() {
				var t = this._interface.getWidth(),
					e = this._interface.getHeight();
				this._objects.player.updateCamera(t / e), this._renderer.setSize(t, e)
			}
			n.prototype = {
				isRetryEnabled: function () {
					return this._states.retry <= this._settings.maxRetry && this._providerApi
					.getCurrentTime() < this._settings.maxGameDuration
				},
				initPlayerPosition: function () {
					return this._objects.player.setPositionFromPathInfos(this._objects.levels.getPathInfos(
						255)), this._objects.player.setPositionFromPathInfos(this._objects.levels
						.getPathInfos(256)), this
				},
				startRender: function () {
					var n = this,
						r = 0,
						a = this._states,
						t = this._objects,
						o = this._interface,
						s = t.player,
						c = t.levels,
						h = function (t) {
							n._raf = requestAnimationFrame(h);
							var e = t - a.start,
								i = (t - r) / (1e3 / 60);
							n._interface.currentScreenIs("game") ? (s.tryToJump(c.getJumpTrigger(s
										.getPosition()), e), s.isJumping() ? (n._pointer.isDown && s.rotate(
										i), s.setJumpingPosition(e, c.getNearestInfos(s.getPosition()))) : s
									.accelerate(n._pointer.isDown).setPositionFromPathInfos(c.getPathInfos(s
										.getDistance())), s.isDead() && o.switchScreen("game", "end"), o
									.updateScore(s.getSpeed() / 10), c.hasReachLastDoor(s.getPosition()) && (s
										.lockCameraPosition(), o.switchScreen("game", c.hasNextLevel() ?
											"end-of-level" : "end")), c.update(t, i), s.update(t, i)) : (o
									.currentScreenIs("end-of-level") || o.currentScreenIs("end")) && (s
									.isDead() || c.hasReachEnd() || s.setPositionFromPathInfos(c.getPathInfos(
										s.getDistance(i))), c.update(t, i), s.update(t, i)), n._renderer
								.render(n._scene, s.getCamera()), r = t
						};
					return n._raf = requestAnimationFrame(h), this
				},
				stopRender: function () {
					return cancelAnimationFrame(this._raf), this
				}
			}, e.default = n
		}, function (t, e, i) {
			(function (t) {
				"use strict";

				function e() {}
				void 0 === Number.EPSILON && (Number.EPSILON = Math.pow(2, -52)), void 0 === Number.isInteger && (
					Number.isInteger = function (t) {
						return "number" == typeof t && isFinite(t) && Math.floor(t) === t
					}), void 0 === Math.sign && (Math.sign = function (t) {
					return t < 0 ? -1 : 0 < t ? 1 : +t
				}), "name" in Function.prototype == !1 && Object.defineProperty(Function.prototype, "name", {
					get: function () {
						return this.toString().match(/^\s*function\s*([^\(\s]*)/)[1]
					}
				}), void 0 === Object.assign && (Object.assign = function (t) {
					if (null == t) throw new TypeError("Cannot convert undefined or null to object");
					for (var e = Object(t), i = 1; i < arguments.length; i++) {
						var n = arguments[i];
						if (null != n)
							for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r])
					}
					return e
				}), Object.assign(e.prototype, {
					addEventListener: function (t, e) {
						void 0 === this._listeners && (this._listeners = {});
						var i = this._listeners;
						void 0 === i[t] && (i[t] = []), -1 === i[t].indexOf(e) && i[t].push(e)
					},
					hasEventListener: function (t, e) {
						if (void 0 === this._listeners) return !1;
						var i = this._listeners;
						return void 0 !== i[t] && -1 !== i[t].indexOf(e)
					},
					removeEventListener: function (t, e) {
						if (void 0 !== this._listeners) {
							var i = this._listeners[t];
							if (void 0 !== i) {
								var n = i.indexOf(e); - 1 !== n && i.splice(n, 1)
							}
						}
					},
					dispatchEvent: function (t) {
						if (void 0 !== this._listeners) {
							var e = this._listeners[t.type];
							if (void 0 !== e) {
								t.target = this;
								for (var i = e.slice(0), n = 0, r = i.length; n < r; n++) i[n].call(
									this, t)
							}
						}
					}
				});
				var i, n, l, u, r, a, o, s, c, h, p, d, f, m, g, v, y, x, b, _, w, M, S, Ht = "102dev",
					E = {
						LEFT: 0,
						MIDDLE: 1,
						RIGHT: 2
					},
					lt = 0,
					ut = 1,
					pt = 2,
					T = 3,
					A = 0,
					L = 1,
					P = 0,
					B = 1,
					I = 2,
					z = 0,
					jt = 1,
					dt = 2,
					R = 1,
					C = 2,
					O = 0,
					D = 1,
					N = 2,
					ft = 0,
					mt = 1,
					gt = 2,
					vt = 3,
					yt = 4,
					xt = 5,
					bt = 100,
					G = 101,
					U = 102,
					F = 103,
					H = 104,
					j = 200,
					k = 201,
					V = 202,
					W = 203,
					q = 204,
					X = 205,
					Y = 206,
					Z = 207,
					J = 208,
					Q = 209,
					K = 210,
					_t = 0,
					wt = 1,
					Mt = 2,
					St = 3,
					Et = 4,
					Tt = 5,
					At = 6,
					Lt = 7,
					$ = 0,
					tt = 1,
					et = 2,
					it = 0,
					kt = 1,
					nt = 2,
					rt = 3,
					at = 4,
					ot = 5,
					st = 300,
					ct = 301,
					ht = 302,
					Pt = 303,
					Rt = 304,
					Ct = 305,
					Ot = 306,
					It = 307,
					Dt = 1e3,
					Bt = 1001,
					zt = 1002,
					Nt = 1003,
					Gt = 1004,
					Ut = 1005,
					Ft = 1006,
					Vt = 1007,
					Wt = 1008,
					qt = 1009,
					Xt = 1010,
					Yt = 1011,
					Zt = 1012,
					Jt = 1013,
					Qt = 1014,
					Kt = 1015,
					$t = 1016,
					te = 1017,
					ee = 1018,
					ie = 1019,
					ne = 1020,
					re = 1021,
					ae = 1022,
					oe = 1023,
					se = 1024,
					ce = 1025,
					he = oe,
					le = 1026,
					ue = 1027,
					pe = 1028,
					de = 33776,
					fe = 33777,
					me = 33778,
					ge = 33779,
					ve = 35840,
					ye = 35841,
					xe = 35842,
					be = 35843,
					_e = 36196,
					we = 37808,
					Me = 37809,
					Se = 37810,
					Ee = 37811,
					Te = 37812,
					Ae = 37813,
					Le = 37814,
					Pe = 37815,
					Re = 37816,
					Ce = 37817,
					Oe = 37818,
					Ie = 37819,
					De = 37820,
					Be = 37821,
					ze = 2200,
					Ne = 2201,
					Ge = 2202,
					Ue = 2300,
					Fe = 2301,
					He = 2302,
					je = 2400,
					ke = 2401,
					Ve = 2402,
					We = 0,
					qe = 1,
					Xe = 2,
					Ye = 3e3,
					Ze = 3001,
					Je = 3007,
					Qe = 3002,
					Ke = 3003,
					$e = 3004,
					ti = 3005,
					ei = 3006,
					ii = 3200,
					ni = 3201,
					ri = 0,
					ai = 1,
					oi = {
						DEG2RAD: Math.PI / 180,
						RAD2DEG: 180 / Math.PI,
						generateUUID: function () {
							for (var r = [], t = 0; t < 256; t++) r[t] = (t < 16 ? "0" : "") + t.toString(16);
							return function () {
								var t = 4294967295 * Math.random() | 0,
									e = 4294967295 * Math.random() | 0,
									i = 4294967295 * Math.random() | 0,
									n = 4294967295 * Math.random() | 0;
								return (r[255 & t] + r[t >> 8 & 255] + r[t >> 16 & 255] + r[t >> 24 &
										255] + "-" + r[255 & e] + r[e >> 8 & 255] + "-" + r[e >> 16 & 15 |
											64] + r[e >> 24 & 255] + "-" + r[63 & i | 128] + r[i >> 8 &
											255] + "-" + r[i >> 16 & 255] + r[i >> 24 & 255] + r[255 &
										n] + r[n >> 8 & 255] + r[n >> 16 & 255] + r[n >> 24 & 255])
									.toUpperCase()
							}
						}(),
						clamp: function (t, e, i) {
							return Math.max(e, Math.min(i, t))
						},
						euclideanModulo: function (t, e) {
							return (t % e + e) % e
						},
						mapLinear: function (t, e, i, n, r) {
							return n + (t - e) * (r - n) / (i - e)
						},
						lerp: function (t, e, i) {
							return (1 - i) * t + i * e
						},
						smoothstep: function (t, e, i) {
							return t <= e ? 0 : i <= t ? 1 : (t = (t - e) / (i - e)) * t * (3 - 2 * t)
						},
						smootherstep: function (t, e, i) {
							return t <= e ? 0 : i <= t ? 1 : (t = (t - e) / (i - e)) * t * t * (t * (6 * t -
								15) + 10)
						},
						randInt: function (t, e) {
							return t + Math.floor(Math.random() * (e - t + 1))
						},
						randFloat: function (t, e) {
							return t + Math.random() * (e - t)
						},
						randFloatSpread: function (t) {
							return t * (.5 - Math.random())
						},
						degToRad: function (t) {
							return t * oi.DEG2RAD
						},
						radToDeg: function (t) {
							return t * oi.RAD2DEG
						},
						isPowerOfTwo: function (t) {
							return 0 == (t & t - 1) && 0 !== t
						},
						ceilPowerOfTwo: function (t) {
							return Math.pow(2, Math.ceil(Math.log(t) / Math.LN2))
						},
						floorPowerOfTwo: function (t) {
							return Math.pow(2, Math.floor(Math.log(t) / Math.LN2))
						}
					};

				function si(t, e) {
					this.x = t || 0, this.y = e || 0
				}

				function ci() {
					this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], 0 < arguments.length &&
						console.error(
							"THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")
				}

				function hi(t, e, i, n) {
					this._x = t || 0, this._y = e || 0, this._z = i || 0, this._w = void 0 !== n ? n : 1
				}

				function li(t, e, i) {
					this.x = t || 0, this.y = e || 0, this.z = i || 0
				}

				function ui() {
					this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1], 0 < arguments.length && console.error(
						"THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")
				}
				Object.defineProperties(si.prototype, {
					width: {
						get: function () {
							return this.x
						},
						set: function (t) {
							this.x = t
						}
					},
					height: {
						get: function () {
							return this.y
						},
						set: function (t) {
							this.y = t
						}
					}
				}), Object.assign(si.prototype, {
					isVector2: !0,
					set: function (t, e) {
						return this.x = t, this.y = e, this
					},
					setScalar: function (t) {
						return this.x = t, this.y = t, this
					},
					setX: function (t) {
						return this.x = t, this
					},
					setY: function (t) {
						return this.y = t, this
					},
					setComponent: function (t, e) {
						switch (t) {
							case 0:
								this.x = e;
								break;
							case 1:
								this.y = e;
								break;
							default:
								throw new Error("index is out of range: " + t)
						}
						return this
					},
					getComponent: function (t) {
						switch (t) {
							case 0:
								return this.x;
							case 1:
								return this.y;
							default:
								throw new Error("index is out of range: " + t)
						}
					},
					clone: function () {
						return new this.constructor(this.x, this.y)
					},
					copy: function (t) {
						return this.x = t.x, this.y = t.y, this
					},
					add: function (t, e) {
						return void 0 !== e ? (console.warn(
							"THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."
							), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this)
					},
					addScalar: function (t) {
						return this.x += t, this.y += t, this
					},
					addVectors: function (t, e) {
						return this.x = t.x + e.x, this.y = t.y + e.y, this
					},
					addScaledVector: function (t, e) {
						return this.x += t.x * e, this.y += t.y * e, this
					},
					sub: function (t, e) {
						return void 0 !== e ? (console.warn(
							"THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."
							), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this)
					},
					subScalar: function (t) {
						return this.x -= t, this.y -= t, this
					},
					subVectors: function (t, e) {
						return this.x = t.x - e.x, this.y = t.y - e.y, this
					},
					multiply: function (t) {
						return this.x *= t.x, this.y *= t.y, this
					},
					multiplyScalar: function (t) {
						return this.x *= t, this.y *= t, this
					},
					divide: function (t) {
						return this.x /= t.x, this.y /= t.y, this
					},
					divideScalar: function (t) {
						return this.multiplyScalar(1 / t)
					},
					applyMatrix3: function (t) {
						var e = this.x,
							i = this.y,
							n = t.elements;
						return this.x = n[0] * e + n[3] * i + n[6], this.y = n[1] * e + n[4] * i + n[
							7], this
					},
					min: function (t) {
						return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this
					},
					max: function (t) {
						return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this
					},
					clamp: function (t, e) {
						return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y,
							Math.min(e.y, this.y)), this
					},
					clampScalar: (i = new si, n = new si, function (t, e) {
						return i.set(t, t), n.set(e, e), this.clamp(i, n)
					}),
					clampLength: function (t, e) {
						var i = this.length();
						return this.divideScalar(i || 1).multiplyScalar(Math.max(t, Math.min(e, i)))
					},
					floor: function () {
						return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this
					},
					ceil: function () {
						return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this
					},
					round: function () {
						return this.x = Math.round(this.x), this.y = Math.round(this.y), this
					},
					roundToZero: function () {
						return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y =
							this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this
					},
					negate: function () {
						return this.x = -this.x, this.y = -this.y, this
					},
					dot: function (t) {
						return this.x * t.x + this.y * t.y
					},
					cross: function (t) {
						return this.x * t.y - this.y * t.x
					},
					lengthSq: function () {
						return this.x * this.x + this.y * this.y
					},
					length: function () {
						return Math.sqrt(this.x * this.x + this.y * this.y)
					},
					manhattanLength: function () {
						return Math.abs(this.x) + Math.abs(this.y)
					},
					normalize: function () {
						return this.divideScalar(this.length() || 1)
					},
					angle: function () {
						var t = Math.atan2(this.y, this.x);
						return t < 0 && (t += 2 * Math.PI), t
					},
					distanceTo: function (t) {
						return Math.sqrt(this.distanceToSquared(t))
					},
					distanceToSquared: function (t) {
						var e = this.x - t.x,
							i = this.y - t.y;
						return e * e + i * i
					},
					manhattanDistanceTo: function (t) {
						return Math.abs(this.x - t.x) + Math.abs(this.y - t.y)
					},
					setLength: function (t) {
						return this.normalize().multiplyScalar(t)
					},
					lerp: function (t, e) {
						return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this
					},
					lerpVectors: function (t, e, i) {
						return this.subVectors(e, t).multiplyScalar(i).add(t)
					},
					equals: function (t) {
						return t.x === this.x && t.y === this.y
					},
					fromArray: function (t, e) {
						return void 0 === e && (e = 0), this.x = t[e], this.y = t[e + 1], this
					},
					toArray: function (t, e) {
						return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this.x, t[e +
							1] = this.y, t
					},
					fromBufferAttribute: function (t, e, i) {
						return void 0 !== i && console.warn(
								"THREE.Vector2: offset has been removed from .fromBufferAttribute()."
								), this.x = t.getX(e), this.y = t.getY(e), this
					},
					rotateAround: function (t, e) {
						var i = Math.cos(e),
							n = Math.sin(e),
							r = this.x - t.x,
							a = this.y - t.y;
						return this.x = r * i - a * n + t.x, this.y = r * n + a * i + t.y, this
					}
				}), Object.assign(ci.prototype, {
					isMatrix4: !0,
					set: function (t, e, i, n, r, a, o, s, c, h, l, u, p, d, f, m) {
						var g = this.elements;
						return g[0] = t, g[4] = e, g[8] = i, g[12] = n, g[1] = r, g[5] = a, g[9] = o,
							g[13] = s, g[2] = c, g[6] = h, g[10] = l, g[14] = u, g[3] = p, g[7] = d,
							g[11] = f, g[15] = m, this
					},
					identity: function () {
						return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
					},
					clone: function () {
						return (new ci).fromArray(this.elements)
					},
					copy: function (t) {
						var e = this.elements,
							i = t.elements;
						return e[0] = i[0], e[1] = i[1], e[2] = i[2], e[3] = i[3], e[4] = i[4], e[5] =
							i[5], e[6] = i[6], e[7] = i[7], e[8] = i[8], e[9] = i[9], e[10] = i[10],
							e[11] = i[11], e[12] = i[12], e[13] = i[13], e[14] = i[14], e[15] = i[15],
							this
					},
					copyPosition: function (t) {
						var e = this.elements,
							i = t.elements;
						return e[12] = i[12], e[13] = i[13], e[14] = i[14], this
					},
					extractBasis: function (t, e, i) {
						return t.setFromMatrixColumn(this, 0), e.setFromMatrixColumn(this, 1), i
							.setFromMatrixColumn(this, 2), this
					},
					makeBasis: function (t, e, i) {
						return this.set(t.x, e.x, i.x, 0, t.y, e.y, i.y, 0, t.z, e.z, i.z, 0, 0, 0, 0,
							1), this
					},
					extractRotation: (p = new li, function (t) {
						var e = this.elements,
							i = t.elements,
							n = 1 / p.setFromMatrixColumn(t, 0).length(),
							r = 1 / p.setFromMatrixColumn(t, 1).length(),
							a = 1 / p.setFromMatrixColumn(t, 2).length();
						return e[0] = i[0] * n, e[1] = i[1] * n, e[2] = i[2] * n, e[3] = 0, e[4] =
							i[4] * r, e[5] = i[5] * r, e[6] = i[6] * r, e[7] = 0, e[8] = i[8] * a,
							e[9] = i[9] * a, e[10] = i[10] * a, e[11] = 0, e[12] = 0, e[13] = 0,
							e[14] = 0, e[15] = 1, this
					}),
					makeRotationFromEuler: function (t) {
						t && t.isEuler || console.error(
							"THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order."
							);
						var e = this.elements,
							i = t.x,
							n = t.y,
							r = t.z,
							a = Math.cos(i),
							o = Math.sin(i),
							s = Math.cos(n),
							c = Math.sin(n),
							h = Math.cos(r),
							l = Math.sin(r);
						if ("XYZ" === t.order) {
							var u = a * h,
								p = a * l,
								d = o * h,
								f = o * l;
							e[0] = s * h, e[4] = -s * l, e[8] = c, e[1] = p + d * c, e[5] = u - f * c,
								e[9] = -o * s, e[2] = f - u * c, e[6] = d + p * c, e[10] = a * s
						} else if ("YXZ" === t.order) {
							var m = s * h,
								g = s * l,
								v = c * h,
								y = c * l;
							e[0] = m + y * o, e[4] = v * o - g, e[8] = a * c, e[1] = a * l, e[5] = a *
								h, e[9] = -o, e[2] = g * o - v, e[6] = y + m * o, e[10] = a * s
						} else if ("ZXY" === t.order) {
							m = s * h, g = s * l, v = c * h, y = c * l;
							e[0] = m - y * o, e[4] = -a * l, e[8] = v + g * o, e[1] = g + v * o, e[
								5] = a * h, e[9] = y - m * o, e[2] = -a * c, e[6] = o, e[10] = a * s
						} else if ("ZYX" === t.order) {
							u = a * h, p = a * l, d = o * h, f = o * l;
							e[0] = s * h, e[4] = d * c - p, e[8] = u * c + f, e[1] = s * l, e[5] = f *
								c + u, e[9] = p * c - d, e[2] = -c, e[6] = o * s, e[10] = a * s
						} else if ("YZX" === t.order) {
							var x = a * s,
								b = a * c,
								_ = o * s,
								w = o * c;
							e[0] = s * h, e[4] = w - x * l, e[8] = _ * l + b, e[1] = l, e[5] = a * h,
								e[9] = -o * h, e[2] = -c * h, e[6] = b * l + _, e[10] = x - w * l
						} else if ("XZY" === t.order) {
							x = a * s, b = a * c, _ = o * s, w = o * c;
							e[0] = s * h, e[4] = -l, e[8] = c * h, e[1] = x * l + w, e[5] = a * h, e[
								9] = b * l - _, e[2] = _ * l - b, e[6] = o * h, e[10] = w * l + x
						}
						return e[3] = 0, e[7] = 0, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] =
							1, this
					},
					makeRotationFromQuaternion: (c = new li(0, 0, 0), h = new li(1, 1, 1), function (t) {
						return this.compose(c, t, h)
					}),
					lookAt: (a = new li, o = new li, s = new li, function (t, e, i) {
						var n = this.elements;
						return s.subVectors(t, e), 0 === s.lengthSq() && (s.z = 1), s.normalize(),
							a.crossVectors(i, s), 0 === a.lengthSq() && (1 === Math.abs(i.z) ? s
								.x += 1e-4 : s.z += 1e-4, s.normalize(), a.crossVectors(i, s)), a
							.normalize(), o.crossVectors(s, a), n[0] = a.x, n[4] = o.x, n[8] = s
							.x, n[1] = a.y, n[5] = o.y, n[9] = s.y, n[2] = a.z, n[6] = o.z, n[
							10] = s.z, this
					}),
					multiply: function (t, e) {
						return void 0 !== e ? (console.warn(
							"THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."
							), this.multiplyMatrices(t, e)) : this.multiplyMatrices(this, t)
					},
					premultiply: function (t) {
						return this.multiplyMatrices(t, this)
					},
					multiplyMatrices: function (t, e) {
						var i = t.elements,
							n = e.elements,
							r = this.elements,
							a = i[0],
							o = i[4],
							s = i[8],
							c = i[12],
							h = i[1],
							l = i[5],
							u = i[9],
							p = i[13],
							d = i[2],
							f = i[6],
							m = i[10],
							g = i[14],
							v = i[3],
							y = i[7],
							x = i[11],
							b = i[15],
							_ = n[0],
							w = n[4],
							M = n[8],
							S = n[12],
							E = n[1],
							T = n[5],
							A = n[9],
							L = n[13],
							P = n[2],
							R = n[6],
							C = n[10],
							O = n[14],
							I = n[3],
							D = n[7],
							B = n[11],
							z = n[15];
						return r[0] = a * _ + o * E + s * P + c * I, r[4] = a * w + o * T + s * R +
							c * D, r[8] = a * M + o * A + s * C + c * B, r[12] = a * S + o * L + s *
							O + c * z, r[1] = h * _ + l * E + u * P + p * I, r[5] = h * w + l * T +
							u * R + p * D, r[9] = h * M + l * A + u * C + p * B, r[13] = h * S + l *
							L + u * O + p * z, r[2] = d * _ + f * E + m * P + g * I, r[6] = d * w +
							f * T + m * R + g * D, r[10] = d * M + f * A + m * C + g * B, r[14] = d *
							S + f * L + m * O + g * z, r[3] = v * _ + y * E + x * P + b * I, r[7] =
							v * w + y * T + x * R + b * D, r[11] = v * M + y * A + x * C + b * B, r[
								15] = v * S + y * L + x * O + b * z, this
					},
					multiplyScalar: function (t) {
						var e = this.elements;
						return e[0] *= t, e[4] *= t, e[8] *= t, e[12] *= t, e[1] *= t, e[5] *= t, e[
							9] *= t, e[13] *= t, e[2] *= t, e[6] *= t, e[10] *= t, e[14] *= t, e[3] *=
							t, e[7] *= t, e[11] *= t, e[15] *= t, this
					},
					applyToBufferAttribute: (r = new li, function (t) {
						for (var e = 0, i = t.count; e < i; e++) r.x = t.getX(e), r.y = t.getY(e),
							r.z = t.getZ(e), r.applyMatrix4(this), t.setXYZ(e, r.x, r.y, r.z);
						return t
					}),
					determinant: function () {
						var t = this.elements,
							e = t[0],
							i = t[4],
							n = t[8],
							r = t[12],
							a = t[1],
							o = t[5],
							s = t[9],
							c = t[13],
							h = t[2],
							l = t[6],
							u = t[10],
							p = t[14];
						return t[3] * (+r * s * l - n * c * l - r * o * u + i * c * u + n * o * p -
							i * s * p) + t[7] * (+e * s * p - e * c * u + r * a * u - n * a * p +
							n * c * h - r * s * h) + t[11] * (+e * c * l - e * o * p - r * a * l +
							i * a * p + r * o * h - i * c * h) + t[15] * (-n * o * h - e * s * l +
							e * o * u + n * a * l - i * a * u + i * s * h)
					},
					transpose: function () {
						var t, e = this.elements;
						return t = e[1], e[1] = e[4], e[4] = t, t = e[2], e[2] = e[8], e[8] = t, t =
							e[6], e[6] = e[9], e[9] = t, t = e[3], e[3] = e[12], e[12] = t, t = e[7],
							e[7] = e[13], e[13] = t, t = e[11], e[11] = e[14], e[14] = t, this
					},
					setPosition: function (t) {
						var e = this.elements;
						return e[12] = t.x, e[13] = t.y, e[14] = t.z, this
					},
					getInverse: function (t, e) {
						var i = this.elements,
							n = t.elements,
							r = n[0],
							a = n[1],
							o = n[2],
							s = n[3],
							c = n[4],
							h = n[5],
							l = n[6],
							u = n[7],
							p = n[8],
							d = n[9],
							f = n[10],
							m = n[11],
							g = n[12],
							v = n[13],
							y = n[14],
							x = n[15],
							b = d * y * u - v * f * u + v * l * m - h * y * m - d * l * x + h * f * x,
							_ = g * f * u - p * y * u - g * l * m + c * y * m + p * l * x - c * f * x,
							w = p * v * u - g * d * u + g * h * m - c * v * m - p * h * x + c * d * x,
							M = g * d * l - p * v * l - g * h * f + c * v * f + p * h * y - c * d * y,
							S = r * b + a * _ + o * w + s * M;
						if (0 === S) {
							var E =
								"THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0";
							if (!0 === e) throw new Error(E);
							return console.warn(E), this.identity()
						}
						var T = 1 / S;
						return i[0] = b * T, i[1] = (v * f * s - d * y * s - v * o * m + a * y * m +
								d * o * x - a * f * x) * T, i[2] = (h * y * s - v * l * s + v * o *
								u - a * y * u - h * o * x + a * l * x) * T, i[3] = (d * l * s - h *
								f * s - d * o * u + a * f * u + h * o * m - a * l * m) * T, i[4] = _ *
							T, i[5] = (p * y * s - g * f * s + g * o * m - r * y * m - p * o * x + r *
								f * x) * T, i[6] = (g * l * s - c * y * s - g * o * u + r * y * u +
								c * o * x - r * l * x) * T, i[7] = (c * f * s - p * l * s + p * o *
								u - r * f * u - c * o * m + r * l * m) * T, i[8] = w * T, i[9] = (g *
								d * s - p * v * s - g * a * m + r * v * m + p * a * x - r * d * x) *
							T, i[10] = (c * v * s - g * h * s + g * a * u - r * v * u - c * a * x +
								r * h * x) * T, i[11] = (p * h * s - c * d * s - p * a * u + r * d *
								u + c * a * m - r * h * m) * T, i[12] = M * T, i[13] = (p * v * o -
								g * d * o + g * a * f - r * v * f - p * a * y + r * d * y) * T, i[
							14] = (g * h * o - c * v * o - g * a * l + r * v * l + c * a * y - r * h *
								y) * T, i[15] = (c * d * o - p * h * o + p * a * l - r * d * l - c *
								a * f + r * h * f) * T, this
					},
					scale: function (t) {
						var e = this.elements,
							i = t.x,
							n = t.y,
							r = t.z;
						return e[0] *= i, e[4] *= n, e[8] *= r, e[1] *= i, e[5] *= n, e[9] *= r, e[
							2] *= i, e[6] *= n, e[10] *= r, e[3] *= i, e[7] *= n, e[11] *= r, this
					},
					getMaxScaleOnAxis: function () {
						var t = this.elements,
							e = t[0] * t[0] + t[1] * t[1] + t[2] * t[2],
							i = t[4] * t[4] + t[5] * t[5] + t[6] * t[6],
							n = t[8] * t[8] + t[9] * t[9] + t[10] * t[10];
						return Math.sqrt(Math.max(e, i, n))
					},
					makeTranslation: function (t, e, i) {
						return this.set(1, 0, 0, t, 0, 1, 0, e, 0, 0, 1, i, 0, 0, 0, 1), this
					},
					makeRotationX: function (t) {
						var e = Math.cos(t),
							i = Math.sin(t);
						return this.set(1, 0, 0, 0, 0, e, -i, 0, 0, i, e, 0, 0, 0, 0, 1), this
					},
					makeRotationY: function (t) {
						var e = Math.cos(t),
							i = Math.sin(t);
						return this.set(e, 0, i, 0, 0, 1, 0, 0, -i, 0, e, 0, 0, 0, 0, 1), this
					},
					makeRotationZ: function (t) {
						var e = Math.cos(t),
							i = Math.sin(t);
						return this.set(e, -i, 0, 0, i, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
					},
					makeRotationAxis: function (t, e) {
						var i = Math.cos(e),
							n = Math.sin(e),
							r = 1 - i,
							a = t.x,
							o = t.y,
							s = t.z,
							c = r * a,
							h = r * o;
						return this.set(c * a + i, c * o - n * s, c * s + n * o, 0, c * o + n * s, h *
							o + i, h * s - n * a, 0, c * s - n * o, h * s + n * a, r * s * s + i,
							0, 0, 0, 0, 1), this
					},
					makeScale: function (t, e, i) {
						return this.set(t, 0, 0, 0, 0, e, 0, 0, 0, 0, i, 0, 0, 0, 0, 1), this
					},
					makeShear: function (t, e, i) {
						return this.set(1, e, i, 0, t, 1, i, 0, t, e, 1, 0, 0, 0, 0, 1), this
					},
					compose: function (t, e, i) {
						var n = this.elements,
							r = e._x,
							a = e._y,
							o = e._z,
							s = e._w,
							c = r + r,
							h = a + a,
							l = o + o,
							u = r * c,
							p = r * h,
							d = r * l,
							f = a * h,
							m = a * l,
							g = o * l,
							v = s * c,
							y = s * h,
							x = s * l,
							b = i.x,
							_ = i.y,
							w = i.z;
						return n[0] = (1 - (f + g)) * b, n[1] = (p + x) * b, n[2] = (d - y) * b, n[
							3] = 0, n[4] = (p - x) * _, n[5] = (1 - (u + g)) * _, n[6] = (m + v) * _,
							n[7] = 0, n[8] = (d + y) * w, n[9] = (m - v) * w, n[10] = (1 - (u + f)) *
							w, n[11] = 0, n[12] = t.x, n[13] = t.y, n[14] = t.z, n[15] = 1, this
					},
					decompose: (l = new li, u = new ci, function (t, e, i) {
						var n = this.elements,
							r = l.set(n[0], n[1], n[2]).length(),
							a = l.set(n[4], n[5], n[6]).length(),
							o = l.set(n[8], n[9], n[10]).length();
						this.determinant() < 0 && (r = -r), t.x = n[12], t.y = n[13], t.z = n[14],
							u.copy(this);
						var s = 1 / r,
							c = 1 / a,
							h = 1 / o;
						return u.elements[0] *= s, u.elements[1] *= s, u.elements[2] *= s, u
							.elements[4] *= c, u.elements[5] *= c, u.elements[6] *= c, u.elements[
								8] *= h, u.elements[9] *= h, u.elements[10] *= h, e
							.setFromRotationMatrix(u), i.x = r, i.y = a, i.z = o, this
					}),
					makePerspective: function (t, e, i, n, r, a) {
						void 0 === a && console.warn(
							"THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs."
							);
						var o = this.elements,
							s = 2 * r / (e - t),
							c = 2 * r / (i - n),
							h = (e + t) / (e - t),
							l = (i + n) / (i - n),
							u = -(a + r) / (a - r),
							p = -2 * a * r / (a - r);
						return o[0] = s, o[4] = 0, o[8] = h, o[12] = 0, o[1] = 0, o[5] = c, o[9] = l,
							o[13] = 0, o[2] = 0, o[6] = 0, o[10] = u, o[14] = p, o[3] = 0, o[7] = 0,
							o[11] = -1, o[15] = 0, this
					},
					makeOrthographic: function (t, e, i, n, r, a) {
						var o = this.elements,
							s = 1 / (e - t),
							c = 1 / (i - n),
							h = 1 / (a - r),
							l = (e + t) * s,
							u = (i + n) * c,
							p = (a + r) * h;
						return o[0] = 2 * s, o[4] = 0, o[8] = 0, o[12] = -l, o[1] = 0, o[5] = 2 * c,
							o[9] = 0, o[13] = -u, o[2] = 0, o[6] = 0, o[10] = -2 * h, o[14] = -p, o[
							3] = 0, o[7] = 0, o[11] = 0, o[15] = 1, this
					},
					equals: function (t) {
						for (var e = this.elements, i = t.elements, n = 0; n < 16; n++)
							if (e[n] !== i[n]) return !1;
						return !0
					},
					fromArray: function (t, e) {
						void 0 === e && (e = 0);
						for (var i = 0; i < 16; i++) this.elements[i] = t[i + e];
						return this
					},
					toArray: function (t, e) {
						void 0 === t && (t = []), void 0 === e && (e = 0);
						var i = this.elements;
						return t[e] = i[0], t[e + 1] = i[1], t[e + 2] = i[2], t[e + 3] = i[3], t[e +
								4] = i[4], t[e + 5] = i[5], t[e + 6] = i[6], t[e + 7] = i[7], t[e +
							8] = i[8], t[e + 9] = i[9], t[e + 10] = i[10], t[e + 11] = i[11], t[e +
								12] = i[12], t[e + 13] = i[13], t[e + 14] = i[14], t[e + 15] = i[15],
							t
					}
				}), Object.assign(hi, {
					slerp: function (t, e, i, n) {
						return i.copy(t).slerp(e, n)
					},
					slerpFlat: function (t, e, i, n, r, a, o) {
						var s = i[n + 0],
							c = i[n + 1],
							h = i[n + 2],
							l = i[n + 3],
							u = r[a + 0],
							p = r[a + 1],
							d = r[a + 2],
							f = r[a + 3];
						if (l !== f || s !== u || c !== p || h !== d) {
							var m = 1 - o,
								g = s * u + c * p + h * d + l * f,
								v = 0 <= g ? 1 : -1,
								y = 1 - g * g;
							if (y > Number.EPSILON) {
								var x = Math.sqrt(y),
									b = Math.atan2(x, g * v);
								m = Math.sin(m * b) / x, o = Math.sin(o * b) / x
							}
							var _ = o * v;
							if (s = s * m + u * _, c = c * m + p * _, h = h * m + d * _, l = l * m +
								f * _, m === 1 - o) {
								var w = 1 / Math.sqrt(s * s + c * c + h * h + l * l);
								s *= w, c *= w, h *= w, l *= w
							}
						}
						t[e] = s, t[e + 1] = c, t[e + 2] = h, t[e + 3] = l
					}
				}), Object.defineProperties(hi.prototype, {
					x: {
						get: function () {
							return this._x
						},
						set: function (t) {
							this._x = t, this.onChangeCallback()
						}
					},
					y: {
						get: function () {
							return this._y
						},
						set: function (t) {
							this._y = t, this.onChangeCallback()
						}
					},
					z: {
						get: function () {
							return this._z
						},
						set: function (t) {
							this._z = t, this.onChangeCallback()
						}
					},
					w: {
						get: function () {
							return this._w
						},
						set: function (t) {
							this._w = t, this.onChangeCallback()
						}
					}
				}), Object.assign(hi.prototype, {
					isQuaternion: !0,
					set: function (t, e, i, n) {
						return this._x = t, this._y = e, this._z = i, this._w = n, this
							.onChangeCallback(), this
					},
					clone: function () {
						return new this.constructor(this._x, this._y, this._z, this._w)
					},
					copy: function (t) {
						return this._x = t.x, this._y = t.y, this._z = t.z, this._w = t.w, this
							.onChangeCallback(), this
					},
					setFromEuler: function (t, e) {
						if (!t || !t.isEuler) throw new Error(
							"THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order."
							);
						var i = t._x,
							n = t._y,
							r = t._z,
							a = t.order,
							o = Math.cos,
							s = Math.sin,
							c = o(i / 2),
							h = o(n / 2),
							l = o(r / 2),
							u = s(i / 2),
							p = s(n / 2),
							d = s(r / 2);
						return "XYZ" === a ? (this._x = u * h * l + c * p * d, this._y = c * p * l -
								u * h * d, this._z = c * h * d + u * p * l, this._w = c * h * l - u *
								p * d) : "YXZ" === a ? (this._x = u * h * l + c * p * d, this._y = c *
								p * l - u * h * d, this._z = c * h * d - u * p * l, this._w = c * h *
								l + u * p * d) : "ZXY" === a ? (this._x = u * h * l - c * p * d, this
								._y = c * p * l + u * h * d, this._z = c * h * d + u * p * l, this
								._w = c * h * l - u * p * d) : "ZYX" === a ? (this._x = u * h * l -
								c * p * d, this._y = c * p * l + u * h * d, this._z = c * h * d - u *
								p * l, this._w = c * h * l + u * p * d) : "YZX" === a ? (this._x = u *
								h * l + c * p * d, this._y = c * p * l + u * h * d, this._z = c * h *
								d - u * p * l, this._w = c * h * l - u * p * d) : "XZY" === a && (this
								._x = u * h * l - c * p * d, this._y = c * p * l - u * h * d, this
								._z = c * h * d + u * p * l, this._w = c * h * l + u * p * d), !1 !==
							e && this.onChangeCallback(), this
					},
					setFromAxisAngle: function (t, e) {
						var i = e / 2,
							n = Math.sin(i);
						return this._x = t.x * n, this._y = t.y * n, this._z = t.z * n, this._w = Math
							.cos(i), this.onChangeCallback(), this
					},
					setFromRotationMatrix: function (t) {
						var e, i = t.elements,
							n = i[0],
							r = i[4],
							a = i[8],
							o = i[1],
							s = i[5],
							c = i[9],
							h = i[2],
							l = i[6],
							u = i[10],
							p = n + s + u;
						return this._z = 0 < p ? (e = .5 / Math.sqrt(p + 1), this._w = .25 / e, this
								._x = (l - c) * e, this._y = (a - h) * e, (o - r) * e) : s < n && u <
							n ? (e = 2 * Math.sqrt(1 + n - s - u), this._w = (l - c) / e, this._x =
								.25 * e, this._y = (r + o) / e, (a + h) / e) : u < s ? (e = 2 * Math
								.sqrt(1 + s - n - u), this._w = (a - h) / e, this._x = (r + o) / e,
								this._y = .25 * e, (c + l) / e) : (e = 2 * Math.sqrt(1 + u - n - s),
								this._w = (o - r) / e, this._x = (a + h) / e, this._y = (c + l) / e,
								.25 * e), this.onChangeCallback(), this
					},
					setFromUnitVectors: (f = new li, m = 1e-6, function (t, e) {
						return void 0 === f && (f = new li), (d = t.dot(e) + 1) < m ? (d = 0, Math
								.abs(t.x) > Math.abs(t.z) ? f.set(-t.y, t.x, 0) : f.set(0, -t.z, t
									.y)) : f.crossVectors(t, e), this._x = f.x, this._y = f.y,
							this._z = f.z, this._w = d, this.normalize()
					}),
					angleTo: function (t) {
						return 2 * Math.acos(Math.abs(oi.clamp(this.dot(t), -1, 1)))
					},
					rotateTowards: function (t, e) {
						var i = this.angleTo(t);
						if (0 === i) return this;
						var n = Math.min(1, e / i);
						return this.slerp(t, n), this
					},
					inverse: function () {
						return this.conjugate()
					},
					conjugate: function () {
						return this._x *= -1, this._y *= -1, this._z *= -1, this.onChangeCallback(),
							this
					},
					dot: function (t) {
						return this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w
					},
					lengthSq: function () {
						return this._x * this._x + this._y * this._y + this._z * this._z + this._w *
							this._w
					},
					length: function () {
						return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z +
							this._w * this._w)
					},
					normalize: function () {
						var t = this.length();
						return this._w = 0 === t ? (this._x = 0, this._y = 0, this._z = 0, 1) : (t =
							1 / t, this._x = this._x * t, this._y = this._y * t, this._z = this
							._z * t, this._w * t), this.onChangeCallback(), this
					},
					multiply: function (t, e) {
						return void 0 !== e ? (console.warn(
							"THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."
							), this.multiplyQuaternions(t, e)) : this.multiplyQuaternions(this, t)
					},
					premultiply: function (t) {
						return this.multiplyQuaternions(t, this)
					},
					multiplyQuaternions: function (t, e) {
						var i = t._x,
							n = t._y,
							r = t._z,
							a = t._w,
							o = e._x,
							s = e._y,
							c = e._z,
							h = e._w;
						return this._x = i * h + a * o + n * c - r * s, this._y = n * h + a * s + r *
							o - i * c, this._z = r * h + a * c + i * s - n * o, this._w = a * h - i *
							o - n * s - r * c, this.onChangeCallback(), this
					},
					slerp: function (t, e) {
						if (0 === e) return this;
						if (1 === e) return this.copy(t);
						var i = this._x,
							n = this._y,
							r = this._z,
							a = this._w,
							o = a * t._w + i * t._x + n * t._y + r * t._z;
						if (o < 0 ? (this._w = -t._w, this._x = -t._x, this._y = -t._y, this._z = -t
								._z, o = -o) : this.copy(t), 1 <= o) return this._w = a, this._x = i,
							this._y = n, this._z = r, this;
						var s = 1 - o * o;
						if (s <= Number.EPSILON) {
							var c = 1 - e;
							return this._w = c * a + e * this._w, this._x = c * i + e * this._x, this
								._y = c * n + e * this._y, this._z = c * r + e * this._z, this
								.normalize()
						}
						var h = Math.sqrt(s),
							l = Math.atan2(h, o),
							u = Math.sin((1 - e) * l) / h,
							p = Math.sin(e * l) / h;
						return this._w = a * u + this._w * p, this._x = i * u + this._x * p, this._y =
							n * u + this._y * p, this._z = r * u + this._z * p, this
							.onChangeCallback(), this
					},
					equals: function (t) {
						return t._x === this._x && t._y === this._y && t._z === this._z && t._w ===
							this._w
					},
					fromArray: function (t, e) {
						return void 0 === e && (e = 0), this._x = t[e], this._y = t[e + 1], this._z =
							t[e + 2], this._w = t[e + 3], this.onChangeCallback(), this
					},
					toArray: function (t, e) {
						return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this._x, t[
							e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._w, t
					},
					onChange: function (t) {
						return this.onChangeCallback = t, this
					},
					onChangeCallback: function () {}
				}), Object.assign(li.prototype, {
					isVector3: !0,
					set: function (t, e, i) {
						return this.x = t, this.y = e, this.z = i, this
					},
					setScalar: function (t) {
						return this.x = t, this.y = t, this.z = t, this
					},
					setX: function (t) {
						return this.x = t, this
					},
					setY: function (t) {
						return this.y = t, this
					},
					setZ: function (t) {
						return this.z = t, this
					},
					setComponent: function (t, e) {
						switch (t) {
							case 0:
								this.x = e;
								break;
							case 1:
								this.y = e;
								break;
							case 2:
								this.z = e;
								break;
							default:
								throw new Error("index is out of range: " + t)
						}
						return this
					},
					getComponent: function (t) {
						switch (t) {
							case 0:
								return this.x;
							case 1:
								return this.y;
							case 2:
								return this.z;
							default:
								throw new Error("index is out of range: " + t)
						}
					},
					clone: function () {
						return new this.constructor(this.x, this.y, this.z)
					},
					copy: function (t) {
						return this.x = t.x, this.y = t.y, this.z = t.z, this
					},
					add: function (t, e) {
						return void 0 !== e ? (console.warn(
							"THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."
							), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this.z += t
							.z, this)
					},
					addScalar: function (t) {
						return this.x += t, this.y += t, this.z += t, this
					},
					addVectors: function (t, e) {
						return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this
					},
					addScaledVector: function (t, e) {
						return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this
					},
					sub: function (t, e) {
						return void 0 !== e ? (console.warn(
							"THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."
							), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this.z -= t
							.z, this)
					},
					subScalar: function (t) {
						return this.x -= t, this.y -= t, this.z -= t, this
					},
					subVectors: function (t, e) {
						return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this
					},
					multiply: function (t, e) {
						return void 0 !== e ? (console.warn(
							"THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."
							), this.multiplyVectors(t, e)) : (this.x *= t.x, this.y *= t.y, this
							.z *= t.z, this)
					},
					multiplyScalar: function (t) {
						return this.x *= t, this.y *= t, this.z *= t, this
					},
					multiplyVectors: function (t, e) {
						return this.x = t.x * e.x, this.y = t.y * e.y, this.z = t.z * e.z, this
					},
					applyEuler: (w = new hi, function (t) {
						return t && t.isEuler || console.error(
							"THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."
							), this.applyQuaternion(w.setFromEuler(t))
					}),
					applyAxisAngle: (_ = new hi, function (t, e) {
						return this.applyQuaternion(_.setFromAxisAngle(t, e))
					}),
					applyMatrix3: function (t) {
						var e = this.x,
							i = this.y,
							n = this.z,
							r = t.elements;
						return this.x = r[0] * e + r[3] * i + r[6] * n, this.y = r[1] * e + r[4] * i +
							r[7] * n, this.z = r[2] * e + r[5] * i + r[8] * n, this
					},
					applyMatrix4: function (t) {
						var e = this.x,
							i = this.y,
							n = this.z,
							r = t.elements,
							a = 1 / (r[3] * e + r[7] * i + r[11] * n + r[15]);
						return this.x = (r[0] * e + r[4] * i + r[8] * n + r[12]) * a, this.y = (r[1] *
							e + r[5] * i + r[9] * n + r[13]) * a, this.z = (r[2] * e + r[6] * i +
							r[10] * n + r[14]) * a, this
					},
					applyQuaternion: function (t) {
						var e = this.x,
							i = this.y,
							n = this.z,
							r = t.x,
							a = t.y,
							o = t.z,
							s = t.w,
							c = s * e + a * n - o * i,
							h = s * i + o * e - r * n,
							l = s * n + r * i - a * e,
							u = -r * e - a * i - o * n;
						return this.x = c * s + u * -r + h * -o - l * -a, this.y = h * s + u * -a +
							l * -r - c * -o, this.z = l * s + u * -o + c * -a - h * -r, this
					},
					project: function (t) {
						return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t
							.projectionMatrix)
					},
					unproject: (b = new ci, function (t) {
						return this.applyMatrix4(b.getInverse(t.projectionMatrix)).applyMatrix4(t
							.matrixWorld)
					}),
					transformDirection: function (t) {
						var e = this.x,
							i = this.y,
							n = this.z,
							r = t.elements;
						return this.x = r[0] * e + r[4] * i + r[8] * n, this.y = r[1] * e + r[5] * i +
							r[9] * n, this.z = r[2] * e + r[6] * i + r[10] * n, this.normalize()
					},
					divide: function (t) {
						return this.x /= t.x, this.y /= t.y, this.z /= t.z, this
					},
					divideScalar: function (t) {
						return this.multiplyScalar(1 / t)
					},
					min: function (t) {
						return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this
							.z = Math.min(this.z, t.z), this
					},
					max: function (t) {
						return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this
							.z = Math.max(this.z, t.z), this
					},
					clamp: function (t, e) {
						return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y,
								Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)),
							this
					},
					clampScalar: (y = new li, x = new li, function (t, e) {
						return y.set(t, t, t), x.set(e, e, e), this.clamp(y, x)
					}),
					clampLength: function (t, e) {
						var i = this.length();
						return this.divideScalar(i || 1).multiplyScalar(Math.max(t, Math.min(e, i)))
					},
					floor: function () {
						return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math
							.floor(this.z), this
					},
					ceil: function () {
						return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math
							.ceil(this.z), this
					},
					round: function () {
						return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math
							.round(this.z), this
					},
					roundToZero: function () {
						return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y =
							this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ?
							Math.ceil(this.z) : Math.floor(this.z), this
					},
					negate: function () {
						return this.x = -this.x, this.y = -this.y, this.z = -this.z, this
					},
					dot: function (t) {
						return this.x * t.x + this.y * t.y + this.z * t.z
					},
					lengthSq: function () {
						return this.x * this.x + this.y * this.y + this.z * this.z
					},
					length: function () {
						return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
					},
					manhattanLength: function () {
						return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
					},
					normalize: function () {
						return this.divideScalar(this.length() || 1)
					},
					setLength: function (t) {
						return this.normalize().multiplyScalar(t)
					},
					lerp: function (t, e) {
						return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (
							t.z - this.z) * e, this
					},
					lerpVectors: function (t, e, i) {
						return this.subVectors(e, t).multiplyScalar(i).add(t)
					},
					cross: function (t, e) {
						return void 0 !== e ? (console.warn(
							"THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."
							), this.crossVectors(t, e)) : this.crossVectors(this, t)
					},
					crossVectors: function (t, e) {
						var i = t.x,
							n = t.y,
							r = t.z,
							a = e.x,
							o = e.y,
							s = e.z;
						return this.x = n * s - r * o, this.y = r * a - i * s, this.z = i * o - n * a,
							this
					},
					projectOnVector: function (t) {
						var e = t.dot(this) / t.lengthSq();
						return this.copy(t).multiplyScalar(e)
					},
					projectOnPlane: (v = new li, function (t) {
						return v.copy(this).projectOnVector(t), this.sub(v)
					}),
					reflect: (g = new li, function (t) {
						return this.sub(g.copy(t).multiplyScalar(2 * this.dot(t)))
					}),
					angleTo: function (t) {
						var e = this.dot(t) / Math.sqrt(this.lengthSq() * t.lengthSq());
						return Math.acos(oi.clamp(e, -1, 1))
					},
					distanceTo: function (t) {
						return Math.sqrt(this.distanceToSquared(t))
					},
					distanceToSquared: function (t) {
						var e = this.x - t.x,
							i = this.y - t.y,
							n = this.z - t.z;
						return e * e + i * i + n * n
					},
					manhattanDistanceTo: function (t) {
						return Math.abs(this.x - t.x) + Math.abs(this.y - t.y) + Math.abs(this.z - t
							.z)
					},
					setFromSpherical: function (t) {
						return this.setFromSphericalCoords(t.radius, t.phi, t.theta)
					},
					setFromSphericalCoords: function (t, e, i) {
						var n = Math.sin(e) * t;
						return this.x = n * Math.sin(i), this.y = Math.cos(e) * t, this.z = n * Math
							.cos(i), this
					},
					setFromCylindrical: function (t) {
						return this.setFromCylindricalCoords(t.radius, t.theta, t.y)
					},
					setFromCylindricalCoords: function (t, e, i) {
						return this.x = t * Math.sin(e), this.y = i, this.z = t * Math.cos(e), this
					},
					setFromMatrixPosition: function (t) {
						var e = t.elements;
						return this.x = e[12], this.y = e[13], this.z = e[14], this
					},
					setFromMatrixScale: function (t) {
						var e = this.setFromMatrixColumn(t, 0).length(),
							i = this.setFromMatrixColumn(t, 1).length(),
							n = this.setFromMatrixColumn(t, 2).length();
						return this.x = e, this.y = i, this.z = n, this
					},
					setFromMatrixColumn: function (t, e) {
						return this.fromArray(t.elements, 4 * e)
					},
					equals: function (t) {
						return t.x === this.x && t.y === this.y && t.z === this.z
					},
					fromArray: function (t, e) {
						return void 0 === e && (e = 0), this.x = t[e], this.y = t[e + 1], this.z = t[
							e + 2], this
					},
					toArray: function (t, e) {
						return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this.x, t[e +
							1] = this.y, t[e + 2] = this.z, t
					},
					fromBufferAttribute: function (t, e, i) {
						return void 0 !== i && console.warn(
								"THREE.Vector3: offset has been removed from .fromBufferAttribute()."
								), this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this
					}
				}), Object.assign(ui.prototype, {
					isMatrix3: !0,
					set: function (t, e, i, n, r, a, o, s, c) {
						var h = this.elements;
						return h[0] = t, h[1] = n, h[2] = o, h[3] = e, h[4] = r, h[5] = s, h[6] = i,
							h[7] = a, h[8] = c, this
					},
					identity: function () {
						return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this
					},
					clone: function () {
						return (new this.constructor).fromArray(this.elements)
					},
					copy: function (t) {
						var e = this.elements,
							i = t.elements;
						return e[0] = i[0], e[1] = i[1], e[2] = i[2], e[3] = i[3], e[4] = i[4], e[5] =
							i[5], e[6] = i[6], e[7] = i[7], e[8] = i[8], this
					},
					setFromMatrix4: function (t) {
						var e = t.elements;
						return this.set(e[0], e[4], e[8], e[1], e[5], e[9], e[2], e[6], e[10]), this
					},
					applyToBufferAttribute: (M = new li, function (t) {
						for (var e = 0, i = t.count; e < i; e++) M.x = t.getX(e), M.y = t.getY(e),
							M.z = t.getZ(e), M.applyMatrix3(this), t.setXYZ(e, M.x, M.y, M.z);
						return t
					}),
					multiply: function (t) {
						return this.multiplyMatrices(this, t)
					},
					premultiply: function (t) {
						return this.multiplyMatrices(t, this)
					},
					multiplyMatrices: function (t, e) {
						var i = t.elements,
							n = e.elements,
							r = this.elements,
							a = i[0],
							o = i[3],
							s = i[6],
							c = i[1],
							h = i[4],
							l = i[7],
							u = i[2],
							p = i[5],
							d = i[8],
							f = n[0],
							m = n[3],
							g = n[6],
							v = n[1],
							y = n[4],
							x = n[7],
							b = n[2],
							_ = n[5],
							w = n[8];
						return r[0] = a * f + o * v + s * b, r[3] = a * m + o * y + s * _, r[6] = a *
							g + o * x + s * w, r[1] = c * f + h * v + l * b, r[4] = c * m + h * y +
							l * _, r[7] = c * g + h * x + l * w, r[2] = u * f + p * v + d * b, r[5] =
							u * m + p * y + d * _, r[8] = u * g + p * x + d * w, this
					},
					multiplyScalar: function (t) {
						var e = this.elements;
						return e[0] *= t, e[3] *= t, e[6] *= t, e[1] *= t, e[4] *= t, e[7] *= t, e[
							2] *= t, e[5] *= t, e[8] *= t, this
					},
					determinant: function () {
						var t = this.elements,
							e = t[0],
							i = t[1],
							n = t[2],
							r = t[3],
							a = t[4],
							o = t[5],
							s = t[6],
							c = t[7],
							h = t[8];
						return e * a * h - e * o * c - i * r * h + i * o * s + n * r * c - n * a * s
					},
					getInverse: function (t, e) {
						t && t.isMatrix4 && console.error(
							"THREE.Matrix3: .getInverse() no longer takes a Matrix4 argument.");
						var i = t.elements,
							n = this.elements,
							r = i[0],
							a = i[1],
							o = i[2],
							s = i[3],
							c = i[4],
							h = i[5],
							l = i[6],
							u = i[7],
							p = i[8],
							d = p * c - h * u,
							f = h * l - p * s,
							m = u * s - c * l,
							g = r * d + a * f + o * m;
						if (0 === g) {
							var v =
								"THREE.Matrix3: .getInverse() can't invert matrix, determinant is 0";
							if (!0 === e) throw new Error(v);
							return console.warn(v), this.identity()
						}
						var y = 1 / g;
						return n[0] = d * y, n[1] = (o * u - p * a) * y, n[2] = (h * a - o * c) * y,
							n[3] = f * y, n[4] = (p * r - o * l) * y, n[5] = (o * s - h * r) * y, n[
							6] = m * y, n[7] = (a * l - u * r) * y, n[8] = (c * r - a * s) * y, this
					},
					transpose: function () {
						var t, e = this.elements;
						return t = e[1], e[1] = e[3], e[3] = t, t = e[2], e[2] = e[6], e[6] = t, t =
							e[5], e[5] = e[7], e[7] = t, this
					},
					getNormalMatrix: function (t) {
						return this.setFromMatrix4(t).getInverse(this).transpose()
					},
					transposeIntoArray: function (t) {
						var e = this.elements;
						return t[0] = e[0], t[1] = e[3], t[2] = e[6], t[3] = e[1], t[4] = e[4], t[5] =
							e[7], t[6] = e[2], t[7] = e[5], t[8] = e[8], this
					},
					setUvTransform: function (t, e, i, n, r, a, o) {
						var s = Math.cos(r),
							c = Math.sin(r);
						this.set(i * s, i * c, -i * (s * a + c * o) + a + t, -n * c, n * s, -n * (-c *
							a + s * o) + o + e, 0, 0, 1)
					},
					scale: function (t, e) {
						var i = this.elements;
						return i[0] *= t, i[3] *= t, i[6] *= t, i[1] *= e, i[4] *= e, i[7] *= e, this
					},
					rotate: function (t) {
						var e = Math.cos(t),
							i = Math.sin(t),
							n = this.elements,
							r = n[0],
							a = n[3],
							o = n[6],
							s = n[1],
							c = n[4],
							h = n[7];
						return n[0] = e * r + i * s, n[3] = e * a + i * c, n[6] = e * o + i * h, n[
							1] = -i * r + e * s, n[4] = -i * a + e * c, n[7] = -i * o + e * h, this
					},
					translate: function (t, e) {
						var i = this.elements;
						return i[0] += t * i[2], i[3] += t * i[5], i[6] += t * i[8], i[1] += e * i[2],
							i[4] += e * i[5], i[7] += e * i[8], this
					},
					equals: function (t) {
						for (var e = this.elements, i = t.elements, n = 0; n < 9; n++)
							if (e[n] !== i[n]) return !1;
						return !0
					},
					fromArray: function (t, e) {
						void 0 === e && (e = 0);
						for (var i = 0; i < 9; i++) this.elements[i] = t[i + e];
						return this
					},
					toArray: function (t, e) {
						void 0 === t && (t = []), void 0 === e && (e = 0);
						var i = this.elements;
						return t[e] = i[0], t[e + 1] = i[1], t[e + 2] = i[2], t[e + 3] = i[3], t[e +
								4] = i[4], t[e + 5] = i[5], t[e + 6] = i[6], t[e + 7] = i[7], t[e +
							8] = i[8], t
					}
				});
				var pi, di, fi, mi, gi, vi, yi, xi, bi, _i, wi, Mi, Si, Ei, Ti, Ai, Li = {
						getDataURL: function (t) {
							var e;
							if ("undefined" == typeof HTMLCanvasElement) return t.src;
							if (t instanceof HTMLCanvasElement) e = t;
							else {
								void 0 === S && (S = document.createElement("canvas")), S.width = t.width, S
									.height = t.height;
								var i = S.getContext("2d");
								t instanceof ImageData ? i.putImageData(t, 0, 0) : i.drawImage(t, 0, 0, t
									.width, t.height), e = S
							}
							return 2048 < e.width || 2048 < e.height ? e.toDataURL("image/jpeg", .6) : e
								.toDataURL("image/png")
						}
					},
					Pi = 0;

				function Ri(t, e, i, n, r, a, o, s, c, h) {
					Object.defineProperty(this, "id", {
							value: Pi++
						}), this.uuid = oi.generateUUID(), this.name = "", this.image = void 0 !== t ? t : Ri
						.DEFAULT_IMAGE, this.mipmaps = [], this.mapping = void 0 !== e ? e : Ri.DEFAULT_MAPPING,
						this.wrapS = void 0 !== i ? i : Bt, this.wrapT = void 0 !== n ? n : Bt, this.magFilter =
						void 0 !== r ? r : Ft, this.minFilter = void 0 !== a ? a : Wt, this.anisotropy =
						void 0 !== c ? c : 1, this.format = void 0 !== o ? o : oe, this.type = void 0 !== s ? s :
						qt, this.offset = new si(0, 0), this.repeat = new si(1, 1), this.center = new si(0, 0),
						this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new ui, this
						.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment =
						4, this.encoding = void 0 !== h ? h : Ye, this.version = 0, this.onUpdate = null
				}

				function Ci(t, e, i, n) {
					this.x = t || 0, this.y = e || 0, this.z = i || 0, this.w = void 0 !== n ? n : 1
				}

				function Oi(t, e, i) {
					this.width = t, this.height = e, this.scissor = new Ci(0, 0, t, e), this.scissorTest = !1,
						this.viewport = new Ci(0, 0, t, e), i = i || {}, this.texture = new Ri(void 0, void 0, i
							.wrapS, i.wrapT, i.magFilter, i.minFilter, i.format, i.type, i.anisotropy, i.encoding
							), this.texture.generateMipmaps = void 0 !== i.generateMipmaps && i.generateMipmaps,
						this.texture.minFilter = void 0 !== i.minFilter ? i.minFilter : Ft, this.depthBuffer =
						void 0 === i.depthBuffer || i.depthBuffer, this.stencilBuffer = void 0 === i
						.stencilBuffer || i.stencilBuffer, this.depthTexture = void 0 !== i.depthTexture ? i
						.depthTexture : null
				}

				function Ii(t, e, i) {
					Oi.call(this, t, e, i), this.samples = 4
				}

				function Di(t, e, i) {
					Oi.call(this, t, e, i)
				}

				function Bi(t, e, i, n, r, a, o, s, c, h, l, u) {
					Ri.call(this, null, a, o, s, c, h, n, r, l, u), this.image = {
							data: t,
							width: e,
							height: i
						}, this.magFilter = void 0 !== c ? c : Nt, this.minFilter = void 0 !== h ? h : Nt, this
						.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1
				}

				function zi(t, e) {
					this.min = void 0 !== t ? t : new li(1 / 0, 1 / 0, 1 / 0), this.max = void 0 !== e ? e :
						new li(-1 / 0, -1 / 0, -1 / 0)
				}

				function Ni(t, e) {
					this.center = void 0 !== t ? t : new li, this.radius = void 0 !== e ? e : 0
				}

				function Gi(t, e) {
					this.normal = void 0 !== t ? t : new li(1, 0, 0), this.constant = void 0 !== e ? e : 0
				}

				function Ui(t, e, i, n, r, a) {
					this.planes = [void 0 !== t ? t : new Gi, void 0 !== e ? e : new Gi, void 0 !== i ? i :
						new Gi, void 0 !== n ? n : new Gi, void 0 !== r ? r : new Gi, void 0 !== a ? a :
						new Gi
					]
				}
				Ri.DEFAULT_IMAGE = void 0, Ri.DEFAULT_MAPPING = st, Ri.prototype = Object.assign(Object.create(e
						.prototype), {
						constructor: Ri,
						isTexture: !0,
						updateMatrix: function () {
							this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this
								.repeat.y, this.rotation, this.center.x, this.center.y)
						},
						clone: function () {
							return (new this.constructor).copy(this)
						},
						copy: function (t) {
							return this.name = t.name, this.image = t.image, this.mipmaps = t.mipmaps
								.slice(0), this.mapping = t.mapping, this.wrapS = t.wrapS, this.wrapT = t
								.wrapT, this.magFilter = t.magFilter, this.minFilter = t.minFilter, this
								.anisotropy = t.anisotropy, this.format = t.format, this.type = t.type,
								this.offset.copy(t.offset), this.repeat.copy(t.repeat), this.center.copy(t
									.center), this.rotation = t.rotation, this.matrixAutoUpdate = t
								.matrixAutoUpdate, this.matrix.copy(t.matrix), this.generateMipmaps = t
								.generateMipmaps, this.premultiplyAlpha = t.premultiplyAlpha, this.flipY =
								t.flipY, this.unpackAlignment = t.unpackAlignment, this.encoding = t
								.encoding, this
						},
						toJSON: function (t) {
							var e = void 0 === t || "string" == typeof t;
							if (!e && void 0 !== t.textures[this.uuid]) return t.textures[this.uuid];
							var i = {
								metadata: {
									version: 4.5,
									type: "Texture",
									generator: "Texture.toJSON"
								},
								uuid: this.uuid,
								name: this.name,
								mapping: this.mapping,
								repeat: [this.repeat.x, this.repeat.y],
								offset: [this.offset.x, this.offset.y],
								center: [this.center.x, this.center.y],
								rotation: this.rotation,
								wrap: [this.wrapS, this.wrapT],
								format: this.format,
								type: this.type,
								encoding: this.encoding,
								minFilter: this.minFilter,
								magFilter: this.magFilter,
								anisotropy: this.anisotropy,
								flipY: this.flipY,
								premultiplyAlpha: this.premultiplyAlpha,
								unpackAlignment: this.unpackAlignment
							};
							if (void 0 !== this.image) {
								var n = this.image;
								if (void 0 === n.uuid && (n.uuid = oi.generateUUID()), !e && void 0 === t
									.images[n.uuid]) {
									var r;
									if (Array.isArray(n)) {
										r = [];
										for (var a = 0, o = n.length; a < o; a++) r.push(Li.getDataURL(n[
											a]))
									} else r = Li.getDataURL(n);
									t.images[n.uuid] = {
										uuid: n.uuid,
										url: r
									}
								}
								i.image = n.uuid
							}
							return e || (t.textures[this.uuid] = i), i
						},
						dispose: function () {
							this.dispatchEvent({
								type: "dispose"
							})
						},
						transformUv: function (t) {
							if (this.mapping !== st) return t;
							if (t.applyMatrix3(this.matrix), t.x < 0 || 1 < t.x) switch (this.wrapS) {
								case Dt:
									t.x = t.x - Math.floor(t.x);
									break;
								case Bt:
									t.x = t.x < 0 ? 0 : 1;
									break;
								case zt:
									1 === Math.abs(Math.floor(t.x) % 2) ? t.x = Math.ceil(t.x) - t.x :
										t.x = t.x - Math.floor(t.x)
							}
							if (t.y < 0 || 1 < t.y) switch (this.wrapT) {
								case Dt:
									t.y = t.y - Math.floor(t.y);
									break;
								case Bt:
									t.y = t.y < 0 ? 0 : 1;
									break;
								case zt:
									1 === Math.abs(Math.floor(t.y) % 2) ? t.y = Math.ceil(t.y) - t.y :
										t.y = t.y - Math.floor(t.y)
							}
							return this.flipY && (t.y = 1 - t.y), t
						}
					}), Object.defineProperty(Ri.prototype, "needsUpdate", {
						set: function (t) {
							!0 === t && this.version++
						}
					}), Object.assign(Ci.prototype, {
						isVector4: !0,
						set: function (t, e, i, n) {
							return this.x = t, this.y = e, this.z = i, this.w = n, this
						},
						setScalar: function (t) {
							return this.x = t, this.y = t, this.z = t, this.w = t, this
						},
						setX: function (t) {
							return this.x = t, this
						},
						setY: function (t) {
							return this.y = t, this
						},
						setZ: function (t) {
							return this.z = t, this
						},
						setW: function (t) {
							return this.w = t, this
						},
						setComponent: function (t, e) {
							switch (t) {
								case 0:
									this.x = e;
									break;
								case 1:
									this.y = e;
									break;
								case 2:
									this.z = e;
									break;
								case 3:
									this.w = e;
									break;
								default:
									throw new Error("index is out of range: " + t)
							}
							return this
						},
						getComponent: function (t) {
							switch (t) {
								case 0:
									return this.x;
								case 1:
									return this.y;
								case 2:
									return this.z;
								case 3:
									return this.w;
								default:
									throw new Error("index is out of range: " + t)
							}
						},
						clone: function () {
							return new this.constructor(this.x, this.y, this.z, this.w)
						},
						copy: function (t) {
							return this.x = t.x, this.y = t.y, this.z = t.z, this.w = void 0 !== t.w ? t
								.w : 1, this
						},
						add: function (t, e) {
							return void 0 !== e ? (console.warn(
								"THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."
								), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this.z += t
								.z, this.w += t.w, this)
						},
						addScalar: function (t) {
							return this.x += t, this.y += t, this.z += t, this.w += t, this
						},
						addVectors: function (t, e) {
							return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this.w = t
								.w + e.w, this
						},
						addScaledVector: function (t, e) {
							return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this.w += t
								.w * e, this
						},
						sub: function (t, e) {
							return void 0 !== e ? (console.warn(
								"THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."
								), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this.z -= t
								.z, this.w -= t.w, this)
						},
						subScalar: function (t) {
							return this.x -= t, this.y -= t, this.z -= t, this.w -= t, this
						},
						subVectors: function (t, e) {
							return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this.w = t
								.w - e.w, this
						},
						multiplyScalar: function (t) {
							return this.x *= t, this.y *= t, this.z *= t, this.w *= t, this
						},
						applyMatrix4: function (t) {
							var e = this.x,
								i = this.y,
								n = this.z,
								r = this.w,
								a = t.elements;
							return this.x = a[0] * e + a[4] * i + a[8] * n + a[12] * r, this.y = a[1] *
								e + a[5] * i + a[9] * n + a[13] * r, this.z = a[2] * e + a[6] * i + a[
								10] * n + a[14] * r, this.w = a[3] * e + a[7] * i + a[11] * n + a[15] * r,
								this
						},
						divideScalar: function (t) {
							return this.multiplyScalar(1 / t)
						},
						setAxisAngleFromQuaternion: function (t) {
							this.w = 2 * Math.acos(t.w);
							var e = Math.sqrt(1 - t.w * t.w);
							return this.z = e < 1e-4 ? (this.x = 1, this.y = 0) : (this.x = t.x / e, this
								.y = t.y / e, t.z / e), this
						},
						setAxisAngleFromRotationMatrix: function (t) {
							var e, i, n, r, a = .01,
								o = .1,
								s = t.elements,
								c = s[0],
								h = s[4],
								l = s[8],
								u = s[1],
								p = s[5],
								d = s[9],
								f = s[2],
								m = s[6],
								g = s[10];
							if (Math.abs(h - u) < a && Math.abs(l - f) < a && Math.abs(d - m) < a) {
								if (Math.abs(h + u) < o && Math.abs(l + f) < o && Math.abs(d + m) < o &&
									Math.abs(c + p + g - 3) < o) return this.set(1, 0, 0, 0), this;
								e = Math.PI;
								var v = (c + 1) / 2,
									y = (p + 1) / 2,
									x = (g + 1) / 2,
									b = (h + u) / 4,
									_ = (l + f) / 4,
									w = (d + m) / 4;
								return y < v && x < v ? r = v < a ? (i = 0, n = .707106781) : (n = b / (
										i = Math.sqrt(v)), _ / i) : x < y ? r = y < a ? (n = 0, i =
										.707106781) : (i = b / (n = Math.sqrt(y)), w / n) : x < a ? (n =
										i = .707106781, r = 0) : (i = _ / (r = Math.sqrt(x)), n = w / r),
									this.set(i, n, r, e), this
							}
							var M = Math.sqrt((m - d) * (m - d) + (l - f) * (l - f) + (u - h) * (u - h));
							return Math.abs(M) < .001 && (M = 1), this.x = (m - d) / M, this.y = (l - f) /
								M, this.z = (u - h) / M, this.w = Math.acos((c + p + g - 1) / 2), this
						},
						min: function (t) {
							return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this
								.z = Math.min(this.z, t.z), this.w = Math.min(this.w, t.w), this
						},
						max: function (t) {
							return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this
								.z = Math.max(this.z, t.z), this.w = Math.max(this.w, t.w), this
						},
						clamp: function (t, e) {
							return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y,
									Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)),
								this.w = Math.max(t.w, Math.min(e.w, this.w)), this
						},
						clampScalar: function (t, e) {
							return void 0 === pi && (pi = new Ci, di = new Ci), pi.set(t, t, t, t), di
								.set(e, e, e, e), this.clamp(pi, di)
						},
						clampLength: function (t, e) {
							var i = this.length();
							return this.divideScalar(i || 1).multiplyScalar(Math.max(t, Math.min(e, i)))
						},
						floor: function () {
							return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math
								.floor(this.z), this.w = Math.floor(this.w), this
						},
						ceil: function () {
							return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math
								.ceil(this.z), this.w = Math.ceil(this.w), this
						},
						round: function () {
							return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math
								.round(this.z), this.w = Math.round(this.w), this
						},
						roundToZero: function () {
							return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y =
								this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ?
								Math.ceil(this.z) : Math.floor(this.z), this.w = this.w < 0 ? Math.ceil(
									this.w) : Math.floor(this.w), this
						},
						negate: function () {
							return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w,
								this
						},
						dot: function (t) {
							return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w
						},
						lengthSq: function () {
							return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
						},
						length: function () {
							return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this
								.w * this.w)
						},
						manhattanLength: function () {
							return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this
								.w)
						},
						normalize: function () {
							return this.divideScalar(this.length() || 1)
						},
						setLength: function (t) {
							return this.normalize().multiplyScalar(t)
						},
						lerp: function (t, e) {
							return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (
								t.z - this.z) * e, this.w += (t.w - this.w) * e, this
						},
						lerpVectors: function (t, e, i) {
							return this.subVectors(e, t).multiplyScalar(i).add(t)
						},
						equals: function (t) {
							return t.x === this.x && t.y === this.y && t.z === this.z && t.w === this.w
						},
						fromArray: function (t, e) {
							return void 0 === e && (e = 0), this.x = t[e], this.y = t[e + 1], this.z = t[
								e + 2], this.w = t[e + 3], this
						},
						toArray: function (t, e) {
							return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this.x, t[e +
								1] = this.y, t[e + 2] = this.z, t[e + 3] = this.w, t
						},
						fromBufferAttribute: function (t, e, i) {
							return void 0 !== i && console.warn(
									"THREE.Vector4: offset has been removed from .fromBufferAttribute()."
									), this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this
								.w = t.getW(e), this
						}
					}), Oi.prototype = Object.assign(Object.create(e.prototype), {
						constructor: Oi,
						isWebGLRenderTarget: !0,
						setSize: function (t, e) {
							this.width === t && this.height === e || (this.width = t, this.height = e,
								this.dispose()), this.viewport.set(0, 0, t, e), this.scissor.set(0, 0,
								t, e)
						},
						clone: function () {
							return (new this.constructor).copy(this)
						},
						copy: function (t) {
							return this.width = t.width, this.height = t.height, this.viewport.copy(t
									.viewport), this.texture = t.texture.clone(), this.depthBuffer = t
								.depthBuffer, this.stencilBuffer = t.stencilBuffer, this.depthTexture = t
								.depthTexture, this
						},
						dispose: function () {
							this.dispatchEvent({
								type: "dispose"
							})
						}
					}), Ii.prototype = Object.assign(Object.create(Oi.prototype), {
						constructor: Ii,
						isWebGLMultisampleRenderTarget: !0,
						copy: function (t) {
							return Oi.prototype.copy.call(this, t), this.samples = t.samples, this
						}
					}), Di.prototype = Object.create(Oi.prototype), (Di.prototype.constructor = Di).prototype
					.isWebGLRenderTargetCube = !0, Bi.prototype = Object.create(Ri.prototype), (Bi.prototype
						.constructor = Bi).prototype.isDataTexture = !0, Object.assign(zi.prototype, {
						isBox3: !0,
						set: function (t, e) {
							return this.min.copy(t), this.max.copy(e), this
						},
						setFromArray: function (t) {
							for (var e = 1 / 0, i = 1 / 0, n = 1 / 0, r = -1 / 0, a = -1 / 0, o = -1 / 0,
									s = 0, c = t.length; s < c; s += 3) {
								var h = t[s],
									l = t[s + 1],
									u = t[s + 2];
								h < e && (e = h), l < i && (i = l), u < n && (n = u), r < h && (r = h),
									a < l && (a = l), o < u && (o = u)
							}
							return this.min.set(e, i, n), this.max.set(r, a, o), this
						},
						setFromBufferAttribute: function (t) {
							for (var e = 1 / 0, i = 1 / 0, n = 1 / 0, r = -1 / 0, a = -1 / 0, o = -1 / 0,
									s = 0, c = t.count; s < c; s++) {
								var h = t.getX(s),
									l = t.getY(s),
									u = t.getZ(s);
								h < e && (e = h), l < i && (i = l), u < n && (n = u), r < h && (r = h),
									a < l && (a = l), o < u && (o = u)
							}
							return this.min.set(e, i, n), this.max.set(r, a, o), this
						},
						setFromPoints: function (t) {
							this.makeEmpty();
							for (var e = 0, i = t.length; e < i; e++) this.expandByPoint(t[e]);
							return this
						},
						setFromCenterAndSize: (yi = new li, function (t, e) {
							var i = yi.copy(e).multiplyScalar(.5);
							return this.min.copy(t).sub(i), this.max.copy(t).add(i), this
						}),
						setFromObject: function (t) {
							return this.makeEmpty(), this.expandByObject(t)
						},
						clone: function () {
							return (new this.constructor).copy(this)
						},
						copy: function (t) {
							return this.min.copy(t.min), this.max.copy(t.max), this
						},
						makeEmpty: function () {
							return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y =
								this.max.z = -1 / 0, this
						},
						isEmpty: function () {
							return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this
								.min.z
						},
						getCenter: function (t) {
							return void 0 === t && (console.warn(
									"THREE.Box3: .getCenter() target is now required"), t = new li), this
								.isEmpty() ? t.set(0, 0, 0) : t.addVectors(this.min, this.max)
								.multiplyScalar(.5)
						},
						getSize: function (t) {
							return void 0 === t && (console.warn(
									"THREE.Box3: .getSize() target is now required"), t = new li), this
								.isEmpty() ? t.set(0, 0, 0) : t.subVectors(this.max, this.min)
						},
						expandByPoint: function (t) {
							return this.min.min(t), this.max.max(t), this
						},
						expandByVector: function (t) {
							return this.min.sub(t), this.max.add(t), this
						},
						expandByScalar: function (t) {
							return this.min.addScalar(-t), this.max.addScalar(t), this
						},
						expandByObject: function () {
							var r, a, o, s = new li;

							function e(t) {
								var e = t.geometry;
								if (void 0 !== e)
									if (e.isGeometry) {
										var i = e.vertices;
										for (a = 0, o = i.length; a < o; a++) s.copy(i[a]), s
											.applyMatrix4(t.matrixWorld), r.expandByPoint(s)
									} else if (e.isBufferGeometry) {
									var n = e.attributes.position;
									if (void 0 !== n)
										for (a = 0, o = n.count; a < o; a++) s.fromBufferAttribute(n, a)
											.applyMatrix4(t.matrixWorld), r.expandByPoint(s)
								}
							}
							return function (t) {
								return r = this, t.updateMatrixWorld(!0), t.traverse(e), this
							}
						}(),
						containsPoint: function (t) {
							return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y >
								this.max.y || t.z < this.min.z || t.z > this.max.z)
						},
						containsBox: function (t) {
							return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min
								.y && t.max.y <= this.max.y && this.min.z <= t.min.z && t.max.z <= this
								.max.z
						},
						getParameter: function (t, e) {
							return void 0 === e && (console.warn(
									"THREE.Box3: .getParameter() target is now required"), e = new li), e
								.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) /
									(this.max.y - this.min.y), (t.z - this.min.z) / (this.max.z - this.min
										.z))
						},
						intersectsBox: function (t) {
							return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min
								.y || t.min.y > this.max.y || t.max.z < this.min.z || t.min.z > this
								.max.z)
						},
						intersectsSphere: (vi = new li, function (t) {
							return this.clampPoint(t.center, vi), vi.distanceToSquared(t.center) <= t
								.radius * t.radius
						}),
						intersectsPlane: function (t) {
							var e, i;
							return i = 0 < t.normal.x ? (e = t.normal.x * this.min.x, t.normal.x * this
									.max.x) : (e = t.normal.x * this.max.x, t.normal.x * this.min.x), 0 <
								t.normal.y ? (e += t.normal.y * this.min.y, i += t.normal.y * this.max
								.y) : (e += t.normal.y * this.max.y, i += t.normal.y * this.min.y), 0 < t
								.normal.z ? (e += t.normal.z * this.min.z, i += t.normal.z * this.max.z) :
								(e += t.normal.z * this.max.z, i += t.normal.z * this.min.z), e <= -t
								.constant && i >= -t.constant
						},
						intersectsTriangle: function () {
							var s = new li,
								c = new li,
								h = new li,
								i = new li,
								n = new li,
								r = new li,
								l = new li,
								a = new li,
								u = new li,
								o = new li;

							function p(t) {
								var e, i;
								for (e = 0, i = t.length - 3; e <= i; e += 3) {
									l.fromArray(t, e);
									var n = u.x * Math.abs(l.x) + u.y * Math.abs(l.y) + u.z * Math.abs(l
											.z),
										r = s.dot(l),
										a = c.dot(l),
										o = h.dot(l);
									if (Math.max(-Math.max(r, a, o), Math.min(r, a, o)) > n) return !1
								}
								return !0
							}
							return function (t) {
								if (this.isEmpty()) return !1;
								this.getCenter(a), u.subVectors(this.max, a), s.subVectors(t.a, a), c
									.subVectors(t.b, a), h.subVectors(t.c, a), i.subVectors(c, s), n
									.subVectors(h, c), r.subVectors(s, h);
								var e = [0, -i.z, i.y, 0, -n.z, n.y, 0, -r.z, r.y, i.z, 0, -i.x, n.z,
									0, -n.x, r.z, 0, -r.x, -i.y, i.x, 0, -n.y, n.x, 0, -r.y, r.x,
									0
								];
								return !!p(e) && (!!p(e = [1, 0, 0, 0, 1, 0, 0, 0, 1]) && (o
									.crossVectors(i, n), p(e = [o.x, o.y, o.z])))
							}
						}(),
						clampPoint: function (t, e) {
							return void 0 === e && (console.warn(
									"THREE.Box3: .clampPoint() target is now required"), e = new li), e
								.copy(t).clamp(this.min, this.max)
						},
						distanceToPoint: (gi = new li, function (t) {
							return gi.copy(t).clamp(this.min, this.max).sub(t).length()
						}),
						getBoundingSphere: (mi = new li, function (t) {
							return void 0 === t && (console.warn(
										"THREE.Box3: .getBoundingSphere() target is now required"),
									t = new Ni), this.getCenter(t.center), t.radius = .5 * this
								.getSize(mi).length(), t
						}),
						intersect: function (t) {
							return this.min.max(t.min), this.max.min(t.max), this.isEmpty() && this
								.makeEmpty(), this
						},
						union: function (t) {
							return this.min.min(t.min), this.max.max(t.max), this
						},
						applyMatrix4: (fi = [new li, new li, new li, new li, new li, new li, new li, new li],
							function (t) {
								return this.isEmpty() || (fi[0].set(this.min.x, this.min.y, this.min.z)
									.applyMatrix4(t), fi[1].set(this.min.x, this.min.y, this.max.z)
									.applyMatrix4(t), fi[2].set(this.min.x, this.max.y, this.min.z)
									.applyMatrix4(t), fi[3].set(this.min.x, this.max.y, this.max.z)
									.applyMatrix4(t), fi[4].set(this.max.x, this.min.y, this.min.z)
									.applyMatrix4(t), fi[5].set(this.max.x, this.min.y, this.max.z)
									.applyMatrix4(t), fi[6].set(this.max.x, this.max.y, this.min.z)
									.applyMatrix4(t), fi[7].set(this.max.x, this.max.y, this.max.z)
									.applyMatrix4(t), this.setFromPoints(fi)), this
							}),
						translate: function (t) {
							return this.min.add(t), this.max.add(t), this
						},
						equals: function (t) {
							return t.min.equals(this.min) && t.max.equals(this.max)
						}
					}), Object.assign(Ni.prototype, {
						set: function (t, e) {
							return this.center.copy(t), this.radius = e, this
						},
						setFromPoints: (xi = new zi, function (t, e) {
							var i = this.center;
							void 0 !== e ? i.copy(e) : xi.setFromPoints(t).getCenter(i);
							for (var n = 0, r = 0, a = t.length; r < a; r++) n = Math.max(n, i
								.distanceToSquared(t[r]));
							return this.radius = Math.sqrt(n), this
						}),
						clone: function () {
							return (new this.constructor).copy(this)
						},
						copy: function (t) {
							return this.center.copy(t.center), this.radius = t.radius, this
						},
						empty: function () {
							return this.radius <= 0
						},
						containsPoint: function (t) {
							return t.distanceToSquared(this.center) <= this.radius * this.radius
						},
						distanceToPoint: function (t) {
							return t.distanceTo(this.center) - this.radius
						},
						intersectsSphere: function (t) {
							var e = this.radius + t.radius;
							return t.center.distanceToSquared(this.center) <= e * e
						},
						intersectsBox: function (t) {
							return t.intersectsSphere(this)
						},
						intersectsPlane: function (t) {
							return Math.abs(t.distanceToPoint(this.center)) <= this.radius
						},
						clampPoint: function (t, e) {
							var i = this.center.distanceToSquared(t);
							return void 0 === e && (console.warn(
									"THREE.Sphere: .clampPoint() target is now required"), e = new li), e
								.copy(t), i > this.radius * this.radius && (e.sub(this.center)
								.normalize(), e.multiplyScalar(this.radius).add(this.center)), e
						},
						getBoundingBox: function (t) {
							return void 0 === t && (console.warn(
									"THREE.Sphere: .getBoundingBox() target is now required"), t =
								new zi), t.set(this.center, this.center), t.expandByScalar(this
								.radius), t
						},
						applyMatrix4: function (t) {
							return this.center.applyMatrix4(t), this.radius = this.radius * t
								.getMaxScaleOnAxis(), this
						},
						translate: function (t) {
							return this.center.add(t), this
						},
						equals: function (t) {
							return t.center.equals(this.center) && t.radius === this.radius
						}
					}), Object.assign(Gi.prototype, {
						set: function (t, e) {
							return this.normal.copy(t), this.constant = e, this
						},
						setComponents: function (t, e, i, n) {
							return this.normal.set(t, e, i), this.constant = n, this
						},
						setFromNormalAndCoplanarPoint: function (t, e) {
							return this.normal.copy(t), this.constant = -e.dot(this.normal), this
						},
						setFromCoplanarPoints: (Mi = new li, Si = new li, function (t, e, i) {
							var n = Mi.subVectors(i, e).cross(Si.subVectors(t, e)).normalize();
							return this.setFromNormalAndCoplanarPoint(n, t), this
						}),
						clone: function () {
							return (new this.constructor).copy(this)
						},
						copy: function (t) {
							return this.normal.copy(t.normal), this.constant = t.constant, this
						},
						normalize: function () {
							var t = 1 / this.normal.length();
							return this.normal.multiplyScalar(t), this.constant *= t, this
						},
						negate: function () {
							return this.constant *= -1, this.normal.negate(), this
						},
						distanceToPoint: function (t) {
							return this.normal.dot(t) + this.constant
						},
						distanceToSphere: function (t) {
							return this.distanceToPoint(t.center) - t.radius
						},
						projectPoint: function (t, e) {
							return void 0 === e && (console.warn(
										"THREE.Plane: .projectPoint() target is now required"), e =
									new li), e.copy(this.normal).multiplyScalar(-this.distanceToPoint(t))
								.add(t)
						},
						intersectLine: (wi = new li, function (t, e) {
							void 0 === e && (console.warn(
									"THREE.Plane: .intersectLine() target is now required"), e =
								new li);
							var i = t.delta(wi),
								n = this.normal.dot(i);
							if (0 === n) return 0 === this.distanceToPoint(t.start) ? e.copy(t
								.start) : void 0;
							var r = -(t.start.dot(this.normal) + this.constant) / n;
							return r < 0 || 1 < r ? void 0 : e.copy(i).multiplyScalar(r).add(t.start)
						}),
						intersectsLine: function (t) {
							var e = this.distanceToPoint(t.start),
								i = this.distanceToPoint(t.end);
							return e < 0 && 0 < i || i < 0 && 0 < e
						},
						intersectsBox: function (t) {
							return t.intersectsPlane(this)
						},
						intersectsSphere: function (t) {
							return t.intersectsPlane(this)
						},
						coplanarPoint: function (t) {
							return void 0 === t && (console.warn(
									"THREE.Plane: .coplanarPoint() target is now required"), t =
								new li), t.copy(this.normal).multiplyScalar(-this.constant)
						},
						applyMatrix4: (bi = new li, _i = new ui, function (t, e) {
							var i = e || _i.getNormalMatrix(t),
								n = this.coplanarPoint(bi).applyMatrix4(t),
								r = this.normal.applyMatrix3(i).normalize();
							return this.constant = -n.dot(r), this
						}),
						translate: function (t) {
							return this.constant -= t.dot(this.normal), this
						},
						equals: function (t) {
							return t.normal.equals(this.normal) && t.constant === this.constant
						}
					}), Object.assign(Ui.prototype, {
						set: function (t, e, i, n, r, a) {
							var o = this.planes;
							return o[0].copy(t), o[1].copy(e), o[2].copy(i), o[3].copy(n), o[4].copy(r),
								o[5].copy(a), this
						},
						clone: function () {
							return (new this.constructor).copy(this)
						},
						copy: function (t) {
							for (var e = this.planes, i = 0; i < 6; i++) e[i].copy(t.planes[i]);
							return this
						},
						setFromMatrix: function (t) {
							var e = this.planes,
								i = t.elements,
								n = i[0],
								r = i[1],
								a = i[2],
								o = i[3],
								s = i[4],
								c = i[5],
								h = i[6],
								l = i[7],
								u = i[8],
								p = i[9],
								d = i[10],
								f = i[11],
								m = i[12],
								g = i[13],
								v = i[14],
								y = i[15];
							return e[0].setComponents(o - n, l - s, f - u, y - m).normalize(), e[1]
								.setComponents(o + n, l + s, f + u, y + m).normalize(), e[2]
								.setComponents(o + r, l + c, f + p, y + g).normalize(), e[3]
								.setComponents(o - r, l - c, f - p, y - g).normalize(), e[4]
								.setComponents(o - a, l - h, f - d, y - v).normalize(), e[5]
								.setComponents(o + a, l + h, f + d, y + v).normalize(), this
						},
						intersectsObject: (Ai = new Ni, function (t) {
							var e = t.geometry;
							return null === e.boundingSphere && e.computeBoundingSphere(), Ai.copy(e
									.boundingSphere).applyMatrix4(t.matrixWorld), this
								.intersectsSphere(Ai)
						}),
						intersectsSprite: (Ti = new Ni, function (t) {
							return Ti.center.set(0, 0, 0), Ti.radius = .7071067811865476, Ti
								.applyMatrix4(t.matrixWorld), this.intersectsSphere(Ti)
						}),
						intersectsSphere: function (t) {
							for (var e = this.planes, i = t.center, n = -t.radius, r = 0; r < 6; r++) {
								if (e[r].distanceToPoint(i) < n) return !1
							}
							return !0
						},
						intersectsBox: (Ei = new li, function (t) {
							for (var e = this.planes, i = 0; i < 6; i++) {
								var n = e[i];
								if (Ei.x = 0 < n.normal.x ? t.max.x : t.min.x, Ei.y = 0 < n.normal.y ?
									t.max.y : t.min.y, Ei.z = 0 < n.normal.z ? t.max.z : t.min.z, n
									.distanceToPoint(Ei) < 0) return !1
							}
							return !0
						}),
						containsPoint: function (t) {
							for (var e = this.planes, i = 0; i < 6; i++)
								if (e[i].distanceToPoint(t) < 0) return !1;
							return !0
						}
					});
				var Fi = {
					alphamap_fragment: "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif",
					alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
					alphatest_fragment: "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif",
					aomap_fragment: "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif",
					aomap_pars_fragment: "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
					begin_vertex: "vec3 transformed = vec3( position );",
					beginnormal_vertex: "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif",
					bsdfs: "vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n#else\n\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t}\n\treturn 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE  = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS  = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\treturn specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec3 F = F_Schlick( specularColor, dotNV );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\tvec3 FssEss = F * brdf.x + brdf.y;\n\tfloat Ess = brdf.x + brdf.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}",
					bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tfDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",
					clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\tif ( clipped ) discard;\n\t#endif\n#endif",
					clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n\t#if ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )\n\t\tvarying vec3 vViewPosition;\n\t#endif\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",
					clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )\n\tvarying vec3 vViewPosition;\n#endif",
					clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif",
					color_fragment: "#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif",
					color_pars_fragment: "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif",
					color_pars_vertex: "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif",
					color_vertex: "#ifdef USE_COLOR\n\tvColor.xyz = color.xyz;\n#endif",
					common: "#define PI 3.14159265359\n#define PI2 6.28318530718\n#define PI_HALF 1.5707963267949\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}",
					cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_textureSize (1024.0)\nint getFaceFromDirection(vec3 direction) {\n\tvec3 absDirection = abs(direction);\n\tint face = -1;\n\tif( absDirection.x > absDirection.z ) {\n\t\tif(absDirection.x > absDirection.y )\n\t\t\tface = direction.x > 0.0 ? 0 : 3;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\telse {\n\t\tif(absDirection.z > absDirection.y )\n\t\t\tface = direction.z > 0.0 ? 2 : 5;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\treturn face;\n}\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\n\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\n\tfloat dxRoughness = dFdx(roughness);\n\tfloat dyRoughness = dFdy(roughness);\n\tvec3 dx = dFdx( vec * scale * dxRoughness );\n\tvec3 dy = dFdy( vec * scale * dyRoughness );\n\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\n\td = clamp(d, 1.0, cubeUV_rangeClamp);\n\tfloat mipLevel = 0.5 * log2(d);\n\treturn vec2(floor(mipLevel), fract(mipLevel));\n}\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\n\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\n\tfloat a = 16.0 * cubeUV_rcpTextureSize;\n\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\n\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\n\tfloat powScale = exp2_packed.x * exp2_packed.y;\n\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\n\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\n\tbool bRes = mipLevel == 0.0;\n\tscale =  bRes && (scale < a) ? a : scale;\n\tvec3 r;\n\tvec2 offset;\n\tint face = getFaceFromDirection(direction);\n\tfloat rcpPowScale = 1.0 / powScale;\n\tif( face == 0) {\n\t\tr = vec3(direction.x, -direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 1) {\n\t\tr = vec3(direction.y, direction.x, direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 2) {\n\t\tr = vec3(direction.z, direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 3) {\n\t\tr = vec3(direction.x, direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse if( face == 4) {\n\t\tr = vec3(direction.y, direction.x, -direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse {\n\t\tr = vec3(direction.z, -direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\tr = normalize(r);\n\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\n\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\n\tvec2 base = offset + vec2( texelOffset );\n\treturn base + s * ( scale - 2.0 * texelOffset );\n}\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\nvec4 textureCubeUV( sampler2D envMap, vec3 reflectedDirection, float roughness ) {\n\tfloat roughnessVal = roughness* cubeUV_maxLods3;\n\tfloat r1 = floor(roughnessVal);\n\tfloat r2 = r1 + 1.0;\n\tfloat t = fract(roughnessVal);\n\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\n\tfloat s = mipInfo.y;\n\tfloat level0 = mipInfo.x;\n\tfloat level1 = level0 + 1.0;\n\tlevel1 = level1 > 5.0 ? 5.0 : level1;\n\tlevel0 += min( floor( s + 0.5 ), 5.0 );\n\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\n\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\n\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\n\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\n\tvec4 result = mix(color10, color20, t);\n\treturn vec4(result.rgb, 1.0);\n}\n#endif",
					defaultnormal_vertex: "vec3 transformedNormal = normalMatrix * objectNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = normalMatrix * objectTangent;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif",
					displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",
					displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\n#endif",
					emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",
					emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",
					encodings_fragment: "gl_FragColor = linearToOutputTexel( gl_FragColor );",
					encodings_pars_fragment: "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = min( floor( D ) / 255.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}",
					envmap_fragment: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\tvec2 sampleUV;\n\t\treflectVec = normalize( reflectVec );\n\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\treflectVec = normalize( reflectVec );\n\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\tenvColor = envMapTexelToLinear( envColor );\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",
					envmap_pars_fragment: "#if defined( USE_ENVMAP ) || defined( PHYSICAL )\n\tuniform float reflectivity;\n\tuniform float envMapIntensity;\n#endif\n#ifdef USE_ENVMAP\n\t#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\n\t\tvarying vec3 vWorldPosition;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",
					envmap_pars_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",
					envmap_physical_pars_fragment: "#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, queryVec, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent ));\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\t\tvec2 sampleUV;\n\t\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif",
					envmap_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",
					fog_vertex: "#ifdef USE_FOG\n\tfogDepth = -mvPosition.z;\n#endif",
					fog_pars_vertex: "#ifdef USE_FOG\n\tvarying float fogDepth;\n#endif",
					fog_fragment: "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 ) );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",
					fog_pars_fragment: "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",
					gradientmap_pars_fragment: "#ifdef TOON\n\tuniform sampler2D gradientMap;\n\tvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\t\tfloat dotNL = dot( normal, lightDirection );\n\t\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t\t#ifdef USE_GRADIENTMAP\n\t\t\treturn texture2D( gradientMap, coord ).rgb;\n\t\t#else\n\t\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t\t#endif\n\t}\n#endif",
					lightmap_fragment: "#ifdef USE_LIGHTMAP\n\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n#endif",
					lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
					lights_lambert_vertex: "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n#endif",
					lights_pars_begin: "uniform vec3 ambientLightColor;\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t\tfloat shadowCameraNear;\n\t\tfloat shadowCameraFar;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif",
					lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",
					lights_phong_pars_fragment: "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifdef TOON\n\t\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#else\n\t\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\t\tvec3 irradiance = dotNL * directLight.color;\n\t#endif\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)",
					lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\n#ifdef STANDARD\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.clearCoat = saturate( clearCoat );\tmaterial.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\n#endif",
					lights_physical_pars_fragment: "struct PhysicalMaterial {\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n\t#ifndef STANDARD\n\t\tfloat clearCoat;\n\t\tfloat clearCoatRoughness;\n\t#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearCoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifndef STANDARD\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\n\treflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\t#ifndef STANDARD\n\t\treflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifndef ENVMAP_TYPE_CUBE_UV\n\t\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\t#endif\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifndef STANDARD\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\tfloat dotNL = dotNV;\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\tfloat clearCoatInv = 1.0 - clearCoatDHR;\n\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec3 singleScattering = vec3( 0.0 );\n\t\tvec3 multiScattering = vec3( 0.0 );\n\t\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\t\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n\t\tvec3 diffuse = material.diffuseColor;\n\t\treflectedLight.indirectSpecular += clearCoatInv * radiance * singleScattering;\n\t\treflectedLight.indirectDiffuse += multiScattering * cosineWeightedIrradiance;\n\t\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n\t#else\n\t\treflectedLight.indirectSpecular += clearCoatInv * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\n\t#endif\n\t#ifndef STANDARD\n\t\treflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",
					lights_fragment_begin: "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = normalize( vViewPosition );\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearCoatRadiance = vec3( 0.0 );\n#endif",
					lights_fragment_maps: "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tirradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), maxMipLevel );\n\t#ifndef STANDARD\n\t\tclearCoatRadiance += getLightProbeIndirectRadiance( geometry, Material_ClearCoat_BlinnShininessExponent( material ), maxMipLevel );\n\t#endif\n#endif",
					lights_fragment_end: "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, irradiance, clearCoatRadiance, geometry, material, reflectedLight );\n#endif",
					logdepthbuf_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",
					logdepthbuf_pars_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n#endif",
					logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif",
					logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t#else\n\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\tgl_Position.z *= gl_Position.w;\n\t#endif\n#endif",
					map_fragment: "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif",
					map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",
					map_particle_fragment: "#ifdef USE_MAP\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif",
					map_particle_pars_fragment: "#ifdef USE_MAP\n\tuniform mat3 uvTransform;\n\tuniform sampler2D map;\n#endif",
					metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",
					metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
					morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n#endif",
					morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n\t#ifndef USE_MORPHNORMALS\n\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif",
					morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\t#endif\n#endif",
					normal_fragment_begin: "#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t\tbitangent = bitangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#endif\n\t#endif\n#endif",
					normal_fragment_maps: "#ifdef USE_NORMALMAP\n\t#ifdef OBJECTSPACE_NORMALMAP\n\t\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\t#ifdef FLIP_SIDED\n\t\t\tnormal = - normal;\n\t\t#endif\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#endif\n\t\tnormal = normalize( normalMatrix * normal );\n\t#else\n\t\t#ifdef USE_TANGENT\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\t\tmapN.xy = normalScale * mapN.xy;\n\t\t\tnormal = normalize( vTBN * mapN );\n\t\t#else\n\t\t\tnormal = perturbNormal2Arb( -vViewPosition, normal );\n\t\t#endif\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif",
					normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n\t#ifdef OBJECTSPACE_NORMALMAP\n\t\tuniform mat3 normalMatrix;\n\t#else\n\t\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\t\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\t\tvec2 st0 = dFdx( vUv.st );\n\t\t\tvec2 st1 = dFdy( vUv.st );\n\t\t\tfloat scale = sign( st1.t * st0.s - st0.t * st1.s );\n\t\t\tvec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\n\t\t\tvec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\n\t\t\tvec3 N = normalize( surf_norm );\n\t\t\tmat3 tsn = mat3( S, T, N );\n\t\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\t\tmapN.xy *= normalScale;\n\t\t\tmapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t\treturn normalize( tsn * mapN );\n\t\t}\n\t#endif\n#endif",
					packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}",
					premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",
					project_vertex: "vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\ngl_Position = projectionMatrix * mvPosition;",
					dithering_fragment: "#if defined( DITHERING )\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",
					dithering_pars_fragment: "#if defined( DITHERING )\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",
					roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",
					roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
					shadowmap_pars_fragment: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n\t\tconst vec2 offset = vec2( 0.0, 1.0 );\n\t\tvec2 texelSize = vec2( 1.0 ) / size;\n\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\n\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n\t\tvec2 f = fract( uv * size + 0.5 );\n\t\tfloat a = mix( lb, lt, f.y );\n\t\tfloat b = mix( rb, rt, f.y );\n\t\tfloat c = mix( a, b, f.x );\n\t\treturn c;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif",
					shadowmap_pars_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n#endif",
					shadowmap_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n#endif",
					shadowmask_pars_fragment: "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tDirectionalLight directionalLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tshadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tSpotLight spotLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tshadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tPointLight pointLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tshadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#endif\n\t#endif\n\treturn shadow;\n}",
					skinbase_vertex: "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
					skinning_pars_vertex: "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif",
					skinning_vertex: "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",
					skinnormal_vertex: "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",
					specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
					specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
					tonemapping_fragment: "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",
					tonemapping_pars_fragment: "#ifndef saturate\n\t#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( ( color * ( 2.51 * color + 0.03 ) ) / ( color * ( 2.43 * color + 0.59 ) + 0.14 ) );\n}",
					uv_pars_fragment: "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n#endif",
					uv_pars_vertex: "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n\tuniform mat3 uvTransform;\n#endif",
					uv_vertex: "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif",
					uv2_pars_fragment: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif",
					uv2_pars_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n#endif",
					uv2_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = uv2;\n#endif",
					worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n#endif",
					background_frag: "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
					background_vert: "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",
					cube_frag: "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldDirection;\nvoid main() {\n\tvec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
					cube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
					depth_frag: "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - gl_FragCoord.z ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\n\t#endif\n}",
					depth_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}",
					distanceRGBA_frag: "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",
					distanceRGBA_vert: "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",
					equirect_frag: "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV;\n\tsampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
					equirect_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",
					linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
					linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\tvLineDistance = scale * lineDistance;\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
					meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\treflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
					meshbasic_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",
					meshlambert_frag: "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
					meshlambert_vert: "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
					meshmatcap_frag: "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
					meshmatcap_vert: "#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#ifndef FLAT_SHADED\n\t\tvNormal = normalize( transformedNormal );\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",
					meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
					meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
					meshphysical_frag: "#define PHYSICAL\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifndef STANDARD\n\tuniform float clearCoat;\n\tuniform float clearCoatRoughness;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
					meshphysical_vert: "#define PHYSICAL\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
					normal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\nvoid main() {\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}",
					normal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",
					points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
					points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",
					shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <fog_fragment>\n}",
					shadow_vert: "#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
					sprite_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
					sprite_vert: "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}"
				};

				function Hi(t) {
					var e = {};
					for (var i in t)
						for (var n in e[i] = {}, t[i]) {
							var r = t[i][n];
							r && (r.isColor || r.isMatrix3 || r.isMatrix4 || r.isVector2 || r.isVector3 || r
									.isVector4 || r.isTexture) ? e[i][n] = r.clone() : Array.isArray(r) ? e[i][
								n] = r.slice() : e[i][n] = r
						}
					return e
				}

				function ji(t) {
					for (var e = {}, i = 0; i < t.length; i++) {
						var n = Hi(t[i]);
						for (var r in n) e[r] = n[r]
					}
					return e
				}
				var ki, Vi, Wi, qi = {
						clone: Hi,
						merge: ji
					},
					Xi = {
						aliceblue: 15792383,
						antiquewhite: 16444375,
						aqua: 65535,
						aquamarine: 8388564,
						azure: 15794175,
						beige: 16119260,
						bisque: 16770244,
						black: 0,
						blanchedalmond: 16772045,
						blue: 255,
						blueviolet: 9055202,
						brown: 10824234,
						burlywood: 14596231,
						cadetblue: 6266528,
						chartreuse: 8388352,
						chocolate: 13789470,
						coral: 16744272,
						cornflowerblue: 6591981,
						cornsilk: 16775388,
						crimson: 14423100,
						cyan: 65535,
						darkblue: 139,
						darkcyan: 35723,
						darkgoldenrod: 12092939,
						darkgray: 11119017,
						darkgreen: 25600,
						darkgrey: 11119017,
						darkkhaki: 12433259,
						darkmagenta: 9109643,
						darkolivegreen: 5597999,
						darkorange: 16747520,
						darkorchid: 10040012,
						darkred: 9109504,
						darksalmon: 15308410,
						darkseagreen: 9419919,
						darkslateblue: 4734347,
						darkslategray: 3100495,
						darkslategrey: 3100495,
						darkturquoise: 52945,
						darkviolet: 9699539,
						deeppink: 16716947,
						deepskyblue: 49151,
						dimgray: 6908265,
						dimgrey: 6908265,
						dodgerblue: 2003199,
						firebrick: 11674146,
						floralwhite: 16775920,
						forestgreen: 2263842,
						fuchsia: 16711935,
						gainsboro: 14474460,
						ghostwhite: 16316671,
						gold: 16766720,
						goldenrod: 14329120,
						gray: 8421504,
						green: 32768,
						greenyellow: 11403055,
						grey: 8421504,
						honeydew: 15794160,
						hotpink: 16738740,
						indianred: 13458524,
						indigo: 4915330,
						ivory: 16777200,
						khaki: 15787660,
						lavender: 15132410,
						lavenderblush: 16773365,
						lawngreen: 8190976,
						lemonchiffon: 16775885,
						lightblue: 11393254,
						lightcoral: 15761536,
						lightcyan: 14745599,
						lightgoldenrodyellow: 16448210,
						lightgray: 13882323,
						lightgreen: 9498256,
						lightgrey: 13882323,
						lightpink: 16758465,
						lightsalmon: 16752762,
						lightseagreen: 2142890,
						lightskyblue: 8900346,
						lightslategray: 7833753,
						lightslategrey: 7833753,
						lightsteelblue: 11584734,
						lightyellow: 16777184,
						lime: 65280,
						limegreen: 3329330,
						linen: 16445670,
						magenta: 16711935,
						maroon: 8388608,
						mediumaquamarine: 6737322,
						mediumblue: 205,
						mediumorchid: 12211667,
						mediumpurple: 9662683,
						mediumseagreen: 3978097,
						mediumslateblue: 8087790,
						mediumspringgreen: 64154,
						mediumturquoise: 4772300,
						mediumvioletred: 13047173,
						midnightblue: 1644912,
						mintcream: 16121850,
						mistyrose: 16770273,
						moccasin: 16770229,
						navajowhite: 16768685,
						navy: 128,
						oldlace: 16643558,
						olive: 8421376,
						olivedrab: 7048739,
						orange: 16753920,
						orangered: 16729344,
						orchid: 14315734,
						palegoldenrod: 15657130,
						palegreen: 10025880,
						paleturquoise: 11529966,
						palevioletred: 14381203,
						papayawhip: 16773077,
						peachpuff: 16767673,
						peru: 13468991,
						pink: 16761035,
						plum: 14524637,
						powderblue: 11591910,
						purple: 8388736,
						rebeccapurple: 6697881,
						red: 16711680,
						rosybrown: 12357519,
						royalblue: 4286945,
						saddlebrown: 9127187,
						salmon: 16416882,
						sandybrown: 16032864,
						seagreen: 3050327,
						seashell: 16774638,
						sienna: 10506797,
						silver: 12632256,
						skyblue: 8900331,
						slateblue: 6970061,
						slategray: 7372944,
						slategrey: 7372944,
						snow: 16775930,
						springgreen: 65407,
						steelblue: 4620980,
						tan: 13808780,
						teal: 32896,
						thistle: 14204888,
						tomato: 16737095,
						turquoise: 4251856,
						violet: 15631086,
						wheat: 16113331,
						white: 16777215,
						whitesmoke: 16119285,
						yellow: 16776960,
						yellowgreen: 10145074
					};

				function Yi(t, e, i) {
					return void 0 === e && void 0 === i ? this.set(t) : this.setRGB(t, e, i)
				}
				Object.assign(Yi.prototype, {
					isColor: !0,
					r: 1,
					g: 1,
					b: 1,
					set: function (t) {
						return t && t.isColor ? this.copy(t) : "number" == typeof t ? this.setHex(t) :
							"string" == typeof t && this.setStyle(t), this
					},
					setScalar: function (t) {
						return this.r = t, this.g = t, this.b = t, this
					},
					setHex: function (t) {
						return t = Math.floor(t), this.r = (t >> 16 & 255) / 255, this.g = (t >> 8 &
							255) / 255, this.b = (255 & t) / 255, this
					},
					setRGB: function (t, e, i) {
						return this.r = t, this.g = e, this.b = i, this
					},
					setHSL: function () {
						function a(t, e, i) {
							return i < 0 && (i += 1), 1 < i && (i -= 1), i < 1 / 6 ? t + 6 * (e - t) *
								i : i < .5 ? e : i < 2 / 3 ? t + 6 * (e - t) * (2 / 3 - i) : t
						}
						return function (t, e, i) {
							if (t = oi.euclideanModulo(t, 1), e = oi.clamp(e, 0, 1), i = oi.clamp(
									i, 0, 1), 0 === e) this.r = this.g = this.b = i;
							else {
								var n = i <= .5 ? i * (1 + e) : i + e - i * e,
									r = 2 * i - n;
								this.r = a(r, n, t + 1 / 3), this.g = a(r, n, t), this.b = a(r, n,
									t - 1 / 3)
							}
							return this
						}
					}(),
					setStyle: function (e) {
						function t(t) {
							void 0 !== t && parseFloat(t) < 1 && console.warn(
								"THREE.Color: Alpha component of " + e + " will be ignored.")
						}
						var i;
						if (i = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(e)) {
							var n, r = i[1],
								a = i[2];
							switch (r) {
								case "rgb":
								case "rgba":
									if (n =
										/^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/
										.exec(a)) return this.r = Math.min(255, parseInt(n[1], 10)) /
										255, this.g = Math.min(255, parseInt(n[2], 10)) / 255,
										this.b = Math.min(255, parseInt(n[3], 10)) / 255, t(n[5]),
										this;
									if (n =
										/^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/
										.exec(a)) return this.r = Math.min(100, parseInt(n[1], 10)) /
										100, this.g = Math.min(100, parseInt(n[2], 10)) / 100,
										this.b = Math.min(100, parseInt(n[3], 10)) / 100, t(n[5]),
										this;
									break;
								case "hsl":
								case "hsla":
									if (n =
										/^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/
										.exec(a)) {
										var o = parseFloat(n[1]) / 360,
											s = parseInt(n[2], 10) / 100,
											c = parseInt(n[3], 10) / 100;
										return t(n[5]), this.setHSL(o, s, c)
									}
							}
						} else if (i = /^\#([A-Fa-f0-9]+)$/.exec(e)) {
							var h, l = (h = i[1]).length;
							if (3 === l) return this.r = parseInt(h.charAt(0) + h.charAt(0), 16) /
								255, this.g = parseInt(h.charAt(1) + h.charAt(1), 16) / 255, this
								.b = parseInt(h.charAt(2) + h.charAt(2), 16) / 255, this;
							if (6 === l) return this.r = parseInt(h.charAt(0) + h.charAt(1), 16) /
								255, this.g = parseInt(h.charAt(2) + h.charAt(3), 16) / 255, this
								.b = parseInt(h.charAt(4) + h.charAt(5), 16) / 255, this
						}
						e && 0 < e.length && (void 0 !== (h = Xi[e]) ? this.setHex(h) : console.warn(
							"THREE.Color: Unknown color " + e));
						return this
					},
					clone: function () {
						return new this.constructor(this.r, this.g, this.b)
					},
					copy: function (t) {
						return this.r = t.r, this.g = t.g, this.b = t.b, this
					},
					copyGammaToLinear: function (t, e) {
						return void 0 === e && (e = 2), this.r = Math.pow(t.r, e), this.g = Math.pow(t
							.g, e), this.b = Math.pow(t.b, e), this
					},
					copyLinearToGamma: function (t, e) {
						void 0 === e && (e = 2);
						var i = 0 < e ? 1 / e : 1;
						return this.r = Math.pow(t.r, i), this.g = Math.pow(t.g, i), this.b = Math
							.pow(t.b, i), this
					},
					convertGammaToLinear: function (t) {
						return this.copyGammaToLinear(this, t), this
					},
					convertLinearToGamma: function (t) {
						return this.copyLinearToGamma(this, t), this
					},
					copySRGBToLinear: function () {
						function e(t) {
							return t < .04045 ? .0773993808 * t : Math.pow(.9478672986 * t +
								.0521327014, 2.4)
						}
						return function (t) {
							return this.r = e(t.r), this.g = e(t.g), this.b = e(t.b), this
						}
					}(),
					copyLinearToSRGB: function () {
						function e(t) {
							return t < .0031308 ? 12.92 * t : 1.055 * Math.pow(t, .41666) - .055
						}
						return function (t) {
							return this.r = e(t.r), this.g = e(t.g), this.b = e(t.b), this
						}
					}(),
					convertSRGBToLinear: function () {
						return this.copySRGBToLinear(this), this
					},
					convertLinearToSRGB: function () {
						return this.copyLinearToSRGB(this), this
					},
					getHex: function () {
						return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0
					},
					getHexString: function () {
						return ("000000" + this.getHex().toString(16)).slice(-6)
					},
					getHSL: function (t) {
						void 0 === t && (console.warn(
							"THREE.Color: .getHSL() target is now required"), t = {
								h: 0,
								s: 0,
								l: 0
							});
						var e, i, n = this.r,
							r = this.g,
							a = this.b,
							o = Math.max(n, r, a),
							s = Math.min(n, r, a),
							c = (s + o) / 2;
						if (s === o) i = e = 0;
						else {
							var h = o - s;
							switch (i = c <= .5 ? h / (o + s) : h / (2 - o - s), o) {
								case n:
									e = (r - a) / h + (r < a ? 6 : 0);
									break;
								case r:
									e = (a - n) / h + 2;
									break;
								case a:
									e = (n - r) / h + 4
							}
							e /= 6
						}
						return t.h = e, t.s = i, t.l = c, t
					},
					getStyle: function () {
						return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 *
							this.b | 0) + ")"
					},
					offsetHSL: (Wi = {}, function (t, e, i) {
						return this.getHSL(Wi), Wi.h += t, Wi.s += e, Wi.l += i, this.setHSL(Wi.h,
							Wi.s, Wi.l), this
					}),
					add: function (t) {
						return this.r += t.r, this.g += t.g, this.b += t.b, this
					},
					addColors: function (t, e) {
						return this.r = t.r + e.r, this.g = t.g + e.g, this.b = t.b + e.b, this
					},
					addScalar: function (t) {
						return this.r += t, this.g += t, this.b += t, this
					},
					sub: function (t) {
						return this.r = Math.max(0, this.r - t.r), this.g = Math.max(0, this.g - t.g),
							this.b = Math.max(0, this.b - t.b), this
					},
					multiply: function (t) {
						return this.r *= t.r, this.g *= t.g, this.b *= t.b, this
					},
					multiplyScalar: function (t) {
						return this.r *= t, this.g *= t, this.b *= t, this
					},
					lerp: function (t, e) {
						return this.r += (t.r - this.r) * e, this.g += (t.g - this.g) * e, this.b += (
							t.b - this.b) * e, this
					},
					lerpHSL: (ki = {
						h: 0,
						s: 0,
						l: 0
					}, Vi = {
						h: 0,
						s: 0,
						l: 0
					}, function (t, e) {
						this.getHSL(ki), t.getHSL(Vi);
						var i = oi.lerp(ki.h, Vi.h, e),
							n = oi.lerp(ki.s, Vi.s, e),
							r = oi.lerp(ki.l, Vi.l, e);
						return this.setHSL(i, n, r), this
					}),
					equals: function (t) {
						return t.r === this.r && t.g === this.g && t.b === this.b
					},
					fromArray: function (t, e) {
						return void 0 === e && (e = 0), this.r = t[e], this.g = t[e + 1], this.b = t[
							e + 2], this
					},
					toArray: function (t, e) {
						return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this.r, t[e +
							1] = this.g, t[e + 2] = this.b, t
					},
					toJSON: function () {
						return this.getHex()
					}
				});
				var Zi, Ji, Qi = {
						common: {
							diffuse: {
								value: new Yi(15658734)
							},
							opacity: {
								value: 1
							},
							map: {
								value: null
							},
							uvTransform: {
								value: new ui
							},
							alphaMap: {
								value: null
							}
						},
						specularmap: {
							specularMap: {
								value: null
							}
						},
						envmap: {
							envMap: {
								value: null
							},
							flipEnvMap: {
								value: -1
							},
							reflectivity: {
								value: 1
							},
							refractionRatio: {
								value: .98
							},
							maxMipLevel: {
								value: 0
							}
						},
						aomap: {
							aoMap: {
								value: null
							},
							aoMapIntensity: {
								value: 1
							}
						},
						lightmap: {
							lightMap: {
								value: null
							},
							lightMapIntensity: {
								value: 1
							}
						},
						emissivemap: {
							emissiveMap: {
								value: null
							}
						},
						bumpmap: {
							bumpMap: {
								value: null
							},
							bumpScale: {
								value: 1
							}
						},
						normalmap: {
							normalMap: {
								value: null
							},
							normalScale: {
								value: new si(1, 1)
							}
						},
						displacementmap: {
							displacementMap: {
								value: null
							},
							displacementScale: {
								value: 1
							},
							displacementBias: {
								value: 0
							}
						},
						roughnessmap: {
							roughnessMap: {
								value: null
							}
						},
						metalnessmap: {
							metalnessMap: {
								value: null
							}
						},
						gradientmap: {
							gradientMap: {
								value: null
							}
						},
						fog: {
							fogDensity: {
								value: 25e-5
							},
							fogNear: {
								value: 1
							},
							fogFar: {
								value: 2e3
							},
							fogColor: {
								value: new Yi(16777215)
							}
						},
						lights: {
							ambientLightColor: {
								value: []
							},
							directionalLights: {
								value: [],
								properties: {
									direction: {},
									color: {},
									shadow: {},
									shadowBias: {},
									shadowRadius: {},
									shadowMapSize: {}
								}
							},
							directionalShadowMap: {
								value: []
							},
							directionalShadowMatrix: {
								value: []
							},
							spotLights: {
								value: [],
								properties: {
									color: {},
									position: {},
									direction: {},
									distance: {},
									coneCos: {},
									penumbraCos: {},
									decay: {},
									shadow: {},
									shadowBias: {},
									shadowRadius: {},
									shadowMapSize: {}
								}
							},
							spotShadowMap: {
								value: []
							},
							spotShadowMatrix: {
								value: []
							},
							pointLights: {
								value: [],
								properties: {
									color: {},
									position: {},
									decay: {},
									distance: {},
									shadow: {},
									shadowBias: {},
									shadowRadius: {},
									shadowMapSize: {},
									shadowCameraNear: {},
									shadowCameraFar: {}
								}
							},
							pointShadowMap: {
								value: []
							},
							pointShadowMatrix: {
								value: []
							},
							hemisphereLights: {
								value: [],
								properties: {
									direction: {},
									skyColor: {},
									groundColor: {}
								}
							},
							rectAreaLights: {
								value: [],
								properties: {
									color: {},
									position: {},
									width: {},
									height: {}
								}
							}
						},
						points: {
							diffuse: {
								value: new Yi(15658734)
							},
							opacity: {
								value: 1
							},
							size: {
								value: 1
							},
							scale: {
								value: 1
							},
							map: {
								value: null
							},
							uvTransform: {
								value: new ui
							}
						},
						sprite: {
							diffuse: {
								value: new Yi(15658734)
							},
							opacity: {
								value: 1
							},
							center: {
								value: new si(.5, .5)
							},
							rotation: {
								value: 0
							},
							map: {
								value: null
							},
							uvTransform: {
								value: new ui
							}
						}
					},
					Ki = {
						basic: {
							uniforms: ji([Qi.common, Qi.specularmap, Qi.envmap, Qi.aomap, Qi.lightmap, Qi.fog]),
							vertexShader: Fi.meshbasic_vert,
							fragmentShader: Fi.meshbasic_frag
						},
						lambert: {
							uniforms: ji([Qi.common, Qi.specularmap, Qi.envmap, Qi.aomap, Qi.lightmap, Qi
								.emissivemap, Qi.fog, Qi.lights, {
									emissive: {
										value: new Yi(0)
									}
								}
							]),
							vertexShader: Fi.meshlambert_vert,
							fragmentShader: Fi.meshlambert_frag
						},
						phong: {
							uniforms: ji([Qi.common, Qi.specularmap, Qi.envmap, Qi.aomap, Qi.lightmap, Qi
								.emissivemap, Qi.bumpmap, Qi.normalmap, Qi.displacementmap, Qi
								.gradientmap, Qi.fog, Qi.lights, {
									emissive: {
										value: new Yi(0)
									},
									specular: {
										value: new Yi(1118481)
									},
									shininess: {
										value: 30
									}
								}
							]),
							vertexShader: Fi.meshphong_vert,
							fragmentShader: Fi.meshphong_frag
						},
						standard: {
							uniforms: ji([Qi.common, Qi.envmap, Qi.aomap, Qi.lightmap, Qi.emissivemap, Qi.bumpmap,
								Qi.normalmap, Qi.displacementmap, Qi.roughnessmap, Qi.metalnessmap, Qi
								.fog, Qi.lights, {
									emissive: {
										value: new Yi(0)
									},
									roughness: {
										value: .5
									},
									metalness: {
										value: .5
									},
									envMapIntensity: {
										value: 1
									}
								}
							]),
							vertexShader: Fi.meshphysical_vert,
							fragmentShader: Fi.meshphysical_frag
						},
						matcap: {
							uniforms: ji([Qi.common, Qi.bumpmap, Qi.normalmap, Qi.displacementmap, Qi.fog, {
								matcap: {
									value: null
								}
							}]),
							vertexShader: Fi.meshmatcap_vert,
							fragmentShader: Fi.meshmatcap_frag
						},
						points: {
							uniforms: ji([Qi.points, Qi.fog]),
							vertexShader: Fi.points_vert,
							fragmentShader: Fi.points_frag
						},
						dashed: {
							uniforms: ji([Qi.common, Qi.fog, {
								scale: {
									value: 1
								},
								dashSize: {
									value: 1
								},
								totalSize: {
									value: 2
								}
							}]),
							vertexShader: Fi.linedashed_vert,
							fragmentShader: Fi.linedashed_frag
						},
						depth: {
							uniforms: ji([Qi.common, Qi.displacementmap]),
							vertexShader: Fi.depth_vert,
							fragmentShader: Fi.depth_frag
						},
						normal: {
							uniforms: ji([Qi.common, Qi.bumpmap, Qi.normalmap, Qi.displacementmap, {
								opacity: {
									value: 1
								}
							}]),
							vertexShader: Fi.normal_vert,
							fragmentShader: Fi.normal_frag
						},
						sprite: {
							uniforms: ji([Qi.sprite, Qi.fog]),
							vertexShader: Fi.sprite_vert,
							fragmentShader: Fi.sprite_frag
						},
						background: {
							uniforms: {
								uvTransform: {
									value: new ui
								},
								t2D: {
									value: null
								}
							},
							vertexShader: Fi.background_vert,
							fragmentShader: Fi.background_frag
						},
						cube: {
							uniforms: {
								tCube: {
									value: null
								},
								tFlip: {
									value: -1
								},
								opacity: {
									value: 1
								}
							},
							vertexShader: Fi.cube_vert,
							fragmentShader: Fi.cube_frag
						},
						equirect: {
							uniforms: {
								tEquirect: {
									value: null
								}
							},
							vertexShader: Fi.equirect_vert,
							fragmentShader: Fi.equirect_frag
						},
						distanceRGBA: {
							uniforms: ji([Qi.common, Qi.displacementmap, {
								referencePosition: {
									value: new li
								},
								nearDistance: {
									value: 1
								},
								farDistance: {
									value: 1e3
								}
							}]),
							vertexShader: Fi.distanceRGBA_vert,
							fragmentShader: Fi.distanceRGBA_frag
						},
						shadow: {
							uniforms: ji([Qi.lights, Qi.fog, {
								color: {
									value: new Yi(0)
								},
								opacity: {
									value: 1
								}
							}]),
							vertexShader: Fi.shadow_vert,
							fragmentShader: Fi.shadow_frag
						}
					};

				function $i() {
					var i = null,
						n = !1,
						r = null;

					function a(t, e) {
						!1 !== n && (r(t, e), i.requestAnimationFrame(a))
					}
					return {
						start: function () {
							!0 !== n && null !== r && (i.requestAnimationFrame(a), n = !0)
						},
						stop: function () {
							n = !1
						},
						setAnimationLoop: function (t) {
							r = t
						},
						setContext: function (t) {
							i = t
						}
					}
				}

				function tn(o) {
					var n = new WeakMap;

					function r(t, e) {
						var i = t.array,
							n = t.dynamic ? 35048 : 35044,
							r = o.createBuffer();
						o.bindBuffer(e, r), o.bufferData(e, i, n), t.onUploadCallback();
						var a = 5126;
						return i instanceof Float32Array ? a = 5126 : i instanceof Float64Array ? console.warn(
								"THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.") :
							i instanceof Uint16Array ? a = 5123 : i instanceof Int16Array ? a = 5122 :
							i instanceof Uint32Array ? a = 5125 : i instanceof Int32Array ? a = 5124 :
							i instanceof Int8Array ? a = 5120 : i instanceof Uint8Array && (a = 5121), {
								buffer: r,
								type: a,
								bytesPerElement: i.BYTES_PER_ELEMENT,
								version: t.version
							}
					}

					function a(t, e, i) {
						var n = e.array,
							r = e.updateRange;
						o.bindBuffer(i, t), !1 === e.dynamic ? o.bufferData(i, n, 35044) : -1 === r.count ? o
							.bufferSubData(i, 0, n) : 0 === r.count ? console.error(
								"THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually."
								) : (o.bufferSubData(i, r.offset * n.BYTES_PER_ELEMENT, n.subarray(r.offset, r
								.offset + r.count)), r.count = -1)
					}

					function t(t) {
						return t.isInterleavedBufferAttribute && (t = t.data), n.get(t)
					}

					function e(t) {
						t.isInterleavedBufferAttribute && (t = t.data);
						var e = n.get(t);
						e && (o.deleteBuffer(e.buffer), n.delete(t))
					}

					function i(t, e) {
						t.isInterleavedBufferAttribute && (t = t.data);
						var i = n.get(t);
						void 0 === i ? n.set(t, r(t, e)) : i.version < t.version && (a(i.buffer, t, e), i
							.version = t.version)
					}
					return {
						get: t,
						remove: e,
						update: i
					}
				}

				function en(t, e, i, n, r, a) {
					this.a = t, this.b = e, this.c = i, this.normal = n && n.isVector3 ? n : new li, this
						.vertexNormals = Array.isArray(n) ? n : [], this.color = r && r.isColor ? r : new Yi, this
						.vertexColors = Array.isArray(r) ? r : [], this.materialIndex = void 0 !== a ? a : 0
				}

				function nn(t, e, i, n) {
					this._x = t || 0, this._y = e || 0, this._z = i || 0, this._order = n || nn.DefaultOrder
				}

				function rn() {
					this.mask = 1
				}
				Ki.physical = {
						uniforms: ji([Ki.standard.uniforms, {
							clearCoat: {
								value: 0
							},
							clearCoatRoughness: {
								value: 0
							}
						}]),
						vertexShader: Fi.meshphysical_vert,
						fragmentShader: Fi.meshphysical_frag
					}, Object.assign(en.prototype, {
						clone: function () {
							return (new this.constructor).copy(this)
						},
						copy: function (t) {
							this.a = t.a, this.b = t.b, this.c = t.c, this.normal.copy(t.normal), this
								.color.copy(t.color), this.materialIndex = t.materialIndex;
							for (var e = 0, i = t.vertexNormals.length; e < i; e++) this.vertexNormals[
								e] = t.vertexNormals[e].clone();
							for (e = 0, i = t.vertexColors.length; e < i; e++) this.vertexColors[e] = t
								.vertexColors[e].clone();
							return this
						}
					}), nn.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"], nn.DefaultOrder = "XYZ",
					Object.defineProperties(nn.prototype, {
						x: {
							get: function () {
								return this._x
							},
							set: function (t) {
								this._x = t, this.onChangeCallback()
							}
						},
						y: {
							get: function () {
								return this._y
							},
							set: function (t) {
								this._y = t, this.onChangeCallback()
							}
						},
						z: {
							get: function () {
								return this._z
							},
							set: function (t) {
								this._z = t, this.onChangeCallback()
							}
						},
						order: {
							get: function () {
								return this._order
							},
							set: function (t) {
								this._order = t, this.onChangeCallback()
							}
						}
					}), Object.assign(nn.prototype, {
						isEuler: !0,
						set: function (t, e, i, n) {
							return this._x = t, this._y = e, this._z = i, this._order = n || this._order,
								this.onChangeCallback(), this
						},
						clone: function () {
							return new this.constructor(this._x, this._y, this._z, this._order)
						},
						copy: function (t) {
							return this._x = t._x, this._y = t._y, this._z = t._z, this._order = t._order,
								this.onChangeCallback(), this
						},
						setFromRotationMatrix: function (t, e, i) {
							var n = oi.clamp,
								r = t.elements,
								a = r[0],
								o = r[4],
								s = r[8],
								c = r[1],
								h = r[5],
								l = r[9],
								u = r[2],
								p = r[6],
								d = r[10];
							return "XYZ" === (e = e || this._order) ? (this._y = Math.asin(n(s, -1, 1)),
									Math.abs(s) < .99999 ? (this._x = Math.atan2(-l, d), this._z = Math
										.atan2(-o, a)) : (this._x = Math.atan2(p, h), this._z = 0)) :
								"YXZ" === e ? (this._x = Math.asin(-n(l, -1, 1)), Math.abs(l) < .99999 ? (
									this._y = Math.atan2(s, d), this._z = Math.atan2(c, h)) : (this
									._y = Math.atan2(-u, a), this._z = 0)) : "ZXY" === e ? (this._x = Math
									.asin(n(p, -1, 1)), Math.abs(p) < .99999 ? (this._y = Math.atan2(-u,
										d), this._z = Math.atan2(-o, h)) : (this._y = 0, this._z = Math
										.atan2(c, a))) : "ZYX" === e ? (this._y = Math.asin(-n(u, -1, 1)),
									Math.abs(u) < .99999 ? (this._x = Math.atan2(p, d), this._z = Math
										.atan2(c, a)) : (this._x = 0, this._z = Math.atan2(-o, h))) :
								"YZX" === e ? (this._z = Math.asin(n(c, -1, 1)), Math.abs(c) < .99999 ? (
									this._x = Math.atan2(-l, h), this._y = Math.atan2(-u, a)) : (this
									._x = 0, this._y = Math.atan2(s, d))) : "XZY" === e ? (this._z = Math
									.asin(-n(o, -1, 1)), Math.abs(o) < .99999 ? (this._x = Math.atan2(p,
										h), this._y = Math.atan2(s, a)) : (this._x = Math.atan2(-l, d),
										this._y = 0)) : console.warn(
									"THREE.Euler: .setFromRotationMatrix() given unsupported order: " + e
									), this._order = e, !1 !== i && this.onChangeCallback(), this
						},
						setFromQuaternion: (Ji = new ci, function (t, e, i) {
							return Ji.makeRotationFromQuaternion(t), this.setFromRotationMatrix(Ji, e,
								i)
						}),
						setFromVector3: function (t, e) {
							return this.set(t.x, t.y, t.z, e || this._order)
						},
						reorder: (Zi = new hi, function (t) {
							return Zi.setFromEuler(this), this.setFromQuaternion(Zi, t)
						}),
						equals: function (t) {
							return t._x === this._x && t._y === this._y && t._z === this._z && t
								._order === this._order
						},
						fromArray: function (t) {
							return this._x = t[0], this._y = t[1], this._z = t[2], void 0 !== t[3] && (
								this._order = t[3]), this.onChangeCallback(), this
						},
						toArray: function (t, e) {
							return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this._x, t[
								e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._order, t
						},
						toVector3: function (t) {
							return t ? t.set(this._x, this._y, this._z) : new li(this._x, this._y, this
								._z)
						},
						onChange: function (t) {
							return this.onChangeCallback = t, this
						},
						onChangeCallback: function () {}
					}), Object.assign(rn.prototype, {
						set: function (t) {
							this.mask = 1 << t | 0
						},
						enable: function (t) {
							this.mask |= 1 << t | 0
						},
						toggle: function (t) {
							this.mask ^= 1 << t | 0
						},
						disable: function (t) {
							this.mask &= ~(1 << t | 0)
						},
						test: function (t) {
							return 0 != (this.mask & t.mask)
						}
					});
				var an, on, sn, cn, hn, ln, un, pn, dn, fn, mn, gn, vn, yn, xn, bn, _n, wn, Mn = 0;

				function Sn() {
					Object.defineProperty(this, "id", {
							value: Mn++
						}), this.uuid = oi.generateUUID(), this.name = "", this.type = "Object3D", this.parent =
						null, this.children = [], this.up = Sn.DefaultUp.clone();
					var t = new li,
						e = new nn,
						i = new hi,
						n = new li(1, 1, 1);

					function r() {
						i.setFromEuler(e, !1)
					}

					function a() {
						e.setFromQuaternion(i, void 0, !1)
					}
					e.onChange(r), i.onChange(a), Object.defineProperties(this, {
							position: {
								configurable: !0,
								enumerable: !0,
								value: t
							},
							rotation: {
								configurable: !0,
								enumerable: !0,
								value: e
							},
							quaternion: {
								configurable: !0,
								enumerable: !0,
								value: i
							},
							scale: {
								configurable: !0,
								enumerable: !0,
								value: n
							},
							modelViewMatrix: {
								value: new ci
							},
							normalMatrix: {
								value: new ui
							}
						}), this.matrix = new ci, this.matrixWorld = new ci, this.matrixAutoUpdate = Sn
						.DefaultMatrixAutoUpdate, this.matrixWorldNeedsUpdate = !1, this.layers = new rn, this
						.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0,
						this.renderOrder = 0, this.userData = {}
				}
				Sn.DefaultUp = new li(0, 1, 0), Sn.DefaultMatrixAutoUpdate = !0, Sn.prototype = Object.assign(
					Object.create(e.prototype), {
						constructor: Sn,
						isObject3D: !0,
						onBeforeRender: function () {},
						onAfterRender: function () {},
						applyMatrix: function (t) {
							this.matrix.multiplyMatrices(t, this.matrix), this.matrix.decompose(this
								.position, this.quaternion, this.scale)
						},
						applyQuaternion: function (t) {
							return this.quaternion.premultiply(t), this
						},
						setRotationFromAxisAngle: function (t, e) {
							this.quaternion.setFromAxisAngle(t, e)
						},
						setRotationFromEuler: function (t) {
							this.quaternion.setFromEuler(t, !0)
						},
						setRotationFromMatrix: function (t) {
							this.quaternion.setFromRotationMatrix(t)
						},
						setRotationFromQuaternion: function (t) {
							this.quaternion.copy(t)
						},
						rotateOnAxis: (wn = new hi, function (t, e) {
							return wn.setFromAxisAngle(t, e), this.quaternion.multiply(wn), this
						}),
						rotateOnWorldAxis: (_n = new hi, function (t, e) {
							return _n.setFromAxisAngle(t, e), this.quaternion.premultiply(_n), this
						}),
						rotateX: (bn = new li(1, 0, 0), function (t) {
							return this.rotateOnAxis(bn, t)
						}),
						rotateY: (xn = new li(0, 1, 0), function (t) {
							return this.rotateOnAxis(xn, t)
						}),
						rotateZ: (yn = new li(0, 0, 1), function (t) {
							return this.rotateOnAxis(yn, t)
						}),
						translateOnAxis: (vn = new li, function (t, e) {
							return vn.copy(t).applyQuaternion(this.quaternion), this.position.add(vn
								.multiplyScalar(e)), this
						}),
						translateX: (gn = new li(1, 0, 0), function (t) {
							return this.translateOnAxis(gn, t)
						}),
						translateY: (mn = new li(0, 1, 0), function (t) {
							return this.translateOnAxis(mn, t)
						}),
						translateZ: (fn = new li(0, 0, 1), function (t) {
							return this.translateOnAxis(fn, t)
						}),
						localToWorld: function (t) {
							return t.applyMatrix4(this.matrixWorld)
						},
						worldToLocal: (dn = new ci, function (t) {
							return t.applyMatrix4(dn.getInverse(this.matrixWorld))
						}),
						lookAt: (hn = new hi, ln = new ci, un = new li, pn = new li, function (t, e, i) {
							t.isVector3 ? un.copy(t) : un.set(t, e, i);
							var n = this.parent;
							this.updateWorldMatrix(!0, !1), pn.setFromMatrixPosition(this
								.matrixWorld), this.isCamera || this.isLight ? ln.lookAt(pn, un, this
									.up) : ln.lookAt(un, pn, this.up), this.quaternion
								.setFromRotationMatrix(ln), n && (ln.extractRotation(n.matrixWorld),
									hn.setFromRotationMatrix(ln), this.quaternion.premultiply(hn
										.inverse()))
						}),
						add: function (t) {
							if (1 < arguments.length) {
								for (var e = 0; e < arguments.length; e++) this.add(arguments[e]);
								return this
							}
							return t === this ? console.error(
									"THREE.Object3D.add: object can't be added as a child of itself.", t
									) : t && t.isObject3D ? (null !== t.parent && t.parent.remove(t), t
									.parent = this, t.dispatchEvent({
										type: "added"
									}), this.children.push(t)) : console.error(
									"THREE.Object3D.add: object not an instance of THREE.Object3D.", t),
								this
						},
						remove: function (t) {
							if (1 < arguments.length) {
								for (var e = 0; e < arguments.length; e++) this.remove(arguments[e]);
								return this
							}
							var i = this.children.indexOf(t);
							return -1 !== i && (t.parent = null, t.dispatchEvent({
								type: "removed"
							}), this.children.splice(i, 1)), this
						},
						getObjectById: function (t) {
							return this.getObjectByProperty("id", t)
						},
						getObjectByName: function (t) {
							return this.getObjectByProperty("name", t)
						},
						getObjectByProperty: function (t, e) {
							if (this[t] === e) return this;
							for (var i = 0, n = this.children.length; i < n; i++) {
								var r = this.children[i].getObjectByProperty(t, e);
								if (void 0 !== r) return r
							}
						},
						getWorldPosition: function (t) {
							return void 0 === t && (console.warn(
									"THREE.Object3D: .getWorldPosition() target is now required"), t =
								new li), this.updateMatrixWorld(!0), t.setFromMatrixPosition(this
								.matrixWorld)
						},
						getWorldQuaternion: (sn = new li, cn = new li, function (t) {
							return void 0 === t && (console.warn(
									"THREE.Object3D: .getWorldQuaternion() target is now required"
									), t = new hi), this.updateMatrixWorld(!0), this.matrixWorld
								.decompose(sn, t, cn), t
						}),
						getWorldScale: (an = new li, on = new hi, function (t) {
							return void 0 === t && (console.warn(
										"THREE.Object3D: .getWorldScale() target is now required"),
									t = new li), this.updateMatrixWorld(!0), this.matrixWorld
								.decompose(an, on, t), t
						}),
						getWorldDirection: function (t) {
							void 0 === t && (console.warn(
									"THREE.Object3D: .getWorldDirection() target is now required"),
								t = new li), this.updateMatrixWorld(!0);
							var e = this.matrixWorld.elements;
							return t.set(e[8], e[9], e[10]).normalize()
						},
						raycast: function () {},
						traverse: function (t) {
							t(this);
							for (var e = this.children, i = 0, n = e.length; i < n; i++) e[i].traverse(t)
						},
						traverseVisible: function (t) {
							if (!1 !== this.visible) {
								t(this);
								for (var e = this.children, i = 0, n = e.length; i < n; i++) e[i]
									.traverseVisible(t)
							}
						},
						traverseAncestors: function (t) {
							var e = this.parent;
							null !== e && (t(e), e.traverseAncestors(t))
						},
						updateMatrix: function () {
							this.matrix.compose(this.position, this.quaternion, this.scale), this
								.matrixWorldNeedsUpdate = !0
						},
						updateMatrixWorld: function (t) {
							this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate ||
								t) && (null === this.parent ? this.matrixWorld.copy(this.matrix) :
								this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this
									.matrix), t = !(this.matrixWorldNeedsUpdate = !1));
							for (var e = this.children, i = 0, n = e.length; i < n; i++) e[i]
								.updateMatrixWorld(t)
						},
						updateWorldMatrix: function (t, e) {
							var i = this.parent;
							if (!0 === t && null !== i && i.updateWorldMatrix(!0, !1), this
								.matrixAutoUpdate && this.updateMatrix(), null === this.parent ? this
								.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this
									.parent.matrixWorld, this.matrix), !0 === e)
								for (var n = this.children, r = 0, a = n.length; r < a; r++) n[r]
									.updateWorldMatrix(!1, !0)
						},
						toJSON: function (i) {
							var t = void 0 === i || "string" == typeof i,
								e = {};
							t && (i = {
								geometries: {},
								materials: {},
								textures: {},
								images: {},
								shapes: {}
							}, e.metadata = {
								version: 4.5,
								type: "Object",
								generator: "Object3D.toJSON"
							});
							var n = {};

							function r(t, e) {
								return void 0 === t[e.uuid] && (t[e.uuid] = e.toJSON(i)), e.uuid
							}
							if (n.uuid = this.uuid, n.type = this.type, "" !== this.name && (n.name = this
									.name), !0 === this.castShadow && (n.castShadow = !0), !0 === this
								.receiveShadow && (n.receiveShadow = !0), !1 === this.visible && (n
									.visible = !1), !1 === this.frustumCulled && (n.frustumCulled = !1),
								0 !== this.renderOrder && (n.renderOrder = this.renderOrder), "{}" !==
								JSON.stringify(this.userData) && (n.userData = this.userData), n.layers =
								this.layers.mask, n.matrix = this.matrix.toArray(), !1 === this
								.matrixAutoUpdate && (n.matrixAutoUpdate = !1), this.isMesh && this
								.drawMode !== We && (n.drawMode = this.drawMode), this.isMesh || this
								.isLine || this.isPoints) {
								n.geometry = r(i.geometries, this.geometry);
								var a = this.geometry.parameters;
								if (void 0 !== a && void 0 !== a.shapes) {
									var o = a.shapes;
									if (Array.isArray(o))
										for (var s = 0, c = o.length; s < c; s++) {
											var h = o[s];
											r(i.shapes, h)
										} else r(i.shapes, o)
								}
							}
							if (void 0 !== this.material)
								if (Array.isArray(this.material)) {
									var l = [];
									for (s = 0, c = this.material.length; s < c; s++) l.push(r(i
										.materials, this.material[s]));
									n.material = l
								} else n.material = r(i.materials, this.material);
							if (0 < this.children.length) {
								n.children = [];
								for (s = 0; s < this.children.length; s++) n.children.push(this.children[
									s].toJSON(i).object)
							}
							if (t) {
								var u = m(i.geometries),
									p = m(i.materials),
									d = m(i.textures),
									f = m(i.images);
								o = m(i.shapes);
								0 < u.length && (e.geometries = u), 0 < p.length && (e.materials = p), 0 <
									d.length && (e.textures = d), 0 < f.length && (e.images = f), 0 < o
									.length && (e.shapes = o)
							}
							return e.object = n, e;

							function m(t) {
								var e = [];
								for (var i in t) {
									var n = t[i];
									delete n.metadata, e.push(n)
								}
								return e
							}
						},
						clone: function (t) {
							return (new this.constructor).copy(this, t)
						},
						copy: function (t, e) {
							if (void 0 === e && (e = !0), this.name = t.name, this.up.copy(t.up), this
								.position.copy(t.position), this.quaternion.copy(t.quaternion), this.scale
								.copy(t.scale), this.matrix.copy(t.matrix), this.matrixWorld.copy(t
									.matrixWorld), this.matrixAutoUpdate = t.matrixAutoUpdate, this
								.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate, this.layers.mask = t
								.layers.mask, this.visible = t.visible, this.castShadow = t.castShadow,
								this.receiveShadow = t.receiveShadow, this.frustumCulled = t
								.frustumCulled, this.renderOrder = t.renderOrder, this.userData = JSON
								.parse(JSON.stringify(t.userData)), !0 === e)
								for (var i = 0; i < t.children.length; i++) {
									var n = t.children[i];
									this.add(n.clone())
								}
							return this
						}
					});
				var En, Tn, An, Ln, Pn, Rn, Cn, On = 0;

				function In() {
					Object.defineProperty(this, "id", {
							value: On += 2
						}), this.uuid = oi.generateUUID(), this.name = "", this.type = "Geometry", this
						.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [
							[]
						], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this
						.skinIndices = [], this.lineDistances = [], this.boundingBox = null, this.boundingSphere =
						null, this.elementsNeedUpdate = !1, this.verticesNeedUpdate = !1, this.uvsNeedUpdate = !1,
						this.normalsNeedUpdate = !1, this.colorsNeedUpdate = !1, this.lineDistancesNeedUpdate = !
						1, this.groupsNeedUpdate = !1
				}

				function Dn(t, e, i) {
					if (Array.isArray(t)) throw new TypeError(
						"THREE.BufferAttribute: array should be a Typed Array.");
					this.name = "", this.array = t, this.itemSize = e, this.count = void 0 !== t ? t.length / e :
						0, this.normalized = !0 === i, this.dynamic = !1, this.updateRange = {
							offset: 0,
							count: -1
						}, this.version = 0
				}

				function Bn(t, e, i) {
					Dn.call(this, new Int8Array(t), e, i)
				}

				function zn(t, e, i) {
					Dn.call(this, new Uint8Array(t), e, i)
				}

				function Nn(t, e, i) {
					Dn.call(this, new Uint8ClampedArray(t), e, i)
				}

				function Gn(t, e, i) {
					Dn.call(this, new Int16Array(t), e, i)
				}

				function Un(t, e, i) {
					Dn.call(this, new Uint16Array(t), e, i)
				}

				function Fn(t, e, i) {
					Dn.call(this, new Int32Array(t), e, i)
				}

				function Hn(t, e, i) {
					Dn.call(this, new Uint32Array(t), e, i)
				}

				function jn(t, e, i) {
					Dn.call(this, new Float32Array(t), e, i)
				}

				function kn(t, e, i) {
					Dn.call(this, new Float64Array(t), e, i)
				}

				function Vn() {
					this.vertices = [], this.normals = [], this.colors = [], this.uvs = [], this.uvs2 = [], this
						.groups = [], this.morphTargets = {}, this.skinWeights = [], this.skinIndices = [], this
						.boundingBox = null, this.boundingSphere = null, this.verticesNeedUpdate = !1, this
						.normalsNeedUpdate = !1, this.colorsNeedUpdate = !1, this.uvsNeedUpdate = !1, this
						.groupsNeedUpdate = !1
				}

				function Wn(t) {
					if (0 === t.length) return -1 / 0;
					for (var e = t[0], i = 1, n = t.length; i < n; ++i) t[i] > e && (e = t[i]);
					return e
				}
				In.prototype = Object.assign(Object.create(e.prototype), {
						constructor: In,
						isGeometry: !0,
						applyMatrix: function (t) {
							for (var e = (new ui).getNormalMatrix(t), i = 0, n = this.vertices.length; i <
								n; i++) {
								this.vertices[i].applyMatrix4(t)
							}
							for (i = 0, n = this.faces.length; i < n; i++) {
								var r = this.faces[i];
								r.normal.applyMatrix3(e).normalize();
								for (var a = 0, o = r.vertexNormals.length; a < o; a++) r.vertexNormals[a]
									.applyMatrix3(e).normalize()
							}
							return null !== this.boundingBox && this.computeBoundingBox(), null !== this
								.boundingSphere && this.computeBoundingSphere(), this
								.verticesNeedUpdate = !0, this.normalsNeedUpdate = !0, this
						},
						rotateX: (Cn = new ci, function (t) {
							return Cn.makeRotationX(t), this.applyMatrix(Cn), this
						}),
						rotateY: (Rn = new ci, function (t) {
							return Rn.makeRotationY(t), this.applyMatrix(Rn), this
						}),
						rotateZ: (Pn = new ci, function (t) {
							return Pn.makeRotationZ(t), this.applyMatrix(Pn), this
						}),
						translate: (Ln = new ci, function (t, e, i) {
							return Ln.makeTranslation(t, e, i), this.applyMatrix(Ln), this
						}),
						scale: (An = new ci, function (t, e, i) {
							return An.makeScale(t, e, i), this.applyMatrix(An), this
						}),
						lookAt: (Tn = new Sn, function (t) {
							Tn.lookAt(t), Tn.updateMatrix(), this.applyMatrix(Tn.matrix)
						}),
						fromBufferGeometry: function (t) {
							var o = this,
								e = null !== t.index ? t.index.array : void 0,
								i = t.attributes,
								n = i.position.array,
								s = void 0 !== i.normal ? i.normal.array : void 0,
								c = void 0 !== i.color ? i.color.array : void 0,
								h = void 0 !== i.uv ? i.uv.array : void 0,
								l = void 0 !== i.uv2 ? i.uv2.array : void 0;
							void 0 !== l && (this.faceVertexUvs[1] = []);
							for (var r = 0, a = 0; r < n.length; r += 3, a += 2) o.vertices.push((new li)
								.fromArray(n, r)), void 0 !== c && o.colors.push((new Yi).fromArray(c,
								r));

							function u(t, e, i, n) {
								var r = void 0 === c ? [] : [o.colors[t].clone(), o.colors[e].clone(), o
										.colors[i].clone()
									],
									a = new en(t, e, i, void 0 === s ? [] : [(new li).fromArray(s, 3 * t),
										(new li).fromArray(s, 3 * e), (new li).fromArray(s, 3 * i)
									], r, n);
								o.faces.push(a), void 0 !== h && o.faceVertexUvs[0].push([(new si)
									.fromArray(h, 2 * t), (new si).fromArray(h, 2 * e), (new si)
									.fromArray(h, 2 * i)
								]), void 0 !== l && o.faceVertexUvs[1].push([(new si).fromArray(l, 2 *
									t), (new si).fromArray(l, 2 * e), (new si).fromArray(l,
									2 * i)])
							}
							var p = t.groups;
							if (0 < p.length)
								for (r = 0; r < p.length; r++)
									for (var d = p[r], f = d.start, m = (a = f, f + d.count); a < m; a +=
										3) void 0 !== e ? u(e[a], e[a + 1], e[a + 2], d.materialIndex) :
										u(a, a + 1, a + 2, d.materialIndex);
							else if (void 0 !== e)
								for (r = 0; r < e.length; r += 3) u(e[r], e[r + 1], e[r + 2]);
							else
								for (r = 0; r < n.length / 3; r += 3) u(r, r + 1, r + 2);
							return this.computeFaceNormals(), null !== t.boundingBox && (this
								.boundingBox = t.boundingBox.clone()), null !== t.boundingSphere && (
								this.boundingSphere = t.boundingSphere.clone()), this
						},
						center: (En = new li, function () {
							return this.computeBoundingBox(), this.boundingBox.getCenter(En).negate(),
								this.translate(En.x, En.y, En.z), this
						}),
						normalize: function () {
							this.computeBoundingSphere();
							var t = this.boundingSphere.center,
								e = this.boundingSphere.radius,
								i = 0 === e ? 1 : 1 / e,
								n = new ci;
							return n.set(i, 0, 0, -i * t.x, 0, i, 0, -i * t.y, 0, 0, i, -i * t.z, 0, 0, 0,
								1), this.applyMatrix(n), this
						},
						computeFaceNormals: function () {
							for (var t = new li, e = new li, i = 0, n = this.faces.length; i < n; i++) {
								var r = this.faces[i],
									a = this.vertices[r.a],
									o = this.vertices[r.b],
									s = this.vertices[r.c];
								t.subVectors(s, o), e.subVectors(a, o), t.cross(e), t.normalize(), r
									.normal.copy(t)
							}
						},
						computeVertexNormals: function (t) {
							var e, i, n, r, a, o;
							for (void 0 === t && (t = !0), o = new Array(this.vertices.length), e = 0, i =
								this.vertices.length; e < i; e++) o[e] = new li;
							if (t) {
								var s, c, h, l = new li,
									u = new li;
								for (n = 0, r = this.faces.length; n < r; n++) a = this.faces[n], s = this
									.vertices[a.a], c = this.vertices[a.b], h = this.vertices[a.c], l
									.subVectors(h, c), u.subVectors(s, c), l.cross(u), o[a.a].add(l), o[a
										.b].add(l), o[a.c].add(l)
							} else
								for (this.computeFaceNormals(), n = 0, r = this.faces.length; n < r; n++)
									o[(a = this.faces[n]).a].add(a.normal), o[a.b].add(a.normal), o[a.c]
									.add(a.normal);
							for (e = 0, i = this.vertices.length; e < i; e++) o[e].normalize();
							for (n = 0, r = this.faces.length; n < r; n++) {
								var p = (a = this.faces[n]).vertexNormals;
								3 === p.length ? (p[0].copy(o[a.a]), p[1].copy(o[a.b]), p[2].copy(o[a
									.c])) : (p[0] = o[a.a].clone(), p[1] = o[a.b].clone(), p[2] = o[a.c]
										.clone())
							}
							0 < this.faces.length && (this.normalsNeedUpdate = !0)
						},
						computeFlatVertexNormals: function () {
							var t, e, i;
							for (this.computeFaceNormals(), t = 0, e = this.faces.length; t < e; t++) {
								var n = (i = this.faces[t]).vertexNormals;
								3 === n.length ? (n[0].copy(i.normal), n[1].copy(i.normal), n[2].copy(i
									.normal)) : (n[0] = i.normal.clone(), n[1] = i.normal.clone(), n[
									2] = i.normal.clone())
							}
							0 < this.faces.length && (this.normalsNeedUpdate = !0)
						},
						computeMorphNormals: function () {
							var t, e, i, n, r;
							for (i = 0, n = this.faces.length; i < n; i++)
								for ((r = this.faces[i]).__originalFaceNormal ? r.__originalFaceNormal
									.copy(r.normal) : r.__originalFaceNormal = r.normal.clone(), r
									.__originalVertexNormals || (r.__originalVertexNormals = []), t = 0,
									e = r.vertexNormals.length; t < e; t++) r.__originalVertexNormals[t] ?
									r.__originalVertexNormals[t].copy(r.vertexNormals[t]) : r
									.__originalVertexNormals[t] = r.vertexNormals[t].clone();
							var a = new In;
							for (a.faces = this.faces, t = 0, e = this.morphTargets.length; t < e; t++) {
								if (!this.morphNormals[t]) {
									this.morphNormals[t] = {}, this.morphNormals[t].faceNormals = [], this
										.morphNormals[t].vertexNormals = [];
									var o = this.morphNormals[t].faceNormals,
										s = this.morphNormals[t].vertexNormals;
									for (i = 0, n = this.faces.length; i < n; i++) c = new li, h = {
										a: new li,
										b: new li,
										c: new li
									}, o.push(c), s.push(h)
								}
								var c, h, l = this.morphNormals[t];
								for (a.vertices = this.morphTargets[t].vertices, a.computeFaceNormals(), a
									.computeVertexNormals(), i = 0, n = this.faces.length; i < n; i++) r =
									this.faces[i], c = l.faceNormals[i], h = l.vertexNormals[i], c.copy(r
										.normal), h.a.copy(r.vertexNormals[0]), h.b.copy(r.vertexNormals[
										1]), h.c.copy(r.vertexNormals[2])
							}
							for (i = 0, n = this.faces.length; i < n; i++)(r = this.faces[i]).normal = r
								.__originalFaceNormal, r.vertexNormals = r.__originalVertexNormals
						},
						computeBoundingBox: function () {
							null === this.boundingBox && (this.boundingBox = new zi), this.boundingBox
								.setFromPoints(this.vertices)
						},
						computeBoundingSphere: function () {
							null === this.boundingSphere && (this.boundingSphere = new Ni), this
								.boundingSphere.setFromPoints(this.vertices)
						},
						merge: function (t, e, i) {
							if (t && t.isGeometry) {
								var n, r = this.vertices.length,
									a = this.vertices,
									o = t.vertices,
									s = this.faces,
									c = t.faces,
									h = this.faceVertexUvs[0],
									l = t.faceVertexUvs[0],
									u = this.colors,
									p = t.colors;
								void 0 === i && (i = 0), void 0 !== e && (n = (new ui).getNormalMatrix(
								e));
								for (var d = 0, f = o.length; d < f; d++) {
									var m = o[d].clone();
									void 0 !== e && m.applyMatrix4(e), a.push(m)
								}
								for (d = 0, f = p.length; d < f; d++) u.push(p[d].clone());
								for (d = 0, f = c.length; d < f; d++) {
									var g, v, y, x = c[d],
										b = x.vertexNormals,
										_ = x.vertexColors;
									(g = new en(x.a + r, x.b + r, x.c + r)).normal.copy(x.normal),
										void 0 !== n && g.normal.applyMatrix3(n).normalize();
									for (var w = 0, M = b.length; w < M; w++) v = b[w].clone(), void 0 !==
										n && v.applyMatrix3(n).normalize(), g.vertexNormals.push(v);
									g.color.copy(x.color);
									for (w = 0, M = _.length; w < M; w++) y = _[w], g.vertexColors.push(y
										.clone());
									g.materialIndex = x.materialIndex + i, s.push(g)
								}
								for (d = 0, f = l.length; d < f; d++) {
									var S = l[d],
										E = [];
									if (void 0 !== S) {
										for (w = 0, M = S.length; w < M; w++) E.push(S[w].clone());
										h.push(E)
									}
								}
							} else console.error(
								"THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.",
								t)
						},
						mergeMesh: function (t) {
							t && t.isMesh ? (t.matrixAutoUpdate && t.updateMatrix(), this.merge(t
								.geometry, t.matrix)) : console.error(
								"THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.", t)
						},
						mergeVertices: function () {
							var t, e, i, n, r, a, o, s, c = {},
								h = [],
								l = [],
								u = 4,
								p = Math.pow(10, u);
							for (i = 0, n = this.vertices.length; i < n; i++) t = this.vertices[i],
								void 0 === c[e = Math.round(t.x * p) + "_" + Math.round(t.y * p) + "_" +
									Math.round(t.z * p)] ? (c[e] = i, h.push(this.vertices[i]), l[i] = h
									.length - 1) : l[i] = l[c[e]];
							var d = [];
							for (i = 0, n = this.faces.length; i < n; i++) {
								(r = this.faces[i]).a = l[r.a], r.b = l[r.b], r.c = l[r.c], a = [r.a, r.b,
									r.c
								];
								for (var f = 0; f < 3; f++)
									if (a[f] === a[(f + 1) % 3]) {
										d.push(i);
										break
									}
							}
							for (i = d.length - 1; 0 <= i; i--) {
								var m = d[i];
								for (this.faces.splice(m, 1), o = 0, s = this.faceVertexUvs.length; o <
									s; o++) this.faceVertexUvs[o].splice(m, 1)
							}
							var g = this.vertices.length - h.length;
							return this.vertices = h, g
						},
						setFromPoints: function (t) {
							this.vertices = [];
							for (var e = 0, i = t.length; e < i; e++) {
								var n = t[e];
								this.vertices.push(new li(n.x, n.y, n.z || 0))
							}
							return this
						},
						sortFacesByMaterialIndex: function () {
							for (var t = this.faces, e = t.length, i = 0; i < e; i++) t[i]._id = i;

							function n(t, e) {
								return t.materialIndex - e.materialIndex
							}
							t.sort(n);
							var r, a, o = this.faceVertexUvs[0],
								s = this.faceVertexUvs[1];
							o && o.length === e && (r = []), s && s.length === e && (a = []);
							for (i = 0; i < e; i++) {
								var c = t[i]._id;
								r && r.push(o[c]), a && a.push(s[c])
							}
							r && (this.faceVertexUvs[0] = r), a && (this.faceVertexUvs[1] = a)
						},
						toJSON: function () {
							var t = {
								metadata: {
									version: 4.5,
									type: "Geometry",
									generator: "Geometry.toJSON"
								}
							};
							if (t.uuid = this.uuid, t.type = this.type, "" !== this.name && (t.name = this
									.name), void 0 !== this.parameters) {
								var e = this.parameters;
								for (var i in e) void 0 !== e[i] && (t[i] = e[i]);
								return t
							}
							for (var n = [], r = 0; r < this.vertices.length; r++) {
								var a = this.vertices[r];
								n.push(a.x, a.y, a.z)
							}
							var o = [],
								s = [],
								c = {},
								h = [],
								l = {},
								u = [],
								p = {};
							for (r = 0; r < this.faces.length; r++) {
								var d = this.faces[r],
									f = !0,
									m = !1,
									g = void 0 !== this.faceVertexUvs[0][r],
									v = 0 < d.normal.length(),
									y = 0 < d.vertexNormals.length,
									x = 1 !== d.color.r || 1 !== d.color.g || 1 !== d.color.b,
									b = 0 < d.vertexColors.length,
									_ = 0;
								if (_ = E(_ = E(_ = E(_ = E(_ = E(_ = E(_ = E(_ = E(_, 0, 0), 1, f), 2,
										m), 3, g), 4, v), 5, y), 6, x), 7, b), o.push(_), o.push(d.a, d.b,
										d.c), o.push(d.materialIndex), g) {
									var w = this.faceVertexUvs[0][r];
									o.push(L(w[0]), L(w[1]), L(w[2]))
								}
								if (v && o.push(T(d.normal)), y) {
									var M = d.vertexNormals;
									o.push(T(M[0]), T(M[1]), T(M[2]))
								}
								if (x && o.push(A(d.color)), b) {
									var S = d.vertexColors;
									o.push(A(S[0]), A(S[1]), A(S[2]))
								}
							}

							function E(t, e, i) {
								return i ? t | 1 << e : t & ~(1 << e)
							}

							function T(t) {
								var e = t.x.toString() + t.y.toString() + t.z.toString();
								return void 0 !== c[e] || (c[e] = s.length / 3, s.push(t.x, t.y, t.z)), c[
									e]
							}

							function A(t) {
								var e = t.r.toString() + t.g.toString() + t.b.toString();
								return void 0 !== l[e] || (l[e] = h.length, h.push(t.getHex())), l[e]
							}

							function L(t) {
								var e = t.x.toString() + t.y.toString();
								return void 0 !== p[e] || (p[e] = u.length / 2, u.push(t.x, t.y)), p[e]
							}
							return t.data = {}, t.data.vertices = n, t.data.normals = s, 0 < h.length && (
									t.data.colors = h), 0 < u.length && (t.data.uvs = [u]), t.data.faces =
								o, t
						},
						clone: function () {
							return (new In).copy(this)
						},
						copy: function (t) {
							var e, i, n, r, a, o;
							this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [
									[]
								], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [],
								this.skinIndices = [], this.lineDistances = [], this.boundingBox = null,
								this.boundingSphere = null, this.name = t.name;
							var s = t.vertices;
							for (e = 0, i = s.length; e < i; e++) this.vertices.push(s[e].clone());
							var c = t.colors;
							for (e = 0, i = c.length; e < i; e++) this.colors.push(c[e].clone());
							var h = t.faces;
							for (e = 0, i = h.length; e < i; e++) this.faces.push(h[e].clone());
							for (e = 0, i = t.faceVertexUvs.length; e < i; e++) {
								var l = t.faceVertexUvs[e];
								for (void 0 === this.faceVertexUvs[e] && (this.faceVertexUvs[e] = []), n =
									0, r = l.length; n < r; n++) {
									var u = l[n],
										p = [];
									for (a = 0, o = u.length; a < o; a++) {
										var d = u[a];
										p.push(d.clone())
									}
									this.faceVertexUvs[e].push(p)
								}
							}
							var f = t.morphTargets;
							for (e = 0, i = f.length; e < i; e++) {
								var m = {};
								if (m.name = f[e].name, void 0 !== f[e].vertices)
									for (m.vertices = [], n = 0, r = f[e].vertices.length; n < r; n++) m
										.vertices.push(f[e].vertices[n].clone());
								if (void 0 !== f[e].normals)
									for (m.normals = [], n = 0, r = f[e].normals.length; n < r; n++) m
										.normals.push(f[e].normals[n].clone());
								this.morphTargets.push(m)
							}
							var g = t.morphNormals;
							for (e = 0, i = g.length; e < i; e++) {
								var v = {};
								if (void 0 !== g[e].vertexNormals)
									for (v.vertexNormals = [], n = 0, r = g[e].vertexNormals.length; n <
										r; n++) {
										var y = g[e].vertexNormals[n],
											x = {};
										x.a = y.a.clone(), x.b = y.b.clone(), x.c = y.c.clone(), v
											.vertexNormals.push(x)
									}
								if (void 0 !== g[e].faceNormals)
									for (v.faceNormals = [], n = 0, r = g[e].faceNormals.length; n <
										r; n++) v.faceNormals.push(g[e].faceNormals[n].clone());
								this.morphNormals.push(v)
							}
							var b = t.skinWeights;
							for (e = 0, i = b.length; e < i; e++) this.skinWeights.push(b[e].clone());
							var _ = t.skinIndices;
							for (e = 0, i = _.length; e < i; e++) this.skinIndices.push(_[e].clone());
							var w = t.lineDistances;
							for (e = 0, i = w.length; e < i; e++) this.lineDistances.push(w[e]);
							var M = t.boundingBox;
							null !== M && (this.boundingBox = M.clone());
							var S = t.boundingSphere;
							return null !== S && (this.boundingSphere = S.clone()), this
								.elementsNeedUpdate = t.elementsNeedUpdate, this.verticesNeedUpdate = t
								.verticesNeedUpdate, this.uvsNeedUpdate = t.uvsNeedUpdate, this
								.normalsNeedUpdate = t.normalsNeedUpdate, this.colorsNeedUpdate = t
								.colorsNeedUpdate, this.lineDistancesNeedUpdate = t
								.lineDistancesNeedUpdate, this.groupsNeedUpdate = t.groupsNeedUpdate, this
						},
						dispose: function () {
							this.dispatchEvent({
								type: "dispose"
							})
						}
					}), Object.defineProperty(Dn.prototype, "needsUpdate", {
						set: function (t) {
							!0 === t && this.version++
						}
					}), Object.assign(Dn.prototype, {
						isBufferAttribute: !0,
						onUploadCallback: function () {},
						setArray: function (t) {
							if (Array.isArray(t)) throw new TypeError(
								"THREE.BufferAttribute: array should be a Typed Array.");
							return this.count = void 0 !== t ? t.length / this.itemSize : 0, this.array =
								t, this
						},
						setDynamic: function (t) {
							return this.dynamic = t, this
						},
						copy: function (t) {
							return this.name = t.name, this.array = new t.array.constructor(t.array), this
								.itemSize = t.itemSize, this.count = t.count, this.normalized = t
								.normalized, this.dynamic = t.dynamic, this
						},
						copyAt: function (t, e, i) {
							t *= this.itemSize, i *= e.itemSize;
							for (var n = 0, r = this.itemSize; n < r; n++) this.array[t + n] = e.array[i +
								n];
							return this
						},
						copyArray: function (t) {
							return this.array.set(t), this
						},
						copyColorsArray: function (t) {
							for (var e = this.array, i = 0, n = 0, r = t.length; n < r; n++) {
								var a = t[n];
								void 0 === a && (console.warn(
									"THREE.BufferAttribute.copyColorsArray(): color is undefined",
									n), a = new Yi), e[i++] = a.r, e[i++] = a.g, e[i++] = a.b
							}
							return this
						},
						copyVector2sArray: function (t) {
							for (var e = this.array, i = 0, n = 0, r = t.length; n < r; n++) {
								var a = t[n];
								void 0 === a && (console.warn(
									"THREE.BufferAttribute.copyVector2sArray(): vector is undefined",
									n), a = new si), e[i++] = a.x, e[i++] = a.y
							}
							return this
						},
						copyVector3sArray: function (t) {
							for (var e = this.array, i = 0, n = 0, r = t.length; n < r; n++) {
								var a = t[n];
								void 0 === a && (console.warn(
									"THREE.BufferAttribute.copyVector3sArray(): vector is undefined",
									n), a = new li), e[i++] = a.x, e[i++] = a.y, e[i++] = a.z
							}
							return this
						},
						copyVector4sArray: function (t) {
							for (var e = this.array, i = 0, n = 0, r = t.length; n < r; n++) {
								var a = t[n];
								void 0 === a && (console.warn(
										"THREE.BufferAttribute.copyVector4sArray(): vector is undefined",
										n), a = new Ci), e[i++] = a.x, e[i++] = a.y, e[i++] = a.z, e[
									i++] = a.w
							}
							return this
						},
						set: function (t, e) {
							return void 0 === e && (e = 0), this.array.set(t, e), this
						},
						getX: function (t) {
							return this.array[t * this.itemSize]
						},
						setX: function (t, e) {
							return this.array[t * this.itemSize] = e, this
						},
						getY: function (t) {
							return this.array[t * this.itemSize + 1]
						},
						setY: function (t, e) {
							return this.array[t * this.itemSize + 1] = e, this
						},
						getZ: function (t) {
							return this.array[t * this.itemSize + 2]
						},
						setZ: function (t, e) {
							return this.array[t * this.itemSize + 2] = e, this
						},
						getW: function (t) {
							return this.array[t * this.itemSize + 3]
						},
						setW: function (t, e) {
							return this.array[t * this.itemSize + 3] = e, this
						},
						setXY: function (t, e, i) {
							return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = i, this
						},
						setXYZ: function (t, e, i, n) {
							return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = i, this
								.array[t + 2] = n, this
						},
						setXYZW: function (t, e, i, n, r) {
							return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = i, this
								.array[t + 2] = n, this.array[t + 3] = r, this
						},
						onUpload: function (t) {
							return this.onUploadCallback = t, this
						},
						clone: function () {
							return new this.constructor(this.array, this.itemSize).copy(this)
						}
					}), Bn.prototype = Object.create(Dn.prototype), Bn.prototype.constructor = Bn, zn.prototype =
					Object.create(Dn.prototype), zn.prototype.constructor = zn, Nn.prototype = Object.create(Dn
						.prototype), Nn.prototype.constructor = Nn, Gn.prototype = Object.create(Dn.prototype), Gn
					.prototype.constructor = Gn, Un.prototype = Object.create(Dn.prototype), Un.prototype
					.constructor = Un, Fn.prototype = Object.create(Dn.prototype), Fn.prototype.constructor = Fn,
					Hn.prototype = Object.create(Dn.prototype), Hn.prototype.constructor = Hn, jn.prototype =
					Object.create(Dn.prototype), jn.prototype.constructor = jn, kn.prototype = Object.create(Dn
						.prototype), kn.prototype.constructor = kn, Object.assign(Vn.prototype, {
						computeGroups: function (t) {
							for (var e, i = [], n = void 0, r = t.faces, a = 0; a < r.length; a++) {
								var o = r[a];
								o.materialIndex !== n && (n = o.materialIndex, void 0 !== e && (e.count =
									3 * a - e.start, i.push(e)), e = {
									start: 3 * a,
									materialIndex: n
								})
							}
							void 0 !== e && (e.count = 3 * a - e.start, i.push(e)), this.groups = i
						},
						fromGeometry: function (t) {
							var e, i = t.faces,
								n = t.vertices,
								r = t.faceVertexUvs,
								a = r[0] && 0 < r[0].length,
								o = r[1] && 0 < r[1].length,
								s = t.morphTargets,
								c = s.length;
							if (0 < c) {
								e = [];
								for (var h = 0; h < c; h++) e[h] = {
									name: s[h].name,
									data: []
								};
								this.morphTargets.position = e
							}
							var l, u = t.morphNormals,
								p = u.length;
							if (0 < p) {
								l = [];
								for (h = 0; h < p; h++) l[h] = {
									name: u[h].name,
									data: []
								};
								this.morphTargets.normal = l
							}
							var d = t.skinIndices,
								f = t.skinWeights,
								m = d.length === n.length,
								g = f.length === n.length;
							0 < n.length && 0 === i.length && console.error(
								"THREE.DirectGeometry: Faceless geometries are not supported.");
							for (h = 0; h < i.length; h++) {
								var v = i[h];
								this.vertices.push(n[v.a], n[v.b], n[v.c]);
								var y = v.vertexNormals;
								if (3 === y.length) this.normals.push(y[0], y[1], y[2]);
								else {
									var x = v.normal;
									this.normals.push(x, x, x)
								}
								var b, _ = v.vertexColors;
								if (3 === _.length) this.colors.push(_[0], _[1], _[2]);
								else {
									var w = v.color;
									this.colors.push(w, w, w)
								}
								if (!0 === a) void 0 !== (b = r[0][h]) ? this.uvs.push(b[0], b[1], b[2]) :
									(console.warn(
											"THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ", h
											), this.uvs.push(new si, new si, new si));
								if (!0 === o) void 0 !== (b = r[1][h]) ? this.uvs2.push(b[0], b[1], b[
									2]) : (console.warn(
										"THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ", h
										), this.uvs2.push(new si, new si, new si));
								for (var M = 0; M < c; M++) {
									var S = s[M].vertices;
									e[M].data.push(S[v.a], S[v.b], S[v.c])
								}
								for (M = 0; M < p; M++) {
									var E = u[M].vertexNormals[h];
									l[M].data.push(E.a, E.b, E.c)
								}
								m && this.skinIndices.push(d[v.a], d[v.b], d[v.c]), g && this.skinWeights
									.push(f[v.a], f[v.b], f[v.c])
							}
							return this.computeGroups(t), this.verticesNeedUpdate = t.verticesNeedUpdate,
								this.normalsNeedUpdate = t.normalsNeedUpdate, this.colorsNeedUpdate = t
								.colorsNeedUpdate, this.uvsNeedUpdate = t.uvsNeedUpdate, this
								.groupsNeedUpdate = t.groupsNeedUpdate, this
						}
					});
				var qn, Xn, Yn, Zn, Jn, Qn, Kn, $n, tr, er, ir = 1;

				function nr() {
					Object.defineProperty(this, "id", {
							value: ir += 2
						}), this.uuid = oi.generateUUID(), this.name = "", this.type = "BufferGeometry", this
						.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this
						.boundingBox = null, this.boundingSphere = null, this.drawRange = {
							start: 0,
							count: 1 / 0
						}, this.userData = {}
				}

				function rr(t, e, i, n, r, a) {
					In.call(this), this.type = "BoxGeometry", this.parameters = {
						width: t,
						height: e,
						depth: i,
						widthSegments: n,
						heightSegments: r,
						depthSegments: a
					}, this.fromBufferGeometry(new ar(t, e, i, n, r, a)), this.mergeVertices()
				}

				function ar(t, e, i, n, r, a) {
					nr.call(this), this.type = "BoxBufferGeometry", this.parameters = {
						width: t,
						height: e,
						depth: i,
						widthSegments: n,
						heightSegments: r,
						depthSegments: a
					};
					var P = this;
					t = t || 1, e = e || 1, i = i || 1, n = Math.floor(n) || 1, r = Math.floor(r) || 1, a = Math
						.floor(a) || 1;
					var R = [],
						C = [],
						O = [],
						I = [],
						D = 0,
						B = 0;

					function o(t, e, i, n, r, a, o, s, c, h, l) {
						var u, p, d = a / c,
							f = o / h,
							m = a / 2,
							g = o / 2,
							v = s / 2,
							y = c + 1,
							x = h + 1,
							b = 0,
							_ = 0,
							w = new li;
						for (p = 0; p < x; p++) {
							var M = p * f - g;
							for (u = 0; u < y; u++) {
								var S = u * d - m;
								w[t] = S * n, w[e] = M * r, w[i] = v, C.push(w.x, w.y, w.z), w[t] = 0, w[e] = 0,
									w[i] = 0 < s ? 1 : -1, O.push(w.x, w.y, w.z), I.push(u / c), I.push(1 - p /
									h), b += 1
							}
						}
						for (p = 0; p < h; p++)
							for (u = 0; u < c; u++) {
								var E = D + u + y * p,
									T = D + u + y * (p + 1),
									A = D + (u + 1) + y * (p + 1),
									L = D + (u + 1) + y * p;
								R.push(E, T, L), R.push(T, A, L), _ += 6
							}
						P.addGroup(B, _, l), B += _, D += b
					}
					o("z", "y", "x", -1, -1, i, e, t, a, r, 0), o("z", "y", "x", 1, -1, i, e, -t, a, r, 1), o("x",
							"z", "y", 1, 1, t, i, e, n, a, 2), o("x", "z", "y", 1, -1, t, i, -e, n, a, 3), o("x",
							"y", "z", 1, -1, t, e, i, n, r, 4), o("x", "y", "z", -1, -1, t, e, -i, n, r, 5), this
						.setIndex(R), this.addAttribute("position", new jn(C, 3)), this.addAttribute("normal",
							new jn(O, 3)), this.addAttribute("uv", new jn(I, 2))
				}

				function or(t, e, i, n) {
					In.call(this), this.type = "PlaneGeometry", this.parameters = {
						width: t,
						height: e,
						widthSegments: i,
						heightSegments: n
					}, this.fromBufferGeometry(new sr(t, e, i, n)), this.mergeVertices()
				}

				function sr(t, e, i, n) {
					nr.call(this), this.type = "PlaneBufferGeometry", this.parameters = {
						width: t,
						height: e,
						widthSegments: i,
						heightSegments: n
					};
					var r, a, o = (t = t || 1) / 2,
						s = (e = e || 1) / 2,
						c = Math.floor(i) || 1,
						h = Math.floor(n) || 1,
						l = c + 1,
						u = h + 1,
						p = t / c,
						d = e / h,
						f = [],
						m = [],
						g = [],
						v = [];
					for (a = 0; a < u; a++) {
						var y = a * d - s;
						for (r = 0; r < l; r++) {
							var x = r * p - o;
							m.push(x, -y, 0), g.push(0, 0, 1), v.push(r / c), v.push(1 - a / h)
						}
					}
					for (a = 0; a < h; a++)
						for (r = 0; r < c; r++) {
							var b = r + l * a,
								_ = r + l * (a + 1),
								w = r + 1 + l * (a + 1),
								M = r + 1 + l * a;
							f.push(b, _, M), f.push(_, w, M)
						}
					this.setIndex(f), this.addAttribute("position", new jn(m, 3)), this.addAttribute("normal",
						new jn(g, 3)), this.addAttribute("uv", new jn(v, 2))
				}
				nr.prototype = Object.assign(Object.create(e.prototype), {
						constructor: nr,
						isBufferGeometry: !0,
						getIndex: function () {
							return this.index
						},
						setIndex: function (t) {
							Array.isArray(t) ? this.index = new(65535 < Wn(t) ? Hn : Un)(t, 1) : this
								.index = t
						},
						addAttribute: function (t, e) {
							return e && e.isBufferAttribute || e && e.isInterleavedBufferAttribute ? (
								"index" === t ? (console.warn(
									"THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."
									), this.setIndex(e)) : this.attributes[t] = e, this) : (console
								.warn(
									"THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."
									), this.addAttribute(t, new Dn(arguments[1], arguments[2])))
						},
						getAttribute: function (t) {
							return this.attributes[t]
						},
						removeAttribute: function (t) {
							return delete this.attributes[t], this
						},
						addGroup: function (t, e, i) {
							this.groups.push({
								start: t,
								count: e,
								materialIndex: void 0 !== i ? i : 0
							})
						},
						clearGroups: function () {
							this.groups = []
						},
						setDrawRange: function (t, e) {
							this.drawRange.start = t, this.drawRange.count = e
						},
						applyMatrix: function (t) {
							var e = this.attributes.position;
							void 0 !== e && (t.applyToBufferAttribute(e), e.needsUpdate = !0);
							var i = this.attributes.normal;
							void 0 !== i && ((new ui).getNormalMatrix(t).applyToBufferAttribute(i), i
								.needsUpdate = !0);
							var n = this.attributes.tangent;
							void 0 !== n && ((new ui).getNormalMatrix(t).applyToBufferAttribute(n), n
								.needsUpdate = !0);
							return null !== this.boundingBox && this.computeBoundingBox(), null !== this
								.boundingSphere && this.computeBoundingSphere(), this
						},
						rotateX: (er = new ci, function (t) {
							return er.makeRotationX(t), this.applyMatrix(er), this
						}),
						rotateY: (tr = new ci, function (t) {
							return tr.makeRotationY(t), this.applyMatrix(tr), this
						}),
						rotateZ: ($n = new ci, function (t) {
							return $n.makeRotationZ(t), this.applyMatrix($n), this
						}),
						translate: (Kn = new ci, function (t, e, i) {
							return Kn.makeTranslation(t, e, i), this.applyMatrix(Kn), this
						}),
						scale: (Qn = new ci, function (t, e, i) {
							return Qn.makeScale(t, e, i), this.applyMatrix(Qn), this
						}),
						lookAt: (Jn = new Sn, function (t) {
							Jn.lookAt(t), Jn.updateMatrix(), this.applyMatrix(Jn.matrix)
						}),
						center: (Zn = new li, function () {
							return this.computeBoundingBox(), this.boundingBox.getCenter(Zn).negate(),
								this.translate(Zn.x, Zn.y, Zn.z), this
						}),
						setFromObject: function (t) {
							var e = t.geometry;
							if (t.isPoints || t.isLine) {
								var i = new jn(3 * e.vertices.length, 3),
									n = new jn(3 * e.colors.length, 3);
								if (this.addAttribute("position", i.copyVector3sArray(e.vertices)), this
									.addAttribute("color", n.copyColorsArray(e.colors)), e
									.lineDistances && e.lineDistances.length === e.vertices.length) {
									var r = new jn(e.lineDistances.length, 1);
									this.addAttribute("lineDistance", r.copyArray(e.lineDistances))
								}
								null !== e.boundingSphere && (this.boundingSphere = e.boundingSphere
									.clone()), null !== e.boundingBox && (this.boundingBox = e
									.boundingBox.clone())
							} else t.isMesh && e && e.isGeometry && this.fromGeometry(e);
							return this
						},
						setFromPoints: function (t) {
							for (var e = [], i = 0, n = t.length; i < n; i++) {
								var r = t[i];
								e.push(r.x, r.y, r.z || 0)
							}
							return this.addAttribute("position", new jn(e, 3)), this
						},
						updateFromObject: function (t) {
							var e, i = t.geometry;
							if (t.isMesh) {
								var n = i.__directGeometry;
								if (!0 === i.elementsNeedUpdate && (n = void 0, i.elementsNeedUpdate = !
									1), void 0 === n) return this.fromGeometry(i);
								n.verticesNeedUpdate = i.verticesNeedUpdate, n.normalsNeedUpdate = i
									.normalsNeedUpdate, n.colorsNeedUpdate = i.colorsNeedUpdate, n
									.uvsNeedUpdate = i.uvsNeedUpdate, n.groupsNeedUpdate = i
									.groupsNeedUpdate, i.verticesNeedUpdate = !1, i.normalsNeedUpdate = !
									1, i.colorsNeedUpdate = !1, i.uvsNeedUpdate = !1, i
									.groupsNeedUpdate = !1, i = n
							}
							return !0 === i.verticesNeedUpdate && (void 0 !== (e = this.attributes
									.position) && (e.copyVector3sArray(i.vertices), e.needsUpdate = !
									0), i.verticesNeedUpdate = !1), !0 === i.normalsNeedUpdate && (
									void 0 !== (e = this.attributes.normal) && (e.copyVector3sArray(i
										.normals), e.needsUpdate = !0), i.normalsNeedUpdate = !1), !0 ===
								i.colorsNeedUpdate && (void 0 !== (e = this.attributes.color) && (e
										.copyColorsArray(i.colors), e.needsUpdate = !0), i
									.colorsNeedUpdate = !1), i.uvsNeedUpdate && (void 0 !== (e = this
									.attributes.uv) && (e.copyVector2sArray(i.uvs), e.needsUpdate = !
									0), i.uvsNeedUpdate = !1), i.lineDistancesNeedUpdate && (void 0 !== (
										e = this.attributes.lineDistance) && (e.copyArray(i
										.lineDistances), e.needsUpdate = !0), i
									.lineDistancesNeedUpdate = !1), i.groupsNeedUpdate && (i
									.computeGroups(t.geometry), this.groups = i.groups, i
									.groupsNeedUpdate = !1), this
						},
						fromGeometry: function (t) {
							return t.__directGeometry = (new Vn).fromGeometry(t), this.fromDirectGeometry(
								t.__directGeometry)
						},
						fromDirectGeometry: function (t) {
							var e = new Float32Array(3 * t.vertices.length);
							if (this.addAttribute("position", new Dn(e, 3).copyVector3sArray(t.vertices)),
								0 < t.normals.length) {
								var i = new Float32Array(3 * t.normals.length);
								this.addAttribute("normal", new Dn(i, 3).copyVector3sArray(t.normals))
							}
							if (0 < t.colors.length) {
								var n = new Float32Array(3 * t.colors.length);
								this.addAttribute("color", new Dn(n, 3).copyColorsArray(t.colors))
							}
							if (0 < t.uvs.length) {
								var r = new Float32Array(2 * t.uvs.length);
								this.addAttribute("uv", new Dn(r, 2).copyVector2sArray(t.uvs))
							}
							if (0 < t.uvs2.length) {
								var a = new Float32Array(2 * t.uvs2.length);
								this.addAttribute("uv2", new Dn(a, 2).copyVector2sArray(t.uvs2))
							}
							for (var o in this.groups = t.groups, t.morphTargets) {
								for (var s = [], c = t.morphTargets[o], h = 0, l = c.length; h < l; h++) {
									var u = c[h],
										p = new jn(3 * u.data.length, 3);
									p.name = u.name, s.push(p.copyVector3sArray(u.data))
								}
								this.morphAttributes[o] = s
							}
							if (0 < t.skinIndices.length) {
								var d = new jn(4 * t.skinIndices.length, 4);
								this.addAttribute("skinIndex", d.copyVector4sArray(t.skinIndices))
							}
							if (0 < t.skinWeights.length) {
								var f = new jn(4 * t.skinWeights.length, 4);
								this.addAttribute("skinWeight", f.copyVector4sArray(t.skinWeights))
							}
							return null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere
								.clone()), null !== t.boundingBox && (this.boundingBox = t.boundingBox
								.clone()), this
						},
						computeBoundingBox: function () {
							null === this.boundingBox && (this.boundingBox = new zi);
							var t = this.attributes.position;
							void 0 !== t ? this.boundingBox.setFromBufferAttribute(t) : this.boundingBox
								.makeEmpty(), (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min
									.y) || isNaN(this.boundingBox.min.z)) && console.error(
									'THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',
									this)
						},
						computeBoundingSphere: (Xn = new zi, Yn = new li, function () {
							null === this.boundingSphere && (this.boundingSphere = new Ni);
							var t = this.attributes.position;
							if (t) {
								var e = this.boundingSphere.center;
								Xn.setFromBufferAttribute(t), Xn.getCenter(e);
								for (var i = 0, n = 0, r = t.count; n < r; n++) Yn.x = t.getX(n), Yn
									.y = t.getY(n), Yn.z = t.getZ(n), i = Math.max(i, e
										.distanceToSquared(Yn));
								this.boundingSphere.radius = Math.sqrt(i), isNaN(this.boundingSphere
									.radius) && console.error(
									'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',
									this)
							}
						}),
						computeFaceNormals: function () {},
						computeVertexNormals: function () {
							var t = this.index,
								e = this.attributes;
							if (e.position) {
								var i = e.position.array;
								if (void 0 === e.normal) this.addAttribute("normal", new Dn(
									new Float32Array(i.length), 3));
								else
									for (var n = e.normal.array, r = 0, a = n.length; r < a; r++) n[r] =
									0;
								var o, s, c, h = e.normal.array,
									l = new li,
									u = new li,
									p = new li,
									d = new li,
									f = new li;
								if (t) {
									var m = t.array;
									for (r = 0, a = t.count; r < a; r += 3) o = 3 * m[r + 0], s = 3 * m[
											r + 1], c = 3 * m[r + 2], l.fromArray(i, o), u.fromArray(i,
										s), p.fromArray(i, c), d.subVectors(p, u), f.subVectors(l, u), d
										.cross(f), h[o] += d.x, h[o + 1] += d.y, h[o + 2] += d.z, h[s] +=
										d.x, h[s + 1] += d.y, h[s + 2] += d.z, h[c] += d.x, h[c + 1] += d
										.y, h[c + 2] += d.z
								} else
									for (r = 0, a = i.length; r < a; r += 9) l.fromArray(i, r), u
										.fromArray(i, r + 3), p.fromArray(i, r + 6), d.subVectors(p, u), f
										.subVectors(l, u), d.cross(f), h[r] = d.x, h[r + 1] = d.y, h[r +
											2] = d.z, h[r + 3] = d.x, h[r + 4] = d.y, h[r + 5] = d.z, h[
											r + 6] = d.x, h[r + 7] = d.y, h[r + 8] = d.z;
								this.normalizeNormals(), e.normal.needsUpdate = !0
							}
						},
						merge: function (t, e) {
							if (t && t.isBufferGeometry) {
								void 0 === e && (e = 0, console.warn(
									"THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."
									));
								var i = this.attributes;
								for (var n in i)
									if (void 0 !== t.attributes[n])
										for (var r = i[n].array, a = t.attributes[n], o = a.array, s = 0,
												c = a.itemSize * e; s < o.length; s++, c++) r[c] = o[s];
								return this
							}
							console.error(
								"THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.",
								t)
						},
						normalizeNormals: (qn = new li, function () {
							for (var t = this.attributes.normal, e = 0, i = t.count; e < i; e++) qn
								.x = t.getX(e), qn.y = t.getY(e), qn.z = t.getZ(e), qn.normalize(), t
								.setXYZ(e, qn.x, qn.y, qn.z)
						}),
						toNonIndexed: function () {
							function t(t, e) {
								for (var i = t.array, n = t.itemSize, r = new i.constructor(e.length * n),
										a = 0, o = 0, s = 0, c = e.length; s < c; s++) {
									a = e[s] * n;
									for (var h = 0; h < n; h++) r[o++] = i[a++]
								}
								return new Dn(r, n)
							}
							if (null === this.index) return console.warn(
								"THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed."
								), this;
							var e = new nr,
								i = this.index.array,
								n = this.attributes;
							for (var r in n) {
								var a = t(n[r], i);
								e.addAttribute(r, a)
							}
							var o = this.morphAttributes;
							for (r in o) {
								for (var s = [], c = o[r], h = 0, l = c.length; h < l; h++) {
									a = t(c[h], i);
									s.push(a)
								}
								e.morphAttributes[r] = s
							}
							for (var u = this.groups, p = (h = 0, u.length); h < p; h++) {
								var d = u[h];
								e.addGroup(d.start, d.count, d.materialIndex)
							}
							return e
						},
						toJSON: function () {
							var t = {
								metadata: {
									version: 4.5,
									type: "BufferGeometry",
									generator: "BufferGeometry.toJSON"
								}
							};
							if (t.uuid = this.uuid, t.type = this.type, "" !== this.name && (t.name = this
									.name), 0 < Object.keys(this.userData).length && (t.userData = this
									.userData), void 0 !== this.parameters) {
								var e = this.parameters;
								for (var i in e) void 0 !== e[i] && (t[i] = e[i]);
								return t
							}
							t.data = {
								attributes: {}
							};
							var n = this.index;
							null !== n && (t.data.index = {
								type: n.array.constructor.name,
								array: Array.prototype.slice.call(n.array)
							});
							var r = this.attributes;
							for (var i in r) {
								var a = {
									itemSize: (p = r[i]).itemSize,
									type: p.array.constructor.name,
									array: Array.prototype.slice.call(p.array),
									normalized: p.normalized
								};
								"" !== p.name && (a.name = p.name), t.data.attributes[i] = a
							}
							var o = {},
								s = !1;
							for (var i in this.morphAttributes) {
								for (var c = this.morphAttributes[i], h = [], l = 0, u = c.length; l <
									u; l++) {
									var p;
									a = {
										itemSize: (p = c[l]).itemSize,
										type: p.array.constructor.name,
										array: Array.prototype.slice.call(p.array),
										normalized: p.normalized
									};
									"" !== p.name && (a.name = p.name), h.push(a)
								}
								0 < h.length && (o[i] = h, s = !0)
							}
							s && (t.data.morphAttributes = o);
							var d = this.groups;
							0 < d.length && (t.data.groups = JSON.parse(JSON.stringify(d)));
							var f = this.boundingSphere;
							return null !== f && (t.data.boundingSphere = {
								center: f.center.toArray(),
								radius: f.radius
							}), t
						},
						clone: function () {
							return (new nr).copy(this)
						},
						copy: function (t) {
							var e, i, n;
							this.index = null, this.attributes = {}, this.morphAttributes = {}, this
								.groups = [], this.boundingBox = null, this.boundingSphere = null, this
								.name = t.name;
							var r = t.index;
							null !== r && this.setIndex(r.clone());
							var a = t.attributes;
							for (e in a) {
								var o = a[e];
								this.addAttribute(e, o.clone())
							}
							var s = t.morphAttributes;
							for (e in s) {
								var c = [],
									h = s[e];
								for (i = 0, n = h.length; i < n; i++) c.push(h[i].clone());
								this.morphAttributes[e] = c
							}
							var l = t.groups;
							for (i = 0, n = l.length; i < n; i++) {
								var u = l[i];
								this.addGroup(u.start, u.count, u.materialIndex)
							}
							var p = t.boundingBox;
							null !== p && (this.boundingBox = p.clone());
							var d = t.boundingSphere;
							return null !== d && (this.boundingSphere = d.clone()), this.drawRange.start =
								t.drawRange.start, this.drawRange.count = t.drawRange.count, this
								.userData = t.userData, this
						},
						dispose: function () {
							this.dispatchEvent({
								type: "dispose"
							})
						}
					}), rr.prototype = Object.create(In.prototype), rr.prototype.constructor = rr, ar.prototype =
					Object.create(nr.prototype), ar.prototype.constructor = ar, or.prototype = Object.create(In
						.prototype), or.prototype.constructor = or, sr.prototype = Object.create(nr.prototype), sr
					.prototype.constructor = sr;
				var cr = 0;

				function hr() {
					Object.defineProperty(this, "id", {
							value: cr++
						}), this.uuid = oi.generateUUID(), this.name = "", this.type = "Material", this.fog = !0,
						this.lights = !0, this.blending = mt, this.side = z, this.flatShading = !1, this
						.vertexTangents = !1, this.vertexColors = O, this.opacity = 1, this.transparent = !1, this
						.blendSrc = q, this.blendDst = X, this.blendEquation = bt, this.blendSrcAlpha = null, this
						.blendDstAlpha = null, this.blendEquationAlpha = null, this.depthFunc = St, this
						.depthTest = !0, this.depthWrite = !0, this.clippingPlanes = null, this
						.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !
						0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this
						.polygonOffsetUnits = 0, this.dithering = !1, this.alphaTest = 0, this
						.premultipliedAlpha = !1, this.visible = !0, this.userData = {}, this.needsUpdate = !0
				}
				hr.prototype = Object.assign(Object.create(e.prototype), {
					constructor: hr,
					isMaterial: !0,
					onBeforeCompile: function () {},
					setValues: function (t) {
						if (void 0 !== t)
							for (var e in t) {
								var i = t[e];
								if (void 0 !== i)
									if ("shading" !== e) {
										var n = this[e];
										void 0 !== n ? n && n.isColor ? n.set(i) : n && n.isVector3 &&
											i && i.isVector3 ? n.copy(i) : this[e] = i : console.warn(
												"THREE." + this.type + ": '" + e +
												"' is not a property of this material.")
									} else console.warn("THREE." + this.type +
										": .shading has been removed. Use the boolean .flatShading instead."
										), this.flatShading = i === R;
								else console.warn("THREE.Material: '" + e +
									"' parameter is undefined.")
							}
					},
					toJSON: function (t) {
						var e = void 0 === t || "string" == typeof t;
						e && (t = {
							textures: {},
							images: {}
						});
						var i = {
							metadata: {
								version: 4.5,
								type: "Material",
								generator: "Material.toJSON"
							}
						};

						function n(t) {
							var e = [];
							for (var i in t) {
								var n = t[i];
								delete n.metadata, e.push(n)
							}
							return e
						}
						if (i.uuid = this.uuid, i.type = this.type, "" !== this.name && (i.name = this
								.name), this.color && this.color.isColor && (i.color = this.color
								.getHex()), void 0 !== this.roughness && (i.roughness = this
								.roughness), void 0 !== this.metalness && (i.metalness = this
								.metalness), this.emissive && this.emissive.isColor && (i.emissive =
								this.emissive.getHex()), 1 !== this.emissiveIntensity && (i
								.emissiveIntensity = this.emissiveIntensity), this.specular && this
							.specular.isColor && (i.specular = this.specular.getHex()), void 0 !==
							this.shininess && (i.shininess = this.shininess), void 0 !== this
							.clearCoat && (i.clearCoat = this.clearCoat), void 0 !== this
							.clearCoatRoughness && (i.clearCoatRoughness = this.clearCoatRoughness),
							this.map && this.map.isTexture && (i.map = this.map.toJSON(t).uuid), this
							.alphaMap && this.alphaMap.isTexture && (i.alphaMap = this.alphaMap
								.toJSON(t).uuid), this.lightMap && this.lightMap.isTexture && (i
								.lightMap = this.lightMap.toJSON(t).uuid), this.aoMap && this.aoMap
							.isTexture && (i.aoMap = this.aoMap.toJSON(t).uuid, i.aoMapIntensity =
								this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (i
								.bumpMap = this.bumpMap.toJSON(t).uuid, i.bumpScale = this.bumpScale),
							this.normalMap && this.normalMap.isTexture && (i.normalMap = this
								.normalMap.toJSON(t).uuid, i.normalMapType = this.normalMapType, i
								.normalScale = this.normalScale.toArray()), this.displacementMap &&
							this.displacementMap.isTexture && (i.displacementMap = this
								.displacementMap.toJSON(t).uuid, i.displacementScale = this
								.displacementScale, i.displacementBias = this.displacementBias), this
							.roughnessMap && this.roughnessMap.isTexture && (i.roughnessMap = this
								.roughnessMap.toJSON(t).uuid), this.metalnessMap && this.metalnessMap
							.isTexture && (i.metalnessMap = this.metalnessMap.toJSON(t).uuid), this
							.emissiveMap && this.emissiveMap.isTexture && (i.emissiveMap = this
								.emissiveMap.toJSON(t).uuid), this.specularMap && this.specularMap
							.isTexture && (i.specularMap = this.specularMap.toJSON(t).uuid), this
							.envMap && this.envMap.isTexture && (i.envMap = this.envMap.toJSON(t)
								.uuid, i.reflectivity = this.reflectivity, void 0 !== this.combine &&
								(i.combine = this.combine), void 0 !== this.envMapIntensity && (i
									.envMapIntensity = this.envMapIntensity)), this.gradientMap &&
							this.gradientMap.isTexture && (i.gradientMap = this.gradientMap.toJSON(t)
								.uuid), void 0 !== this.size && (i.size = this.size), void 0 !== this
							.sizeAttenuation && (i.sizeAttenuation = this.sizeAttenuation), this
							.blending !== mt && (i.blending = this.blending), !0 === this
							.flatShading && (i.flatShading = this.flatShading), this.side !== z && (i
								.side = this.side), this.vertexColors !== O && (i.vertexColors = this
								.vertexColors), this.opacity < 1 && (i.opacity = this.opacity), !0 ===
							this.transparent && (i.transparent = this.transparent), i.depthFunc = this
							.depthFunc, i.depthTest = this.depthTest, i.depthWrite = this.depthWrite,
							0 !== this.rotation && (i.rotation = this.rotation), !0 === this
							.polygonOffset && (i.polygonOffset = !0), 0 !== this
							.polygonOffsetFactor && (i.polygonOffsetFactor = this
							.polygonOffsetFactor), 0 !== this.polygonOffsetUnits && (i
								.polygonOffsetUnits = this.polygonOffsetUnits), 1 !== this
							.linewidth && (i.linewidth = this.linewidth), void 0 !== this.dashSize &&
							(i.dashSize = this.dashSize), void 0 !== this.gapSize && (i.gapSize = this
								.gapSize), void 0 !== this.scale && (i.scale = this.scale), !0 ===
							this.dithering && (i.dithering = !0), 0 < this.alphaTest && (i.alphaTest =
								this.alphaTest), !0 === this.premultipliedAlpha && (i
								.premultipliedAlpha = this.premultipliedAlpha), !0 === this
							.wireframe && (i.wireframe = this.wireframe), 1 < this
							.wireframeLinewidth && (i.wireframeLinewidth = this.wireframeLinewidth),
							"round" !== this.wireframeLinecap && (i.wireframeLinecap = this
								.wireframeLinecap), "round" !== this.wireframeLinejoin && (i
								.wireframeLinejoin = this.wireframeLinejoin), !0 === this
							.morphTargets && (i.morphTargets = !0), !0 === this.skinning && (i
								.skinning = !0), !1 === this.visible && (i.visible = !1), "{}" !==
							JSON.stringify(this.userData) && (i.userData = this.userData), e) {
							var r = n(t.textures),
								a = n(t.images);
							0 < r.length && (i.textures = r), 0 < a.length && (i.images = a)
						}
						return i
					},
					clone: function () {
						return (new this.constructor).copy(this)
					},
					copy: function (t) {
						this.name = t.name, this.fog = t.fog, this.lights = t.lights, this.blending =
							t.blending, this.side = t.side, this.flatShading = t.flatShading, this
							.vertexColors = t.vertexColors, this.opacity = t.opacity, this
							.transparent = t.transparent, this.blendSrc = t.blendSrc, this.blendDst =
							t.blendDst, this.blendEquation = t.blendEquation, this.blendSrcAlpha = t
							.blendSrcAlpha, this.blendDstAlpha = t.blendDstAlpha, this
							.blendEquationAlpha = t.blendEquationAlpha, this.depthFunc = t.depthFunc,
							this.depthTest = t.depthTest, this.depthWrite = t.depthWrite, this
							.colorWrite = t.colorWrite, this.precision = t.precision, this
							.polygonOffset = t.polygonOffset, this.polygonOffsetFactor = t
							.polygonOffsetFactor, this.polygonOffsetUnits = t.polygonOffsetUnits, this
							.dithering = t.dithering, this.alphaTest = t.alphaTest, this
							.premultipliedAlpha = t.premultipliedAlpha, this.visible = t.visible, this
							.userData = JSON.parse(JSON.stringify(t.userData)), this.clipShadows = t
							.clipShadows, this.clipIntersection = t.clipIntersection;
						var e = t.clippingPlanes,
							i = null;
						if (null !== e) {
							var n = e.length;
							i = new Array(n);
							for (var r = 0; r !== n; ++r) i[r] = e[r].clone()
						}
						return this.clippingPlanes = i, this.shadowSide = t.shadowSide, this
					},
					dispose: function () {
						this.dispatchEvent({
							type: "dispose"
						})
					}
				});
				var lr, ur, pr, dr, fr, mr, gr, vr, yr, xr, br, _r, wr, Mr, Sr, Er, Tr, Ar, Lr, Pr, Rr, Cr, Or,
					Ir, Dr, Br =
					"void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",
					zr = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";

				function Nr(t) {
					hr.call(this), this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this
						.vertexShader = Br, this.fragmentShader = zr, this.linewidth = 1, this.wireframe = !1,
						this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this
						.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.extensions = {
							derivatives: !1,
							fragDepth: !1,
							drawBuffers: !1,
							shaderTextureLOD: !1
						}, this.defaultAttributeValues = {
							color: [1, 1, 1],
							uv: [0, 0],
							uv2: [0, 0]
						}, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, void 0 !== t && (
							void 0 !== t.attributes && console.error(
								"THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."
								), this.setValues(t))
				}

				function Gr(t, e) {
					this.origin = void 0 !== t ? t : new li, this.direction = void 0 !== e ? e : new li
				}

				function Ur(t, e, i) {
					this.a = void 0 !== t ? t : new li, this.b = void 0 !== e ? e : new li, this.c = void 0 !==
						i ? i : new li
				}

				function Fr(t) {
					hr.call(this), this.type = "MeshBasicMaterial", this.color = new Yi(16777215), this.map =
						null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this
						.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null,
						this.combine = $, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1,
						this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin =
						"round", this.skinning = !1, this.morphTargets = !1, this.lights = !1, this.setValues(t)
				}

				function Hr(t, e) {
					Sn.call(this), this.type = "Mesh", this.geometry = void 0 !== t ? t : new nr, this.material =
						void 0 !== e ? e : new Fr({
							color: 16777215 * Math.random()
						}), this.drawMode = We, this.updateMorphTargets()
				}

				function jr(o, i, s, n) {
					var c, h, l = new Yi(0),
						u = 0,
						p = null,
						d = 0;

					function t(t, e, i, n) {
						var r = e.background;
						if (null === r ? (f(l, u), p = null, d = 0) : r && r.isColor && (f(r, 1), n = !0, p =
								null, d = 0), (o.autoClear || n) && o.clear(o.autoClearColor, o.autoClearDepth, o
								.autoClearStencil), r && (r.isCubeTexture || r.isWebGLRenderTargetCube)) {
							void 0 === h && ((h = new Hr(new ar(1, 1, 1), new Nr({
									type: "BackgroundCubeMaterial",
									uniforms: Hi(Ki.cube.uniforms),
									vertexShader: Ki.cube.vertexShader,
									fragmentShader: Ki.cube.fragmentShader,
									side: jt,
									depthTest: !1,
									depthWrite: !1,
									fog: !1
								}))).geometry.removeAttribute("normal"), h.geometry.removeAttribute("uv"), h
								.onBeforeRender = function (t, e, i) {
									this.matrixWorld.copyPosition(i.matrixWorld)
								}, Object.defineProperty(h.material, "map", {
									get: function () {
										return this.uniforms.tCube.value
									}
								}), s.update(h));
							var a = r.isWebGLRenderTargetCube ? r.texture : r;
							h.material.uniforms.tCube.value = a, h.material.uniforms.tFlip.value = r
								.isWebGLRenderTargetCube ? 1 : -1, p === r && d === a.version || (h.material
									.needsUpdate = !0, p = r, d = a.version), t.unshift(h, h.geometry, h.material,
									0, 0, null)
						} else r && r.isTexture && (void 0 === c && ((c = new Hr(new sr(2, 2), new Nr({
								type: "BackgroundMaterial",
								uniforms: Hi(Ki.background.uniforms),
								vertexShader: Ki.background.vertexShader,
								fragmentShader: Ki.background.fragmentShader,
								side: z,
								depthTest: !1,
								depthWrite: !1,
								fog: !1
							}))).geometry.removeAttribute("normal"), Object.defineProperty(c.material,
								"map", {
									get: function () {
										return this.uniforms.t2D.value
									}
								}), s.update(c)), !0 === (c.material.uniforms.t2D.value = r)
							.matrixAutoUpdate && r.updateMatrix(), c.material.uniforms.uvTransform.value.copy(
								r.matrix), p === r && d === r.version || (c.material.needsUpdate = !0, d = (
								p = r).version), t.unshift(c, c.geometry, c.material, 0, 0, null))
					}

					function f(t, e) {
						i.buffers.color.setClear(t.r, t.g, t.b, e, n)
					}
					return {
						getClearColor: function () {
							return l
						},
						setClearColor: function (t, e) {
							l.set(t), f(l, u = void 0 !== e ? e : 1)
						},
						getClearAlpha: function () {
							return u
						},
						setClearAlpha: function (t) {
							f(l, u = t)
						},
						render: t
					}
				}

				function kr(r, a, o, s) {
					var c;

					function t(t) {
						c = t
					}

					function e(t, e) {
						r.drawArrays(c, t, e), o.update(e, c)
					}

					function i(t, e, i) {
						var n;
						if (s.isWebGL2) n = r;
						else if (null === (n = a.get("ANGLE_instanced_arrays"))) return void console.error(
							"THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
							);
						n[s.isWebGL2 ? "drawArraysInstanced" : "drawArraysInstancedANGLE"](c, e, i, t
							.maxInstancedCount), o.update(i, c, t.maxInstancedCount)
					}
					this.setMode = t, this.render = e, this.renderInstances = i
				}

				function Vr(e, i, t) {
					var n;

					function r() {
						if (void 0 !== n) return n;
						var t = i.get("EXT_texture_filter_anisotropic");
						return n = null !== t ? e.getParameter(t.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0
					}

					function a(t) {
						if ("highp" === t) {
							if (0 < e.getShaderPrecisionFormat(35633, 36338).precision && 0 < e
								.getShaderPrecisionFormat(35632, 36338).precision) return "highp";
							t = "mediump"
						}
						return "mediump" === t && 0 < e.getShaderPrecisionFormat(35633, 36337).precision && 0 < e
							.getShaderPrecisionFormat(35632, 36337).precision ? "mediump" : "lowp"
					}
					var o = "undefined" != typeof WebGL2RenderingContext && e instanceof WebGL2RenderingContext,
						s = void 0 !== t.precision ? t.precision : "highp",
						c = a(s);
					c !== s && (console.warn("THREE.WebGLRenderer:", s, "not supported, using", c, "instead."),
						s = c);
					var h = !0 === t.logarithmicDepthBuffer,
						l = e.getParameter(34930),
						u = e.getParameter(35660),
						p = e.getParameter(3379),
						d = e.getParameter(34076),
						f = e.getParameter(34921),
						m = e.getParameter(36347),
						g = e.getParameter(36348),
						v = e.getParameter(36349),
						y = 0 < u,
						x = o || !!i.get("OES_texture_float");
					return {
						isWebGL2: o,
						getMaxAnisotropy: r,
						getMaxPrecision: a,
						precision: s,
						logarithmicDepthBuffer: h,
						maxTextures: l,
						maxVertexTextures: u,
						maxTextureSize: p,
						maxCubemapSize: d,
						maxAttributes: f,
						maxVertexUniforms: m,
						maxVaryings: g,
						maxFragmentUniforms: v,
						vertexTextures: y,
						floatFragmentTextures: x,
						floatVertexTextures: y && x,
						maxSamples: o ? e.getParameter(36183) : 0
					}
				}

				function Wr() {
					var l = this,
						u = null,
						p = 0,
						d = !1,
						f = !1,
						m = new Gi,
						g = new ui,
						v = {
							value: null,
							needsUpdate: !1
						};

					function y() {
						v.value !== u && (v.value = u, v.needsUpdate = 0 < p), l.numPlanes = p, l
							.numIntersection = 0
					}

					function x(t, e, i, n) {
						var r = null !== t ? t.length : 0,
							a = null;
						if (0 !== r) {
							if (a = v.value, !0 !== n || null === a) {
								var o = i + 4 * r,
									s = e.matrixWorldInverse;
								g.getNormalMatrix(s), (null === a || a.length < o) && (a = new Float32Array(o));
								for (var c = 0, h = i; c !== r; ++c, h += 4) m.copy(t[c]).applyMatrix4(s, g), m
									.normal.toArray(a, h), a[h + 3] = m.constant
							}
							v.value = a, v.needsUpdate = !0
						}
						return l.numPlanes = r, a
					}
					this.uniform = v, this.numPlanes = 0, this.numIntersection = 0, this.init = function (t, e,
					i) {
						var n = 0 !== t.length || e || 0 !== p || d;
						return d = e, u = x(t, i, 0), p = t.length, n
					}, this.beginShadows = function () {
						f = !0, x(null)
					}, this.endShadows = function () {
						f = !1, y()
					}, this.setState = function (t, e, i, n, r, a) {
						if (!d || null === t || 0 === t.length || f && !i) f ? x(null) : y();
						else {
							var o = f ? 0 : p,
								s = 4 * o,
								c = r.clippingState || null;
							v.value = c, c = x(t, n, s, a);
							for (var h = 0; h !== s; ++h) c[h] = u[h];
							r.clippingState = c, this.numIntersection = e ? this.numPlanes : 0, this
								.numPlanes += o
						}
					}
				}

				function qr(i) {
					var n = {};
					return {
						get: function (t) {
							if (void 0 !== n[t]) return n[t];
							var e;
							switch (t) {
								case "WEBGL_depth_texture":
									e = i.getExtension("WEBGL_depth_texture") || i.getExtension(
										"MOZ_WEBGL_depth_texture") || i.getExtension(
										"WEBKIT_WEBGL_depth_texture");
									break;
								case "EXT_texture_filter_anisotropic":
									e = i.getExtension("EXT_texture_filter_anisotropic") || i.getExtension(
										"MOZ_EXT_texture_filter_anisotropic") || i.getExtension(
										"WEBKIT_EXT_texture_filter_anisotropic");
									break;
								case "WEBGL_compressed_texture_s3tc":
									e = i.getExtension("WEBGL_compressed_texture_s3tc") || i.getExtension(
										"MOZ_WEBGL_compressed_texture_s3tc") || i.getExtension(
										"WEBKIT_WEBGL_compressed_texture_s3tc");
									break;
								case "WEBGL_compressed_texture_pvrtc":
									e = i.getExtension("WEBGL_compressed_texture_pvrtc") || i.getExtension(
										"WEBKIT_WEBGL_compressed_texture_pvrtc");
									break;
								default:
									e = i.getExtension(t)
							}
							return null === e && console.warn("THREE.WebGLRenderer: " + t +
								" extension not supported."), n[t] = e
						}
					}
				}

				function Xr(t, u, a) {
					var o = {},
						p = {};

					function s(t) {
						var e = t.target,
							i = o[e.id];
						for (var n in null !== i.index && u.remove(i.index), i.attributes) u.remove(i.attributes[
							n]);
						e.removeEventListener("dispose", s), delete o[e.id];
						var r = p[i.id];
						r && (u.remove(r), delete p[i.id]), a.memory.geometries--
					}

					function e(t, e) {
						var i = o[e.id];
						return i || (e.addEventListener("dispose", s), e.isBufferGeometry ? i = e : e
							.isGeometry && (void 0 === e._bufferGeometry && (e._bufferGeometry = (new nr)
								.setFromObject(t)), i = e._bufferGeometry), o[e.id] = i, a.memory
							.geometries++, i)
					}

					function i(t) {
						var e = t.index,
							i = t.attributes;
						for (var n in null !== e && u.update(e, 34963), i) u.update(i[n], 34962);
						var r = t.morphAttributes;
						for (var n in r)
							for (var a = r[n], o = 0, s = a.length; o < s; o++) u.update(a[o], 34962)
					}

					function n(t) {
						var e = p[t.id];
						if (e) return e;
						var i = [],
							n = t.index,
							r = t.attributes;
						if (null !== n)
							for (var a = 0, o = (l = n.array).length; a < o; a += 3) {
								var s = l[a + 0],
									c = l[a + 1],
									h = l[a + 2];
								i.push(s, c, c, h, h, s)
							} else {
								var l;
								for (a = 0, o = (l = r.position.array).length / 3 - 1; a < o; a += 3) {
									s = a + 0, c = a + 1, h = a + 2;
									i.push(s, c, c, h, h, s)
								}
							}
						return e = new(65535 < Wn(i) ? Hn : Un)(i, 1), u.update(e, 34963), p[t.id] = e
					}
					return {
						get: e,
						update: i,
						getWireframeAttribute: n
					}
				}

				function Yr(r, a, o, s) {
					var c, h, l;

					function t(t) {
						c = t
					}

					function e(t) {
						h = t.type, l = t.bytesPerElement
					}

					function i(t, e) {
						r.drawElements(c, e, h, t * l), o.update(e, c)
					}

					function n(t, e, i) {
						var n;
						if (s.isWebGL2) n = r;
						else if (null === (n = a.get("ANGLE_instanced_arrays"))) return void console.error(
							"THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
							);
						n[s.isWebGL2 ? "drawElementsInstanced" : "drawElementsInstancedANGLE"](c, i, h, e * l, t
							.maxInstancedCount), o.update(i, c, t.maxInstancedCount)
					}
					this.setMode = t, this.setIndex = e, this.render = i, this.renderInstances = n
				}

				function Zr(t) {
					var n = {
						frame: 0,
						calls: 0,
						triangles: 0,
						points: 0,
						lines: 0
					};

					function e(t, e, i) {
						switch (i = i || 1, n.calls++, e) {
							case 4:
								n.triangles += i * (t / 3);
								break;
							case 5:
							case 6:
								n.triangles += i * (t - 2);
								break;
							case 1:
								n.lines += i * (t / 2);
								break;
							case 3:
								n.lines += i * (t - 1);
								break;
							case 2:
								n.lines += i * t;
								break;
							case 0:
								n.points += i * t;
								break;
							default:
								console.error("THREE.WebGLInfo: Unknown draw mode:", e)
						}
					}

					function i() {
						n.frame++, n.calls = 0, n.triangles = 0, n.points = 0, n.lines = 0
					}
					return {
						memory: {
							geometries: 0,
							textures: 0
						},
						render: n,
						programs: null,
						autoReset: !0,
						reset: i,
						update: e
					}
				}

				function Jr(t, e) {
					return Math.abs(e[1]) - Math.abs(t[1])
				}

				function Qr(d) {
					var f = {},
						m = new Float32Array(8);

					function t(t, e, i, n) {
						var r = t.morphTargetInfluences,
							a = r.length,
							o = f[e.id];
						if (void 0 === o) {
							o = [];
							for (var s = 0; s < a; s++) o[s] = [s, 0];
							f[e.id] = o
						}
						var c = i.morphTargets && e.morphAttributes.position,
							h = i.morphNormals && e.morphAttributes.normal;
						for (s = 0; s < a; s++) {
							0 !== (l = o[s])[1] && (c && e.removeAttribute("morphTarget" + s), h && e
								.removeAttribute("morphNormal" + s))
						}
						for (s = 0; s < a; s++) {
							(l = o[s])[0] = s, l[1] = r[s]
						}
						o.sort(Jr);
						for (s = 0; s < 8; s++) {
							var l;
							if (l = o[s]) {
								var u = l[0],
									p = l[1];
								if (p) {
									c && e.addAttribute("morphTarget" + s, c[u]), h && e.addAttribute(
										"morphNormal" + s, h[u]), m[s] = p;
									continue
								}
							}
							m[s] = 0
						}
						n.getUniforms().setValue(d, "morphTargetInfluences", m)
					}
					return {
						update: t
					}
				}

				function Kr(r, a) {
					var o = {};

					function t(t) {
						var e = a.render.frame,
							i = t.geometry,
							n = r.get(t, i);
						return o[n.id] !== e && (i.isGeometry && n.updateFromObject(t), r.update(n), o[n.id] = e),
							n
					}

					function e() {
						o = {}
					}
					return {
						update: t,
						dispose: e
					}
				}

				function $r(t, e, i, n, r, a, o, s, c, h) {
					t = void 0 !== t ? t : [], e = void 0 !== e ? e : ct, o = void 0 !== o ? o : ae, Ri.call(this,
						t, e, i, n, r, a, o, s, c, h), this.flipY = !1
				}

				function ta(t, e, i, n) {
					Ri.call(this, null), this.image = {
							data: t,
							width: e,
							height: i,
							depth: n
						}, this.magFilter = Nt, this.minFilter = Nt, this.wrapR = Bt, this.generateMipmaps = !1,
						this.flipY = !1
				}
				Nr.prototype = Object.create(hr.prototype), (Nr.prototype.constructor = Nr).prototype
					.isShaderMaterial = !0, Nr.prototype.copy = function (t) {
						return hr.prototype.copy.call(this, t), this.fragmentShader = t.fragmentShader, this
							.vertexShader = t.vertexShader, this.uniforms = Hi(t.uniforms), this.defines = Object
							.assign({}, t.defines), this.wireframe = t.wireframe, this.wireframeLinewidth = t
							.wireframeLinewidth, this.lights = t.lights, this.clipping = t.clipping, this
							.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t
							.morphNormals, this.extensions = t.extensions, this
					}, Nr.prototype.toJSON = function (t) {
						var e = hr.prototype.toJSON.call(this, t);
						for (var i in e.uniforms = {}, this.uniforms) {
							var n = this.uniforms[i].value;
							n && n.isTexture ? e.uniforms[i] = {
								type: "t",
								value: n.toJSON(t).uuid
							} : n && n.isColor ? e.uniforms[i] = {
								type: "c",
								value: n.getHex()
							} : n && n.isVector2 ? e.uniforms[i] = {
								type: "v2",
								value: n.toArray()
							} : n && n.isVector3 ? e.uniforms[i] = {
								type: "v3",
								value: n.toArray()
							} : n && n.isVector4 ? e.uniforms[i] = {
								type: "v4",
								value: n.toArray()
							} : n && n.isMatrix3 ? e.uniforms[i] = {
								type: "m3",
								value: n.toArray()
							} : n && n.isMatrix4 ? e.uniforms[i] = {
								type: "m4",
								value: n.toArray()
							} : e.uniforms[i] = {
								value: n
							}
						}
						0 < Object.keys(this.defines).length && (e.defines = this.defines), e.vertexShader = this
							.vertexShader, e.fragmentShader = this.fragmentShader;
						var r = {};
						for (var a in this.extensions) !0 === this.extensions[a] && (r[a] = !0);
						return 0 < Object.keys(r).length && (e.extensions = r), e
					}, Object.assign(Gr.prototype, {
						set: function (t, e) {
							return this.origin.copy(t), this.direction.copy(e), this
						},
						clone: function () {
							return (new this.constructor).copy(this)
						},
						copy: function (t) {
							return this.origin.copy(t.origin), this.direction.copy(t.direction), this
						},
						at: function (t, e) {
							return void 0 === e && (console.warn(
								"THREE.Ray: .at() target is now required"), e = new li), e.copy(this
								.direction).multiplyScalar(t).add(this.origin)
						},
						lookAt: function (t) {
							return this.direction.copy(t).sub(this.origin).normalize(), this
						},
						recast: (br = new li, function (t) {
							return this.origin.copy(this.at(t, br)), this
						}),
						closestPointToPoint: function (t, e) {
							void 0 === e && (console.warn(
									"THREE.Ray: .closestPointToPoint() target is now required"), e =
								new li), e.subVectors(t, this.origin);
							var i = e.dot(this.direction);
							return i < 0 ? e.copy(this.origin) : e.copy(this.direction).multiplyScalar(i)
								.add(this.origin)
						},
						distanceToPoint: function (t) {
							return Math.sqrt(this.distanceSqToPoint(t))
						},
						distanceSqToPoint: (xr = new li, function (t) {
							var e = xr.subVectors(t, this.origin).dot(this.direction);
							return e < 0 ? this.origin.distanceToSquared(t) : (xr.copy(this.direction)
								.multiplyScalar(e).add(this.origin), xr.distanceToSquared(t))
						}),
						distanceSqToSegment: (gr = new li, vr = new li, yr = new li, function (t, e, i, n) {
							gr.copy(t).add(e).multiplyScalar(.5), vr.copy(e).sub(t).normalize(), yr
								.copy(this.origin).sub(gr);
							var r, a, o, s, c = .5 * t.distanceTo(e),
								h = -this.direction.dot(vr),
								l = yr.dot(this.direction),
								u = -yr.dot(vr),
								p = yr.lengthSq(),
								d = Math.abs(1 - h * h);
							if (0 < d)
								if (a = h * l - u, s = c * d, 0 <= (r = h * u - l))
									if (-s <= a)
										if (a <= s) {
											var f = 1 / d;
											o = (r *= f) * (r + h * (a *= f) + 2 * l) + a * (h * r +
												a + 2 * u) + p
										} else a = c, o = -(r = Math.max(0, -(h * a + l))) * r + a * (
											a + 2 * u) + p;
							else a = -c, o = -(r = Math.max(0, -(h * a + l))) * r + a * (a + 2 * u) +
								p;
							else o = a <= -s ? -(r = Math.max(0, -(-h * c + l))) * r + (a = 0 < r ? -
								c : Math.min(Math.max(-c, -u), c)) * (a + 2 * u) + p : a <= s ? (
								r = 0, (a = Math.min(Math.max(-c, -u), c)) * (a + 2 * u) + p) : -(
								r = Math.max(0, -(h * c + l))) * r + (a = 0 < r ? c : Math.min(
								Math.max(-c, -u), c)) * (a + 2 * u) + p;
							else a = 0 < h ? -c : c, o = -(r = Math.max(0, -(h * a + l))) * r + a * (
								a + 2 * u) + p;
							return i && i.copy(this.direction).multiplyScalar(r).add(this.origin),
								n && n.copy(vr).multiplyScalar(a).add(gr), o
						}),
						intersectSphere: (mr = new li, function (t, e) {
							mr.subVectors(t.center, this.origin);
							var i = mr.dot(this.direction),
								n = mr.dot(mr) - i * i,
								r = t.radius * t.radius;
							if (r < n) return null;
							var a = Math.sqrt(r - n),
								o = i - a,
								s = i + a;
							return o < 0 && s < 0 ? null : o < 0 ? this.at(s, e) : this.at(o, e)
						}),
						intersectsSphere: function (t) {
							return this.distanceSqToPoint(t.center) <= t.radius * t.radius
						},
						distanceToPlane: function (t) {
							var e = t.normal.dot(this.direction);
							if (0 === e) return 0 === t.distanceToPoint(this.origin) ? 0 : null;
							var i = -(this.origin.dot(t.normal) + t.constant) / e;
							return 0 <= i ? i : null
						},
						intersectPlane: function (t, e) {
							var i = this.distanceToPlane(t);
							return null === i ? null : this.at(i, e)
						},
						intersectsPlane: function (t) {
							var e = t.distanceToPoint(this.origin);
							return 0 === e || t.normal.dot(this.direction) * e < 0
						},
						intersectBox: function (t, e) {
							var i, n, r, a, o, s, c = 1 / this.direction.x,
								h = 1 / this.direction.y,
								l = 1 / this.direction.z,
								u = this.origin;
							return n = 0 <= c ? (i = (t.min.x - u.x) * c, (t.max.x - u.x) * c) : (i = (t
								.max.x - u.x) * c, (t.min.x - u.x) * c), (a = 0 <= h ? (r = (t.min.y -
								u.y) * h, (t.max.y - u.y) * h) : (r = (t.max.y - u.y) * h, (t.min
								.y - u.y) * h)) < i || n < r ? null : ((i < r || i != i) && (i = r), (
								a < n || n != n) && (n = a), (s = 0 <= l ? (o = (t.min.z - u.z) *
								l, (t.max.z - u.z) * l) : (o = (t.max.z - u.z) * l, (t.min.z -
								u.z) * l)) < i || n < o ? null : ((i < o || i != i) && (i = o), (
								s < n || n != n) && (n = s), n < 0 ? null : this.at(0 <= i ?
								i : n, e)))
						},
						intersectsBox: (fr = new li, function (t) {
							return null !== this.intersectBox(t, fr)
						}),
						intersectTriangle: (lr = new li, ur = new li, pr = new li, dr = new li, function (t,
							e, i, n, r) {
							ur.subVectors(e, t), pr.subVectors(i, t), dr.crossVectors(ur, pr);
							var a, o = this.direction.dot(dr);
							if (0 < o) {
								if (n) return null;
								a = 1
							} else {
								if (!(o < 0)) return null;
								a = -1, o = -o
							}
							lr.subVectors(this.origin, t);
							var s = a * this.direction.dot(pr.crossVectors(lr, pr));
							if (s < 0) return null;
							var c = a * this.direction.dot(ur.cross(lr));
							if (c < 0) return null;
							if (o < s + c) return null;
							var h = -a * lr.dot(dr);
							return h < 0 ? null : this.at(h / o, r)
						}),
						applyMatrix4: function (t) {
							return this.origin.applyMatrix4(t), this.direction.transformDirection(t), this
						},
						equals: function (t) {
							return t.origin.equals(this.origin) && t.direction.equals(this.direction)
						}
					}), Object.assign(Ur, {
						getNormal: (Tr = new li, function (t, e, i, n) {
							void 0 === n && (console.warn(
									"THREE.Triangle: .getNormal() target is now required"), n =
								new li), n.subVectors(i, e), Tr.subVectors(t, e), n.cross(Tr);
							var r = n.lengthSq();
							return 0 < r ? n.multiplyScalar(1 / Math.sqrt(r)) : n.set(0, 0, 0)
						}),
						getBarycoord: (Mr = new li, Sr = new li, Er = new li, function (t, e, i, n, r) {
							Mr.subVectors(n, e), Sr.subVectors(i, e), Er.subVectors(t, e);
							var a = Mr.dot(Mr),
								o = Mr.dot(Sr),
								s = Mr.dot(Er),
								c = Sr.dot(Sr),
								h = Sr.dot(Er),
								l = a * c - o * o;
							if (void 0 === r && (console.warn(
										"THREE.Triangle: .getBarycoord() target is now required"), r =
									new li), 0 === l) return r.set(-2, -1, -1);
							var u = 1 / l,
								p = (c * s - o * h) * u,
								d = (a * h - o * s) * u;
							return r.set(1 - p - d, d, p)
						}),
						containsPoint: (wr = new li, function (t, e, i, n) {
							return Ur.getBarycoord(t, e, i, n, wr), 0 <= wr.x && 0 <= wr.y && wr.x +
								wr.y <= 1
						}),
						getUV: (_r = new li, function (t, e, i, n, r, a, o, s) {
							return this.getBarycoord(t, e, i, n, _r), s.set(0, 0), s.addScaledVector(
									r, _r.x), s.addScaledVector(a, _r.y), s.addScaledVector(o, _r.z),
								s
						})
					}), Object.assign(Ur.prototype, {
						set: function (t, e, i) {
							return this.a.copy(t), this.b.copy(e), this.c.copy(i), this
						},
						setFromPointsAndIndices: function (t, e, i, n) {
							return this.a.copy(t[e]), this.b.copy(t[i]), this.c.copy(t[n]), this
						},
						clone: function () {
							return (new this.constructor).copy(this)
						},
						copy: function (t) {
							return this.a.copy(t.a), this.b.copy(t.b), this.c.copy(t.c), this
						},
						getArea: (Ir = new li, Dr = new li, function () {
							return Ir.subVectors(this.c, this.b), Dr.subVectors(this.a, this.b), .5 *
								Ir.cross(Dr).length()
						}),
						getMidpoint: function (t) {
							return void 0 === t && (console.warn(
									"THREE.Triangle: .getMidpoint() target is now required"), t =
								new li), t.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 /
								3)
						},
						getNormal: function (t) {
							return Ur.getNormal(this.a, this.b, this.c, t)
						},
						getPlane: function (t) {
							return void 0 === t && (console.warn(
									"THREE.Triangle: .getPlane() target is now required"), t = new li), t
								.setFromCoplanarPoints(this.a, this.b, this.c)
						},
						getBarycoord: function (t, e) {
							return Ur.getBarycoord(t, this.a, this.b, this.c, e)
						},
						containsPoint: function (t) {
							return Ur.containsPoint(t, this.a, this.b, this.c)
						},
						getUV: function (t, e, i, n, r) {
							return Ur.getUV(t, this.a, this.b, this.c, e, i, n, r)
						},
						intersectsBox: function (t) {
							return t.intersectsTriangle(this)
						},
						closestPointToPoint: (Ar = new li, Lr = new li, Pr = new li, Rr = new li, Cr = new li,
							Or = new li,
							function (t, e) {
								void 0 === e && (console.warn(
									"THREE.Triangle: .closestPointToPoint() target is now required"
									), e = new li);
								var i, n, r = this.a,
									a = this.b,
									o = this.c;
								Ar.subVectors(a, r), Lr.subVectors(o, r), Rr.subVectors(t, r);
								var s = Ar.dot(Rr),
									c = Lr.dot(Rr);
								if (s <= 0 && c <= 0) return e.copy(r);
								Cr.subVectors(t, a);
								var h = Ar.dot(Cr),
									l = Lr.dot(Cr);
								if (0 <= h && l <= h) return e.copy(a);
								var u = s * l - h * c;
								if (u <= 0 && 0 <= s && h <= 0) return i = s / (s - h), e.copy(r)
									.addScaledVector(Ar, i);
								Or.subVectors(t, o);
								var p = Ar.dot(Or),
									d = Lr.dot(Or);
								if (0 <= d && p <= d) return e.copy(o);
								var f = p * c - s * d;
								if (f <= 0 && 0 <= c && d <= 0) return n = c / (c - d), e.copy(r)
									.addScaledVector(Lr, n);
								var m = h * d - p * l;
								if (m <= 0 && 0 <= l - h && 0 <= p - d) return Pr.subVectors(o, a), n = (
									l - h) / (l - h + (p - d)), e.copy(a).addScaledVector(Pr, n);
								var g = 1 / (m + f + u);
								return i = f * g, n = u * g, e.copy(r).addScaledVector(Ar, i)
									.addScaledVector(Lr, n)
							}),
						equals: function (t) {
							return t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c)
						}
					}), Fr.prototype = Object.create(hr.prototype), (Fr.prototype.constructor = Fr).prototype
					.isMeshBasicMaterial = !0, Fr.prototype.copy = function (t) {
						return hr.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this
							.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t
							.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.specularMap = t.specularMap, this
							.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this
							.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this
							.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this
							.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin,
							this.skinning = t.skinning, this.morphTargets = t.morphTargets, this
					}, Hr.prototype = Object.assign(Object.create(Sn.prototype), {
						constructor: Hr,
						isMesh: !0,
						setDrawMode: function (t) {
							this.drawMode = t
						},
						copy: function (t) {
							return Sn.prototype.copy.call(this, t), this.drawMode = t.drawMode, void 0 !==
								t.morphTargetInfluences && (this.morphTargetInfluences = t
									.morphTargetInfluences.slice()), void 0 !== t.morphTargetDictionary &&
								(this.morphTargetDictionary = Object.assign({}, t.morphTargetDictionary)),
								this
						},
						updateMorphTargets: function () {
							var t, e, i, n = this.geometry;
							if (n.isBufferGeometry) {
								var r = n.morphAttributes,
									a = Object.keys(r);
								if (0 < a.length) {
									var o = r[a[0]];
									if (void 0 !== o)
										for (this.morphTargetInfluences = [], this
											.morphTargetDictionary = {}, t = 0, e = o.length; t < e; t++)
											i = o[t].name || String(t), this.morphTargetInfluences.push(
											0), this.morphTargetDictionary[i] = t
								}
							} else {
								var s = n.morphTargets;
								void 0 !== s && 0 < s.length && console.error(
									"THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
									)
							}
						},
						raycast: function () {
							var U = new ci,
								F = new Gr,
								H = new Ni,
								j = new li,
								k = new li,
								V = new li,
								W = new li,
								q = new li,
								X = new li,
								Y = new si,
								Z = new si,
								J = new si,
								Q = new li,
								h = new li;

							function K(t, e, i, n, r, a, o, s) {
								if (null === (e.side === jt ? n.intersectTriangle(o, a, r, !0, s) : n
										.intersectTriangle(r, a, o, e.side !== dt, s))) return null;
								h.copy(s), h.applyMatrix4(t.matrixWorld);
								var c = i.ray.origin.distanceTo(h);
								return c < i.near || c > i.far ? null : {
									distance: c,
									point: h.clone(),
									object: t
								}
							}

							function $(t, e, i, n, r, a, o, s, c) {
								j.fromBufferAttribute(r, o), k.fromBufferAttribute(r, s), V
									.fromBufferAttribute(r, c);
								var h = K(t, e, i, n, j, k, V, Q);
								if (h) {
									a && (Y.fromBufferAttribute(a, o), Z.fromBufferAttribute(a, s), J
										.fromBufferAttribute(a, c), h.uv = Ur.getUV(Q, j, k, V, Y, Z,
											J, new si));
									var l = new en(o, s, c);
									Ur.getNormal(j, k, V, l.normal), h.face = l
								}
								return h
							}
							return function (t, e) {
								var i, n = this.geometry,
									r = this.material,
									a = this.matrixWorld;
								if (void 0 !== r && (null === n.boundingSphere && n
										.computeBoundingSphere(), H.copy(n.boundingSphere), H
										.applyMatrix4(a), !1 !== t.ray.intersectsSphere(H) && (U
											.getInverse(a), F.copy(t.ray).applyMatrix4(U), null === n
											.boundingBox || !1 !== F.intersectsBox(n.boundingBox))))
									if (n.isBufferGeometry) {
										var o, s, c, h, l, u, p, d, f, m = n.index,
											g = n.attributes.position,
											v = n.attributes.uv,
											y = n.groups,
											x = n.drawRange;
										if (null !== m)
											if (Array.isArray(r))
												for (h = 0, u = y.length; h < u; h++)
													for (f = r[(d = y[h]).materialIndex], l = Math
														.max(d.start, x.start), p = Math.min(d.start +
															d.count, x.start + x.count); l < p; l += 3
														) o = m.getX(l), s = m.getX(l + 1), c = m
														.getX(l + 2), (i = $(this, f, t, F, g, v, o,
															s, c)) && (i.faceIndex = Math.floor(l /
															3), i.face.materialIndex = d
															.materialIndex, e.push(i));
											else
												for (h = Math.max(0, x.start), u = Math.min(m.count, x
														.start + x.count); h < u; h += 3) o = m.getX(
													h), s = m.getX(h + 1), c = m.getX(h + 2), (i =
													$(this, r, t, F, g, v, o, s, c)) && (i
													.faceIndex = Math.floor(h / 3), e.push(i));
										else if (void 0 !== g)
											if (Array.isArray(r))
												for (h = 0, u = y.length; h < u; h++)
													for (f = r[(d = y[h]).materialIndex], l = Math
														.max(d.start, x.start), p = Math.min(d.start +
															d.count, x.start + x.count); l < p; l += 3
														)(i = $(this, f, t, F, g, v, o = l, s = l + 1,
														c = l + 2)) && (i.faceIndex = Math.floor(
															l / 3), i.face.materialIndex = d
														.materialIndex, e.push(i));
											else
												for (h = Math.max(0, x.start), u = Math.min(g.count, x
														.start + x.count); h < u; h += 3)(i = $(this,
													r, t, F, g, v, o = h, s = h + 1, c = h + 2
													)) && (i.faceIndex = Math.floor(h / 3), e
													.push(i))
									} else if (n.isGeometry) {
									var b, _, w, M, S = Array.isArray(r),
										E = n.vertices,
										T = n.faces,
										A = n.faceVertexUvs[0];
									0 < A.length && (M = A);
									for (var L = 0, P = T.length; L < P; L++) {
										var R = T[L],
											C = S ? r[R.materialIndex] : r;
										if (void 0 !== C) {
											if (b = E[R.a], _ = E[R.b], w = E[R.c], !0 === C
												.morphTargets) {
												var O = n.morphTargets,
													I = this.morphTargetInfluences;
												j.set(0, 0, 0), k.set(0, 0, 0), V.set(0, 0, 0);
												for (var D = 0, B = O.length; D < B; D++) {
													var z = I[D];
													if (0 !== z) {
														var N = O[D].vertices;
														j.addScaledVector(W.subVectors(N[R.a], b), z),
															k.addScaledVector(q.subVectors(N[R.b], _),
																z), V.addScaledVector(X.subVectors(N[R
																.c], w), z)
													}
												}
												j.add(b), k.add(_), V.add(w), b = j, _ = k, w = V
											}
											if (i = K(this, C, t, F, b, _, w, Q)) {
												if (M && M[L]) {
													var G = M[L];
													Y.copy(G[0]), Z.copy(G[1]), J.copy(G[2]), i.uv =
														Ur.getUV(Q, b, _, w, Y, Z, J, new si)
												}
												i.face = R, i.faceIndex = L, e.push(i)
											}
										}
									}
								}
							}
						}(),
						clone: function () {
							return new this.constructor(this.geometry, this.material).copy(this)
						}
					}), $r.prototype = Object.create(Ri.prototype), ($r.prototype.constructor = $r).prototype
					.isCubeTexture = !0, Object.defineProperty($r.prototype, "images", {
						get: function () {
							return this.image
						},
						set: function (t) {
							this.image = t
						}
					}), ta.prototype = Object.create(Ri.prototype), (ta.prototype.constructor = ta).prototype
					.isDataTexture3D = !0;
				var ea = new Ri,
					ia = new ta,
					na = new $r;

				function ra() {
					this.seq = [], this.map = {}
				}
				var aa = [],
					oa = [],
					sa = new Float32Array(16),
					ca = new Float32Array(9),
					ha = new Float32Array(4);

				function la(t, e, i) {
					var n = t[0];
					if (n <= 0 || 0 < n) return t;
					var r = e * i,
						a = aa[r];
					if (void 0 === a && (a = new Float32Array(r), aa[r] = a), 0 !== e) {
						n.toArray(a, 0);
						for (var o = 1, s = 0; o !== e; ++o) s += i, t[o].toArray(a, s)
					}
					return a
				}

				function ua(t, e) {
					if (t.length !== e.length) return !1;
					for (var i = 0, n = t.length; i < n; i++)
						if (t[i] !== e[i]) return !1;
					return !0
				}

				function pa(t, e) {
					for (var i = 0, n = e.length; i < n; i++) t[i] = e[i]
				}

				function da(t, e) {
					var i = oa[e];
					void 0 === i && (i = new Int32Array(e), oa[e] = i);
					for (var n = 0; n !== e; ++n) i[n] = t.allocTextureUnit();
					return i
				}

				function fa(t, e) {
					var i = this.cache;
					i[0] !== e && (t.uniform1f(this.addr, e), i[0] = e)
				}

				function ma(t, e) {
					var i = this.cache;
					i[0] !== e && (t.uniform1i(this.addr, e), i[0] = e)
				}

				function ga(t, e) {
					var i = this.cache;
					if (void 0 !== e.x) i[0] === e.x && i[1] === e.y || (t.uniform2f(this.addr, e.x, e.y), i[0] =
						e.x, i[1] = e.y);
					else {
						if (ua(i, e)) return;
						t.uniform2fv(this.addr, e), pa(i, e)
					}
				}

				function va(t, e) {
					var i = this.cache;
					if (void 0 !== e.x) i[0] === e.x && i[1] === e.y && i[2] === e.z || (t.uniform3f(this.addr, e
						.x, e.y, e.z), i[0] = e.x, i[1] = e.y, i[2] = e.z);
					else if (void 0 !== e.r) i[0] === e.r && i[1] === e.g && i[2] === e.b || (t.uniform3f(this
						.addr, e.r, e.g, e.b), i[0] = e.r, i[1] = e.g, i[2] = e.b);
					else {
						if (ua(i, e)) return;
						t.uniform3fv(this.addr, e), pa(i, e)
					}
				}

				function ya(t, e) {
					var i = this.cache;
					if (void 0 !== e.x) i[0] === e.x && i[1] === e.y && i[2] === e.z && i[3] === e.w || (t
						.uniform4f(this.addr, e.x, e.y, e.z, e.w), i[0] = e.x, i[1] = e.y, i[2] = e.z, i[3] =
						e.w);
					else {
						if (ua(i, e)) return;
						t.uniform4fv(this.addr, e), pa(i, e)
					}
				}

				function xa(t, e) {
					var i = this.cache,
						n = e.elements;
					if (void 0 === n) {
						if (ua(i, e)) return;
						t.uniformMatrix2fv(this.addr, !1, e), pa(i, e)
					} else {
						if (ua(i, n)) return;
						ha.set(n), t.uniformMatrix2fv(this.addr, !1, ha), pa(i, n)
					}
				}

				function ba(t, e) {
					var i = this.cache,
						n = e.elements;
					if (void 0 === n) {
						if (ua(i, e)) return;
						t.uniformMatrix3fv(this.addr, !1, e), pa(i, e)
					} else {
						if (ua(i, n)) return;
						ca.set(n), t.uniformMatrix3fv(this.addr, !1, ca), pa(i, n)
					}
				}

				function _a(t, e) {
					var i = this.cache,
						n = e.elements;
					if (void 0 === n) {
						if (ua(i, e)) return;
						t.uniformMatrix4fv(this.addr, !1, e), pa(i, e)
					} else {
						if (ua(i, n)) return;
						sa.set(n), t.uniformMatrix4fv(this.addr, !1, sa), pa(i, n)
					}
				}

				function wa(t, e, i) {
					var n = this.cache,
						r = i.allocTextureUnit();
					n[0] !== r && (t.uniform1i(this.addr, r), n[0] = r), i.setTexture2D(e || ea, r)
				}

				function Ma(t, e, i) {
					var n = this.cache,
						r = i.allocTextureUnit();
					n[0] !== r && (t.uniform1i(this.addr, r), n[0] = r), i.setTexture3D(e || ia, r)
				}

				function Sa(t, e, i) {
					var n = this.cache,
						r = i.allocTextureUnit();
					n[0] !== r && (t.uniform1i(this.addr, r), n[0] = r), i.setTextureCube(e || na, r)
				}

				function Ea(t, e) {
					var i = this.cache;
					ua(i, e) || (t.uniform2iv(this.addr, e), pa(i, e))
				}

				function Ta(t, e) {
					var i = this.cache;
					ua(i, e) || (t.uniform3iv(this.addr, e), pa(i, e))
				}

				function Aa(t, e) {
					var i = this.cache;
					ua(i, e) || (t.uniform4iv(this.addr, e), pa(i, e))
				}

				function La(t) {
					switch (t) {
						case 5126:
							return fa;
						case 35664:
							return ga;
						case 35665:
							return va;
						case 35666:
							return ya;
						case 35674:
							return xa;
						case 35675:
							return ba;
						case 35676:
							return _a;
						case 35678:
						case 36198:
							return wa;
						case 35679:
							return Ma;
						case 35680:
							return Sa;
						case 5124:
						case 35670:
							return ma;
						case 35667:
						case 35671:
							return Ea;
						case 35668:
						case 35672:
							return Ta;
						case 35669:
						case 35673:
							return Aa
					}
				}

				function Pa(t, e) {
					var i = this.cache;
					ua(i, e) || (t.uniform1fv(this.addr, e), pa(i, e))
				}

				function Ra(t, e) {
					var i = this.cache;
					ua(i, e) || (t.uniform1iv(this.addr, e), pa(i, e))
				}

				function Ca(t, e) {
					var i = this.cache,
						n = la(e, this.size, 2);
					ua(i, n) || (t.uniform2fv(this.addr, n), this.updateCache(n))
				}

				function Oa(t, e) {
					var i = this.cache,
						n = la(e, this.size, 3);
					ua(i, n) || (t.uniform3fv(this.addr, n), this.updateCache(n))
				}

				function Ia(t, e) {
					var i = this.cache,
						n = la(e, this.size, 4);
					ua(i, n) || (t.uniform4fv(this.addr, n), this.updateCache(n))
				}

				function Da(t, e) {
					var i = this.cache,
						n = la(e, this.size, 4);
					ua(i, n) || (t.uniformMatrix2fv(this.addr, !1, n), this.updateCache(n))
				}

				function Ba(t, e) {
					var i = this.cache,
						n = la(e, this.size, 9);
					ua(i, n) || (t.uniformMatrix3fv(this.addr, !1, n), this.updateCache(n))
				}

				function za(t, e) {
					var i = this.cache,
						n = la(e, this.size, 16);
					ua(i, n) || (t.uniformMatrix4fv(this.addr, !1, n), this.updateCache(n))
				}

				function Na(t, e, i) {
					var n = this.cache,
						r = e.length,
						a = da(i, r);
					!1 === ua(n, a) && (t.uniform1iv(this.addr, a), pa(n, a));
					for (var o = 0; o !== r; ++o) i.setTexture2D(e[o] || ea, a[o])
				}

				function Ga(t, e, i) {
					var n = this.cache,
						r = e.length,
						a = da(i, r);
					!1 === ua(n, a) && (t.uniform1iv(this.addr, a), pa(n, a));
					for (var o = 0; o !== r; ++o) i.setTextureCube(e[o] || na, a[o])
				}

				function Ua(t) {
					switch (t) {
						case 5126:
							return Pa;
						case 35664:
							return Ca;
						case 35665:
							return Oa;
						case 35666:
							return Ia;
						case 35674:
							return Da;
						case 35675:
							return Ba;
						case 35676:
							return za;
						case 35678:
							return Na;
						case 35680:
							return Ga;
						case 5124:
						case 35670:
							return Ra;
						case 35667:
						case 35671:
							return Ea;
						case 35668:
						case 35672:
							return Ta;
						case 35669:
						case 35673:
							return Aa
					}
				}

				function Fa(t, e, i) {
					this.id = t, this.addr = i, this.cache = [], this.setValue = La(e.type)
				}

				function Ha(t, e, i) {
					this.id = t, this.addr = i, this.cache = [], this.size = e.size, this.setValue = Ua(e.type)
				}

				function ja(t) {
					this.id = t, ra.call(this)
				}
				Ha.prototype.updateCache = function (t) {
					var e = this.cache;
					t instanceof Float32Array && e.length !== t.length && (this.cache = new Float32Array(t
						.length)), pa(e, t)
				}, ja.prototype.setValue = function (t, e, i) {
					for (var n = this.seq, r = 0, a = n.length; r !== a; ++r) {
						var o = n[r];
						o.setValue(t, e[o.id], i)
					}
				};
				var ka = /([\w\d_]+)(\])?(\[|\.)?/g;

				function Va(t, e) {
					t.seq.push(e), t.map[e.id] = e
				}

				function Wa(t, e, i) {
					var n = t.name,
						r = n.length;
					for (ka.lastIndex = 0;;) {
						var a = ka.exec(n),
							o = ka.lastIndex,
							s = a[1],
							c = "]" === a[2],
							h = a[3];
						if (c && (s |= 0), void 0 === h || "[" === h && o + 2 === r) {
							Va(i, void 0 === h ? new Fa(s, t, e) : new Ha(s, t, e));
							break
						}
						var l = i.map[s];
						void 0 === l && Va(i, l = new ja(s)), i = l
					}
				}

				function qa(t, e, i) {
					ra.call(this), this.renderer = i;
					for (var n = t.getProgramParameter(e, 35718), r = 0; r < n; ++r) {
						var a = t.getActiveUniform(e, r);
						Wa(a, t.getUniformLocation(e, a.name), this)
					}
				}

				function Xa(t) {
					for (var e = t.split("\n"), i = 0; i < e.length; i++) e[i] = i + 1 + ": " + e[i];
					return e.join("\n")
				}

				function Ya(t, e, i) {
					var n = t.createShader(e);
					return t.shaderSource(n, i), t.compileShader(n), !1 === t.getShaderParameter(n, 35713) &&
						console.error("THREE.WebGLShader: Shader couldn't compile."), "" !== t.getShaderInfoLog(
						n) && console.warn("THREE.WebGLShader: gl.getShaderInfoLog()", 35633 === e ? "vertex" :
							"fragment", t.getShaderInfoLog(n), Xa(i)), n
				}
				qa.prototype.setValue = function (t, e, i) {
					var n = this.map[e];
					void 0 !== n && n.setValue(t, i, this.renderer)
				}, qa.prototype.setOptional = function (t, e, i) {
					var n = e[i];
					void 0 !== n && this.setValue(t, i, n)
				}, qa.upload = function (t, e, i, n) {
					for (var r = 0, a = e.length; r !== a; ++r) {
						var o = e[r],
							s = i[o.id];
						!1 !== s.needsUpdate && o.setValue(t, s.value, n)
					}
				}, qa.seqWithValue = function (t, e) {
					for (var i = [], n = 0, r = t.length; n !== r; ++n) {
						var a = t[n];
						a.id in e && i.push(a)
					}
					return i
				};
				var Za = 0;

				function Ja(t) {
					switch (t) {
						case Ye:
							return ["Linear", "( value )"];
						case Ze:
							return ["sRGB", "( value )"];
						case Qe:
							return ["RGBE", "( value )"];
						case $e:
							return ["RGBM", "( value, 7.0 )"];
						case ti:
							return ["RGBM", "( value, 16.0 )"];
						case ei:
							return ["RGBD", "( value, 256.0 )"];
						case Je:
							return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
						default:
							throw new Error("unsupported encoding: " + t)
					}
				}

				function Qa(t, e) {
					var i = Ja(e);
					return "vec4 " + t + "( vec4 value ) { return " + i[0] + "ToLinear" + i[1] + "; }"
				}

				function Ka(t, e) {
					var i = Ja(e);
					return "vec4 " + t + "( vec4 value ) { return LinearTo" + i[0] + i[1] + "; }"
				}

				function $a(t, e) {
					var i;
					switch (e) {
						case kt:
							i = "Linear";
							break;
						case nt:
							i = "Reinhard";
							break;
						case rt:
							i = "Uncharted2";
							break;
						case at:
							i = "OptimizedCineon";
							break;
						case ot:
							i = "ACESFilmic";
							break;
						default:
							throw new Error("unsupported toneMapping: " + e)
					}
					return "vec3 " + t + "( vec3 color ) { return " + i + "ToneMapping( color ); }"
				}

				function to(t, e, i) {
					return [(t = t || {}).derivatives || e.envMapCubeUV || e.bumpMap || e.normalMap && !e
						.objectSpaceNormalMap || e.flatShading ?
						"#extension GL_OES_standard_derivatives : enable" : "", (t.fragDepth || e
							.logarithmicDepthBuffer) && i.get("EXT_frag_depth") ?
						"#extension GL_EXT_frag_depth : enable" : "", t.drawBuffers && i.get(
							"WEBGL_draw_buffers") ? "#extension GL_EXT_draw_buffers : require" : "", (t
							.shaderTextureLOD || e.envMap) && i.get("EXT_shader_texture_lod") ?
						"#extension GL_EXT_shader_texture_lod : enable" : ""
					].filter(no).join("\n")
				}

				function eo(t) {
					var e = [];
					for (var i in t) {
						var n = t[i];
						!1 !== n && e.push("#define " + i + " " + n)
					}
					return e.join("\n")
				}

				function io(t, e) {
					for (var i = {}, n = t.getProgramParameter(e, 35721), r = 0; r < n; r++) {
						var a = t.getActiveAttrib(e, r).name;
						i[a] = t.getAttribLocation(e, a)
					}
					return i
				}

				function no(t) {
					return "" !== t
				}

				function ro(t, e) {
					return t.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e
						.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(
						/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights)
				}

				function ao(t, e) {
					return t.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(
						/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection)
				}

				function oo(t) {
					var e = /^[ \t]*#include +<([\w\d./]+)>/gm;

					function i(t, e) {
						var i = Fi[e];
						if (void 0 === i) throw new Error("Can not resolve #include <" + e + ">");
						return oo(i)
					}
					return t.replace(e, i)
				}

				function so(t) {
					var e =
						/#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;

					function i(t, e, i, n) {
						for (var r = "", a = parseInt(e); a < parseInt(i); a++) r += n.replace(/\[ i \]/g, "[ " +
							a + " ]");
						return r
					}
					return t.replace(e, i)
				}

				function co(t, e, i, n, r, a, o) {
					var s = t.context,
						c = n.defines,
						h = r.vertexShader,
						l = r.fragmentShader,
						u = "SHADOWMAP_TYPE_BASIC";
					a.shadowMapType === B ? u = "SHADOWMAP_TYPE_PCF" : a.shadowMapType === I && (u =
						"SHADOWMAP_TYPE_PCF_SOFT");
					var p = "ENVMAP_TYPE_CUBE",
						d = "ENVMAP_MODE_REFLECTION",
						f = "ENVMAP_BLENDING_MULTIPLY";
					if (a.envMap) {
						switch (n.envMap.mapping) {
							case ct:
							case ht:
								p = "ENVMAP_TYPE_CUBE";
								break;
							case Ot:
							case It:
								p = "ENVMAP_TYPE_CUBE_UV";
								break;
							case Pt:
							case Rt:
								p = "ENVMAP_TYPE_EQUIREC";
								break;
							case Ct:
								p = "ENVMAP_TYPE_SPHERE"
						}
						switch (n.envMap.mapping) {
							case ht:
							case Rt:
								d = "ENVMAP_MODE_REFRACTION"
						}
						switch (n.combine) {
							case $:
								f = "ENVMAP_BLENDING_MULTIPLY";
								break;
							case tt:
								f = "ENVMAP_BLENDING_MIX";
								break;
							case et:
								f = "ENVMAP_BLENDING_ADD"
						}
					}
					var m, g, v = 0 < t.gammaFactor ? t.gammaFactor : 1,
						y = o.isWebGL2 ? "" : to(n.extensions, a, e),
						x = eo(c),
						b = s.createProgram();
					if (n.isRawShaderMaterial ? (0 < (m = [x].filter(no).join("\n")).length && (m += "\n"), 0 < (
							g = [y, x].filter(no).join("\n")).length && (g += "\n")) : (m = ["precision " + a
							.precision + " float;", "precision " + a.precision + " int;",
							"#define SHADER_NAME " + r.name, x, a.supportsVertexTextures ?
							"#define VERTEX_TEXTURES" : "", "#define GAMMA_FACTOR " + v,
							"#define MAX_BONES " + a.maxBones, a.useFog && a.fog ? "#define USE_FOG" : "", a
							.useFog && a.fogExp ? "#define FOG_EXP2" : "", a.map ? "#define USE_MAP" : "", a
							.envMap ? "#define USE_ENVMAP" : "", a.envMap ? "#define " + d : "", a.lightMap ?
							"#define USE_LIGHTMAP" : "", a.aoMap ? "#define USE_AOMAP" : "", a.emissiveMap ?
							"#define USE_EMISSIVEMAP" : "", a.bumpMap ? "#define USE_BUMPMAP" : "", a
							.normalMap ? "#define USE_NORMALMAP" : "", a.normalMap && a.objectSpaceNormalMap ?
							"#define OBJECTSPACE_NORMALMAP" : "", a.displacementMap && a
							.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", a.specularMap ?
							"#define USE_SPECULARMAP" : "", a.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
							a.metalnessMap ? "#define USE_METALNESSMAP" : "", a.alphaMap ?
							"#define USE_ALPHAMAP" : "", a.vertexTangents ? "#define USE_TANGENT" : "", a
							.vertexColors ? "#define USE_COLOR" : "", a.flatShading ? "#define FLAT_SHADED" :
							"", a.skinning ? "#define USE_SKINNING" : "", a.useVertexTexture ?
							"#define BONE_TEXTURE" : "", a.morphTargets ? "#define USE_MORPHTARGETS" : "", a
							.morphNormals && !1 === a.flatShading ? "#define USE_MORPHNORMALS" : "", a
							.doubleSided ? "#define DOUBLE_SIDED" : "", a.flipSided ? "#define FLIP_SIDED" :
							"", a.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", a.shadowMapEnabled ?
							"#define " + u : "", a.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", a
							.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", a
							.logarithmicDepthBuffer && (o.isWebGL2 || e.get("EXT_frag_depth")) ?
							"#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;",
							"uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;",
							"uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;",
							"uniform vec3 cameraPosition;", "attribute vec3 position;",
							"attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_TANGENT",
							"\tattribute vec4 tangent;", "#endif", "#ifdef USE_COLOR",
							"\tattribute vec3 color;", "#endif", "#ifdef USE_MORPHTARGETS",
							"\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;",
							"\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;",
							"\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;",
							"\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;",
							"\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;",
							"\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;",
							"\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif", "#ifdef USE_SKINNING",
							"\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"
						].filter(no).join("\n"), g = [y, "precision " + a.precision + " float;",
							"precision " + a.precision + " int;", "#define SHADER_NAME " + r.name, x, a
							.alphaTest ? "#define ALPHATEST " + a.alphaTest + (a.alphaTest % 1 ? "" : ".0") :
							"", "#define GAMMA_FACTOR " + v, a.useFog && a.fog ? "#define USE_FOG" : "", a
							.useFog && a.fogExp ? "#define FOG_EXP2" : "", a.map ? "#define USE_MAP" : "", a
							.matcap ? "#define USE_MATCAP" : "", a.envMap ? "#define USE_ENVMAP" : "", a
							.envMap ? "#define " + p : "", a.envMap ? "#define " + d : "", a.envMap ?
							"#define " + f : "", a.lightMap ? "#define USE_LIGHTMAP" : "", a.aoMap ?
							"#define USE_AOMAP" : "", a.emissiveMap ? "#define USE_EMISSIVEMAP" : "", a
							.bumpMap ? "#define USE_BUMPMAP" : "", a.normalMap ? "#define USE_NORMALMAP" : "",
							a.normalMap && a.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", a
							.specularMap ? "#define USE_SPECULARMAP" : "", a.roughnessMap ?
							"#define USE_ROUGHNESSMAP" : "", a.metalnessMap ? "#define USE_METALNESSMAP" : "",
							a.alphaMap ? "#define USE_ALPHAMAP" : "", a.vertexTangents ?
							"#define USE_TANGENT" : "", a.vertexColors ? "#define USE_COLOR" : "", a
							.gradientMap ? "#define USE_GRADIENTMAP" : "", a.flatShading ?
							"#define FLAT_SHADED" : "", a.doubleSided ? "#define DOUBLE_SIDED" : "", a
							.flipSided ? "#define FLIP_SIDED" : "", a.shadowMapEnabled ?
							"#define USE_SHADOWMAP" : "", a.shadowMapEnabled ? "#define " + u : "", a
							.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", a
							.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", a
							.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", a
							.logarithmicDepthBuffer && (o.isWebGL2 || e.get("EXT_frag_depth")) ?
							"#define USE_LOGDEPTHBUF_EXT" : "", a.envMap && (o.isWebGL2 || e.get(
								"EXT_shader_texture_lod")) ? "#define TEXTURE_LOD_EXT" : "",
							"uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", a.toneMapping !== it ?
							"#define TONE_MAPPING" : "", a.toneMapping !== it ? Fi.tonemapping_pars_fragment :
							"", a.toneMapping !== it ? $a("toneMapping", a.toneMapping) : "", a.dithering ?
							"#define DITHERING" : "", a.outputEncoding || a.mapEncoding || a.matcapEncoding ||
							a.envMapEncoding || a.emissiveMapEncoding ? Fi.encodings_pars_fragment : "", a
							.mapEncoding ? Qa("mapTexelToLinear", a.mapEncoding) : "", a.matcapEncoding ? Qa(
								"matcapTexelToLinear", a.matcapEncoding) : "", a.envMapEncoding ? Qa(
								"envMapTexelToLinear", a.envMapEncoding) : "", a.emissiveMapEncoding ? Qa(
								"emissiveMapTexelToLinear", a.emissiveMapEncoding) : "", a.outputEncoding ?
							Ka("linearToOutputTexel", a.outputEncoding) : "", a.depthPacking ?
							"#define DEPTH_PACKING " + n.depthPacking : "", "\n"
						].filter(no).join("\n")), h = ao(h = ro(h = oo(h), a), a), l = ao(l = ro(l = oo(l), a),
						a), h = so(h), l = so(l), o.isWebGL2 && !n.isRawShaderMaterial) {
						var _ = !1,
							w = /^\s*#version\s+300\s+es\s*\n/;
						n.isShaderMaterial && null !== h.match(w) && null !== l.match(w) && (_ = !0, h = h
							.replace(w, ""), l = l.replace(w, "")), m = ["#version 300 es\n",
							"#define attribute in", "#define varying out", "#define texture2D texture"
						].join("\n") + "\n" + m, g = ["#version 300 es\n", "#define varying in", _ ? "" :
							"out highp vec4 pc_fragColor;", _ ? "" : "#define gl_FragColor pc_fragColor",
							"#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture",
							"#define textureCube texture", "#define texture2DProj textureProj",
							"#define texture2DLodEXT textureLod",
							"#define texture2DProjLodEXT textureProjLod",
							"#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad",
							"#define texture2DProjGradEXT textureProjGrad",
							"#define textureCubeGradEXT textureGrad"
						].join("\n") + "\n" + g
					}
					var M = g + l,
						S = Ya(s, 35633, m + h),
						E = Ya(s, 35632, M);
					s.attachShader(b, S), s.attachShader(b, E), void 0 !== n.index0AttributeName ? s
						.bindAttribLocation(b, 0, n.index0AttributeName) : !0 === a.morphTargets && s
						.bindAttribLocation(b, 0, "position"), s.linkProgram(b);
					var T, A, L = s.getProgramInfoLog(b).trim(),
						P = s.getShaderInfoLog(S).trim(),
						R = s.getShaderInfoLog(E).trim(),
						C = !0,
						O = !0;
					return !1 === s.getProgramParameter(b, 35714) ? (C = !1, console.error(
							"THREE.WebGLProgram: shader error: ", s.getError(), "35715", s
							.getProgramParameter(b, 35715), "gl.getProgramInfoLog", L, P, R)) : "" !== L ? console
						.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", L) : "" !== P && "" !== R || (O = !1),
						O && (this.diagnostics = {
							runnable: C,
							material: n,
							programLog: L,
							vertexShader: {
								log: P,
								prefix: m
							},
							fragmentShader: {
								log: R,
								prefix: g
							}
						}), s.deleteShader(S), s.deleteShader(E), this.getUniforms = function () {
							return void 0 === T && (T = new qa(s, b, t)), T
						}, this.getAttributes = function () {
							return void 0 === A && (A = io(s, b)), A
						}, this.destroy = function () {
							s.deleteProgram(b), this.program = void 0
						}, Object.defineProperties(this, {
							uniforms: {
								get: function () {
									return console.warn(
											"THREE.WebGLProgram: .uniforms is now .getUniforms()."), this
										.getUniforms()
								}
							},
							attributes: {
								get: function () {
									return console.warn(
											"THREE.WebGLProgram: .attributes is now .getAttributes()."),
										this.getAttributes()
								}
							}
						}), this.name = r.name, this.id = Za++, this.code = i, this.usedTimes = 1, this.program =
						b, this.vertexShader = S, this.fragmentShader = E, this
				}

				function ho(u, c, p) {
					var h = [],
						d = {
							MeshDepthMaterial: "depth",
							MeshDistanceMaterial: "distanceRGBA",
							MeshNormalMaterial: "normal",
							MeshBasicMaterial: "basic",
							MeshLambertMaterial: "lambert",
							MeshPhongMaterial: "phong",
							MeshToonMaterial: "phong",
							MeshStandardMaterial: "physical",
							MeshPhysicalMaterial: "physical",
							MeshMatcapMaterial: "matcap",
							LineBasicMaterial: "basic",
							LineDashedMaterial: "dashed",
							PointsMaterial: "points",
							ShadowMaterial: "shadow",
							SpriteMaterial: "sprite"
						},
						a = ["precision", "supportsVertexTextures", "map", "mapEncoding", "matcap",
							"matcapEncoding", "envMap", "envMapMode", "envMapEncoding", "lightMap", "aoMap",
							"emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "objectSpaceNormalMap",
							"displacementMap", "specularMap", "roughnessMap", "metalnessMap", "gradientMap",
							"alphaMap", "combine", "vertexColors", "vertexTangents", "fog", "useFog", "fogExp",
							"flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning", "maxBones",
							"useVertexTexture", "morphTargets", "morphNormals", "maxMorphTargets",
							"maxMorphNormals", "premultipliedAlpha", "numDirLights", "numPointLights",
							"numSpotLights", "numHemiLights", "numRectAreaLights", "shadowMapEnabled",
							"shadowMapType", "toneMapping", "physicallyCorrectLights", "alphaTest", "doubleSided",
							"flipSided", "numClippingPlanes", "numClipIntersection", "depthPacking", "dithering"
						];

					function f(t) {
						var e = t.skeleton.bones;
						if (p.floatVertexTextures) return 1024;
						var i = p.maxVertexUniforms,
							n = Math.floor((i - 20) / 4),
							r = Math.min(n, e.length);
						return r < e.length ? (console.warn("THREE.WebGLRenderer: Skeleton has " + e.length +
							" bones. This GPU supports " + r + "."), 0) : r
					}

					function m(t, e) {
						var i;
						return t ? t.isTexture ? i = t.encoding : t.isWebGLRenderTarget && (console.warn(
							"THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."
							), i = t.texture.encoding) : i = Ye, i === Ye && e && (i = Je), i
					}
					this.getParameters = function (t, e, i, n, r, a, o) {
						var s = d[t.type],
							c = o.isSkinnedMesh ? f(o) : 0,
							h = p.precision;
						null !== t.precision && (h = p.getMaxPrecision(t.precision)) !== t.precision &&
							console.warn("THREE.WebGLProgram.getParameters:", t.precision,
								"not supported, using", h, "instead.");
						var l = u.getRenderTarget();
						return {
							shaderID: s,
							precision: h,
							supportsVertexTextures: p.vertexTextures,
							outputEncoding: m(l ? l.texture : null, u.gammaOutput),
							map: !!t.map,
							mapEncoding: m(t.map, u.gammaInput),
							matcap: !!t.matcap,
							matcapEncoding: m(t.matcap, u.gammaInput),
							envMap: !!t.envMap,
							envMapMode: t.envMap && t.envMap.mapping,
							envMapEncoding: m(t.envMap, u.gammaInput),
							envMapCubeUV: !!t.envMap && (t.envMap.mapping === Ot || t.envMap.mapping === It),
							lightMap: !!t.lightMap,
							aoMap: !!t.aoMap,
							emissiveMap: !!t.emissiveMap,
							emissiveMapEncoding: m(t.emissiveMap, u.gammaInput),
							bumpMap: !!t.bumpMap,
							normalMap: !!t.normalMap,
							objectSpaceNormalMap: t.normalMapType === ai,
							displacementMap: !!t.displacementMap,
							roughnessMap: !!t.roughnessMap,
							metalnessMap: !!t.metalnessMap,
							specularMap: !!t.specularMap,
							alphaMap: !!t.alphaMap,
							gradientMap: !!t.gradientMap,
							combine: t.combine,
							vertexTangents: t.vertexTangents,
							vertexColors: t.vertexColors,
							fog: !!n,
							useFog: t.fog,
							fogExp: n && n.isFogExp2,
							flatShading: t.flatShading,
							sizeAttenuation: t.sizeAttenuation,
							logarithmicDepthBuffer: p.logarithmicDepthBuffer,
							skinning: t.skinning && 0 < c,
							maxBones: c,
							useVertexTexture: p.floatVertexTextures,
							morphTargets: t.morphTargets,
							morphNormals: t.morphNormals,
							maxMorphTargets: u.maxMorphTargets,
							maxMorphNormals: u.maxMorphNormals,
							numDirLights: e.directional.length,
							numPointLights: e.point.length,
							numSpotLights: e.spot.length,
							numRectAreaLights: e.rectArea.length,
							numHemiLights: e.hemi.length,
							numClippingPlanes: r,
							numClipIntersection: a,
							dithering: t.dithering,
							shadowMapEnabled: u.shadowMap.enabled && o.receiveShadow && 0 < i.length,
							shadowMapType: u.shadowMap.type,
							toneMapping: u.toneMapping,
							physicallyCorrectLights: u.physicallyCorrectLights,
							premultipliedAlpha: t.premultipliedAlpha,
							alphaTest: t.alphaTest,
							doubleSided: t.side === dt,
							flipSided: t.side === jt,
							depthPacking: void 0 !== t.depthPacking && t.depthPacking
						}
					}, this.getProgramCode = function (t, e) {
						var i = [];
						if (e.shaderID ? i.push(e.shaderID) : (i.push(t.fragmentShader), i.push(t
								.vertexShader)), void 0 !== t.defines)
							for (var n in t.defines) i.push(n), i.push(t.defines[n]);
						for (var r = 0; r < a.length; r++) i.push(e[a[r]]);
						return i.push(t.onBeforeCompile.toString()), i.push(u.gammaOutput), i.push(u
							.gammaFactor), i.join()
					}, this.acquireProgram = function (t, e, i, n) {
						for (var r, a = 0, o = h.length; a < o; a++) {
							var s = h[a];
							if (s.code === n) {
								++(r = s).usedTimes;
								break
							}
						}
						return void 0 === r && (r = new co(u, c, n, t, e, i, p), h.push(r)), r
					}, this.releaseProgram = function (t) {
						if (0 == --t.usedTimes) {
							var e = h.indexOf(t);
							h[e] = h[h.length - 1], h.pop(), t.destroy()
						}
					}, this.programs = h
				}

				function lo() {
					var n = new WeakMap;

					function t(t) {
						var e = n.get(t);
						return void 0 === e && (e = {}, n.set(t, e)), e
					}

					function e(t) {
						n.delete(t)
					}

					function i(t, e, i) {
						n.get(t)[e] = i
					}

					function r() {
						n = new WeakMap
					}
					return {
						get: t,
						remove: e,
						update: i,
						dispose: r
					}
				}

				function uo(t, e) {
					return t.groupOrder !== e.groupOrder ? t.groupOrder - e.groupOrder : t.renderOrder !== e
						.renderOrder ? t.renderOrder - e.renderOrder : t.program && e.program && t.program !== e
						.program ? t.program.id - e.program.id : t.material.id !== e.material.id ? t.material.id -
						e.material.id : t.z !== e.z ? t.z - e.z : t.id - e.id
				}

				function po(t, e) {
					return t.groupOrder !== e.groupOrder ? t.groupOrder - e.groupOrder : t.renderOrder !== e
						.renderOrder ? t.renderOrder - e.renderOrder : t.z !== e.z ? e.z - t.z : t.id - e.id
				}

				function fo() {
					var s = [],
						c = 0,
						h = [],
						l = [];

					function t() {
						c = 0, h.length = 0, l.length = 0
					}

					function u(t, e, i, n, r, a) {
						var o = s[c];
						return void 0 === o ? (o = {
								id: t.id,
								object: t,
								geometry: e,
								material: i,
								program: i.program,
								groupOrder: n,
								renderOrder: t.renderOrder,
								z: r,
								group: a
							}, s[c] = o) : (o.id = t.id, o.object = t, o.geometry = e, o.material = i, o.program =
								i.program, o.groupOrder = n, o.renderOrder = t.renderOrder, o.z = r, o.group = a),
							c++, o
					}

					function e(t, e, i, n, r, a) {
						var o = u(t, e, i, n, r, a);
						(!0 === i.transparent ? l : h).push(o)
					}

					function i(t, e, i, n, r, a) {
						var o = u(t, e, i, n, r, a);
						(!0 === i.transparent ? l : h).unshift(o)
					}

					function n() {
						1 < h.length && h.sort(uo), 1 < l.length && l.sort(po)
					}
					return {
						opaque: h,
						transparent: l,
						init: t,
						push: e,
						unshift: i,
						sort: n
					}
				}

				function mo() {
					var r = {};

					function a(t) {
						var e = t.target;
						e.removeEventListener("dispose", a), delete r[e.id]
					}

					function t(t, e) {
						var i, n = r[t.id];
						return void 0 === n ? (i = new fo, r[t.id] = {}, r[t.id][e.id] = i, t.addEventListener(
							"dispose", a)) : void 0 === (i = n[e.id]) && (i = new fo, n[e.id] = i), i
					}

					function e() {
						r = {}
					}
					return {
						get: t,
						dispose: e
					}
				}

				function go() {
					var i = {};
					return {
						get: function (t) {
							if (void 0 !== i[t.id]) return i[t.id];
							var e;
							switch (t.type) {
								case "DirectionalLight":
									e = {
										direction: new li,
										color: new Yi,
										shadow: !1,
										shadowBias: 0,
										shadowRadius: 1,
										shadowMapSize: new si
									};
									break;
								case "SpotLight":
									e = {
										position: new li,
										direction: new li,
										color: new Yi,
										distance: 0,
										coneCos: 0,
										penumbraCos: 0,
										decay: 0,
										shadow: !1,
										shadowBias: 0,
										shadowRadius: 1,
										shadowMapSize: new si
									};
									break;
								case "PointLight":
									e = {
										position: new li,
										color: new Yi,
										distance: 0,
										decay: 0,
										shadow: !1,
										shadowBias: 0,
										shadowRadius: 1,
										shadowMapSize: new si,
										shadowCameraNear: 1,
										shadowCameraFar: 1e3
									};
									break;
								case "HemisphereLight":
									e = {
										direction: new li,
										skyColor: new Yi,
										groundColor: new Yi
									};
									break;
								case "RectAreaLight":
									e = {
										color: new Yi,
										position: new li,
										halfWidth: new li,
										halfHeight: new li
									}
							}
							return i[t.id] = e
						}
					}
				}
				var vo = 0;

				function yo() {
					var _ = new go,
						w = {
							id: vo++,
							hash: {
								stateID: -1,
								directionalLength: -1,
								pointLength: -1,
								spotLength: -1,
								rectAreaLength: -1,
								hemiLength: -1,
								shadowsLength: -1
							},
							ambient: [0, 0, 0],
							directional: [],
							directionalShadowMap: [],
							directionalShadowMatrix: [],
							spot: [],
							spotShadowMap: [],
							spotShadowMatrix: [],
							rectArea: [],
							point: [],
							pointShadowMap: [],
							pointShadowMatrix: [],
							hemi: []
						},
						M = new li,
						S = new ci,
						E = new ci;

					function t(t, e, i) {
						for (var n = 0, r = 0, a = 0, o = 0, s = 0, c = 0, h = 0, l = 0, u = i.matrixWorldInverse,
								p = 0, d = t.length; p < d; p++) {
							var f = t[p],
								m = f.color,
								g = f.intensity,
								v = f.distance,
								y = f.shadow && f.shadow.map ? f.shadow.map.texture : null;
							if (f.isAmbientLight) n += m.r * g, r += m.g * g, a += m.b * g;
							else if (f.isDirectionalLight) {
								if ((b = _.get(f)).color.copy(f.color).multiplyScalar(f.intensity), b.direction
									.setFromMatrixPosition(f.matrixWorld), M.setFromMatrixPosition(f.target
										.matrixWorld), b.direction.sub(M), b.direction.transformDirection(u), b
									.shadow = f.castShadow, f.castShadow) {
									var x = f.shadow;
									b.shadowBias = x.bias, b.shadowRadius = x.radius, b.shadowMapSize = x.mapSize
								}
								w.directionalShadowMap[o] = y, w.directionalShadowMatrix[o] = f.shadow.matrix, w
									.directional[o] = b, o++
							} else if (f.isSpotLight) {
								if ((b = _.get(f)).position.setFromMatrixPosition(f.matrixWorld), b.position
									.applyMatrix4(u), b.color.copy(m).multiplyScalar(g), b.distance = v, b
									.direction.setFromMatrixPosition(f.matrixWorld), M.setFromMatrixPosition(f
										.target.matrixWorld), b.direction.sub(M), b.direction.transformDirection(
										u), b.coneCos = Math.cos(f.angle), b.penumbraCos = Math.cos(f.angle * (1 -
										f.penumbra)), b.decay = f.decay, b.shadow = f.castShadow, f.castShadow) {
									x = f.shadow;
									b.shadowBias = x.bias, b.shadowRadius = x.radius, b.shadowMapSize = x.mapSize
								}
								w.spotShadowMap[c] = y, w.spotShadowMatrix[c] = f.shadow.matrix, w.spot[c] = b,
									c++
							} else if (f.isRectAreaLight) {
								(b = _.get(f)).color.copy(m).multiplyScalar(g), b.position.setFromMatrixPosition(f
										.matrixWorld), b.position.applyMatrix4(u), E.identity(), S.copy(f
										.matrixWorld), S.premultiply(u), E.extractRotation(S), b.halfWidth.set(
										.5 * f.width, 0, 0), b.halfHeight.set(0, .5 * f.height, 0), b.halfWidth
									.applyMatrix4(E), b.halfHeight.applyMatrix4(E), w.rectArea[h] = b, h++
							} else if (f.isPointLight) {
								if ((b = _.get(f)).position.setFromMatrixPosition(f.matrixWorld), b.position
									.applyMatrix4(u), b.color.copy(f.color).multiplyScalar(f.intensity), b
									.distance = f.distance, b.decay = f.decay, b.shadow = f.castShadow, f
									.castShadow) {
									x = f.shadow;
									b.shadowBias = x.bias, b.shadowRadius = x.radius, b.shadowMapSize = x.mapSize,
										b.shadowCameraNear = x.camera.near, b.shadowCameraFar = x.camera.far
								}
								w.pointShadowMap[s] = y, w.pointShadowMatrix[s] = f.shadow.matrix, w.point[s] = b,
									s++
							} else if (f.isHemisphereLight) {
								var b;
								(b = _.get(f)).direction.setFromMatrixPosition(f.matrixWorld), b.direction
									.transformDirection(u), b.direction.normalize(), b.skyColor.copy(f.color)
									.multiplyScalar(g), b.groundColor.copy(f.groundColor).multiplyScalar(g), w
									.hemi[l] = b, l++
							}
						}
						w.ambient[0] = n, w.ambient[1] = r, w.ambient[2] = a, w.directional.length = o, w.spot
							.length = c, w.rectArea.length = h, w.point.length = s, w.hemi.length = l, w.hash
							.stateID = w.id, w.hash.directionalLength = o, w.hash.pointLength = s, w.hash
							.spotLength = c, w.hash.rectAreaLength = h, w.hash.hemiLength = l, w.hash
							.shadowsLength = e.length
					}
					return {
						setup: t,
						state: w
					}
				}

				function xo() {
					var e = new yo,
						i = [],
						n = [];

					function t() {
						i.length = 0, n.length = 0
					}

					function r(t) {
						i.push(t)
					}

					function a(t) {
						n.push(t)
					}

					function o(t) {
						e.setup(i, n, t)
					}
					return {
						init: t,
						state: {
							lightsArray: i,
							shadowsArray: n,
							lights: e
						},
						setupLights: o,
						pushLight: r,
						pushShadow: a
					}
				}

				function bo() {
					var n = {};

					function r(t) {
						var e = t.target;
						e.removeEventListener("dispose", r), delete n[e.id]
					}

					function t(t, e) {
						var i;
						return void 0 === n[t.id] ? (i = new xo, n[t.id] = {}, n[t.id][e.id] = i, t
							.addEventListener("dispose", r)) : void 0 === n[t.id][e.id] ? (i = new xo, n[t.id]
							[e.id] = i) : i = n[t.id][e.id], i
					}

					function e() {
						n = {}
					}
					return {
						get: t,
						dispose: e
					}
				}

				function _o(t) {
					hr.call(this), this.type = "MeshDepthMaterial", this.depthPacking = ii, this.skinning = !1,
						this.morphTargets = !1, this.map = null, this.alphaMap = null, this.displacementMap =
						null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this
						.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.setValues(t)
				}

				function wo(t) {
					hr.call(this), this.type = "MeshDistanceMaterial", this.referencePosition = new li, this
						.nearDistance = 1, this.farDistance = 1e3, this.skinning = !1, this.morphTargets = !1,
						this.map = null, this.alphaMap = null, this.displacementMap = null, this
						.displacementScale = 1, this.displacementBias = 0, this.fog = !1, this.lights = !1, this
						.setValues(t)
				}

				function Mo(x, m, t) {
					for (var b = new Ui, _ = new ci, w = new si, M = new si(t, t), S = new li, E = new li, v = 1,
							y = 2, e = 1 + (v | y), T = new Array(e), A = new Array(e), L = {}, P = {
								0: jt,
								1: z,
								2: dt
							}, R = [new li(1, 0, 0), new li(-1, 0, 0), new li(0, 0, 1), new li(0, 0, -1), new li(
								0, 1, 0), new li(0, -1, 0)], C = [new li(0, 1, 0), new li(0, 1, 0), new li(0, 1,
								0), new li(0, 1, 0), new li(0, 0, 1), new li(0, 0, -1)], O = [new Ci, new Ci,
								new Ci, new Ci, new Ci, new Ci
							], i = 0; i !== e; ++i) {
						var n = 0 != (i & v),
							r = 0 != (i & y),
							a = new _o({
								depthPacking: ni,
								morphTargets: n,
								skinning: r
							});
						T[i] = a;
						var o = new wo({
							morphTargets: n,
							skinning: r
						});
						A[i] = o
					}
					var I = this;

					function g(t, e, i, n, r, a) {
						var o = t.geometry,
							s = null,
							c = T,
							h = t.customDepthMaterial;
						if (i && (c = A, h = t.customDistanceMaterial), h) s = h;
						else {
							var l = !1;
							e.morphTargets && (o && o.isBufferGeometry ? l = o.morphAttributes && o
									.morphAttributes.position && 0 < o.morphAttributes.position.length : o && o
									.isGeometry && (l = o.morphTargets && 0 < o.morphTargets.length)), t
								.isSkinnedMesh && !1 === e.skinning && console.warn(
									"THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:",
									t);
							var u = t.isSkinnedMesh && e.skinning,
								p = 0;
							l && (p |= v), u && (p |= y), s = c[p]
						}
						if (x.localClippingEnabled && !0 === e.clipShadows && 0 !== e.clippingPlanes.length) {
							var d = s.uuid,
								f = e.uuid,
								m = L[d];
							void 0 === m && (m = {}, L[d] = m);
							var g = m[f];
							void 0 === g && (g = s.clone(), m[f] = g), s = g
						}
						return s.visible = e.visible, s.wireframe = e.wireframe, s.side = null != e.shadowSide ? e
							.shadowSide : P[e.side], s.clipShadows = e.clipShadows, s.clippingPlanes = e
							.clippingPlanes, s.clipIntersection = e.clipIntersection, s.wireframeLinewidth = e
							.wireframeLinewidth, s.linewidth = e.linewidth, i && s.isMeshDistanceMaterial && (s
								.referencePosition.copy(n), s.nearDistance = r, s.farDistance = a), s
					}

					function D(t, e, i, n) {
						if (!1 !== t.visible) {
							if (t.layers.test(e.layers) && (t.isMesh || t.isLine || t.isPoints) && t.castShadow &&
								(!t.frustumCulled || b.intersectsObject(t))) {
								t.modelViewMatrix.multiplyMatrices(i.matrixWorldInverse, t.matrixWorld);
								var r = m.update(t),
									a = t.material;
								if (Array.isArray(a))
									for (var o = r.groups, s = 0, c = o.length; s < c; s++) {
										var h = o[s],
											l = a[h.materialIndex];
										if (l && l.visible) {
											var u = g(t, l, n, E, i.near, i.far);
											x.renderBufferDirect(i, null, r, u, t, h)
										}
									} else if (a.visible) {
										u = g(t, a, n, E, i.near, i.far);
										x.renderBufferDirect(i, null, r, u, t, null)
									}
							}
							for (var p = t.children, d = 0, f = p.length; d < f; d++) D(p[d], e, i, n)
						}
					}
					this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = B, this.render =
						function (t, e, i) {
							if (!1 !== I.enabled && (!1 !== I.autoUpdate || !1 !== I.needsUpdate) && 0 !== t
								.length) {
								var n, r = x.getRenderTarget(),
									a = x.state;
								a.setBlending(ft), a.buffers.color.setClear(1, 1, 1, 1), a.buffers.depth.setTest(!
									0), a.setScissorTest(!1);
								for (var o = 0, s = t.length; o < s; o++) {
									var c = t[o],
										h = c.shadow,
										l = c && c.isPointLight;
									if (void 0 !== h) {
										var u = h.camera;
										if (w.copy(h.mapSize), w.min(M), l) {
											var p = w.x,
												d = w.y;
											O[0].set(2 * p, d, p, d), O[1].set(0, d, p, d), O[2].set(3 * p, d, p,
												d), O[3].set(p, d, p, d), O[4].set(3 * p, 0, p, d), O[5].set(
												p, 0, p, d), w.x *= 4, w.y *= 2
										}
										if (null === h.map) {
											var f = {
												minFilter: Nt,
												magFilter: Nt,
												format: oe
											};
											h.map = new Oi(w.x, w.y, f), h.map.texture.name = c.name +
												".shadowMap", u.updateProjectionMatrix()
										}
										h.isSpotLightShadow && h.update(c);
										var m = h.map,
											g = h.matrix;
										E.setFromMatrixPosition(c.matrixWorld), u.position.copy(E), l ? (n = 6, g
											.makeTranslation(-E.x, -E.y, -E.z)) : (n = 1, S
											.setFromMatrixPosition(c.target.matrixWorld), u.lookAt(S), u
											.updateMatrixWorld(), g.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5,
												.5, 0, 0, 0, 1), g.multiply(u.projectionMatrix), g.multiply(u
												.matrixWorldInverse)), x.setRenderTarget(m), x.clear();
										for (var v = 0; v < n; v++) {
											if (l) {
												S.copy(u.position), S.add(R[v]), u.up.copy(C[v]), u.lookAt(S), u
													.updateMatrixWorld();
												var y = O[v];
												a.viewport(y)
											}
											_.multiplyMatrices(u.projectionMatrix, u.matrixWorldInverse), b
												.setFromMatrix(_), D(e, i, u, l)
										}
									} else console.warn("THREE.WebGLShadowMap:", c, "has no shadow.")
								}
								I.needsUpdate = !1, x.setRenderTarget(r)
							}
						}
				}

				function So(l, i, c, n) {
					function t() {
						var e = !1,
							a = new Ci,
							i = null,
							o = new Ci(0, 0, 0, 0);
						return {
							setMask: function (t) {
								i === t || e || (l.colorMask(t, t, t, t), i = t)
							},
							setLocked: function (t) {
								e = t
							},
							setClear: function (t, e, i, n, r) {
								!0 === r && (t *= n, e *= n, i *= n), a.set(t, e, i, n), !1 === o.equals(a) &&
									(l.clearColor(t, e, i, n), o.copy(a))
							},
							reset: function () {
								e = !1, i = null, o.set(-1, 0, 0, 0)
							}
						}
					}

					function e() {
						var e = !1,
							i = null,
							n = null,
							r = null;
						return {
							setTest: function (t) {
								t ? W(2929) : q(2929)
							},
							setMask: function (t) {
								i === t || e || (l.depthMask(t), i = t)
							},
							setFunc: function (t) {
								if (n !== t) {
									if (t) switch (t) {
										case _t:
											l.depthFunc(512);
											break;
										case wt:
											l.depthFunc(519);
											break;
										case Mt:
											l.depthFunc(513);
											break;
										case St:
											l.depthFunc(515);
											break;
										case Et:
											l.depthFunc(514);
											break;
										case Tt:
											l.depthFunc(518);
											break;
										case At:
											l.depthFunc(516);
											break;
										case Lt:
											l.depthFunc(517);
											break;
										default:
											l.depthFunc(515)
									} else l.depthFunc(515);
									n = t
								}
							},
							setLocked: function (t) {
								e = t
							},
							setClear: function (t) {
								r !== t && (l.clearDepth(t), r = t)
							},
							reset: function () {
								e = !1, r = n = i = null
							}
						}
					}

					function r() {
						var e = !1,
							i = null,
							n = null,
							r = null,
							a = null,
							o = null,
							s = null,
							c = null,
							h = null;
						return {
							setTest: function (t) {
								t ? W(2960) : q(2960)
							},
							setMask: function (t) {
								i === t || e || (l.stencilMask(t), i = t)
							},
							setFunc: function (t, e, i) {
								n === t && r === e && a === i || (l.stencilFunc(t, e, i), n = t, r = e, a = i)
							},
							setOp: function (t, e, i) {
								o === t && s === e && c === i || (l.stencilOp(t, e, i), o = t, s = e, c = i)
							},
							setLocked: function (t) {
								e = t
							},
							setClear: function (t) {
								h !== t && (l.clearStencil(t), h = t)
							},
							reset: function () {
								e = !1, h = c = s = o = a = r = n = i = null
							}
						}
					}
					var a = new t,
						o = new e,
						s = new r,
						h = l.getParameter(34921),
						u = new Uint8Array(h),
						p = new Uint8Array(h),
						d = new Uint8Array(h),
						f = {},
						m = null,
						g = null,
						v = null,
						y = null,
						x = null,
						b = null,
						_ = null,
						w = null,
						M = null,
						S = null,
						E = !1,
						T = null,
						A = null,
						L = null,
						P = null,
						R = null,
						C = l.getParameter(35661),
						O = !1,
						I = 0,
						D = l.getParameter(7938); - 1 !== D.indexOf("WebGL") ? (I = parseFloat(/^WebGL\ ([0-9])/
						.exec(D)[1]), O = 1 <= I) : -1 !== D.indexOf("OpenGL ES") && (I = parseFloat(
						/^OpenGL\ ES\ ([0-9])/.exec(D)[1]), O = 2 <= I);
					var B = null,
						z = {},
						N = new Ci,
						G = new Ci;

					function U(t, e, i) {
						var n = new Uint8Array(4),
							r = l.createTexture();
						l.bindTexture(t, r), l.texParameteri(t, 10241, 9728), l.texParameteri(t, 10240, 9728);
						for (var a = 0; a < i; a++) l.texImage2D(e + a, 0, 6408, 1, 1, 0, 6408, 5121, n);
						return r
					}
					var F = {};

					function H() {
						for (var t = 0, e = u.length; t < e; t++) u[t] = 0
					}

					function j(t) {
						k(t, 0)
					}

					function k(t, e) {
						(u[t] = 1, 0 === p[t] && (l.enableVertexAttribArray(t), p[t] = 1), d[t] !== e) && ((n
							.isWebGL2 ? l : i.get("ANGLE_instanced_arrays"))[n.isWebGL2 ?
							"vertexAttribDivisor" : "vertexAttribDivisorANGLE"](t, e), d[t] = e)
					}

					function V() {
						for (var t = 0, e = p.length; t !== e; ++t) p[t] !== u[t] && (l.disableVertexAttribArray(
							t), p[t] = 0)
					}

					function W(t) {
						!0 !== f[t] && (l.enable(t), f[t] = !0)
					}

					function q(t) {
						!1 !== f[t] && (l.disable(t), f[t] = !1)
					}

					function X() {
						if (null === m && (m = [], i.get("WEBGL_compressed_texture_pvrtc") || i.get(
									"WEBGL_compressed_texture_s3tc") || i.get("WEBGL_compressed_texture_etc1") ||
								i.get("WEBGL_compressed_texture_astc")))
							for (var t = l.getParameter(34467), e = 0; e < t.length; e++) m.push(t[e]);
						return m
					}

					function Y(t) {
						return g !== t && (l.useProgram(t), g = t, !0)
					}

					function Z(t, e, i, n, r, a, o, s) {
						if (t !== ft) {
							if (v || (W(3042), v = !0), t === xt) r = r || e, a = a || i, o = o || n, e === x &&
								r === w || (l.blendEquationSeparate(c.convert(e), c.convert(r)), x = e, w = r),
								i === b && n === _ && a === M && o === S || (l.blendFuncSeparate(c.convert(i), c
									.convert(n), c.convert(a), c.convert(o)), b = i, _ = n, M = a, S = o), y = t,
								E = null;
							else if (t !== y || s !== E) {
								if (x === bt && w === bt || (l.blendEquation(32774), w = x = bt), s) switch (t) {
									case mt:
										l.blendFuncSeparate(1, 771, 1, 771);
										break;
									case gt:
										l.blendFunc(1, 1);
										break;
									case vt:
										l.blendFuncSeparate(0, 0, 769, 771);
										break;
									case yt:
										l.blendFuncSeparate(0, 768, 0, 770);
										break;
									default:
										console.error("THREE.WebGLState: Invalid blending: ", t)
								} else switch (t) {
									case mt:
										l.blendFuncSeparate(770, 771, 1, 771);
										break;
									case gt:
										l.blendFunc(770, 1);
										break;
									case vt:
										l.blendFunc(0, 769);
										break;
									case yt:
										l.blendFunc(0, 768);
										break;
									default:
										console.error("THREE.WebGLState: Invalid blending: ", t)
								}
								S = M = _ = b = null, y = t, E = s
							}
						} else v && (q(3042), v = !1)
					}

					function J(t, e) {
						t.side === dt ? q(2884) : W(2884);
						var i = t.side === jt;
						e && (i = !i), Q(i), t.blending === mt && !1 === t.transparent ? Z(ft) : Z(t.blending, t
							.blendEquation, t.blendSrc, t.blendDst, t.blendEquationAlpha, t.blendSrcAlpha, t
							.blendDstAlpha, t.premultipliedAlpha), o.setFunc(t.depthFunc), o.setTest(t
							.depthTest), o.setMask(t.depthWrite), a.setMask(t.colorWrite), tt(t.polygonOffset,
							t.polygonOffsetFactor, t.polygonOffsetUnits)
					}

					function Q(t) {
						T !== t && (t ? l.frontFace(2304) : l.frontFace(2305), T = t)
					}

					function K(t) {
						t !== lt ? (W(2884), t !== A && (t === ut ? l.cullFace(1029) : t === pt ? l.cullFace(
							1028) : l.cullFace(1032))) : q(2884), A = t
					}

					function $(t) {
						t !== L && (O && l.lineWidth(t), L = t)
					}

					function tt(t, e, i) {
						t ? (W(32823), P === e && R === i || (l.polygonOffset(e, i), P = e, R = i)) : q(32823)
					}

					function et(t) {
						t ? W(3089) : q(3089)
					}

					function it(t) {
						void 0 === t && (t = 33984 + C - 1), B !== t && (l.activeTexture(t), B = t)
					}

					function nt(t, e) {
						null === B && it();
						var i = z[B];
						void 0 === i && (i = {
							type: void 0,
							texture: void 0
						}, z[B] = i), i.type === t && i.texture === e || (l.bindTexture(t, e || F[t]), i
							.type = t, i.texture = e)
					}

					function rt() {
						try {
							l.compressedTexImage2D.apply(l, arguments)
						} catch (t) {
							console.error("THREE.WebGLState:", t)
						}
					}

					function at() {
						try {
							l.texImage2D.apply(l, arguments)
						} catch (t) {
							console.error("THREE.WebGLState:", t)
						}
					}

					function ot() {
						try {
							l.texImage3D.apply(l, arguments)
						} catch (t) {
							console.error("THREE.WebGLState:", t)
						}
					}

					function st(t) {
						!1 === N.equals(t) && (l.scissor(t.x, t.y, t.z, t.w), N.copy(t))
					}

					function ct(t) {
						!1 === G.equals(t) && (l.viewport(t.x, t.y, t.z, t.w), G.copy(t))
					}

					function ht() {
						for (var t = 0; t < p.length; t++) 1 === p[t] && (l.disableVertexAttribArray(t), p[t] =
						0);
						f = {}, z = {}, A = T = y = g = B = m = null, a.reset(), o.reset(), s.reset()
					}
					return F[3553] = U(3553, 3553, 1), F[34067] = U(34067, 34069, 6), a.setClear(0, 0, 0, 1), o
						.setClear(1), s.setClear(0), W(2929), o.setFunc(St), Q(!1), K(ut), W(2884), Z(ft), {
							buffers: {
								color: a,
								depth: o,
								stencil: s
							},
							initAttributes: H,
							enableAttribute: j,
							enableAttributeAndDivisor: k,
							disableUnusedAttributes: V,
							enable: W,
							disable: q,
							getCompressedTextureFormats: X,
							useProgram: Y,
							setBlending: Z,
							setMaterial: J,
							setFlipSided: Q,
							setCullFace: K,
							setLineWidth: $,
							setPolygonOffset: tt,
							setScissorTest: et,
							activeTexture: it,
							bindTexture: nt,
							compressedTexImage2D: rt,
							texImage2D: at,
							texImage3D: ot,
							scissor: st,
							viewport: ct,
							reset: ht
						}
				}

				function Eo(g, r, v, y, x, b, h) {
					var l, n = {},
						u = "undefined" != typeof OffscreenCanvas;

					function p(t, e) {
						return u ? new OffscreenCanvas(t, e) : document.createElement(
							"http://www.w3.org/1999/xhtml", "canvas")
					}

					function _(t, e, i, n) {
						var r = 1;
						if ((t.width > n || t.height > n) && (r = n / Math.max(t.width, t.height)), r < 1 || !
							0 === e) {
							if (t instanceof ImageBitmap || t instanceof HTMLImageElement ||
								t instanceof HTMLCanvasElement) {
								var a = e ? oi.floorPowerOfTwo : Math.floor,
									o = a(r * t.width),
									s = a(r * t.height);
								void 0 === l && (l = p(o, s));
								var c = i ? p(o, s) : l;
								return c.width = o, c.height = s, c.getContext("2d").drawImage(t, 0, 0, o, s),
									console.warn("THREE.WebGLRenderer: Texture has been resized from (" + t
										.width + "x" + t.height + ") to (" + o + "x" + s + ")."), u ? c
									.transferToImageBitmap() : c
							}
							return "data" in t && console.warn(
								"THREE.WebGLRenderer: Image in DataTexture is too big (" + t.width + "x" + t
								.height + ")."), t
						}
						return t
					}

					function w(t) {
						return oi.isPowerOfTwo(t.width) && oi.isPowerOfTwo(t.height)
					}

					function f(t) {
						return !x.isWebGL2 && (t.wrapS !== Bt || t.wrapT !== Bt || t.minFilter !== Nt && t
							.minFilter !== Ft)
					}

					function M(t, e) {
						return t.generateMipmaps && e && t.minFilter !== Nt && t.minFilter !== Ft
					}

					function S(t, e, i, n) {
						g.generateMipmap(t), y.get(e).__maxMipLevel = Math.log(Math.max(i, n)) * Math.LOG2E
					}

					function E(t, e) {
						if (!x.isWebGL2) return t;
						var i = t;
						return 6403 === t && (5126 === e && (i = 33326), 5131 === e && (i = 33325), 5121 === e &&
								(i = 33321)), 6407 === t && (5126 === e && (i = 34837), 5131 === e && (i = 34843),
								5121 === e && (i = 32849)), 6408 === t && (5126 === e && (i = 34836), 5131 ===
								e && (i = 34842), 5121 === e && (i = 32856)), 33325 === i || 33326 === i ||
							34842 === i || 34836 === i ? r.get("EXT_color_buffer_float") : 34843 !== i &&
							34837 !== i || console.warn(
								"THREE.WebGLRenderer: Floating point textures with RGB format not supported. Please use RGBA instead."
								), i
					}

					function a(t) {
						return t === Nt || t === Gt || t === Ut ? 9728 : 9729
					}

					function i(t) {
						var e = t.target;
						e.removeEventListener("dispose", i), o(e), e.isVideoTexture && delete n[e.id], h.memory
							.textures--
					}

					function d(t) {
						var e = t.target;
						e.removeEventListener("dispose", d), s(e), h.memory.textures--
					}

					function o(t) {
						var e = y.get(t);
						void 0 !== e.__webglInit && (g.deleteTexture(e.__webglTexture), y.remove(t))
					}

					function s(t) {
						var e = y.get(t),
							i = y.get(t.texture);
						if (t) {
							if (void 0 !== i.__webglTexture && g.deleteTexture(i.__webglTexture), t
								.depthTexture && t.depthTexture.dispose(), t.isWebGLRenderTargetCube)
								for (var n = 0; n < 6; n++) g.deleteFramebuffer(e.__webglFramebuffer[n]), e
									.__webglDepthbuffer && g.deleteRenderbuffer(e.__webglDepthbuffer[n]);
							else g.deleteFramebuffer(e.__webglFramebuffer), e.__webglDepthbuffer && g
								.deleteRenderbuffer(e.__webglDepthbuffer);
							y.remove(t.texture), y.remove(t)
						}
					}

					function c(t, e) {
						var i = y.get(t);
						if (t.isVideoTexture && N(t), 0 < t.version && i.__version !== t.version) {
							var n = t.image;
							if (void 0 === n) console.warn(
								"THREE.WebGLRenderer: Texture marked for update but image is undefined");
							else {
								if (!1 !== n.complete) return void L(i, t, e);
								console.warn(
									"THREE.WebGLRenderer: Texture marked for update but image is incomplete")
							}
						}
						v.activeTexture(33984 + e), v.bindTexture(3553, i.__webglTexture)
					}

					function t(t, e) {
						var i = y.get(t);
						0 < t.version && i.__version !== t.version ? L(i, t, e) : (v.activeTexture(33984 + e), v
							.bindTexture(32879, i.__webglTexture))
					}

					function e(t, e) {
						var i = y.get(t);
						if (6 === t.image.length)
							if (0 < t.version && i.__version !== t.version) {
								A(i, t), v.activeTexture(33984 + e), v.bindTexture(34067, i.__webglTexture), g
									.pixelStorei(37440, t.flipY);
								for (var n = t && t.isCompressedTexture, r = t.image[0] && t.image[0]
										.isDataTexture, a = [], o = 0; o < 6; o++) a[o] = n || r ? r ? t.image[o]
									.image : t.image[o] : _(t.image[o], !1, !0, x.maxCubemapSize);
								var s = a[0],
									c = w(s) || x.isWebGL2,
									h = b.convert(t.format),
									l = b.convert(t.type),
									u = E(h, l);
								T(34067, t, c);
								for (o = 0; o < 6; o++)
									if (n)
										for (var p, d = a[o].mipmaps, f = 0, m = d.length; f < m; f++) p = d[f], t
											.format !== oe && t.format !== ae ? -1 < v
											.getCompressedTextureFormats().indexOf(h) ? v.compressedTexImage2D(
												34069 + o, f, u, p.width, p.height, 0, p.data) : console.warn(
												"THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"
												) : v.texImage2D(34069 + o, f, u, p.width, p.height, 0, h, l, p
												.data);
									else r ? v.texImage2D(34069 + o, 0, u, a[o].width, a[o].height, 0, h, l, a[o]
										.data) : v.texImage2D(34069 + o, 0, u, h, l, a[o]);
								i.__maxMipLevel = n ? d.length - 1 : 0, M(t, c) && S(34067, t, s.width, s.height),
									i.__version = t.version, t.onUpdate && t.onUpdate(t)
							} else v.activeTexture(33984 + e), v.bindTexture(34067, i.__webglTexture)
					}

					function m(t, e) {
						v.activeTexture(33984 + e), v.bindTexture(34067, y.get(t).__webglTexture)
					}

					function T(t, e, i) {
						var n;
						if (i ? (g.texParameteri(t, 10242, b.convert(e.wrapS)), g.texParameteri(t, 10243, b
								.convert(e.wrapT)), 32879 === t && g.texParameteri(t, 32882, b.convert(e
								.wrapR)), g.texParameteri(t, 10240, b.convert(e.magFilter)), g.texParameteri(
								t, 10241, b.convert(e.minFilter))) : (g.texParameteri(t, 10242, 33071), g
								.texParameteri(t, 10243, 33071), 32879 === t && g.texParameteri(t, 32882, 33071),
								e.wrapS === Bt && e.wrapT === Bt || console.warn(
									"THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."
									), g.texParameteri(t, 10240, a(e.magFilter)), g.texParameteri(t, 10241, a(e
									.minFilter)), e.minFilter !== Nt && e.minFilter !== Ft && console.warn(
									"THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter."
									)), n = r.get("EXT_texture_filter_anisotropic")) {
							if (e.type === Kt && null === r.get("OES_texture_float_linear")) return;
							if (e.type === $t && null === (x.isWebGL2 || r.get("OES_texture_half_float_linear")))
								return;
							(1 < e.anisotropy || y.get(e).__currentAnisotropy) && (g.texParameterf(t, n
									.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(e.anisotropy, x.getMaxAnisotropy())), y
								.get(e).__currentAnisotropy = e.anisotropy)
						}
					}

					function A(t, e) {
						void 0 === t.__webglInit && (t.__webglInit = !0, e.addEventListener("dispose", i), t
							.__webglTexture = g.createTexture(), h.memory.textures++)
					}

					function L(t, e, i) {
						var n = e.isDataTexture3D ? 32879 : 3553;
						A(t, e), v.activeTexture(33984 + i), v.bindTexture(n, t.__webglTexture), g.pixelStorei(
							37440, e.flipY), g.pixelStorei(37441, e.premultiplyAlpha), g.pixelStorei(3317, e
							.unpackAlignment);
						var r = f(e) && !1 === w(e.image),
							a = _(e.image, r, !1, x.maxTextureSize),
							o = w(a) || x.isWebGL2,
							s = b.convert(e.format),
							c = b.convert(e.type),
							h = E(s, c);
						T(n, e, o);
						var l, u = e.mipmaps;
						if (e.isDepthTexture) {
							if (h = 6402, e.type === Kt) {
								if (!x.isWebGL2) throw new Error(
								"Float Depth Texture only supported in WebGL2.0");
								h = 36012
							} else x.isWebGL2 && (h = 33189);
							e.format === le && 6402 === h && e.type !== Zt && e.type !== Qt && (console.warn(
								"THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."
								), e.type = Zt, c = b.convert(e.type)), e.format === ue && (h = 34041, e
								.type !== ne && (console.warn(
									"THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."
									), e.type = ne, c = b.convert(e.type))), v.texImage2D(3553, 0, h, a.width,
								a.height, 0, s, c, null)
						} else if (e.isDataTexture)
							if (0 < u.length && o) {
								for (var p = 0, d = u.length; p < d; p++) l = u[p], v.texImage2D(3553, p, h, l
									.width, l.height, 0, s, c, l.data);
								e.generateMipmaps = !1, t.__maxMipLevel = u.length - 1
							} else v.texImage2D(3553, 0, h, a.width, a.height, 0, s, c, a.data), t.__maxMipLevel =
								0;
						else if (e.isCompressedTexture) {
							for (p = 0, d = u.length; p < d; p++) l = u[p], e.format !== oe && e.format !== ae ? -
								1 < v.getCompressedTextureFormats().indexOf(s) ? v.compressedTexImage2D(3553, p,
									h, l.width, l.height, 0, l.data) : console.warn(
									"THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"
									) : v.texImage2D(3553, p, h, l.width, l.height, 0, s, c, l.data);
							t.__maxMipLevel = u.length - 1
						} else if (e.isDataTexture3D) v.texImage3D(32879, 0, h, a.width, a.height, a.depth, 0, s,
							c, a.data), t.__maxMipLevel = 0;
						else if (0 < u.length && o) {
							for (p = 0, d = u.length; p < d; p++) l = u[p], v.texImage2D(3553, p, h, s, c, l);
							e.generateMipmaps = !1, t.__maxMipLevel = u.length - 1
						} else v.texImage2D(3553, 0, h, s, c, a), t.__maxMipLevel = 0;
						M(e, o) && S(3553, e, a.width, a.height), t.__version = e.version, e.onUpdate && e
							.onUpdate(e)
					}

					function P(t, e, i, n) {
						var r = b.convert(e.texture.format),
							a = b.convert(e.texture.type),
							o = E(r, a);
						v.texImage2D(n, 0, o, e.width, e.height, 0, r, a, null), g.bindFramebuffer(36160, t), g
							.framebufferTexture2D(36160, i, n, y.get(e.texture).__webglTexture, 0), g
							.bindFramebuffer(36160, null)
					}

					function R(t, e, i) {
						if (g.bindRenderbuffer(36161, t), e.depthBuffer && !e.stencilBuffer) {
							if (i) {
								var n = z(e);
								g.renderbufferStorageMultisample(36161, n, 33189, e.width, e.height)
							} else g.renderbufferStorage(36161, 33189, e.width, e.height);
							g.framebufferRenderbuffer(36160, 36096, 36161, t)
						} else if (e.depthBuffer && e.stencilBuffer) {
							if (i) {
								n = z(e);
								g.renderbufferStorageMultisample(36161, n, 34041, e.width, e.height)
							} else g.renderbufferStorage(36161, 34041, e.width, e.height);
							g.framebufferRenderbuffer(36160, 33306, 36161, t)
						} else {
							var r = E(b.convert(e.texture.format), b.convert(e.texture.type));
							if (i) {
								n = z(e);
								g.renderbufferStorageMultisample(36161, n, r, e.width, e.height)
							} else g.renderbufferStorage(36161, r, e.width, e.height)
						}
						g.bindRenderbuffer(36161, null)
					}

					function C(t, e) {
						if (e && e.isWebGLRenderTargetCube) throw new Error(
							"Depth Texture with cube render targets is not supported");
						if (g.bindFramebuffer(36160, t), !e.depthTexture || !e.depthTexture.isDepthTexture)
						throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
						y.get(e.depthTexture).__webglTexture && e.depthTexture.image.width === e.width && e
							.depthTexture.image.height === e.height || (e.depthTexture.image.width = e.width, e
								.depthTexture.image.height = e.height, e.depthTexture.needsUpdate = !0), c(e
								.depthTexture, 0);
						var i = y.get(e.depthTexture).__webglTexture;
						if (e.depthTexture.format === le) g.framebufferTexture2D(36160, 36096, 3553, i, 0);
						else {
							if (e.depthTexture.format !== ue) throw new Error("Unknown depthTexture format");
							g.framebufferTexture2D(36160, 33306, 3553, i, 0)
						}
					}

					function O(t) {
						var e = y.get(t),
							i = !0 === t.isWebGLRenderTargetCube;
						if (t.depthTexture) {
							if (i) throw new Error("target.depthTexture not supported in Cube render targets");
							C(e.__webglFramebuffer, t)
						} else if (i) {
							e.__webglDepthbuffer = [];
							for (var n = 0; n < 6; n++) g.bindFramebuffer(36160, e.__webglFramebuffer[n]), e
								.__webglDepthbuffer[n] = g.createRenderbuffer(), R(e.__webglDepthbuffer[n], t)
						} else g.bindFramebuffer(36160, e.__webglFramebuffer), e.__webglDepthbuffer = g
							.createRenderbuffer(), R(e.__webglDepthbuffer, t);
						g.bindFramebuffer(36160, null)
					}

					function I(t) {
						var e = y.get(t),
							i = y.get(t.texture);
						t.addEventListener("dispose", d), i.__webglTexture = g.createTexture(), h.memory
							.textures++;
						var n = !0 === t.isWebGLRenderTargetCube,
							r = !0 === t.isWebGLMultisampleRenderTarget,
							a = w(t) || x.isWebGL2;
						if (n) {
							e.__webglFramebuffer = [];
							for (var o = 0; o < 6; o++) e.__webglFramebuffer[o] = g.createFramebuffer()
						} else if (e.__webglFramebuffer = g.createFramebuffer(), r)
							if (x.isWebGL2) {
								e.__webglMultisampledFramebuffer = g.createFramebuffer(), e
									.__webglColorRenderbuffer = g.createRenderbuffer(), g.bindRenderbuffer(36161,
										e.__webglColorRenderbuffer);
								var s = E(b.convert(t.texture.format), b.convert(t.texture.type)),
									c = z(t);
								g.renderbufferStorageMultisample(36161, c, s, t.width, t.height), g
									.bindFramebuffer(36160, e.__webglMultisampledFramebuffer), g
									.framebufferRenderbuffer(36160, 36064, 36161, e.__webglColorRenderbuffer), g
									.bindRenderbuffer(36161, null), t.depthBuffer && (e.__webglDepthRenderbuffer =
										g.createRenderbuffer(), R(e.__webglDepthRenderbuffer, t, !0)), g
									.bindFramebuffer(36160, null)
							} else console.warn(
								"THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2."
								);
						if (n) {
							v.bindTexture(34067, i.__webglTexture), T(34067, t.texture, a);
							for (o = 0; o < 6; o++) P(e.__webglFramebuffer[o], t, 36064, 34069 + o);
							M(t.texture, a) && S(34067, t.texture, t.width, t.height), v.bindTexture(34067, null)
						} else v.bindTexture(3553, i.__webglTexture), T(3553, t.texture, a), P(e
							.__webglFramebuffer, t, 36064, 3553), M(t.texture, a) && S(3553, t.texture, t
							.width, t.height), v.bindTexture(3553, null);
						t.depthBuffer && O(t)
					}

					function D(t) {
						var e = t.texture;
						if (M(e, w(t) || x.isWebGL2)) {
							var i = t.isWebGLRenderTargetCube ? 34067 : 3553,
								n = y.get(e).__webglTexture;
							v.bindTexture(i, n), S(i, e, t.width, t.height), v.bindTexture(i, null)
						}
					}

					function B(t) {
						if (t.isWebGLMultisampleRenderTarget)
							if (x.isWebGL2) {
								var e = y.get(t);
								g.bindFramebuffer(36008, e.__webglMultisampledFramebuffer), g.bindFramebuffer(
									36009, e.__webglFramebuffer);
								var i = t.width,
									n = t.height,
									r = 16384;
								t.depthBuffer && (r |= 256), t.stencilBuffer && (r |= 1024), g.blitFramebuffer(0,
									0, i, n, 0, 0, i, n, r, 9728)
							} else console.warn(
								"THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2."
								)
					}

					function z(t) {
						return x.isWebGL2 && t.isWebGLMultisampleRenderTarget ? Math.min(x.maxSamples, t
							.samples) : 0
					}

					function N(t) {
						var e = t.id,
							i = h.render.frame;
						n[e] !== i && (n[e] = i, t.update())
					}
					this.setTexture2D = c, this.setTexture3D = t, this.setTextureCube = e, this
						.setTextureCubeDynamic = m, this.setupRenderTarget = I, this.updateRenderTargetMipmap = D,
						this.updateMultisampleRenderTarget = B
				}

				function To(t, i, n) {
					function e(t) {
						var e;
						if (t === Dt) return 10497;
						if (t === Bt) return 33071;
						if (t === zt) return 33648;
						if (t === Nt) return 9728;
						if (t === Gt) return 9984;
						if (t === Ut) return 9986;
						if (t === Ft) return 9729;
						if (t === Vt) return 9985;
						if (t === Wt) return 9987;
						if (t === qt) return 5121;
						if (t === te) return 32819;
						if (t === ee) return 32820;
						if (t === ie) return 33635;
						if (t === Xt) return 5120;
						if (t === Yt) return 5122;
						if (t === Zt) return 5123;
						if (t === Jt) return 5124;
						if (t === Qt) return 5125;
						if (t === Kt) return 5126;
						if (t === $t) {
							if (n.isWebGL2) return 5131;
							if (null !== (e = i.get("OES_texture_half_float"))) return e.HALF_FLOAT_OES
						}
						if (t === re) return 6406;
						if (t === ae) return 6407;
						if (t === oe) return 6408;
						if (t === se) return 6409;
						if (t === ce) return 6410;
						if (t === le) return 6402;
						if (t === ue) return 34041;
						if (t === pe) return 6403;
						if (t === bt) return 32774;
						if (t === G) return 32778;
						if (t === U) return 32779;
						if (t === j) return 0;
						if (t === k) return 1;
						if (t === V) return 768;
						if (t === W) return 769;
						if (t === q) return 770;
						if (t === X) return 771;
						if (t === Y) return 772;
						if (t === Z) return 773;
						if (t === J) return 774;
						if (t === Q) return 775;
						if (t === K) return 776;
						if ((t === de || t === fe || t === me || t === ge) && null !== (e = i.get(
								"WEBGL_compressed_texture_s3tc"))) {
							if (t === de) return e.COMPRESSED_RGB_S3TC_DXT1_EXT;
							if (t === fe) return e.COMPRESSED_RGBA_S3TC_DXT1_EXT;
							if (t === me) return e.COMPRESSED_RGBA_S3TC_DXT3_EXT;
							if (t === ge) return e.COMPRESSED_RGBA_S3TC_DXT5_EXT
						}
						if ((t === ve || t === ye || t === xe || t === be) && null !== (e = i.get(
								"WEBGL_compressed_texture_pvrtc"))) {
							if (t === ve) return e.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
							if (t === ye) return e.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
							if (t === xe) return e.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
							if (t === be) return e.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
						}
						if (t === _e && null !== (e = i.get("WEBGL_compressed_texture_etc1"))) return e
							.COMPRESSED_RGB_ETC1_WEBGL;
						if ((t === we || t === Me || t === Se || t === Ee || t === Te || t === Ae || t === Le ||
								t === Pe || t === Re || t === Ce || t === Oe || t === Ie || t === De || t === Be
								) && null !== (e = i.get("WEBGL_compressed_texture_astc"))) return t;
						if (t === F || t === H) {
							if (n.isWebGL2) {
								if (t === F) return 32775;
								if (t === H) return 32776
							}
							if (null !== (e = i.get("EXT_blend_minmax"))) {
								if (t === F) return e.MIN_EXT;
								if (t === H) return e.MAX_EXT
							}
						}
						if (t === ne) {
							if (n.isWebGL2) return 34042;
							if (null !== (e = i.get("WEBGL_depth_texture"))) return e.UNSIGNED_INT_24_8_WEBGL
						}
						return 0
					}
					return {
						convert: e
					}
				}

				function Ao() {
					Sn.call(this), this.type = "Group"
				}

				function Lo() {
					Sn.call(this), this.type = "Camera", this.matrixWorldInverse = new ci, this.projectionMatrix =
						new ci, this.projectionMatrixInverse = new ci
				}

				function Po(t, e, i, n) {
					Lo.call(this), this.type = "PerspectiveCamera", this.fov = void 0 !== t ? t : 50, this.zoom =
						1, this.near = void 0 !== i ? i : .1, this.far = void 0 !== n ? n : 2e3, this.focus = 10,
						this.aspect = void 0 !== e ? e : 1, this.view = null, this.filmGauge = 35, this
						.filmOffset = 0, this.updateProjectionMatrix()
				}

				function Ro(t) {
					Po.call(this), this.cameras = t || []
				}
				_o.prototype = Object.create(hr.prototype), (_o.prototype.constructor = _o).prototype
					.isMeshDepthMaterial = !0, _o.prototype.copy = function (t) {
						return hr.prototype.copy.call(this, t), this.depthPacking = t.depthPacking, this
							.skinning = t.skinning, this.morphTargets = t.morphTargets, this.map = t.map, this
							.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this
							.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias,
							this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this
					}, wo.prototype = Object.create(hr.prototype), (wo.prototype.constructor = wo).prototype
					.isMeshDistanceMaterial = !0, wo.prototype.copy = function (t) {
						return hr.prototype.copy.call(this, t), this.referencePosition.copy(t.referencePosition),
							this.nearDistance = t.nearDistance, this.farDistance = t.farDistance, this.skinning =
							t.skinning, this.morphTargets = t.morphTargets, this.map = t.map, this.alphaMap = t
							.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t
							.displacementScale, this.displacementBias = t.displacementBias, this
					}, Ao.prototype = Object.assign(Object.create(Sn.prototype), {
						constructor: Ao,
						isGroup: !0
					}), Lo.prototype = Object.assign(Object.create(Sn.prototype), {
						constructor: Lo,
						isCamera: !0,
						copy: function (t, e) {
							return Sn.prototype.copy.call(this, t, e), this.matrixWorldInverse.copy(t
									.matrixWorldInverse), this.projectionMatrix.copy(t.projectionMatrix),
								this.projectionMatrixInverse.copy(t.projectionMatrixInverse), this
						},
						getWorldDirection: function (t) {
							void 0 === t && (console.warn(
									"THREE.Camera: .getWorldDirection() target is now required"), t =
								new li), this.updateMatrixWorld(!0);
							var e = this.matrixWorld.elements;
							return t.set(-e[8], -e[9], -e[10]).normalize()
						},
						updateMatrixWorld: function (t) {
							Sn.prototype.updateMatrixWorld.call(this, t), this.matrixWorldInverse
								.getInverse(this.matrixWorld)
						},
						clone: function () {
							return (new this.constructor).copy(this)
						}
					}), Po.prototype = Object.assign(Object.create(Lo.prototype), {
						constructor: Po,
						isPerspectiveCamera: !0,
						copy: function (t, e) {
							return Lo.prototype.copy.call(this, t, e), this.fov = t.fov, this.zoom = t
								.zoom, this.near = t.near, this.far = t.far, this.focus = t.focus, this
								.aspect = t.aspect, this.view = null === t.view ? null : Object.assign({},
									t.view), this.filmGauge = t.filmGauge, this.filmOffset = t.filmOffset,
								this
						},
						setFocalLength: function (t) {
							var e = .5 * this.getFilmHeight() / t;
							this.fov = 2 * oi.RAD2DEG * Math.atan(e), this.updateProjectionMatrix()
						},
						getFocalLength: function () {
							var t = Math.tan(.5 * oi.DEG2RAD * this.fov);
							return .5 * this.getFilmHeight() / t
						},
						getEffectiveFOV: function () {
							return 2 * oi.RAD2DEG * Math.atan(Math.tan(.5 * oi.DEG2RAD * this.fov) / this
								.zoom)
						},
						getFilmWidth: function () {
							return this.filmGauge * Math.min(this.aspect, 1)
						},
						getFilmHeight: function () {
							return this.filmGauge / Math.max(this.aspect, 1)
						},
						setViewOffset: function (t, e, i, n, r, a) {
							this.aspect = t / e, null === this.view && (this.view = {
									enabled: !0,
									fullWidth: 1,
									fullHeight: 1,
									offsetX: 0,
									offsetY: 0,
									width: 1,
									height: 1
								}), this.view.enabled = !0, this.view.fullWidth = t, this.view
								.fullHeight = e, this.view.offsetX = i, this.view.offsetY = n, this.view
								.width = r, this.view.height = a, this.updateProjectionMatrix()
						},
						clearViewOffset: function () {
							null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
						},
						updateProjectionMatrix: function () {
							var t = this.near,
								e = t * Math.tan(.5 * oi.DEG2RAD * this.fov) / this.zoom,
								i = 2 * e,
								n = this.aspect * i,
								r = -.5 * n,
								a = this.view;
							if (null !== this.view && this.view.enabled) {
								var o = a.fullWidth,
									s = a.fullHeight;
								r += a.offsetX * n / o, e -= a.offsetY * i / s, n *= a.width / o, i *= a
									.height / s
							}
							var c = this.filmOffset;
							0 !== c && (r += t * c / this.getFilmWidth()), this.projectionMatrix
								.makePerspective(r, r + n, e, e - i, t, this.far), this
								.projectionMatrixInverse.getInverse(this.projectionMatrix)
						},
						toJSON: function (t) {
							var e = Sn.prototype.toJSON.call(this, t);
							return e.object.fov = this.fov, e.object.zoom = this.zoom, e.object.near =
								this.near, e.object.far = this.far, e.object.focus = this.focus, e.object
								.aspect = this.aspect, null !== this.view && (e.object.view = Object
									.assign({}, this.view)), e.object.filmGauge = this.filmGauge, e.object
								.filmOffset = this.filmOffset, e
						}
					}), Ro.prototype = Object.assign(Object.create(Po.prototype), {
						constructor: Ro,
						isArrayCamera: !0
					});
				var Co, Oo, Io, Do, Bo, zo, No, Go, Uo, Fo, Ho, jo, ko, Vo, Wo, qo, Xo = new li,
					Yo = new li;

				function Zo(t, e, i) {
					Xo.setFromMatrixPosition(e.matrixWorld), Yo.setFromMatrixPosition(i.matrixWorld);
					var n = Xo.distanceTo(Yo),
						r = e.projectionMatrix.elements,
						a = i.projectionMatrix.elements,
						o = r[14] / (r[10] - 1),
						s = r[14] / (r[10] + 1),
						c = (r[9] + 1) / r[5],
						h = (r[9] - 1) / r[5],
						l = (r[8] - 1) / r[0],
						u = (a[8] + 1) / a[0],
						p = o * l,
						d = o * u,
						f = n / (-l + u),
						m = f * -l;
					e.matrixWorld.decompose(t.position, t.quaternion, t.scale), t.translateX(m), t.translateZ(f),
						t.matrixWorld.compose(t.position, t.quaternion, t.scale), t.matrixWorldInverse.getInverse(
							t.matrixWorld);
					var g = o + f,
						v = s + f,
						y = p - m,
						x = d + (n - m),
						b = c * s / v * g,
						_ = h * s / v * g;
					t.projectionMatrix.makePerspective(y, x, b, _, g, v)
				}

				function Jo(n) {
					var r = this,
						c = null,
						h = null,
						l = null,
						a = [],
						u = new ci,
						p = new ci,
						o = 1,
						d = "stage";
					"undefined" != typeof window && "VRFrameData" in window && (h = new window.VRFrameData, window
						.addEventListener("vrdisplaypresentchange", t, !1));
					var f = new ci,
						m = new hi,
						g = new li,
						v = new Po;
					v.bounds = new Ci(0, 0, .5, 1), v.layers.enable(1);
					var y = new Po;
					y.bounds = new Ci(.5, 0, .5, 1), y.layers.enable(2);
					var x = new Ro([v, y]);

					function s() {
						return null !== c && !0 === c.isPresenting
					}
					x.layers.enable(1), x.layers.enable(2);
					var b, _ = new si;

					function t() {
						if (s()) {
							var t = c.getEyeParameters("left"),
								e = t.renderWidth * o,
								i = t.renderHeight * o;
							b = n.getPixelRatio(), n.getSize(_), n.setDrawingBufferSize(2 * e, i, 1), E.start()
						} else r.enabled && n.setDrawingBufferSize(_.width, _.height, b), E.stop()
					}
					var w = [];

					function M(t) {
						for (var e = navigator.getGamepads && navigator.getGamepads(), i = 0, n = 0, r = e
							.length; i < r; i++) {
							var a = e[i];
							if (a && ("Daydream Controller" === a.id || "Gear VR Controller" === a.id ||
									"Oculus Go Controller" === a.id || "OpenVR Gamepad" === a.id || a.id
									.startsWith("Oculus Touch") || a.id.startsWith("Spatial Controller"))) {
								if (n === t) return a;
								n++
							}
						}
					}

					function S() {
						for (var t = 0; t < a.length; t++) {
							var e = a[t],
								i = M(t);
							if (void 0 !== i && void 0 !== i.pose) {
								if (null === i.pose) return;
								var n = i.pose;
								!1 === n.hasPosition && e.position.set(.2, -.6, -.05), null !== n.position && e
									.position.fromArray(n.position), null !== n.orientation && e.quaternion
									.fromArray(n.orientation), e.matrix.compose(e.position, e.quaternion, e
									.scale), e.matrix.premultiply(u), e.matrix.decompose(e.position, e.quaternion,
										e.scale), e.matrixWorldNeedsUpdate = !0, e.visible = !0;
								var r = "Daydream Controller" === i.id ? 0 : 1;
								w[t] !== i.buttons[r].pressed && (w[t] = i.buttons[r].pressed, !0 === w[t] ? e
									.dispatchEvent({
										type: "selectstart"
									}) : (e.dispatchEvent({
										type: "selectend"
									}), e.dispatchEvent({
										type: "select"
									})))
							} else e.visible = !1
						}
					}
					this.enabled = !1, this.getController = function (t) {
						var e = a[t];
						return void 0 === e && ((e = new Ao).matrixAutoUpdate = !1, e.visible = !1, a[t] = e),
							e
					}, this.getDevice = function () {
						return c
					}, this.setDevice = function (t) {
						void 0 !== t && (c = t), E.setContext(t)
					}, this.setFramebufferScaleFactor = function (t) {
						o = t
					}, this.setFrameOfReferenceType = function (t) {
						d = t
					}, this.setPoseTarget = function (t) {
						void 0 !== t && (l = t)
					}, this.getCamera = function (t) {
						var e = "stage" === d ? 1.6 : 0;
						if (null === c) return t.position.set(0, e, 0), t;
						if (c.depthNear = t.near, c.depthFar = t.far, c.getFrameData(h), "stage" === d) {
							var i = c.stageParameters;
							i ? u.fromArray(i.sittingToStandingTransform) : u.makeTranslation(0, e, 0)
						}
						var n = h.pose,
							r = null !== l ? l : t;
						if (r.matrix.copy(u), r.matrix.decompose(r.position, r.quaternion, r.scale), null !==
							n.orientation && (m.fromArray(n.orientation), r.quaternion.multiply(m)), null !==
							n.position && (m.setFromRotationMatrix(u), g.fromArray(n.position), g
								.applyQuaternion(m), r.position.add(g)), r.updateMatrixWorld(), !1 === c
							.isPresenting) return t;
						v.near = t.near, y.near = t.near, v.far = t.far, y.far = t.far, v.matrixWorldInverse
							.fromArray(h.leftViewMatrix), y.matrixWorldInverse.fromArray(h.rightViewMatrix), p
							.getInverse(u), "stage" === d && (v.matrixWorldInverse.multiply(p), y
								.matrixWorldInverse.multiply(p));
						var a = r.parent;
						null !== a && (f.getInverse(a.matrixWorld), v.matrixWorldInverse.multiply(f), y
								.matrixWorldInverse.multiply(f)), v.matrixWorld.getInverse(v
								.matrixWorldInverse), y.matrixWorld.getInverse(y.matrixWorldInverse), v
							.projectionMatrix.fromArray(h.leftProjectionMatrix), y.projectionMatrix.fromArray(
								h.rightProjectionMatrix), Zo(x, v, y);
						var o = c.getLayers();
						if (o.length) {
							var s = o[0];
							null !== s.leftBounds && 4 === s.leftBounds.length && v.bounds.fromArray(s
									.leftBounds), null !== s.rightBounds && 4 === s.rightBounds.length && y
								.bounds.fromArray(s.rightBounds)
						}
						return S(), x
					}, this.getStandingMatrix = function () {
						return u
					}, this.isPresenting = s;
					var E = new $i;
					this.setAnimationLoop = function (t) {
						E.setAnimationLoop(t)
					}, this.submitFrame = function () {
						s() && c.submitFrame()
					}, this.dispose = function () {
						"undefined" != typeof window && window.removeEventListener("vrdisplaypresentchange",
							t)
					}
				}

				function Qo(e) {
					var i = e.context,
						n = null,
						p = null,
						r = 1,
						d = null,
						a = "stage",
						f = null,
						m = [],
						g = [];

					function o() {
						return null !== p && null !== d
					}
					var s = new Po;
					s.layers.enable(1), s.viewport = new Ci;
					var c = new Po;
					c.layers.enable(2), c.viewport = new Ci;
					var v = new Ro([s, c]);

					function h(t) {
						var e = m[g.indexOf(t.inputSource)];
						e && e.dispatchEvent({
							type: t.type
						})
					}

					function l() {
						e.setFramebuffer(null), x.stop()
					}

					function u(t, e) {
						null === e ? t.matrixWorld.copy(t.matrix) : t.matrixWorld.multiplyMatrices(e.matrixWorld,
							t.matrix), t.matrixWorldInverse.getInverse(t.matrixWorld)
					}
					v.layers.enable(1), v.layers.enable(2), this.enabled = !1, this.getController = function (t) {
						var e = m[t];
						return void 0 === e && ((e = new Ao).matrixAutoUpdate = !1, e.visible = !1, m[t] = e),
							e
					}, this.getDevice = function () {
						return n
					}, this.setDevice = function (t) {
						void 0 !== t && (n = t), t instanceof XRDevice && i.setCompatibleXRDevice(t)
					}, this.setFramebufferScaleFactor = function (t) {
						r = t
					}, this.setFrameOfReferenceType = function (t) {
						a = t
					}, this.setSession = function (t) {
						null !== (p = t) && (p.addEventListener("select", h), p.addEventListener(
							"selectstart", h), p.addEventListener("selectend", h), p.addEventListener(
							"end", l), p.baseLayer = new XRWebGLLayer(p, i, {
							framebufferScaleFactor: r
						}), p.requestFrameOfReference(a).then(function (t) {
							d = t, e.setFramebuffer(p.baseLayer.framebuffer), x.setContext(p), x
								.start()
						}), g = p.getInputSources(), p.addEventListener("inputsourceschange",
							function () {
								g = p.getInputSources(), console.log(g);
								for (var t = 0; t < m.length; t++) {
									m[t].userData.inputSource = g[t]
								}
							}))
					}, this.getCamera = function (t) {
						if (o()) {
							var e = t.parent,
								i = v.cameras;
							u(v, e);
							for (var n = 0; n < i.length; n++) u(i[n], e);
							t.matrixWorld.copy(v.matrixWorld);
							for (var r = t.children, a = (n = 0, r.length); n < a; n++) r[n]
								.updateMatrixWorld(!0);
							return Zo(v, s, c), v
						}
						return t
					}, this.isPresenting = o;
					var y = null;

					function t(t, e) {
						if (null !== (f = e.getDevicePose(d)))
							for (var i = p.baseLayer, n = e.views, r = 0; r < n.length; r++) {
								var a = n[r],
									o = i.getViewport(a),
									s = f.getViewMatrix(a),
									c = v.cameras[r];
								c.matrix.fromArray(s).getInverse(c.matrix), c.projectionMatrix.fromArray(a
										.projectionMatrix), c.viewport.set(o.x, o.y, o.width, o.height), 0 ===
									r && v.matrix.copy(c.matrix)
							}
						for (r = 0; r < m.length; r++) {
							var h = m[r],
								l = g[r];
							if (l) {
								var u = e.getInputPose(l, d);
								if (null !== u) {
									"targetRay" in u ? h.matrix.elements = u.targetRay.transformMatrix :
										"pointerMatrix" in u && (h.matrix.elements = u.pointerMatrix), h.matrix
										.decompose(h.position, h.rotation, h.scale), h.visible = !0;
									continue
								}
							}
							h.visible = !1
						}
						y && y(t)
					}
					var x = new $i;
					x.setAnimationLoop(t), this.setAnimationLoop = function (t) {
						y = t
					}, this.dispose = function () {}, this.getStandingMatrix = function () {
						return console.warn("THREE.WebXRManager: getStandingMatrix() is no longer needed."),
							new THREE.Matrix4
					}, this.submitFrame = function () {}
				}

				function Ko(t) {
					console.log("THREE.WebGLRenderer", Ht);
					var n = void 0 !== (t = t || {}).canvas ? t.canvas : document.createElement("canvas"),
						e = void 0 !== t.context ? t.context : null,
						i = void 0 !== t.alpha && t.alpha,
						r = void 0 === t.depth || t.depth,
						a = void 0 === t.stencil || t.stencil,
						o = void 0 !== t.antialias && t.antialias,
						s = void 0 === t.premultipliedAlpha || t.premultipliedAlpha,
						c = void 0 !== t.preserveDrawingBuffer && t.preserveDrawingBuffer,
						h = void 0 !== t.powerPreference ? t.powerPreference : "default",
						p = null,
						_ = null;
					this.domElement = n, this.context = null, this.autoClear = !0, this.autoClearColor = !0, this
						.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this
						.clippingPlanes = [], this.localClippingEnabled = !1, this.gammaFactor = 2, this
						.gammaInput = !1, this.gammaOutput = !1, this.physicallyCorrectLights = !1, this
						.toneMapping = kt, this.toneMappingExposure = 1, this.toneMappingWhitePoint = 1, this
						.maxMorphTargets = 8, this.maxMorphNormals = 4;
					var M, x, w, S, l, E, u, T, A, d, y, f, m, g, L, P, R, v, C = this,
						b = !1,
						O = null,
						I = null,
						D = null,
						B = -1,
						z = {
							geometry: null,
							program: null,
							wireframe: !1
						},
						N = null,
						G = null,
						U = new Ci,
						F = new Ci,
						H = null,
						j = 0,
						k = n.width,
						V = n.height,
						W = 1,
						q = new Ci(0, 0, k, V),
						X = new Ci(0, 0, k, V),
						Y = !1,
						Z = new Ui,
						J = new Wr,
						Q = !1,
						K = !1,
						$ = new ci,
						tt = new li;

					function et() {
						return null === I ? W : 1
					}
					try {
						var it = {
							alpha: i,
							depth: r,
							stencil: a,
							antialias: o,
							premultipliedAlpha: s,
							preserveDrawingBuffer: c,
							powerPreference: h
						};
						if (n.addEventListener("webglcontextlost", ot, !1), n.addEventListener(
								"webglcontextrestored", st, !1), null === (M = e || n.getContext("webgl", it) || n
								.getContext("experimental-webgl", it))) throw null !== n.getContext("webgl") ?
							new Error("Error creating WebGL context with your selected attributes.") :
							new Error("Error creating WebGL context.");
						void 0 === M.getShaderPrecisionFormat && (M.getShaderPrecisionFormat = function () {
							return {
								rangeMin: 1,
								rangeMax: 1,
								precision: 1
							}
						})
					} catch (t) {
						throw console.error("THREE.WebGLRenderer: " + t.message), t
					}

					function nt() {
						x = new qr(M), (w = new Vr(M, x, t)).isWebGL2 || (x.get("WEBGL_depth_texture"), x.get(
								"OES_texture_float"), x.get("OES_texture_half_float"), x.get(
								"OES_texture_half_float_linear"), x.get("OES_standard_derivatives"), x.get(
								"OES_element_index_uint"), x.get("ANGLE_instanced_arrays")), x.get(
								"OES_texture_float_linear"), v = new To(M, x, w), (S = new So(M, x, v, w))
							.scissor(F.copy(X).multiplyScalar(W)), S.viewport(U.copy(q).multiplyScalar(W)), l =
							new Zr(M), E = new lo, u = new Eo(M, x, S, E, w, v, l), T = new tn(M), A = new Xr(M,
								T, l), d = new Kr(A, l), L = new Qr(M), y = new ho(C, x, w), f = new mo, m =
							new bo, g = new jr(C, S, d, s), P = new kr(M, x, l, w), R = new Yr(M, x, l, w), l
							.programs = y.programs, C.context = M, C.capabilities = w, C.extensions = x, C
							.properties = E, C.renderLists = f, C.state = S, C.info = l
					}
					nt();
					var rt = null;
					"undefined" != typeof navigator && (rt = "xr" in navigator ? new Qo(C) : new Jo(C)), this.vr =
						rt;
					var at = new Mo(C, d, w.maxTextureSize);

					function ot(t) {
						t.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), b = !0
					}

					function st() {
						console.log("THREE.WebGLRenderer: Context Restored."), b = !1, nt()
					}

					function ct(t) {
						var e = t.target;
						e.removeEventListener("dispose", ct), ht(e)
					}

					function ht(t) {
						lt(t), E.remove(t)
					}

					function lt(t) {
						var e = E.get(t).program;
						(t.program = void 0) !== e && y.releaseProgram(e)
					}

					function ut(t, e) {
						t.render(function (t) {
							C.renderBufferImmediate(t, e)
						})
					}

					function pt(t, e, i) {
						if (i && i.isInstancedBufferGeometry && !w.isWebGL2 && null === x.get(
								"ANGLE_instanced_arrays")) console.error(
							"THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
							);
						else {
							S.initAttributes();
							var n = i.attributes,
								r = e.getAttributes(),
								a = t.defaultAttributeValues;
							for (var o in r) {
								var s = r[o];
								if (0 <= s) {
									var c = n[o];
									if (void 0 !== c) {
										var h = c.normalized,
											l = c.itemSize,
											u = T.get(c);
										if (void 0 === u) continue;
										var p = u.buffer,
											d = u.type,
											f = u.bytesPerElement;
										if (c.isInterleavedBufferAttribute) {
											var m = c.data,
												g = m.stride,
												v = c.offset;
											m && m.isInstancedInterleavedBuffer ? (S.enableAttributeAndDivisor(s,
													m.meshPerAttribute), void 0 === i.maxInstancedCount && (i
													.maxInstancedCount = m.meshPerAttribute * m.count)) : S
												.enableAttribute(s), M.bindBuffer(34962, p), M
												.vertexAttribPointer(s, l, d, h, g * f, v * f)
										} else c.isInstancedBufferAttribute ? (S.enableAttributeAndDivisor(s, c
												.meshPerAttribute), void 0 === i.maxInstancedCount && (i
												.maxInstancedCount = c.meshPerAttribute * c.count)) : S
											.enableAttribute(s), M.bindBuffer(34962, p), M.vertexAttribPointer(s,
												l, d, h, 0, 0)
									} else if (void 0 !== a) {
										var y = a[o];
										if (void 0 !== y) switch (y.length) {
											case 2:
												M.vertexAttrib2fv(s, y);
												break;
											case 3:
												M.vertexAttrib3fv(s, y);
												break;
											case 4:
												M.vertexAttrib4fv(s, y);
												break;
											default:
												M.vertexAttrib1fv(s, y)
										}
									}
								}
							}
							S.disableUnusedAttributes()
						}
					}
					this.shadowMap = at, this.getContext = function () {
						return M
					}, this.getContextAttributes = function () {
						return M.getContextAttributes()
					}, this.forceContextLoss = function () {
						var t = x.get("WEBGL_lose_context");
						t && t.loseContext()
					}, this.forceContextRestore = function () {
						var t = x.get("WEBGL_lose_context");
						t && t.restoreContext()
					}, this.getPixelRatio = function () {
						return W
					}, this.setPixelRatio = function (t) {
						void 0 !== t && (W = t, this.setSize(k, V, !1))
					}, this.getSize = function (t) {
						return void 0 === t && (console.warn(
								"WebGLRenderer: .getsize() now requires a Vector2 as an argument"), t =
							new si), t.set(k, V)
					}, this.setSize = function (t, e, i) {
						rt.isPresenting() ? console.warn(
							"THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (
							k = t, V = e, n.width = t * W, n.height = e * W, !1 !== i && (n.style.width =
								t + "px", n.style.height = e + "px"), this.setViewport(0, 0, t, e))
					}, this.getDrawingBufferSize = function (t) {
						return void 0 === t && (console.warn(
							"WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument"
							), t = new si), t.set(k * W, V * W)
					}, this.setDrawingBufferSize = function (t, e, i) {
						k = t, V = e, W = i, n.width = t * i, n.height = e * i, this.setViewport(0, 0, t, e)
					}, this.getCurrentViewport = function (t) {
						return void 0 === t && (console.warn(
							"WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument"
							), t = new Ci), t.copy(U)
					}, this.getViewport = function (t) {
						return t.copy(q)
					}, this.setViewport = function (t, e, i, n) {
						t.isVector4 ? q.set(t.x, t.y, t.z, t.w) : q.set(t, e, i, n), S.viewport(U.copy(q)
							.multiplyScalar(W))
					}, this.getScissor = function (t) {
						return t.copy(X)
					}, this.setScissor = function (t, e, i, n) {
						t.isVector4 ? X.set(t.x, t.y, t.z, t.w) : X.set(t, e, i, n), S.scissor(F.copy(X)
							.multiplyScalar(W))
					}, this.getScissorTest = function () {
						return Y
					}, this.setScissorTest = function (t) {
						S.setScissorTest(Y = t)
					}, this.getClearColor = function () {
						return g.getClearColor()
					}, this.setClearColor = function () {
						g.setClearColor.apply(g, arguments)
					}, this.getClearAlpha = function () {
						return g.getClearAlpha()
					}, this.setClearAlpha = function () {
						g.setClearAlpha.apply(g, arguments)
					}, this.clear = function (t, e, i) {
						var n = 0;
						(void 0 === t || t) && (n |= 16384), (void 0 === e || e) && (n |= 256), (void 0 ===
							i || i) && (n |= 1024), M.clear(n)
					}, this.clearColor = function () {
						this.clear(!0, !1, !1)
					}, this.clearDepth = function () {
						this.clear(!1, !0, !1)
					}, this.clearStencil = function () {
						this.clear(!1, !1, !0)
					}, this.dispose = function () {
						n.removeEventListener("webglcontextlost", ot, !1), n.removeEventListener(
								"webglcontextrestored", st, !1), f.dispose(), m.dispose(), E.dispose(), d
							.dispose(), rt.dispose(), yt.stop()
					}, this.renderBufferImmediate = function (t, e) {
						S.initAttributes();
						var i = E.get(t);
						t.hasPositions && !i.position && (i.position = M.createBuffer()), t.hasNormals && !i
							.normal && (i.normal = M.createBuffer()), t.hasUvs && !i.uv && (i.uv = M
								.createBuffer()), t.hasColors && !i.color && (i.color = M.createBuffer());
						var n = e.getAttributes();
						t.hasPositions && (M.bindBuffer(34962, i.position), M.bufferData(34962, t
								.positionArray, 35048), S.enableAttribute(n.position), M
							.vertexAttribPointer(n.position, 3, 5126, !1, 0, 0)), t.hasNormals && (M
							.bindBuffer(34962, i.normal), M.bufferData(34962, t.normalArray, 35048), S
							.enableAttribute(n.normal), M.vertexAttribPointer(n.normal, 3, 5126, !1, 0, 0)
							), t.hasUvs && (M.bindBuffer(34962, i.uv), M.bufferData(34962, t.uvArray,
							35048), S.enableAttribute(n.uv), M.vertexAttribPointer(n.uv, 2, 5126, !1,
							0, 0)), t.hasColors && (M.bindBuffer(34962, i.color), M.bufferData(34962, t
							.colorArray, 35048), S.enableAttribute(n.color), M.vertexAttribPointer(n
							.color, 3, 5126, !1, 0, 0)), S.disableUnusedAttributes(), M.drawArrays(4, 0, t
							.count), t.count = 0
					}, this.renderBufferDirect = function (t, e, i, n, r, a) {
						var o = r.isMesh && r.normalMatrix.determinant() < 0;
						S.setMaterial(n, o);
						var s = Mt(t, e, n, r),
							c = !1;
						z.geometry === i.id && z.program === s.id && z.wireframe === (!0 === n.wireframe) || (
								z.geometry = i.id, z.program = s.id, z.wireframe = !0 === n.wireframe, c = !0
								), r.morphTargetInfluences && (L.update(r, i, n, s), c = !0);
						var h, l = i.index,
							u = i.attributes.position,
							p = 1;
						!0 === n.wireframe && (l = A.getWireframeAttribute(i), p = 2);
						var d = P;
						null !== l && (h = T.get(l), (d = R).setIndex(h)), c && (pt(n, s, i), null !== l && M
							.bindBuffer(34963, h.buffer));
						var f = 1 / 0;
						null !== l ? f = l.count : void 0 !== u && (f = u.count);
						var m = i.drawRange.start * p,
							g = i.drawRange.count * p,
							v = null !== a ? a.start * p : 0,
							y = null !== a ? a.count * p : 1 / 0,
							x = Math.max(m, v),
							b = Math.min(f, m + g, v + y) - 1,
							_ = Math.max(0, b - x + 1);
						if (0 !== _) {
							if (r.isMesh)
								if (!0 === n.wireframe) S.setLineWidth(n.wireframeLinewidth * et()), d
									.setMode(1);
								else switch (r.drawMode) {
									case We:
										d.setMode(4);
										break;
									case qe:
										d.setMode(5);
										break;
									case Xe:
										d.setMode(6)
								} else if (r.isLine) {
									var w = n.linewidth;
									void 0 === w && (w = 1), S.setLineWidth(w * et()), r.isLineSegments ?
										d.setMode(1) : r.isLineLoop ? d.setMode(2) : d.setMode(3)
								} else r.isPoints ? d.setMode(0) : r.isSprite && d.setMode(4);
							i && i.isInstancedBufferGeometry ? 0 < i.maxInstancedCount && d.renderInstances(i,
								x, _) : d.render(x, _)
						}
					}, this.compile = function (i, t) {
						(_ = m.get(i, t)).init(), i.traverse(function (t) {
							t.isLight && (_.pushLight(t), t.castShadow && _.pushShadow(t))
						}), _.setupLights(t), i.traverse(function (t) {
							if (t.material)
								if (Array.isArray(t.material))
									for (var e = 0; e < t.material.length; e++) wt(t.material[e], i
										.fog, t);
								else wt(t.material, i.fog, t)
						})
					};
					var dt = null;

					function ft(t) {
						rt.isPresenting() || dt && dt(t)
					}
					var mt, gt, vt, yt = new $i;

					function xt(t, e, i, n) {
						if (!1 !== t.visible) {
							if (t.layers.test(e.layers))
								if (t.isGroup) i = t.renderOrder;
								else if (t.isLight) _.pushLight(t), t.castShadow && _.pushShadow(t);
							else if (t.isSprite) {
								if (!t.frustumCulled || Z.intersectsSprite(t)) {
									n && tt.setFromMatrixPosition(t.matrixWorld).applyMatrix4($);
									var r = d.update(t),
										a = t.material;
									p.push(t, r, a, i, tt.z, null)
								}
							} else if (t.isImmediateRenderObject) n && tt.setFromMatrixPosition(t.matrixWorld)
								.applyMatrix4($), p.push(t, null, t.material, i, tt.z, null);
							else if ((t.isMesh || t.isLine || t.isPoints) && (t.isSkinnedMesh && t.skeleton
									.update(), !t.frustumCulled || Z.intersectsObject(t))) {
								n && tt.setFromMatrixPosition(t.matrixWorld).applyMatrix4($);
								r = d.update(t), a = t.material;
								if (Array.isArray(a))
									for (var o = r.groups, s = 0, c = o.length; s < c; s++) {
										var h = o[s],
											l = a[h.materialIndex];
										l && l.visible && p.push(t, r, l, i, tt.z, h)
									} else a.visible && p.push(t, r, a, i, tt.z, null)
							}
							var u = t.children;
							for (s = 0, c = u.length; s < c; s++) xt(u[s], e, i, n)
						}
					}

					function bt(t, e, i, n) {
						for (var r = 0, a = t.length; r < a; r++) {
							var o = t[r],
								s = o.object,
								c = o.geometry,
								h = void 0 === n ? o.material : n,
								l = o.group;
							if (i.isArrayCamera)
								for (var u = (G = i).cameras, p = 0, d = u.length; p < d; p++) {
									var f = u[p];
									if (s.layers.test(f.layers)) {
										if ("viewport" in f) S.viewport(U.copy(f.viewport));
										else {
											var m = f.bounds,
												g = m.x * k,
												v = m.y * V,
												y = m.z * k,
												x = m.w * V;
											S.viewport(U.set(g, v, y, x).multiplyScalar(W))
										}
										_.setupLights(f), _t(s, e, f, c, h, l)
									}
								} else G = null, _t(s, e, i, c, h, l)
						}
					}

					function _t(t, e, i, n, r, a) {
						if (t.onBeforeRender(C, e, i, n, r, a), _ = m.get(e, G || i), t.modelViewMatrix
							.multiplyMatrices(i.matrixWorldInverse, t.matrixWorld), t.normalMatrix
							.getNormalMatrix(t.modelViewMatrix), t.isImmediateRenderObject) {
							S.setMaterial(r);
							var o = Mt(i, e.fog, r, t);
							z.geometry = null, z.program = null, z.wireframe = !1, ut(t, o)
						} else C.renderBufferDirect(i, e.fog, n, r, t, a);
						t.onAfterRender(C, e, i, n, r, a), _ = m.get(e, G || i)
					}

					function wt(t, e, i) {
						var n = E.get(t),
							r = _.state.lights,
							a = _.state.shadowsArray,
							o = n.lightsHash,
							s = r.state.hash,
							c = y.getParameters(t, r.state, a, e, J.numPlanes, J.numIntersection, i),
							h = y.getProgramCode(t, c),
							l = n.program,
							u = !0;
						if (void 0 === l) t.addEventListener("dispose", ct);
						else if (l.code !== h) lt(t);
						else if (o.stateID !== s.stateID || o.directionalLength !== s.directionalLength || o
							.pointLength !== s.pointLength || o.spotLength !== s.spotLength || o
							.rectAreaLength !== s.rectAreaLength || o.hemiLength !== s.hemiLength || o
							.shadowsLength !== s.shadowsLength) o.stateID = s.stateID, o.directionalLength = s
							.directionalLength, o.pointLength = s.pointLength, o.spotLength = s.spotLength, o
							.rectAreaLength = s.rectAreaLength, o.hemiLength = s.hemiLength, o.shadowsLength = s
							.shadowsLength, u = !1;
						else {
							if (void 0 !== c.shaderID) return;
							u = !1
						}
						if (u) {
							if (c.shaderID) {
								var p = Ki[c.shaderID];
								n.shader = {
									name: t.type,
									uniforms: Hi(p.uniforms),
									vertexShader: p.vertexShader,
									fragmentShader: p.fragmentShader
								}
							} else n.shader = {
								name: t.type,
								uniforms: t.uniforms,
								vertexShader: t.vertexShader,
								fragmentShader: t.fragmentShader
							};
							t.onBeforeCompile(n.shader, C), h = y.getProgramCode(t, c), l = y.acquireProgram(t, n
								.shader, c, h), n.program = l, t.program = l
						}
						var d = l.getAttributes();
						if (t.morphTargets)
							for (var f = t.numSupportedMorphTargets = 0; f < C.maxMorphTargets; f++) 0 <= d[
								"morphTarget" + f] && t.numSupportedMorphTargets++;
						if (t.morphNormals)
							for (f = t.numSupportedMorphNormals = 0; f < C.maxMorphNormals; f++) 0 <= d[
								"morphNormal" + f] && t.numSupportedMorphNormals++;
						var m = n.shader.uniforms;
						(t.isShaderMaterial || t.isRawShaderMaterial) && !0 !== t.clipping || (n
								.numClippingPlanes = J.numPlanes, n.numIntersection = J.numIntersection, m
								.clippingPlanes = J.uniform), n.fog = e, void 0 === o && (n.lightsHash = o = {}),
							o.stateID = s.stateID, o.directionalLength = s.directionalLength, o.pointLength = s
							.pointLength, o.spotLength = s.spotLength, o.rectAreaLength = s.rectAreaLength, o
							.hemiLength = s.hemiLength, o.shadowsLength = s.shadowsLength, t.lights && (m
								.ambientLightColor.value = r.state.ambient, m.directionalLights.value = r.state
								.directional, m.spotLights.value = r.state.spot, m.rectAreaLights.value = r.state
								.rectArea, m.pointLights.value = r.state.point, m.hemisphereLights.value = r.state
								.hemi, m.directionalShadowMap.value = r.state.directionalShadowMap, m
								.directionalShadowMatrix.value = r.state.directionalShadowMatrix, m.spotShadowMap
								.value = r.state.spotShadowMap, m.spotShadowMatrix.value = r.state
								.spotShadowMatrix, m.pointShadowMap.value = r.state.pointShadowMap, m
								.pointShadowMatrix.value = r.state.pointShadowMatrix);
						var g = n.program.getUniforms(),
							v = qa.seqWithValue(g.seq, m);
						n.uniformsList = v
					}

					function Mt(t, e, i, n) {
						j = 0;
						var r = E.get(i),
							a = _.state.lights,
							o = r.lightsHash,
							s = a.state.hash;
						if (Q && (K || t !== N)) {
							var c = t === N && i.id === B;
							J.setState(i.clippingPlanes, i.clipIntersection, i.clipShadows, t, r, c)
						}!1 === i.needsUpdate && (void 0 === r.program ? i.needsUpdate = !0 : i.fog && r.fog !==
							e ? i.needsUpdate = !0 : (!i.lights || o.stateID === s.stateID && o
								.directionalLength === s.directionalLength && o.pointLength === s
								.pointLength && o.spotLength === s.spotLength && o.rectAreaLength === s
								.rectAreaLength && o.hemiLength === s.hemiLength && o.shadowsLength === s
								.shadowsLength) && (void 0 === r.numClippingPlanes || r.numClippingPlanes ===
								J.numPlanes && r.numIntersection === J.numIntersection) || (i.needsUpdate = !
								0)), i.needsUpdate && (wt(i, e, n), i.needsUpdate = !1);
						var h = !1,
							l = !1,
							u = !1,
							p = r.program,
							d = p.getUniforms(),
							f = r.shader.uniforms;
						if (S.useProgram(p.program) && (u = l = h = !0), i.id !== B && (B = i.id, l = !0), h ||
							N !== t) {
							if (d.setValue(M, "projectionMatrix", t.projectionMatrix), w.logarithmicDepthBuffer &&
								d.setValue(M, "logDepthBufFC", 2 / (Math.log(t.far + 1) / Math.LN2)), N !== t && (
									N = t, u = l = !0), i.isShaderMaterial || i.isMeshPhongMaterial || i
								.isMeshStandardMaterial || i.envMap) {
								var m = d.map.cameraPosition;
								void 0 !== m && m.setValue(M, tt.setFromMatrixPosition(t.matrixWorld))
							}(i.isMeshPhongMaterial || i.isMeshLambertMaterial || i.isMeshBasicMaterial || i
								.isMeshStandardMaterial || i.isShaderMaterial || i.skinning) && d.setValue(M,
								"viewMatrix", t.matrixWorldInverse)
						}
						if (i.skinning) {
							d.setOptional(M, n, "bindMatrix"), d.setOptional(M, n, "bindMatrixInverse");
							var g = n.skeleton;
							if (g) {
								var v = g.bones;
								if (w.floatVertexTextures) {
									if (void 0 === g.boneTexture) {
										var y = Math.sqrt(4 * v.length);
										y = oi.ceilPowerOfTwo(y), y = Math.max(y, 4);
										var x = new Float32Array(y * y * 4);
										x.set(g.boneMatrices);
										var b = new Bi(x, y, y, oe, Kt);
										b.needsUpdate = !0, g.boneMatrices = x, g.boneTexture = b, g
											.boneTextureSize = y
									}
									d.setValue(M, "boneTexture", g.boneTexture), d.setValue(M, "boneTextureSize",
										g.boneTextureSize)
								} else d.setOptional(M, g, "boneMatrices")
							}
						}
						return l && (d.setValue(M, "toneMappingExposure", C.toneMappingExposure), d.setValue(M,
									"toneMappingWhitePoint", C.toneMappingWhitePoint), i.lights && Ut(f, u), e &&
								i.fog && Pt(f, e), i.isMeshBasicMaterial ? St(f, i) : i.isMeshLambertMaterial ? (
									St(f, i), Rt(f, i)) : i.isMeshPhongMaterial ? (St(f, i), i
									.isMeshToonMaterial ? Ot(f, i) : Ct(f, i)) : i.isMeshStandardMaterial ? (St(f,
									i), i.isMeshPhysicalMaterial ? Dt(f, i) : It(f, i)) : i.isMeshMatcapMaterial ?
								(St(f, i), Bt(f, i)) : i.isMeshDepthMaterial ? (St(f, i), zt(f, i)) : i
								.isMeshDistanceMaterial ? (St(f, i), Nt(f, i)) : i.isMeshNormalMaterial ? (St(f,
									i), Gt(f, i)) : i.isLineBasicMaterial ? (Et(f, i), i.isLineDashedMaterial &&
									Tt(f, i)) : i.isPointsMaterial ? At(f, i) : i.isSpriteMaterial ? Lt(f, i) : i
								.isShadowMaterial && (f.color.value = i.color, f.opacity.value = i.opacity),
								void 0 !== f.ltc_1 && (f.ltc_1.value = Qi.LTC_1), void 0 !== f.ltc_2 && (f.ltc_2
									.value = Qi.LTC_2), qa.upload(M, r.uniformsList, f, C)), i.isShaderMaterial &&
							!0 === i.uniformsNeedUpdate && (qa.upload(M, r.uniformsList, f, C), i
								.uniformsNeedUpdate = !1), i.isSpriteMaterial && d.setValue(M, "center", n
							.center), d.setValue(M, "modelViewMatrix", n.modelViewMatrix), d.setValue(M,
								"normalMatrix", n.normalMatrix), d.setValue(M, "modelMatrix", n.matrixWorld), p
					}

					function St(t, e) {
						var i;
						t.opacity.value = e.opacity, e.color && (t.diffuse.value = e.color), e.emissive && t
							.emissive.value.copy(e.emissive).multiplyScalar(e.emissiveIntensity), e.map && (t.map
								.value = e.map), e.alphaMap && (t.alphaMap.value = e.alphaMap), e.specularMap && (
								t.specularMap.value = e.specularMap), e.envMap && (t.envMap.value = e.envMap, t
								.flipEnvMap.value = e.envMap.isCubeTexture ? -1 : 1, t.reflectivity.value = e
								.reflectivity, t.refractionRatio.value = e.refractionRatio, t.maxMipLevel.value =
								E.get(e.envMap).__maxMipLevel), e.lightMap && (t.lightMap.value = e.lightMap, t
								.lightMapIntensity.value = e.lightMapIntensity), e.aoMap && (t.aoMap.value = e
								.aoMap, t.aoMapIntensity.value = e.aoMapIntensity), e.map ? i = e.map : e
							.specularMap ? i = e.specularMap : e.displacementMap ? i = e.displacementMap : e
							.normalMap ? i = e.normalMap : e.bumpMap ? i = e.bumpMap : e.roughnessMap ? i = e
							.roughnessMap : e.metalnessMap ? i = e.metalnessMap : e.alphaMap ? i = e.alphaMap : e
							.emissiveMap && (i = e.emissiveMap), void 0 !== i && (i.isWebGLRenderTarget && (i = i
									.texture), !0 === i.matrixAutoUpdate && i.updateMatrix(), t.uvTransform.value
								.copy(i.matrix))
					}

					function Et(t, e) {
						t.diffuse.value = e.color, t.opacity.value = e.opacity
					}

					function Tt(t, e) {
						t.dashSize.value = e.dashSize, t.totalSize.value = e.dashSize + e.gapSize, t.scale.value =
							e.scale
					}

					function At(t, e) {
						t.diffuse.value = e.color, t.opacity.value = e.opacity, t.size.value = e.size * W, t.scale
							.value = .5 * V, t.map.value = e.map, null !== e.map && (!0 === e.map
								.matrixAutoUpdate && e.map.updateMatrix(), t.uvTransform.value.copy(e.map.matrix))
					}

					function Lt(t, e) {
						t.diffuse.value = e.color, t.opacity.value = e.opacity, t.rotation.value = e.rotation, t
							.map.value = e.map, null !== e.map && (!0 === e.map.matrixAutoUpdate && e.map
								.updateMatrix(), t.uvTransform.value.copy(e.map.matrix))
					}

					function Pt(t, e) {
						t.fogColor.value = e.color, e.isFog ? (t.fogNear.value = e.near, t.fogFar.value = e.far) :
							e.isFogExp2 && (t.fogDensity.value = e.density)
					}

					function Rt(t, e) {
						e.emissiveMap && (t.emissiveMap.value = e.emissiveMap)
					}

					function Ct(t, e) {
						t.specular.value = e.specular, t.shininess.value = Math.max(e.shininess, 1e-4), e
							.emissiveMap && (t.emissiveMap.value = e.emissiveMap), e.bumpMap && (t.bumpMap.value =
								e.bumpMap, t.bumpScale.value = e.bumpScale, e.side === jt && (t.bumpScale.value *=
									-1)), e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value
								.copy(e.normalScale), e.side === jt && t.normalScale.value.negate()), e
							.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale
								.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
					}

					function Ot(t, e) {
						Ct(t, e), e.gradientMap && (t.gradientMap.value = e.gradientMap)
					}

					function It(t, e) {
						t.roughness.value = e.roughness, t.metalness.value = e.metalness, e.roughnessMap && (t
								.roughnessMap.value = e.roughnessMap), e.metalnessMap && (t.metalnessMap.value = e
								.metalnessMap), e.emissiveMap && (t.emissiveMap.value = e.emissiveMap), e
							.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, e.side ===
								jt && (t.bumpScale.value *= -1)), e.normalMap && (t.normalMap.value = e.normalMap,
								t.normalScale.value.copy(e.normalScale), e.side === jt && t.normalScale.value
								.negate()), e.displacementMap && (t.displacementMap.value = e.displacementMap, t
								.displacementScale.value = e.displacementScale, t.displacementBias.value = e
								.displacementBias), e.envMap && (t.envMapIntensity.value = e.envMapIntensity)
					}

					function Dt(t, e) {
						It(t, e), t.reflectivity.value = e.reflectivity, t.clearCoat.value = e.clearCoat, t
							.clearCoatRoughness.value = e.clearCoatRoughness
					}

					function Bt(t, e) {
						e.matcap && (t.matcap.value = e.matcap), e.bumpMap && (t.bumpMap.value = e.bumpMap, t
								.bumpScale.value = e.bumpScale, e.side === jt && (t.bumpScale.value *= -1)), e
							.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e
								.normalScale), e.side === jt && t.normalScale.value.negate()), e
							.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale
								.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
					}

					function zt(t, e) {
						e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale
							.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
					}

					function Nt(t, e) {
						e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale
								.value = e.displacementScale, t.displacementBias.value = e.displacementBias), t
							.referencePosition.value.copy(e.referencePosition), t.nearDistance.value = e
							.nearDistance, t.farDistance.value = e.farDistance
					}

					function Gt(t, e) {
						e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, e.side ===
							jt && (t.bumpScale.value *= -1)), e.normalMap && (t.normalMap.value = e.normalMap,
							t.normalScale.value.copy(e.normalScale), e.side === jt && t.normalScale.value
							.negate()), e.displacementMap && (t.displacementMap.value = e.displacementMap, t
							.displacementScale.value = e.displacementScale, t.displacementBias.value = e
							.displacementBias)
					}

					function Ut(t, e) {
						t.ambientLightColor.needsUpdate = e, t.directionalLights.needsUpdate = e, t.pointLights
							.needsUpdate = e, t.spotLights.needsUpdate = e, t.rectAreaLights.needsUpdate = e, t
							.hemisphereLights.needsUpdate = e
					}

					function Ft() {
						var t = j;
						return t >= w.maxTextures && console.warn("THREE.WebGLRenderer: Trying to use " + t +
							" texture units while this GPU supports only " + w.maxTextures), j += 1, t
					}
					yt.setAnimationLoop(ft), "undefined" != typeof window && yt.setContext(window), this
						.setAnimationLoop = function (t) {
							dt = t, rt.setAnimationLoop(t), yt.start()
						}, this.render = function (t, e) {
							var i, n;
							if (void 0 !== arguments[2] && (console.warn(
									"THREE.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead."
									), i = arguments[2]), void 0 !== arguments[3] && (console.warn(
									"THREE.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead."
									), n = arguments[3]), e && e.isCamera) {
								if (!b) {
									z.geometry = null, z.program = null, z.wireframe = !1, B = -1, !(N = null) ===
										t.autoUpdate && t.updateMatrixWorld(), null === e.parent && e
										.updateMatrixWorld(), rt.enabled && (e = rt.getCamera(e)), (_ = m.get(t,
											e)).init(), t.onBeforeRender(C, t, e, i || I), $.multiplyMatrices(e
											.projectionMatrix, e.matrixWorldInverse), Z.setFromMatrix($), K = this
										.localClippingEnabled, Q = J.init(this.clippingPlanes, K, e), (p = f.get(
											t, e)).init(), xt(t, e, 0, C.sortObjects), !0 === C.sortObjects && p
										.sort(), Q && J.beginShadows();
									var r = _.state.shadowsArray;
									at.render(r, t, e), _.setupLights(e), Q && J.endShadows(), this.info
										.autoReset && this.info.reset(), void 0 !== i && this.setRenderTarget(i),
										g.render(p, t, e, n);
									var a = p.opaque,
										o = p.transparent;
									if (t.overrideMaterial) {
										var s = t.overrideMaterial;
										a.length && bt(a, t, e, s), o.length && bt(o, t, e, s)
									} else a.length && bt(a, t, e), o.length && bt(o, t, e);
									null !== I && (u.updateRenderTargetMipmap(I), u.updateMultisampleRenderTarget(
											I)), S.buffers.depth.setTest(!0), S.buffers.depth.setMask(!0), S
										.buffers.color.setMask(!0), S.setPolygonOffset(!1), t.onAfterRender(C, t,
											e), rt.enabled && rt.submitFrame(), _ = p = null
								}
							} else console.error(
								"THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.")
						}, this.allocTextureUnit = Ft, this.setTexture2D = (mt = !1, function (t, e) {
							t && t.isWebGLRenderTarget && (mt || (console.warn(
								"THREE.WebGLRenderer.setTexture2D: don't use render targets as textures. Use their .texture property instead."
								), mt = !0), t = t.texture), u.setTexture2D(t, e)
						}), this.setTexture3D = function (t, e) {
							u.setTexture3D(t, e)
						}, this.setTexture = (gt = !1, function (t, e) {
							gt || (console.warn(
								"THREE.WebGLRenderer: .setTexture is deprecated, use setTexture2D instead."
								), gt = !0), u.setTexture2D(t, e)
						}), this.setTextureCube = (vt = !1, function (t, e) {
							t && t.isWebGLRenderTargetCube && (vt || (console.warn(
									"THREE.WebGLRenderer.setTextureCube: don't use cube render targets as textures. Use their .texture property instead."
									), vt = !0), t = t.texture), t && t.isCubeTexture || Array.isArray(t
									.image) && 6 === t.image.length ? u.setTextureCube(t, e) : u
								.setTextureCubeDynamic(t, e)
						}), this.setFramebuffer = function (t) {
							O = t
						}, this.getRenderTarget = function () {
							return I
						}, this.setRenderTarget = function (t, e, i) {
							(I = t) && void 0 === E.get(t).__webglFramebuffer && u.setupRenderTarget(t);
							var n = O,
								r = !1;
							if (t) {
								var a = E.get(t).__webglFramebuffer;
								t.isWebGLRenderTargetCube ? (n = a[e || 0], r = !0) : n = t
									.isWebGLMultisampleRenderTarget ? E.get(t).__webglMultisampledFramebuffer : a,
									U.copy(t.viewport), F.copy(t.scissor), H = t.scissorTest
							} else U.copy(q).multiplyScalar(W), F.copy(X).multiplyScalar(W), H = Y;
							if (D !== n && (M.bindFramebuffer(36160, n), D = n), S.viewport(U), S.scissor(F), S
								.setScissorTest(H), r) {
								var o = E.get(t.texture);
								M.framebufferTexture2D(36160, 36064, 34069 + e || 0, o.__webglTexture, i || 0)
							}
						}, this.readRenderTargetPixels = function (t, e, i, n, r, a) {
							if (t && t.isWebGLRenderTarget) {
								var o = E.get(t).__webglFramebuffer;
								if (o) {
									var s = !1;
									o !== D && (M.bindFramebuffer(36160, o), s = !0);
									try {
										var c = t.texture,
											h = c.format,
											l = c.type;
										if (h !== oe && v.convert(h) !== M.getParameter(35739))
										return void console.error(
												"THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format."
												);
										if (!(l === qt || v.convert(l) === M.getParameter(35738) || l === Kt && (w
												.isWebGL2 || x.get("OES_texture_float") || x.get(
													"WEBGL_color_buffer_float")) || l === $t && (w.isWebGL2 ?
												x.get("EXT_color_buffer_float") : x.get(
													"EXT_color_buffer_half_float")))) return void console.error(
											"THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type."
											);
										36053 === M.checkFramebufferStatus(36160) ? 0 <= e && e <= t.width - n &&
											0 <= i && i <= t.height - r && M.readPixels(e, i, n, r, v.convert(h),
												v.convert(l), a) : console.error(
												"THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete."
												)
									} finally {
										s && M.bindFramebuffer(36160, D)
									}
								}
							} else console.error(
								"THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget."
								)
						}, this.copyFramebufferToTexture = function (t, e, i) {
							var n = e.image.width,
								r = e.image.height,
								a = v.convert(e.format);
							this.setTexture2D(e, 0), M.copyTexImage2D(3553, i || 0, a, t.x, t.y, n, r, 0)
						}, this.copyTextureToTexture = function (t, e, i, n) {
							var r = e.image.width,
								a = e.image.height,
								o = v.convert(i.format),
								s = v.convert(i.type);
							this.setTexture2D(i, 0), e.isDataTexture ? M.texSubImage2D(3553, n || 0, t.x, t.y, r,
								a, o, s, e.image.data) : M.texSubImage2D(3553, n || 0, t.x, t.y, o, s, e
								.image)
						}
				}

				function $o(t, e) {
					this.name = "", this.color = new Yi(t), this.density = void 0 !== e ? e : 25e-5
				}

				function ts(t, e, i) {
					this.name = "", this.color = new Yi(t), this.near = void 0 !== e ? e : 1, this.far =
						void 0 !== i ? i : 1e3
				}

				function es() {
					Sn.call(this), this.type = "Scene", this.background = null, this.fog = null, this
						.overrideMaterial = null, this.autoUpdate = !0
				}

				function is(t, e) {
					this.array = t, this.stride = e, this.count = void 0 !== t ? t.length / e : 0, this
						.dynamic = !1, this.updateRange = {
							offset: 0,
							count: -1
						}, this.version = 0
				}

				function ns(t, e, i, n) {
					this.data = t, this.itemSize = e, this.offset = i, this.normalized = !0 === n
				}

				function rs(t) {
					hr.call(this), this.type = "SpriteMaterial", this.color = new Yi(16777215), this.map = null,
						this.rotation = 0, this.sizeAttenuation = !0, this.lights = !1, this.transparent = !0,
						this.setValues(t)
				}

				function as(t) {
					if (Sn.call(this), this.type = "Sprite", void 0 === Co) {
						Co = new nr;
						var e = new is(new Float32Array([-.5, -.5, 0, 0, 0, .5, -.5, 0, 1, 0, .5, .5, 0, 1, 1, -
							.5, .5, 0, 0, 1
						]), 5);
						Co.setIndex([0, 1, 2, 0, 2, 3]), Co.addAttribute("position", new ns(e, 3, 0, !1)), Co
							.addAttribute("uv", new ns(e, 2, 3, !1))
					}
					this.geometry = Co, this.material = void 0 !== t ? t : new rs, this.center = new si(.5, .5)
				}

				function os() {
					Sn.call(this), this.type = "LOD", Object.defineProperties(this, {
						levels: {
							enumerable: !0,
							value: []
						}
					})
				}

				function ss(t, e) {
					t && t.isGeometry && console.error(
							"THREE.SkinnedMesh no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
							), Hr.call(this, t, e), this.type = "SkinnedMesh", this.bindMode = "attached", this
						.bindMatrix = new ci, this.bindMatrixInverse = new ci
				}

				function cs(t, e) {
					if (t = t || [], this.bones = t.slice(0), this.boneMatrices = new Float32Array(16 * this.bones
							.length), void 0 === e) this.calculateInverses();
					else if (this.bones.length === e.length) this.boneInverses = e.slice(0);
					else {
						console.warn("THREE.Skeleton boneInverses is the wrong length."), this.boneInverses = [];
						for (var i = 0, n = this.bones.length; i < n; i++) this.boneInverses.push(new ci)
					}
				}

				function hs() {
					Sn.call(this), this.type = "Bone"
				}

				function ls(t) {
					hr.call(this), this.type = "LineBasicMaterial", this.color = new Yi(16777215), this
						.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.lights = !1, this
						.setValues(t)
				}

				function us(t, e, i) {
					1 === i && console.error(
							"THREE.Line: parameter THREE.LinePieces no longer supported. Use THREE.LineSegments instead."
							), Sn.call(this), this.type = "Line", this.geometry = void 0 !== t ? t : new nr, this
						.material = void 0 !== e ? e : new ls({
							color: 16777215 * Math.random()
						})
				}

				function ps(t, e) {
					us.call(this, t, e), this.type = "LineSegments"
				}

				function ds(t, e) {
					us.call(this, t, e), this.type = "LineLoop"
				}

				function fs(t) {
					hr.call(this), this.type = "PointsMaterial", this.color = new Yi(16777215), this.map = null,
						this.size = 1, this.sizeAttenuation = !0, this.morphTargets = !1, this.lights = !1, this
						.setValues(t)
				}

				function ms(t, e) {
					Sn.call(this), this.type = "Points", this.geometry = void 0 !== t ? t : new nr, this
						.material = void 0 !== e ? e : new fs({
							color: 16777215 * Math.random()
						})
				}

				function gs(t, e, i, n, r, a, o, s, c) {
					Ri.call(this, t, e, i, n, r, a, o, s, c), this.format = void 0 !== o ? o : ae, this
						.minFilter = void 0 !== a ? a : Ft, this.magFilter = void 0 !== r ? r : Ft, this
						.generateMipmaps = !1
				}

				function vs(t, e, i, n, r, a, o, s, c, h, l, u) {
					Ri.call(this, null, a, o, s, c, h, n, r, l, u), this.image = {
						width: e,
						height: i
					}, this.mipmaps = t, this.flipY = !1, this.generateMipmaps = !1
				}

				function ys(t, e, i, n, r, a, o, s, c) {
					Ri.call(this, t, e, i, n, r, a, o, s, c), this.needsUpdate = !0
				}

				function xs(t, e, i, n, r, a, o, s, c, h) {
					if ((h = void 0 !== h ? h : le) !== le && h !== ue) throw new Error(
						"DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat"
						);
					void 0 === i && h === le && (i = Zt), void 0 === i && h === ue && (i = ne), Ri.call(this,
							null, n, r, a, o, s, h, i, c), this.image = {
							width: t,
							height: e
						}, this.magFilter = void 0 !== o ? o : Nt, this.minFilter = void 0 !== s ? s : Nt, this
						.flipY = !1, this.generateMipmaps = !1
				}

				function bs(t) {
					nr.call(this), this.type = "WireframeGeometry";
					var e, i, n, r, a, o, s, c, h, l, u = [],
						p = [0, 0],
						d = {},
						f = ["a", "b", "c"];
					if (t && t.isGeometry) {
						var m = t.faces;
						for (e = 0, n = m.length; e < n; e++) {
							var g = m[e];
							for (i = 0; i < 3; i++) s = g[f[i]], c = g[f[(i + 1) % 3]], p[0] = Math.min(s, c), p[
								1] = Math.max(s, c), void 0 === d[h = p[0] + "," + p[1]] && (d[h] = {
								index1: p[0],
								index2: p[1]
							})
						}
						for (h in d) o = d[h], l = t.vertices[o.index1], u.push(l.x, l.y, l.z), l = t.vertices[o
							.index2], u.push(l.x, l.y, l.z)
					} else if (t && t.isBufferGeometry) {
						var v, y, x, b, _, w;
						if (l = new li, null !== t.index) {
							for (v = t.attributes.position, y = t.index, 0 === (x = t.groups).length && (x = [{
									start: 0,
									count: y.count,
									materialIndex: 0
								}]), r = 0, a = x.length; r < a; ++r)
								for (n = (e = (b = x[r]).start) + b.count; e < n; e += 3)
									for (i = 0; i < 3; i++) s = y.getX(e + i), c = y.getX(e + (i + 1) % 3), p[0] =
										Math.min(s, c), p[1] = Math.max(s, c), void 0 === d[h = p[0] + "," + p[
										1]] && (d[h] = {
											index1: p[0],
											index2: p[1]
										});
							for (h in d) o = d[h], l.fromBufferAttribute(v, o.index1), u.push(l.x, l.y, l.z), l
								.fromBufferAttribute(v, o.index2), u.push(l.x, l.y, l.z)
						} else
							for (e = 0, n = (v = t.attributes.position).count / 3; e < n; e++)
								for (i = 0; i < 3; i++) _ = 3 * e + i, l.fromBufferAttribute(v, _), u.push(l.x, l
									.y, l.z), w = 3 * e + (i + 1) % 3, l.fromBufferAttribute(v, w), u.push(l
									.x, l.y, l.z)
					}
					this.addAttribute("position", new jn(u, 3))
				}

				function _s(t, e, i) {
					In.call(this), this.type = "ParametricGeometry", this.parameters = {
						func: t,
						slices: e,
						stacks: i
					}, this.fromBufferGeometry(new ws(t, e, i)), this.mergeVertices()
				}

				function ws(t, e, i) {
					nr.call(this), this.type = "ParametricBufferGeometry", this.parameters = {
						func: t,
						slices: e,
						stacks: i
					};
					var n, r, a = [],
						o = [],
						s = [],
						c = [],
						h = 1e-5,
						l = new li,
						u = new li,
						p = new li,
						d = new li,
						f = new li;
					t.length < 3 && console.error(
						"THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.");
					var m = e + 1;
					for (n = 0; n <= i; n++) {
						var g = n / i;
						for (r = 0; r <= e; r++) {
							var v = r / e;
							t(v, g, u), o.push(u.x, u.y, u.z), 0 <= v - h ? (t(v - h, g, p), d.subVectors(u, p)) :
								(t(v + h, g, p), d.subVectors(p, u)), 0 <= g - h ? (t(v, g - h, p), f.subVectors(
									u, p)) : (t(v, g + h, p), f.subVectors(p, u)), l.crossVectors(d, f)
								.normalize(), s.push(l.x, l.y, l.z), c.push(v, g)
						}
					}
					for (n = 0; n < i; n++)
						for (r = 0; r < e; r++) {
							var y = n * m + r,
								x = n * m + r + 1,
								b = (n + 1) * m + r + 1,
								_ = (n + 1) * m + r;
							a.push(y, x, _), a.push(x, b, _)
						}
					this.setIndex(a), this.addAttribute("position", new jn(o, 3)), this.addAttribute("normal",
						new jn(s, 3)), this.addAttribute("uv", new jn(c, 2))
				}

				function Ms(t, e, i, n) {
					In.call(this), this.type = "PolyhedronGeometry", this.parameters = {
						vertices: t,
						indices: e,
						radius: i,
						detail: n
					}, this.fromBufferGeometry(new Ss(t, e, i, n)), this.mergeVertices()
				}

				function Ss(n, a, t, e) {
					nr.call(this), this.type = "PolyhedronBufferGeometry", this.parameters = {
						vertices: n,
						indices: a,
						radius: t,
						detail: e
					}, t = t || 1;
					var l = [],
						u = [];

					function i(t) {
						for (var e = new li, i = new li, n = new li, r = 0; r < a.length; r += 3) h(a[r + 0], e),
							h(a[r + 1], i), h(a[r + 2], n), o(e, i, n, t)
					}

					function o(t, e, i, n) {
						var r, a, o = Math.pow(2, n),
							s = [];
						for (r = 0; r <= o; r++) {
							s[r] = [];
							var c = t.clone().lerp(i, r / o),
								h = e.clone().lerp(i, r / o),
								l = o - r;
							for (a = 0; a <= l; a++) s[r][a] = 0 === a && r === o ? c : c.clone().lerp(h, a / l)
						}
						for (r = 0; r < o; r++)
							for (a = 0; a < 2 * (o - r) - 1; a++) {
								var u = Math.floor(a / 2);
								a % 2 == 0 ? (p(s[r][u + 1]), p(s[r + 1][u]), p(s[r][u])) : (p(s[r][u + 1]), p(s[
									r + 1][u + 1]), p(s[r + 1][u]))
							}
					}

					function r(t) {
						for (var e = new li, i = 0; i < l.length; i += 3) e.x = l[i + 0], e.y = l[i + 1], e.z = l[
								i + 2], e.normalize().multiplyScalar(t), l[i + 0] = e.x, l[i + 1] = e.y, l[i +
							2] = e.z
					}

					function s() {
						for (var t = new li, e = 0; e < l.length; e += 3) {
							t.x = l[e + 0], t.y = l[e + 1], t.z = l[e + 2];
							var i = m(t) / 2 / Math.PI + .5,
								n = g(t) / Math.PI + .5;
							u.push(i, 1 - n)
						}
						d(), c()
					}

					function c() {
						for (var t = 0; t < u.length; t += 6) {
							var e = u[t + 0],
								i = u[t + 2],
								n = u[t + 4],
								r = Math.max(e, i, n),
								a = Math.min(e, i, n);
							.9 < r && a < .1 && (e < .2 && (u[t + 0] += 1), i < .2 && (u[t + 2] += 1), n < .2 && (
								u[t + 4] += 1))
						}
					}

					function p(t) {
						l.push(t.x, t.y, t.z)
					}

					function h(t, e) {
						var i = 3 * t;
						e.x = n[i + 0], e.y = n[i + 1], e.z = n[i + 2]
					}

					function d() {
						for (var t = new li, e = new li, i = new li, n = new li, r = new si, a = new si, o =
								new si, s = 0, c = 0; s < l.length; s += 9, c += 6) {
							t.set(l[s + 0], l[s + 1], l[s + 2]), e.set(l[s + 3], l[s + 4], l[s + 5]), i.set(l[s +
									6], l[s + 7], l[s + 8]), r.set(u[c + 0], u[c + 1]), a.set(u[c + 2], u[c + 3]),
								o.set(u[c + 4], u[c + 5]), n.copy(t).add(e).add(i).divideScalar(3);
							var h = m(n);
							f(r, c + 0, t, h), f(a, c + 2, e, h), f(o, c + 4, i, h)
						}
					}

					function f(t, e, i, n) {
						n < 0 && 1 === t.x && (u[e] = t.x - 1), 0 === i.x && 0 === i.z && (u[e] = n / 2 / Math
							.PI + .5)
					}

					function m(t) {
						return Math.atan2(t.z, -t.x)
					}

					function g(t) {
						return Math.atan2(-t.y, Math.sqrt(t.x * t.x + t.z * t.z))
					}
					i(e = e || 0), r(t), s(), this.addAttribute("position", new jn(l, 3)), this.addAttribute(
							"normal", new jn(l.slice(), 3)), this.addAttribute("uv", new jn(u, 2)), 0 === e ? this
						.computeVertexNormals() : this.normalizeNormals()
				}

				function Es(t, e) {
					In.call(this), this.type = "TetrahedronGeometry", this.parameters = {
						radius: t,
						detail: e
					}, this.fromBufferGeometry(new Ts(t, e)), this.mergeVertices()
				}

				function Ts(t, e) {
					var i = [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1],
						n = [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1];
					Ss.call(this, i, n, t, e), this.type = "TetrahedronBufferGeometry", this.parameters = {
						radius: t,
						detail: e
					}
				}

				function As(t, e) {
					In.call(this), this.type = "OctahedronGeometry", this.parameters = {
						radius: t,
						detail: e
					}, this.fromBufferGeometry(new Ls(t, e)), this.mergeVertices()
				}

				function Ls(t, e) {
					var i = [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1],
						n = [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2];
					Ss.call(this, i, n, t, e), this.type = "OctahedronBufferGeometry", this.parameters = {
						radius: t,
						detail: e
					}
				}

				function Ps(t, e) {
					In.call(this), this.type = "IcosahedronGeometry", this.parameters = {
						radius: t,
						detail: e
					}, this.fromBufferGeometry(new Rs(t, e)), this.mergeVertices()
				}

				function Rs(t, e) {
					var i = (1 + Math.sqrt(5)) / 2,
						n = [-1, i, 0, 1, i, 0, -1, -i, 0, 1, -i, 0, 0, -1, i, 0, 1, i, 0, -1, -i, 0, 1, -i, i, 0,
							-1, i, 0, 1, -i, 0, -1, -i, 0, 1
						],
						r = [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7,
							6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10,
							8, 6, 7, 9, 8, 1
						];
					Ss.call(this, n, r, t, e), this.type = "IcosahedronBufferGeometry", this.parameters = {
						radius: t,
						detail: e
					}
				}

				function Cs(t, e) {
					In.call(this), this.type = "DodecahedronGeometry", this.parameters = {
						radius: t,
						detail: e
					}, this.fromBufferGeometry(new Os(t, e)), this.mergeVertices()
				}

				function Os(t, e) {
					var i = (1 + Math.sqrt(5)) / 2,
						n = 1 / i,
						r = [-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1,
							0, -n, -i, 0, -n, i, 0, n, -i, 0, n, i, -n, -i, 0, -n, i, 0, n, -i, 0, n, i, 0, -i, 0,
							-n, i, 0, -n, -i, 0, n, i, 0, n
						],
						a = [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10,
							17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6,
							2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4,
							14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19,
							4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9
						];
					Ss.call(this, r, a, t, e), this.type = "DodecahedronBufferGeometry", this.parameters = {
						radius: t,
						detail: e
					}
				}

				function Is(t, e, i, n, r, a) {
					In.call(this), this.type = "TubeGeometry", this.parameters = {
						path: t,
						tubularSegments: e,
						radius: i,
						radialSegments: n,
						closed: r
					}, void 0 !== a && console.warn("THREE.TubeGeometry: taper has been removed.");
					var o = new Ds(t, e, i, n, r);
					this.tangents = o.tangents, this.normals = o.normals, this.binormals = o.binormals, this
						.fromBufferGeometry(o), this.mergeVertices()
				}

				function Ds(o, s, c, h, t) {
					nr.call(this), this.type = "TubeBufferGeometry", this.parameters = {
						path: o,
						tubularSegments: s,
						radius: c,
						radialSegments: h,
						closed: t
					}, s = s || 64, c = c || 1, h = h || 8, t = t || !1;
					var l = o.computeFrenetFrames(s, t);
					this.tangents = l.tangents, this.normals = l.normals, this.binormals = l.binormals;
					var r, u, p = new li,
						d = new li,
						e = new si,
						f = new li,
						m = [],
						g = [],
						i = [],
						a = [];

					function n() {
						for (r = 0; r < s; r++) v(r);
						v(!1 === t ? s : 0), x(), y()
					}

					function v(t) {
						f = o.getPointAt(t / s, f);
						var e = l.normals[t],
							i = l.binormals[t];
						for (u = 0; u <= h; u++) {
							var n = u / h * Math.PI * 2,
								r = Math.sin(n),
								a = -Math.cos(n);
							d.x = a * e.x + r * i.x, d.y = a * e.y + r * i.y, d.z = a * e.z + r * i.z, d
								.normalize(), g.push(d.x, d.y, d.z), p.x = f.x + c * d.x, p.y = f.y + c * d.y, p
								.z = f.z + c * d.z, m.push(p.x, p.y, p.z)
						}
					}

					function y() {
						for (u = 1; u <= s; u++)
							for (r = 1; r <= h; r++) {
								var t = (h + 1) * (u - 1) + (r - 1),
									e = (h + 1) * u + (r - 1),
									i = (h + 1) * u + r,
									n = (h + 1) * (u - 1) + r;
								a.push(t, e, n), a.push(e, i, n)
							}
					}

					function x() {
						for (r = 0; r <= s; r++)
							for (u = 0; u <= h; u++) e.x = r / s, e.y = u / h, i.push(e.x, e.y)
					}
					n(), this.setIndex(a), this.addAttribute("position", new jn(m, 3)), this.addAttribute(
						"normal", new jn(g, 3)), this.addAttribute("uv", new jn(i, 2))
				}

				function Bs(t, e, i, n, r, a, o) {
					In.call(this), this.type = "TorusKnotGeometry", this.parameters = {
						radius: t,
						tube: e,
						tubularSegments: i,
						radialSegments: n,
						p: r,
						q: a
					}, void 0 !== o && console.warn(
						"THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead."
						), this.fromBufferGeometry(new zs(t, e, i, n, r, a)), this.mergeVertices()
				}

				function zs(t, e, i, n, r, a) {
					nr.call(this), this.type = "TorusKnotBufferGeometry", this.parameters = {
							radius: t,
							tube: e,
							tubularSegments: i,
							radialSegments: n,
							p: r,
							q: a
						}, t = t || 1, e = e || .4, i = Math.floor(i) || 64, n = Math.floor(n) || 8, r = r || 2,
						a = a || 3;
					var o, s, c = [],
						h = [],
						l = [],
						u = [],
						p = new li,
						d = new li,
						f = new li,
						m = new li,
						g = new li,
						v = new li,
						y = new li;
					for (o = 0; o <= i; ++o) {
						var x = o / i * r * Math.PI * 2;
						for (A(x, r, a, t, f), A(x + .01, r, a, t, m), v.subVectors(m, f), y.addVectors(m, f), g
							.crossVectors(v, y), y.crossVectors(g, v), g.normalize(), y.normalize(), s = 0; s <=
							n; ++s) {
							var b = s / n * Math.PI * 2,
								_ = -e * Math.cos(b),
								w = e * Math.sin(b);
							p.x = f.x + (_ * y.x + w * g.x), p.y = f.y + (_ * y.y + w * g.y), p.z = f.z + (_ * y
								.z + w * g.z), h.push(p.x, p.y, p.z), d.subVectors(p, f).normalize(), l.push(d
								.x, d.y, d.z), u.push(o / i), u.push(s / n)
						}
					}
					for (s = 1; s <= i; s++)
						for (o = 1; o <= n; o++) {
							var M = (n + 1) * (s - 1) + (o - 1),
								S = (n + 1) * s + (o - 1),
								E = (n + 1) * s + o,
								T = (n + 1) * (s - 1) + o;
							c.push(M, S, T), c.push(S, E, T)
						}

					function A(t, e, i, n, r) {
						var a = Math.cos(t),
							o = Math.sin(t),
							s = i / e * t,
							c = Math.cos(s);
						r.x = n * (2 + c) * .5 * a, r.y = n * (2 + c) * o * .5, r.z = n * Math.sin(s) * .5
					}
					this.setIndex(c), this.addAttribute("position", new jn(h, 3)), this.addAttribute("normal",
						new jn(l, 3)), this.addAttribute("uv", new jn(u, 2))
				}

				function Ns(t, e, i, n, r) {
					In.call(this), this.type = "TorusGeometry", this.parameters = {
						radius: t,
						tube: e,
						radialSegments: i,
						tubularSegments: n,
						arc: r
					}, this.fromBufferGeometry(new Gs(t, e, i, n, r)), this.mergeVertices()
				}

				function Gs(t, e, i, n, r) {
					nr.call(this), this.type = "TorusBufferGeometry", this.parameters = {
							radius: t,
							tube: e,
							radialSegments: i,
							tubularSegments: n,
							arc: r
						}, t = t || 1, e = e || .4, i = Math.floor(i) || 8, n = Math.floor(n) || 6, r = r || 2 *
						Math.PI;
					var a, o, s = [],
						c = [],
						h = [],
						l = [],
						u = new li,
						p = new li,
						d = new li;
					for (a = 0; a <= i; a++)
						for (o = 0; o <= n; o++) {
							var f = o / n * r,
								m = a / i * Math.PI * 2;
							p.x = (t + e * Math.cos(m)) * Math.cos(f), p.y = (t + e * Math.cos(m)) * Math.sin(f),
								p.z = e * Math.sin(m), c.push(p.x, p.y, p.z), u.x = t * Math.cos(f), u.y = t *
								Math.sin(f), d.subVectors(p, u).normalize(), h.push(d.x, d.y, d.z), l.push(o / n),
								l.push(a / i)
						}
					for (a = 1; a <= i; a++)
						for (o = 1; o <= n; o++) {
							var g = (n + 1) * a + o - 1,
								v = (n + 1) * (a - 1) + o - 1,
								y = (n + 1) * (a - 1) + o,
								x = (n + 1) * a + o;
							s.push(g, v, x), s.push(v, y, x)
						}
					this.setIndex(s), this.addAttribute("position", new jn(c, 3)), this.addAttribute("normal",
						new jn(h, 3)), this.addAttribute("uv", new jn(l, 2))
				}
				$o.prototype.isFogExp2 = !0, $o.prototype.clone = function () {
						return new $o(this.color, this.density)
					}, $o.prototype.toJSON = function () {
						return {
							type: "FogExp2",
							color: this.color.getHex(),
							density: this.density
						}
					}, ts.prototype.isFog = !0, ts.prototype.clone = function () {
						return new ts(this.color, this.near, this.far)
					}, ts.prototype.toJSON = function () {
						return {
							type: "Fog",
							color: this.color.getHex(),
							near: this.near,
							far: this.far
						}
					}, es.prototype = Object.assign(Object.create(Sn.prototype), {
						constructor: es,
						isScene: !0,
						copy: function (t, e) {
							return Sn.prototype.copy.call(this, t, e), null !== t.background && (this
									.background = t.background.clone()), null !== t.fog && (this.fog = t
									.fog.clone()), null !== t.overrideMaterial && (this.overrideMaterial =
									t.overrideMaterial.clone()), this.autoUpdate = t.autoUpdate, this
								.matrixAutoUpdate = t.matrixAutoUpdate, this
						},
						toJSON: function (t) {
							var e = Sn.prototype.toJSON.call(this, t);
							return null !== this.background && (e.object.background = this.background
									.toJSON(t)), null !== this.fog && (e.object.fog = this.fog.toJSON()),
								e
						},
						dispose: function () {
							this.dispatchEvent({
								type: "dispose"
							})
						}
					}), Object.defineProperty(is.prototype, "needsUpdate", {
						set: function (t) {
							!0 === t && this.version++
						}
					}), Object.assign(is.prototype, {
						isInterleavedBuffer: !0,
						onUploadCallback: function () {},
						setArray: function (t) {
							if (Array.isArray(t)) throw new TypeError(
								"THREE.BufferAttribute: array should be a Typed Array.");
							return this.count = void 0 !== t ? t.length / this.stride : 0, this.array = t,
								this
						},
						setDynamic: function (t) {
							return this.dynamic = t, this
						},
						copy: function (t) {
							return this.array = new t.array.constructor(t.array), this.count = t.count,
								this.stride = t.stride, this.dynamic = t.dynamic, this
						},
						copyAt: function (t, e, i) {
							t *= this.stride, i *= e.stride;
							for (var n = 0, r = this.stride; n < r; n++) this.array[t + n] = e.array[i +
								n];
							return this
						},
						set: function (t, e) {
							return void 0 === e && (e = 0), this.array.set(t, e), this
						},
						clone: function () {
							return (new this.constructor).copy(this)
						},
						onUpload: function (t) {
							return this.onUploadCallback = t, this
						}
					}), Object.defineProperties(ns.prototype, {
						count: {
							get: function () {
								return this.data.count
							}
						},
						array: {
							get: function () {
								return this.data.array
							}
						}
					}), Object.assign(ns.prototype, {
						isInterleavedBufferAttribute: !0,
						setX: function (t, e) {
							return this.data.array[t * this.data.stride + this.offset] = e, this
						},
						setY: function (t, e) {
							return this.data.array[t * this.data.stride + this.offset + 1] = e, this
						},
						setZ: function (t, e) {
							return this.data.array[t * this.data.stride + this.offset + 2] = e, this
						},
						setW: function (t, e) {
							return this.data.array[t * this.data.stride + this.offset + 3] = e, this
						},
						getX: function (t) {
							return this.data.array[t * this.data.stride + this.offset]
						},
						getY: function (t) {
							return this.data.array[t * this.data.stride + this.offset + 1]
						},
						getZ: function (t) {
							return this.data.array[t * this.data.stride + this.offset + 2]
						},
						getW: function (t) {
							return this.data.array[t * this.data.stride + this.offset + 3]
						},
						setXY: function (t, e, i) {
							return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e,
								this.data.array[t + 1] = i, this
						},
						setXYZ: function (t, e, i, n) {
							return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e,
								this.data.array[t + 1] = i, this.data.array[t + 2] = n, this
						},
						setXYZW: function (t, e, i, n, r) {
							return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e,
								this.data.array[t + 1] = i, this.data.array[t + 2] = n, this.data.array[
									t + 3] = r, this
						}
					}), rs.prototype = Object.create(hr.prototype), (rs.prototype.constructor = rs).prototype
					.isSpriteMaterial = !0, rs.prototype.copy = function (t) {
						return hr.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this
							.rotation = t.rotation, this.sizeAttenuation = t.sizeAttenuation, this
					}, as.prototype = Object.assign(Object.create(Sn.prototype), {
						constructor: as,
						isSprite: !0,
						raycast: function () {
							var c = new li,
								h = new li,
								l = new li,
								o = new si,
								s = new si,
								u = new ci,
								p = new li,
								d = new li,
								f = new li,
								m = new si,
								g = new si,
								v = new si;

							function y(t, e, i, n, r, a) {
								o.subVectors(t, i).addScalar(.5).multiply(n), void 0 !== r ? (s.x = a * o
										.x - r * o.y, s.y = r * o.x + a * o.y) : s.copy(o), t.copy(e), t
									.x += s.x, t.y += s.y, t.applyMatrix4(u)
							}
							return function (t, e) {
								h.setFromMatrixScale(this.matrixWorld), u.getInverse(this
										.modelViewMatrix).premultiply(this.matrixWorld), l
									.setFromMatrixPosition(this.modelViewMatrix);
								var i, n, r = this.material.rotation;
								0 !== r && (n = Math.cos(r), i = Math.sin(r));
								var a = this.center;
								y(p.set(-.5, -.5, 0), l, a, h, i, n), y(d.set(.5, -.5, 0), l, a, h, i,
									n), y(f.set(.5, .5, 0), l, a, h, i, n), m.set(0, 0), g.set(1,
									0), v.set(1, 1);
								var o = t.ray.intersectTriangle(p, d, f, !1, c);
								if (null !== o || (y(d.set(-.5, .5, 0), l, a, h, i, n), g.set(0, 1),
										null !== (o = t.ray.intersectTriangle(p, f, d, !1, c)))) {
									var s = t.ray.origin.distanceTo(c);
									s < t.near || s > t.far || e.push({
										distance: s,
										point: c.clone(),
										uv: Ur.getUV(c, p, d, f, m, g, v, new si),
										face: null,
										object: this
									})
								}
							}
						}(),
						clone: function () {
							return new this.constructor(this.material).copy(this)
						},
						copy: function (t) {
							return Sn.prototype.copy.call(this, t), void 0 !== t.center && this.center
								.copy(t.center), this
						}
					}), os.prototype = Object.assign(Object.create(Sn.prototype), {
						constructor: os,
						copy: function (t) {
							Sn.prototype.copy.call(this, t, !1);
							for (var e = t.levels, i = 0, n = e.length; i < n; i++) {
								var r = e[i];
								this.addLevel(r.object.clone(), r.distance)
							}
							return this
						},
						addLevel: function (t, e) {
							void 0 === e && (e = 0), e = Math.abs(e);
							for (var i = this.levels, n = 0; n < i.length && !(e < i[n].distance); n++);
							i.splice(n, 0, {
								distance: e,
								object: t
							}), this.add(t)
						},
						getObjectForDistance: function (t) {
							for (var e = this.levels, i = 1, n = e.length; i < n && !(t < e[i]
								.distance); i++);
							return e[i - 1].object
						},
						raycast: (Do = new li, function (t, e) {
							Do.setFromMatrixPosition(this.matrixWorld);
							var i = t.ray.origin.distanceTo(Do);
							this.getObjectForDistance(i).raycast(t, e)
						}),
						update: (Oo = new li, Io = new li, function (t) {
							var e = this.levels;
							if (1 < e.length) {
								Oo.setFromMatrixPosition(t.matrixWorld), Io.setFromMatrixPosition(this
									.matrixWorld);
								var i = Oo.distanceTo(Io);
								e[0].object.visible = !0;
								for (var n = 1, r = e.length; n < r && i >= e[n].distance; n++) e[n -
									1].object.visible = !1, e[n].object.visible = !0;
								for (; n < r; n++) e[n].object.visible = !1
							}
						}),
						toJSON: function (t) {
							var e = Sn.prototype.toJSON.call(this, t);
							e.object.levels = [];
							for (var i = this.levels, n = 0, r = i.length; n < r; n++) {
								var a = i[n];
								e.object.levels.push({
									object: a.object.uuid,
									distance: a.distance
								})
							}
							return e
						}
					}), ss.prototype = Object.assign(Object.create(Hr.prototype), {
						constructor: ss,
						isSkinnedMesh: !0,
						bind: function (t, e) {
							this.skeleton = t, void 0 === e && (this.updateMatrixWorld(!0), this.skeleton
									.calculateInverses(), e = this.matrixWorld), this.bindMatrix.copy(e),
								this.bindMatrixInverse.getInverse(e)
						},
						pose: function () {
							this.skeleton.pose()
						},
						normalizeSkinWeights: function () {
							for (var t = new Ci, e = this.geometry.attributes.skinWeight, i = 0, n = e
									.count; i < n; i++) {
								t.x = e.getX(i), t.y = e.getY(i), t.z = e.getZ(i), t.w = e.getW(i);
								var r = 1 / t.manhattanLength();
								r !== 1 / 0 ? t.multiplyScalar(r) : t.set(1, 0, 0, 0), e.setXYZW(i, t.x, t
									.y, t.z, t.w)
							}
						},
						updateMatrixWorld: function (t) {
							Hr.prototype.updateMatrixWorld.call(this, t), "attached" === this.bindMode ?
								this.bindMatrixInverse.getInverse(this.matrixWorld) : "detached" === this
								.bindMode ? this.bindMatrixInverse.getInverse(this.bindMatrix) : console
								.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode)
						},
						clone: function () {
							return new this.constructor(this.geometry, this.material).copy(this)
						}
					}), Object.assign(cs.prototype, {
						calculateInverses: function () {
							this.boneInverses = [];
							for (var t = 0, e = this.bones.length; t < e; t++) {
								var i = new ci;
								this.bones[t] && i.getInverse(this.bones[t].matrixWorld), this
									.boneInverses.push(i)
							}
						},
						pose: function () {
							var t, e, i;
							for (e = 0, i = this.bones.length; e < i; e++)(t = this.bones[e]) && t
								.matrixWorld.getInverse(this.boneInverses[e]);
							for (e = 0, i = this.bones.length; e < i; e++)(t = this.bones[e]) && (t
								.parent && t.parent.isBone ? (t.matrix.getInverse(t.parent
									.matrixWorld), t.matrix.multiply(t.matrixWorld)) : t.matrix.copy(t
									.matrixWorld), t.matrix.decompose(t.position, t.quaternion, t
									.scale))
						},
						update: (Bo = new ci, zo = new ci, function () {
							for (var t = this.bones, e = this.boneInverses, i = this.boneMatrices, n =
									this.boneTexture, r = 0, a = t.length; r < a; r++) {
								var o = t[r] ? t[r].matrixWorld : zo;
								Bo.multiplyMatrices(o, e[r]), Bo.toArray(i, 16 * r)
							}
							void 0 !== n && (n.needsUpdate = !0)
						}),
						clone: function () {
							return new cs(this.bones, this.boneInverses)
						},
						getBoneByName: function (t) {
							for (var e = 0, i = this.bones.length; e < i; e++) {
								var n = this.bones[e];
								if (n.name === t) return n
							}
						}
					}), hs.prototype = Object.assign(Object.create(Sn.prototype), {
						constructor: hs,
						isBone: !0
					}), ls.prototype = Object.create(hr.prototype), (ls.prototype.constructor = ls).prototype
					.isLineBasicMaterial = !0, ls.prototype.copy = function (t) {
						return hr.prototype.copy.call(this, t), this.color.copy(t.color), this.linewidth = t
							.linewidth, this.linecap = t.linecap, this.linejoin = t.linejoin, this
					}, us.prototype = Object.assign(Object.create(Sn.prototype), {
						constructor: us,
						isLine: !0,
						computeLineDistances: (Fo = new li, Ho = new li, function () {
							var t = this.geometry;
							if (t.isBufferGeometry)
								if (null === t.index) {
									for (var e = t.attributes.position, i = [0], n = 1, r = e
										.count; n < r; n++) Fo.fromBufferAttribute(e, n - 1), Ho
										.fromBufferAttribute(e, n), i[n] = i[n - 1], i[n] += Fo
										.distanceTo(Ho);
									t.addAttribute("lineDistance", new jn(i, 1))
								} else console.warn(
									"THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
									);
							else if (t.isGeometry) {
								var a = t.vertices;
								for ((i = t.lineDistances)[0] = 0, n = 1, r = a.length; n < r; n++) i[
									n] = i[n - 1], i[n] += a[n - 1].distanceTo(a[n])
							}
							return this
						}),
						raycast: (No = new ci, Go = new Gr, Uo = new Ni, function (t, e) {
							var i = t.linePrecision,
								n = this.geometry,
								r = this.matrixWorld;
							if (null === n.boundingSphere && n.computeBoundingSphere(), Uo.copy(n
									.boundingSphere), Uo.applyMatrix4(r), Uo.radius += i, !1 !== t.ray
								.intersectsSphere(Uo)) {
								No.getInverse(r), Go.copy(t.ray).applyMatrix4(No);
								var a = i / ((this.scale.x + this.scale.y + this.scale.z) / 3),
									o = a * a,
									s = new li,
									c = new li,
									h = new li,
									l = new li,
									u = this && this.isLineSegments ? 2 : 1;
								if (n.isBufferGeometry) {
									var p = n.index,
										d = n.attributes.position.array;
									if (null !== p)
										for (var f = p.array, m = 0, g = f.length - 1; m < g; m +=
											u) {
											var v = f[m],
												y = f[m + 1];
											s.fromArray(d, 3 * v), c.fromArray(d, 3 * y), o < Go
												.distanceSqToSegment(s, c, l, h) || (l.applyMatrix4(
														this.matrixWorld), (_ = t.ray.origin
														.distanceTo(l)) < t.near || _ > t.far || e
													.push({
														distance: _,
														point: h.clone().applyMatrix4(this
															.matrixWorld),
														index: m,
														face: null,
														faceIndex: null,
														object: this
													}))
										} else
											for (m = 0, g = d.length / 3 - 1; m < g; m += u) s
												.fromArray(d, 3 * m), c.fromArray(d, 3 * m + 3), o <
												Go.distanceSqToSegment(s, c, l, h) || (l.applyMatrix4(
														this.matrixWorld), (_ = t.ray.origin
														.distanceTo(l)) < t.near || _ > t.far || e
													.push({
														distance: _,
														point: h.clone().applyMatrix4(this
															.matrixWorld),
														index: m,
														face: null,
														faceIndex: null,
														object: this
													}))
								} else if (n.isGeometry) {
									var x = n.vertices,
										b = x.length;
									for (m = 0; m < b - 1; m += u) {
										var _;
										o < Go.distanceSqToSegment(x[m], x[m + 1], l, h) || (l
											.applyMatrix4(this.matrixWorld), (_ = t.ray.origin
												.distanceTo(l)) < t.near || _ > t.far || e.push({
												distance: _,
												point: h.clone().applyMatrix4(this
													.matrixWorld),
												index: m,
												face: null,
												faceIndex: null,
												object: this
											}))
									}
								}
							}
						}),
						copy: function (t) {
							return Sn.prototype.copy.call(this, t), this.geometry.copy(t.geometry), this
								.material.copy(t.material), this
						},
						clone: function () {
							return (new this.constructor).copy(this)
						}
					}), ps.prototype = Object.assign(Object.create(us.prototype), {
						constructor: ps,
						isLineSegments: !0,
						computeLineDistances: (jo = new li, ko = new li, function () {
							var t = this.geometry;
							if (t.isBufferGeometry)
								if (null === t.index) {
									for (var e = t.attributes.position, i = [], n = 0, r = e
										.count; n < r; n += 2) jo.fromBufferAttribute(e, n), ko
										.fromBufferAttribute(e, n + 1), i[n] = 0 === n ? 0 : i[n - 1],
										i[n + 1] = i[n] + jo.distanceTo(ko);
									t.addAttribute("lineDistance", new jn(i, 1))
								} else console.warn(
									"THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
									);
							else if (t.isGeometry) {
								var a = t.vertices;
								for (i = t.lineDistances, n = 0, r = a.length; n < r; n += 2) jo.copy(
									a[n]), ko.copy(a[n + 1]), i[n] = 0 === n ? 0 : i[n - 1], i[n +
									1] = i[n] + jo.distanceTo(ko)
							}
							return this
						})
					}), ds.prototype = Object.assign(Object.create(us.prototype), {
						constructor: ds,
						isLineLoop: !0
					}), fs.prototype = Object.create(hr.prototype), (fs.prototype.constructor = fs).prototype
					.isPointsMaterial = !0, fs.prototype.copy = function (t) {
						return hr.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this
							.size = t.size, this.sizeAttenuation = t.sizeAttenuation, this.morphTargets = t
							.morphTargets, this
					}, ms.prototype = Object.assign(Object.create(Sn.prototype), {
						constructor: ms,
						isPoints: !0,
						raycast: (Vo = new ci, Wo = new Gr, qo = new Ni, function (r, a) {
							var o = this,
								t = this.geometry,
								s = this.matrixWorld,
								e = r.params.Points.threshold;
							if (null === t.boundingSphere && t.computeBoundingSphere(), qo.copy(t
									.boundingSphere), qo.applyMatrix4(s), qo.radius += e, !1 !== r.ray
								.intersectsSphere(qo)) {
								Vo.getInverse(s), Wo.copy(r.ray).applyMatrix4(Vo);
								var i = e / ((this.scale.x + this.scale.y + this.scale.z) / 3),
									c = i * i,
									n = new li,
									h = new li;
								if (t.isBufferGeometry) {
									var l = t.index,
										u = t.attributes.position.array;
									if (null !== l)
										for (var p = l.array, d = 0, f = p.length; d < f; d++) {
											var m = p[d];
											n.fromArray(u, 3 * m), y(n, m)
										} else {
											d = 0;
											for (var g = u.length / 3; d < g; d++) n.fromArray(u, 3 *
												d), y(n, d)
										}
								} else {
									var v = t.vertices;
									for (d = 0, g = v.length; d < g; d++) y(v[d], d)
								}
							}

							function y(t, e) {
								var i = Wo.distanceSqToPoint(t);
								if (i < c) {
									Wo.closestPointToPoint(t, h), h.applyMatrix4(s);
									var n = r.ray.origin.distanceTo(h);
									if (n < r.near || n > r.far) return;
									a.push({
										distance: n,
										distanceToRay: Math.sqrt(i),
										point: h.clone(),
										index: e,
										face: null,
										object: o
									})
								}
							}
						}),
						clone: function () {
							return new this.constructor(this.geometry, this.material).copy(this)
						}
					}), gs.prototype = Object.assign(Object.create(Ri.prototype), {
						constructor: gs,
						isVideoTexture: !0,
						update: function () {
							var t = this.image;
							t.readyState >= t.HAVE_CURRENT_DATA && (this.needsUpdate = !0)
						}
					}), vs.prototype = Object.create(Ri.prototype), (vs.prototype.constructor = vs).prototype
					.isCompressedTexture = !0, ys.prototype = Object.create(Ri.prototype), (ys.prototype
						.constructor = ys).prototype.isCanvasTexture = !0, xs.prototype = Object.create(Ri
						.prototype), (xs.prototype.constructor = xs).prototype.isDepthTexture = !0, bs.prototype =
					Object.create(nr.prototype), bs.prototype.constructor = bs, _s.prototype = Object.create(In
						.prototype), _s.prototype.constructor = _s, ws.prototype = Object.create(nr.prototype), ws
					.prototype.constructor = ws, Ms.prototype = Object.create(In.prototype), Ms.prototype
					.constructor = Ms, Ss.prototype = Object.create(nr.prototype), Ss.prototype.constructor = Ss,
					Es.prototype = Object.create(In.prototype), Es.prototype.constructor = Es, Ts.prototype =
					Object.create(Ss.prototype), Ts.prototype.constructor = Ts, As.prototype = Object.create(In
						.prototype), As.prototype.constructor = As, Ls.prototype = Object.create(Ss.prototype), Ls
					.prototype.constructor = Ls, Ps.prototype = Object.create(In.prototype), Ps.prototype
					.constructor = Ps, Rs.prototype = Object.create(Ss.prototype), Rs.prototype.constructor = Rs,
					Cs.prototype = Object.create(In.prototype), Cs.prototype.constructor = Cs, Os.prototype =
					Object.create(Ss.prototype), Os.prototype.constructor = Os, Is.prototype = Object.create(In
						.prototype), Is.prototype.constructor = Is, Ds.prototype = Object.create(nr.prototype), (
						Ds.prototype.constructor = Ds).prototype.toJSON = function () {
						var t = nr.prototype.toJSON.call(this);
						return t.path = this.parameters.path.toJSON(), t
					}, Bs.prototype = Object.create(In.prototype), Bs.prototype.constructor = Bs, zs.prototype =
					Object.create(nr.prototype), zs.prototype.constructor = zs, Ns.prototype = Object.create(In
						.prototype), Ns.prototype.constructor = Ns, Gs.prototype = Object.create(nr.prototype), Gs
					.prototype.constructor = Gs;
				var Us = {
					triangulate: function (t, e, i) {
						i = i || 2;
						var n, r, a, o, s, c, h, l = e && e.length,
							u = l ? e[0] * i : t.length,
							p = Fs(t, 0, u, i, !0),
							d = [];
						if (!p) return d;
						if (l && (p = Xs(t, e, p, i)), t.length > 80 * i) {
							n = a = t[0], r = o = t[1];
							for (var f = i; f < u; f += i)(s = t[f]) < n && (n = s), (c = t[f + 1]) < r &&
								(r = c), a < s && (a = s), o < c && (o = c);
							h = 0 !== (h = Math.max(a - n, o - r)) ? 1 / h : 0
						}
						return js(p, d, i, n, r, h), d
					}
				};

				function Fs(t, e, i, n, r) {
					var a, o;
					if (r === 0 < dc(t, e, i, n))
						for (a = e; a < i; a += n) o = lc(a, t[a], t[a + 1], o);
					else
						for (a = i - n; e <= a; a -= n) o = lc(a, t[a], t[a + 1], o);
					return o && rc(o, o.next) && (uc(o), o = o.next), o
				}

				function Hs(t, e) {
					if (!t) return t;
					e || (e = t);
					var i, n = t;
					do {
						if (i = !1, n.steiner || !rc(n, n.next) && 0 !== nc(n.prev, n, n.next)) n = n.next;
						else {
							if (uc(n), (n = e = n.prev) === n.next) break;
							i = !0
						}
					} while (i || n !== e);
					return e
				}

				function js(t, e, i, n, r, a, o) {
					if (t) {
						!o && a && Qs(t, n, r, a);
						for (var s, c, h = t; t.prev !== t.next;)
							if (s = t.prev, c = t.next, a ? Vs(t, n, r, a) : ks(t)) e.push(s.i / i), e.push(t.i /
								i), e.push(c.i / i), uc(t), t = c.next, h = c.next;
							else if ((t = c) === h) {
							o ? 1 === o ? js(t = Ws(t, e, i), e, i, n, r, a, 2) : 2 === o && qs(t, e, i, n, r,
								a) : js(Hs(t), e, i, n, r, a, 1);
							break
						}
					}
				}

				function ks(t) {
					var e = t.prev,
						i = t,
						n = t.next;
					if (0 <= nc(e, i, n)) return !1;
					for (var r = t.next.next; r !== t.prev;) {
						if (ec(e.x, e.y, i.x, i.y, n.x, n.y, r.x, r.y) && 0 <= nc(r.prev, r, r.next)) return !1;
						r = r.next
					}
					return !0
				}

				function Vs(t, e, i, n) {
					var r = t.prev,
						a = t,
						o = t.next;
					if (0 <= nc(r, a, o)) return !1;
					for (var s = r.x < a.x ? r.x < o.x ? r.x : o.x : a.x < o.x ? a.x : o.x, c = r.y < a.y ? r.y <
							o.y ? r.y : o.y : a.y < o.y ? a.y : o.y, h = r.x > a.x ? r.x > o.x ? r.x : o.x : a.x >
							o.x ? a.x : o.x, l = r.y > a.y ? r.y > o.y ? r.y : o.y : a.y > o.y ? a.y : o.y, u =
							$s(s, c, e, i, n), p = $s(h, l, e, i, n), d = t.nextZ; d && d.z <= p;) {
						if (d !== t.prev && d !== t.next && ec(r.x, r.y, a.x, a.y, o.x, o.y, d.x, d.y) && 0 <= nc(
								d.prev, d, d.next)) return !1;
						d = d.nextZ
					}
					for (d = t.prevZ; d && d.z >= u;) {
						if (d !== t.prev && d !== t.next && ec(r.x, r.y, a.x, a.y, o.x, o.y, d.x, d.y) && 0 <= nc(
								d.prev, d, d.next)) return !1;
						d = d.prevZ
					}
					return !0
				}

				function Ws(t, e, i) {
					var n = t;
					do {
						var r = n.prev,
							a = n.next.next;
						!rc(r, a) && ac(r, n, n.next, a) && sc(r, a) && sc(a, r) && (e.push(r.i / i), e.push(n.i /
							i), e.push(a.i / i), uc(n), uc(n.next), n = t = a), n = n.next
					} while (n !== t);
					return n
				}

				function qs(t, e, i, n, r, a) {
					var o = t;
					do {
						for (var s = o.next.next; s !== o.prev;) {
							if (o.i !== s.i && ic(o, s)) {
								var c = hc(o, s);
								return o = Hs(o, o.next), c = Hs(c, c.next), js(o, e, i, n, r, a), void js(c, e,
									i, n, r, a)
							}
							s = s.next
						}
						o = o.next
					} while (o !== t)
				}

				function Xs(t, e, i, n) {
					var r, a, o, s = [];
					for (r = 0, a = e.length; r < a; r++)(o = Fs(t, e[r] * n, r < a - 1 ? e[r + 1] * n : t.length,
						n, !1)) === o.next && (o.steiner = !0), s.push(tc(o));
					for (s.sort(Ys), r = 0; r < s.length; r++) Zs(s[r], i), i = Hs(i, i.next);
					return i
				}

				function Ys(t, e) {
					return t.x - e.x
				}

				function Zs(t, e) {
					if (e = Js(t, e)) {
						var i = hc(e, t);
						Hs(i, i.next)
					}
				}

				function Js(t, e) {
					var i, n = e,
						r = t.x,
						a = t.y,
						o = -1 / 0;
					do {
						if (a <= n.y && a >= n.next.y && n.next.y !== n.y) {
							var s = n.x + (a - n.y) * (n.next.x - n.x) / (n.next.y - n.y);
							if (s <= r && o < s) {
								if ((o = s) === r) {
									if (a === n.y) return n;
									if (a === n.next.y) return n.next
								}
								i = n.x < n.next.x ? n : n.next
							}
						}
						n = n.next
					} while (n !== e);
					if (!i) return null;
					if (r === o) return i.prev;
					var c, h = i,
						l = i.x,
						u = i.y,
						p = 1 / 0;
					for (n = i.next; n !== h;) r >= n.x && n.x >= l && r !== n.x && ec(a < u ? r : o, a, l, u, a <
						u ? o : r, a, n.x, n.y) && ((c = Math.abs(a - n.y) / (r - n.x)) < p || c === p && n
						.x > i.x) && sc(n, t) && (i = n, p = c), n = n.next;
					return i
				}

				function Qs(t, e, i, n) {
					for (var r = t; null === r.z && (r.z = $s(r.x, r.y, e, i, n)), r.prevZ = r.prev, r.nextZ = r
						.next, (r = r.next) !== t;);
					r.prevZ.nextZ = null, r.prevZ = null, Ks(r)
				}

				function Ks(t) {
					var e, i, n, r, a, o, s, c, h = 1;
					do {
						for (i = t, a = t = null, o = 0; i;) {
							for (o++, n = i, e = s = 0; e < h && (s++, n = n.nextZ); e++);
							for (c = h; 0 < s || 0 < c && n;) 0 !== s && (0 === c || !n || i.z <= n.z) ? (i = (r =
									i).nextZ, s--) : (n = (r = n).nextZ, c--), a ? a.nextZ = r : t = r, r.prevZ =
								a, a = r;
							i = n
						}
						a.nextZ = null, h *= 2
					} while (1 < o);
					return t
				}

				function $s(t, e, i, n, r) {
					return (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = 32767 * (
						t - i) * r) | t << 8)) | t << 4)) | t << 2)) | t << 1)) | (e = 1431655765 & ((e =
						858993459 & ((e = 252645135 & ((e = 16711935 & ((e = 32767 * (e - n) * r) |
							e << 8)) | e << 4)) | e << 2)) | e << 1)) << 1
				}

				function tc(t) {
					for (var e = t, i = t; e.x < i.x && (i = e), (e = e.next) !== t;);
					return i
				}

				function ec(t, e, i, n, r, a, o, s) {
					return 0 <= (r - o) * (e - s) - (t - o) * (a - s) && 0 <= (t - o) * (n - s) - (i - o) * (e -
						s) && 0 <= (i - o) * (a - s) - (r - o) * (n - s)
				}

				function ic(t, e) {
					return t.next.i !== e.i && t.prev.i !== e.i && !oc(t, e) && sc(t, e) && sc(e, t) && cc(t, e)
				}

				function nc(t, e, i) {
					return (e.y - t.y) * (i.x - e.x) - (e.x - t.x) * (i.y - e.y)
				}

				function rc(t, e) {
					return t.x === e.x && t.y === e.y
				}

				function ac(t, e, i, n) {
					return !!(rc(t, e) && rc(i, n) || rc(t, n) && rc(i, e)) || 0 < nc(t, e, i) != 0 < nc(t, e,
						n) && 0 < nc(i, n, t) != 0 < nc(i, n, e)
				}

				function oc(t, e) {
					var i = t;
					do {
						if (i.i !== t.i && i.next.i !== t.i && i.i !== e.i && i.next.i !== e.i && ac(i, i.next, t,
								e)) return !0;
						i = i.next
					} while (i !== t);
					return !1
				}

				function sc(t, e) {
					return nc(t.prev, t, t.next) < 0 ? 0 <= nc(t, e, t.next) && 0 <= nc(t, t.prev, e) : nc(t, e, t
						.prev) < 0 || nc(t, t.next, e) < 0
				}

				function cc(t, e) {
					for (var i = t, n = !1, r = (t.x + e.x) / 2, a = (t.y + e.y) / 2; i.y > a != i.next.y > a && i
						.next.y !== i.y && r < (i.next.x - i.x) * (a - i.y) / (i.next.y - i.y) + i.x && (n = !n),
						(i = i.next) !== t;);
					return n
				}

				function hc(t, e) {
					var i = new pc(t.i, t.x, t.y),
						n = new pc(e.i, e.x, e.y),
						r = t.next,
						a = e.prev;
					return (t.next = e).prev = t, (i.next = r).prev = i, (n.next = i).prev = n, (a.next = n)
						.prev = a, n
				}

				function lc(t, e, i, n) {
					var r = new pc(t, e, i);
					return n ? (r.next = n.next, (r.prev = n).next.prev = r, n.next = r) : (r.prev = r).next = r,
						r
				}

				function uc(t) {
					t.next.prev = t.prev, t.prev.next = t.next, t.prevZ && (t.prevZ.nextZ = t.nextZ), t.nextZ && (
						t.nextZ.prevZ = t.prevZ)
				}

				function pc(t, e, i) {
					this.i = t, this.x = e, this.y = i, this.prev = null, this.next = null, this.z = null, this
						.prevZ = null, this.nextZ = null, this.steiner = !1
				}

				function dc(t, e, i, n) {
					for (var r = 0, a = e, o = i - n; a < i; a += n) r += (t[o] - t[a]) * (t[a + 1] + t[o + 1]),
						o = a;
					return r
				}
				var fc = {
					area: function (t) {
						for (var e = t.length, i = 0, n = e - 1, r = 0; r < e; n = r++) i += t[n].x * t[r]
							.y - t[r].x * t[n].y;
						return .5 * i
					},
					isClockWise: function (t) {
						return fc.area(t) < 0
					},
					triangulateShape: function (t, e) {
						var i = [],
							n = [],
							r = [];
						mc(t), gc(i, t);
						var a = t.length;
						e.forEach(mc);
						for (var o = 0; o < e.length; o++) n.push(a), a += e[o].length, gc(i, e[o]);
						var s = Us.triangulate(i, n);
						for (o = 0; o < s.length; o += 3) r.push(s.slice(o, o + 3));
						return r
					}
				};

				function mc(t) {
					var e = t.length;
					2 < e && t[e - 1].equals(t[0]) && t.pop()
				}

				function gc(t, e) {
					for (var i = 0; i < e.length; i++) t.push(e[i].x), t.push(e[i].y)
				}

				function vc(t, e) {
					In.call(this), this.type = "ExtrudeGeometry", this.parameters = {
						shapes: t,
						options: e
					}, this.fromBufferGeometry(new yc(t, e)), this.mergeVertices()
				}

				function yc(t, K) {
					nr.call(this), this.type = "ExtrudeBufferGeometry", this.parameters = {
						shapes: t,
						options: K
					}, t = Array.isArray(t) ? t : [t];
					for (var $ = this, tt = [], et = [], e = 0, i = t.length; e < i; e++) {
						n(t[e])
					}

					function n(t) {
						var n = [],
							e = void 0 !== K.curveSegments ? K.curveSegments : 12,
							c = void 0 !== K.steps ? K.steps : 1,
							i = void 0 !== K.depth ? K.depth : 100,
							r = void 0 === K.bevelEnabled || K.bevelEnabled,
							a = void 0 !== K.bevelThickness ? K.bevelThickness : 6,
							o = void 0 !== K.bevelSize ? K.bevelSize : a - 2,
							h = void 0 !== K.bevelSegments ? K.bevelSegments : 3,
							s = K.extrudePath,
							l = void 0 !== K.UVGenerator ? K.UVGenerator : xc;
						void 0 !== K.amount && (console.warn(
								"THREE.ExtrudeBufferGeometry: amount has been renamed to depth."), i = K
							.amount);
						var u, p, d, f, m, g, v, y, x = !1;
						s && (u = s.getSpacedPoints(c), r = !(x = !0), p = s.computeFrenetFrames(c, !1), d =
							new li, f = new li, m = new li), r || (o = a = h = 0);
						var b = t.extractPoints(e),
							_ = b.shape,
							w = b.holes;
						if (!fc.isClockWise(_))
							for (_ = _.reverse(), v = 0, y = w.length; v < y; v++) g = w[v], fc.isClockWise(g) &&
								(w[v] = g.reverse());
						var M = fc.triangulateShape(_, w),
							S = _;
						for (v = 0, y = w.length; v < y; v++) g = w[v], _ = _.concat(g);

						function E(t, e, i) {
							return e || console.error("THREE.ExtrudeGeometry: vec does not exist"), e.clone()
								.multiplyScalar(i).add(t)
						}
						var T, A, L, P, R, C, O = _.length,
							I = M.length;

						function D(t, e, i) {
							var n, r, a, o = t.x - e.x,
								s = t.y - e.y,
								c = i.x - t.x,
								h = i.y - t.y,
								l = o * o + s * s,
								u = o * h - s * c;
							if (Math.abs(u) > Number.EPSILON) {
								var p = Math.sqrt(l),
									d = Math.sqrt(c * c + h * h),
									f = e.x - s / p,
									m = e.y + o / p,
									g = ((i.x - h / d - f) * h - (i.y + c / d - m) * c) / (o * h - s * c),
									v = (n = f + o * g - t.x) * n + (r = m + s * g - t.y) * r;
								if (v <= 2) return new si(n, r);
								a = Math.sqrt(v / 2)
							} else {
								var y = !1;
								o > Number.EPSILON ? c > Number.EPSILON && (y = !0) : o < -Number.EPSILON ? c < -
									Number.EPSILON && (y = !0) : Math.sign(s) === Math.sign(h) && (y = !0), a =
									y ? (n = -s, r = o, Math.sqrt(l)) : (n = o, r = s, Math.sqrt(l / 2))
							}
							return new si(n / a, r / a)
						}
						for (var B = [], z = 0, N = S.length, G = N - 1, U = z + 1; z < N; z++, G++, U++) G ===
							N && (G = 0), U === N && (U = 0), B[z] = D(S[z], S[G], S[U]);
						var F, H, j = [],
							k = B.concat();
						for (v = 0, y = w.length; v < y; v++) {
							for (g = w[v], F = [], z = 0, G = (N = g.length) - 1, U = z + 1; z < N; z++, G++, U++)
								G === N && (G = 0), U === N && (U = 0), F[z] = D(g[z], g[G], g[U]);
							j.push(F), k = k.concat(F)
						}
						for (T = 0; T < h; T++) {
							for (L = T / h, P = a * Math.cos(L * Math.PI / 2), A = o * Math.sin(L * Math.PI / 2),
								z = 0, N = S.length; z < N; z++) X((R = E(S[z], B[z], A)).x, R.y, -P);
							for (v = 0, y = w.length; v < y; v++)
								for (g = w[v], F = j[v], z = 0, N = g.length; z < N; z++) X((R = E(g[z], F[z], A))
									.x, R.y, -P)
						}
						for (A = o, z = 0; z < O; z++) R = r ? E(_[z], k[z], A) : _[z], x ? (f.copy(p.normals[0])
							.multiplyScalar(R.x), d.copy(p.binormals[0]).multiplyScalar(R.y), m.copy(u[0])
							.add(f).add(d), X(m.x, m.y, m.z)) : X(R.x, R.y, 0);
						for (H = 1; H <= c; H++)
							for (z = 0; z < O; z++) R = r ? E(_[z], k[z], A) : _[z], x ? (f.copy(p.normals[H])
								.multiplyScalar(R.x), d.copy(p.binormals[H]).multiplyScalar(R.y), m.copy(u[H])
								.add(f).add(d), X(m.x, m.y, m.z)) : X(R.x, R.y, i / c * H);
						for (T = h - 1; 0 <= T; T--) {
							for (L = T / h, P = a * Math.cos(L * Math.PI / 2), A = o * Math.sin(L * Math.PI / 2),
								z = 0, N = S.length; z < N; z++) X((R = E(S[z], B[z], A)).x, R.y, i + P);
							for (v = 0, y = w.length; v < y; v++)
								for (g = w[v], F = j[v], z = 0, N = g.length; z < N; z++) R = E(g[z], F[z], A),
									x ? X(R.x, R.y + u[c - 1].y, u[c - 1].x + P) : X(R.x, R.y, i + P)
						}

						function V() {
							var t = tt.length / 3;
							if (r) {
								var e = 0,
									i = O * e;
								for (z = 0; z < I; z++) Y((C = M[z])[2] + i, C[1] + i, C[0] + i);
								for (i = O * (e = c + 2 * h), z = 0; z < I; z++) Y((C = M[z])[0] + i, C[1] + i, C[
									2] + i)
							} else {
								for (z = 0; z < I; z++) Y((C = M[z])[2], C[1], C[0]);
								for (z = 0; z < I; z++) Y((C = M[z])[0] + O * c, C[1] + O * c, C[2] + O * c)
							}
							$.addGroup(t, tt.length / 3 - t, 0)
						}

						function W() {
							var t = tt.length / 3,
								e = 0;
							for (q(S, e), e += S.length, v = 0, y = w.length; v < y; v++) q(g = w[v], e), e += g
								.length;
							$.addGroup(t, tt.length / 3 - t, 1)
						}

						function q(t, e) {
							var i, n;
							for (z = t.length; 0 <= --z;) {
								(n = (i = z) - 1) < 0 && (n = t.length - 1);
								var r = 0,
									a = c + 2 * h;
								for (r = 0; r < a; r++) {
									var o = O * r,
										s = O * (r + 1);
									Z(e + i + o, e + n + o, e + n + s, e + i + s)
								}
							}
						}

						function X(t, e, i) {
							n.push(t), n.push(e), n.push(i)
						}

						function Y(t, e, i) {
							J(t), J(e), J(i);
							var n = tt.length / 3,
								r = l.generateTopUV($, tt, n - 3, n - 2, n - 1);
							Q(r[0]), Q(r[1]), Q(r[2])
						}

						function Z(t, e, i, n) {
							J(t), J(e), J(n), J(e), J(i), J(n);
							var r = tt.length / 3,
								a = l.generateSideWallUV($, tt, r - 6, r - 3, r - 2, r - 1);
							Q(a[0]), Q(a[1]), Q(a[3]), Q(a[1]), Q(a[2]), Q(a[3])
						}

						function J(t) {
							tt.push(n[3 * t + 0]), tt.push(n[3 * t + 1]), tt.push(n[3 * t + 2])
						}

						function Q(t) {
							et.push(t.x), et.push(t.y)
						}
						V(), W()
					}
					this.addAttribute("position", new jn(tt, 3)), this.addAttribute("uv", new jn(et, 2)), this
						.computeVertexNormals()
				}
				vc.prototype = Object.create(In.prototype), (vc.prototype.constructor = vc).prototype.toJSON =
					function () {
						var t = In.prototype.toJSON.call(this);
						return bc(this.parameters.shapes, this.parameters.options, t)
					}, yc.prototype = Object.create(nr.prototype), (yc.prototype.constructor = yc).prototype
					.toJSON = function () {
						var t = nr.prototype.toJSON.call(this);
						return bc(this.parameters.shapes, this.parameters.options, t)
					};
				var xc = {
					generateTopUV: function (t, e, i, n, r) {
						var a = e[3 * i],
							o = e[3 * i + 1],
							s = e[3 * n],
							c = e[3 * n + 1],
							h = e[3 * r],
							l = e[3 * r + 1];
						return [new si(a, o), new si(s, c), new si(h, l)]
					},
					generateSideWallUV: function (t, e, i, n, r, a) {
						var o = e[3 * i],
							s = e[3 * i + 1],
							c = e[3 * i + 2],
							h = e[3 * n],
							l = e[3 * n + 1],
							u = e[3 * n + 2],
							p = e[3 * r],
							d = e[3 * r + 1],
							f = e[3 * r + 2],
							m = e[3 * a],
							g = e[3 * a + 1],
							v = e[3 * a + 2];
						return Math.abs(s - l) < .01 ? [new si(o, 1 - c), new si(h, 1 - u), new si(p, 1 -
							f), new si(m, 1 - v)] : [new si(s, 1 - c), new si(l, 1 - u), new si(d, 1 -
							f), new si(g, 1 - v)]
					}
				};

				function bc(t, e, i) {
					if (i.shapes = [], Array.isArray(t))
						for (var n = 0, r = t.length; n < r; n++) {
							var a = t[n];
							i.shapes.push(a.uuid)
						} else i.shapes.push(t.uuid);
					return void 0 !== e.extrudePath && (i.options.extrudePath = e.extrudePath.toJSON()), i
				}

				function _c(t, e) {
					In.call(this), this.type = "TextGeometry", this.parameters = {
						text: t,
						parameters: e
					}, this.fromBufferGeometry(new wc(t, e)), this.mergeVertices()
				}

				function wc(t, e) {
					var i = (e = e || {}).font;
					if (!i || !i.isFont) return console.error(
						"THREE.TextGeometry: font parameter is not an instance of THREE.Font."), new In;
					var n = i.generateShapes(t, e.size);
					e.depth = void 0 !== e.height ? e.height : 50, void 0 === e.bevelThickness && (e
							.bevelThickness = 10), void 0 === e.bevelSize && (e.bevelSize = 8), void 0 === e
						.bevelEnabled && (e.bevelEnabled = !1), yc.call(this, n, e), this.type =
						"TextBufferGeometry"
				}

				function Mc(t, e, i, n, r, a, o) {
					In.call(this), this.type = "SphereGeometry", this.parameters = {
						radius: t,
						widthSegments: e,
						heightSegments: i,
						phiStart: n,
						phiLength: r,
						thetaStart: a,
						thetaLength: o
					}, this.fromBufferGeometry(new Sc(t, e, i, n, r, a, o)), this.mergeVertices()
				}

				function Sc(t, e, i, n, r, a, o) {
					nr.call(this), this.type = "SphereBufferGeometry", this.parameters = {
							radius: t,
							widthSegments: e,
							heightSegments: i,
							phiStart: n,
							phiLength: r,
							thetaStart: a,
							thetaLength: o
						}, t = t || 1, e = Math.max(3, Math.floor(e) || 8), i = Math.max(2, Math.floor(i) || 6),
						n = void 0 !== n ? n : 0, r = void 0 !== r ? r : 2 * Math.PI;
					var s, c, h = (a = void 0 !== a ? a : 0) + (o = void 0 !== o ? o : Math.PI),
						l = 0,
						u = [],
						p = new li,
						d = new li,
						f = [],
						m = [],
						g = [],
						v = [];
					for (c = 0; c <= i; c++) {
						var y = [],
							x = c / i;
						for (s = 0; s <= e; s++) {
							var b = s / e;
							p.x = -t * Math.cos(n + b * r) * Math.sin(a + x * o), p.y = t * Math.cos(a + x * o), p
								.z = t * Math.sin(n + b * r) * Math.sin(a + x * o), m.push(p.x, p.y, p.z), d.set(p
									.x, p.y, p.z).normalize(), g.push(d.x, d.y, d.z), v.push(b, 1 - x), y.push(
									l++)
						}
						u.push(y)
					}
					for (c = 0; c < i; c++)
						for (s = 0; s < e; s++) {
							var _ = u[c][s + 1],
								w = u[c][s],
								M = u[c + 1][s],
								S = u[c + 1][s + 1];
							(0 !== c || 0 < a) && f.push(_, w, S), (c !== i - 1 || h < Math.PI) && f.push(w, M, S)
						}
					this.setIndex(f), this.addAttribute("position", new jn(m, 3)), this.addAttribute("normal",
						new jn(g, 3)), this.addAttribute("uv", new jn(v, 2))
				}

				function Ec(t, e, i, n, r, a) {
					In.call(this), this.type = "RingGeometry", this.parameters = {
						innerRadius: t,
						outerRadius: e,
						thetaSegments: i,
						phiSegments: n,
						thetaStart: r,
						thetaLength: a
					}, this.fromBufferGeometry(new Tc(t, e, i, n, r, a)), this.mergeVertices()
				}

				function Tc(t, e, i, n, r, a) {
					nr.call(this), this.type = "RingBufferGeometry", this.parameters = {
							innerRadius: t,
							outerRadius: e,
							thetaSegments: i,
							phiSegments: n,
							thetaStart: r,
							thetaLength: a
						}, t = t || .5, e = e || 1, r = void 0 !== r ? r : 0, a = void 0 !== a ? a : 2 * Math.PI,
						i = void 0 !== i ? Math.max(3, i) : 8;
					var o, s, c, h = [],
						l = [],
						u = [],
						p = [],
						d = t,
						f = (e - t) / (n = void 0 !== n ? Math.max(1, n) : 1),
						m = new li,
						g = new si;
					for (s = 0; s <= n; s++) {
						for (c = 0; c <= i; c++) o = r + c / i * a, m.x = d * Math.cos(o), m.y = d * Math.sin(o),
							l.push(m.x, m.y, m.z), u.push(0, 0, 1), g.x = (m.x / e + 1) / 2, g.y = (m.y / e + 1) /
							2, p.push(g.x, g.y);
						d += f
					}
					for (s = 0; s < n; s++) {
						var v = s * (i + 1);
						for (c = 0; c < i; c++) {
							var y = o = c + v,
								x = o + i + 1,
								b = o + i + 2,
								_ = o + 1;
							h.push(y, x, _), h.push(x, b, _)
						}
					}
					this.setIndex(h), this.addAttribute("position", new jn(l, 3)), this.addAttribute("normal",
						new jn(u, 3)), this.addAttribute("uv", new jn(p, 2))
				}

				function Ac(t, e, i, n) {
					In.call(this), this.type = "LatheGeometry", this.parameters = {
						points: t,
						segments: e,
						phiStart: i,
						phiLength: n
					}, this.fromBufferGeometry(new Lc(t, e, i, n)), this.mergeVertices()
				}

				function Lc(t, e, i, n) {
					nr.call(this), this.type = "LatheBufferGeometry", this.parameters = {
						points: t,
						segments: e,
						phiStart: i,
						phiLength: n
					}, e = Math.floor(e) || 12, i = i || 0, n = n || 2 * Math.PI, n = oi.clamp(n, 0, 2 * Math
						.PI);
					var r, a, o, s = [],
						c = [],
						h = [],
						l = 1 / e,
						u = new li,
						p = new si;
					for (a = 0; a <= e; a++) {
						var d = i + a * l * n,
							f = Math.sin(d),
							m = Math.cos(d);
						for (o = 0; o <= t.length - 1; o++) u.x = t[o].x * f, u.y = t[o].y, u.z = t[o].x * m, c
							.push(u.x, u.y, u.z), p.x = a / e, p.y = o / (t.length - 1), h.push(p.x, p.y)
					}
					for (a = 0; a < e; a++)
						for (o = 0; o < t.length - 1; o++) {
							var g = r = o + a * t.length,
								v = r + t.length,
								y = r + t.length + 1,
								x = r + 1;
							s.push(g, v, x), s.push(v, y, x)
						}
					if (this.setIndex(s), this.addAttribute("position", new jn(c, 3)), this.addAttribute("uv",
							new jn(h, 2)), this.computeVertexNormals(), n === 2 * Math.PI) {
						var b = this.attributes.normal.array,
							_ = new li,
							w = new li,
							M = new li;
						for (r = e * t.length * 3, o = a = 0; a < t.length; a++, o += 3) _.x = b[o + 0], _.y = b[
								o + 1], _.z = b[o + 2], w.x = b[r + o + 0], w.y = b[r + o + 1], w.z = b[r + o +
							2], M.addVectors(_, w).normalize(), b[o + 0] = b[r + o + 0] = M.x, b[o + 1] = b[r +
								o + 1] = M.y, b[o + 2] = b[r + o + 2] = M.z
					}
				}

				function Pc(t, e) {
					In.call(this), this.type = "ShapeGeometry", "object" == typeof e && (console.warn(
							"THREE.ShapeGeometry: Options parameter has been removed."), e = e.curveSegments),
						this.parameters = {
							shapes: t,
							curveSegments: e
						}, this.fromBufferGeometry(new Rc(t, e)), this.mergeVertices()
				}

				function Rc(t, f) {
					nr.call(this), this.type = "ShapeBufferGeometry", this.parameters = {
						shapes: t,
						curveSegments: f
					}, f = f || 12;
					var m = [],
						g = [],
						v = [],
						y = [],
						e = 0,
						x = 0;
					if (!1 === Array.isArray(t)) n(t);
					else
						for (var i = 0; i < t.length; i++) n(t[i]), this.addGroup(e, x, i), e += x, x = 0;

					function n(t) {
						var e, i, n, r = g.length / 3,
							a = t.extractPoints(f),
							o = a.shape,
							s = a.holes;
						for (!1 === fc.isClockWise(o) && (o = o.reverse()), e = 0, i = s.length; e < i; e++) n =
							s[e], !0 === fc.isClockWise(n) && (s[e] = n.reverse());
						var c = fc.triangulateShape(o, s);
						for (e = 0, i = s.length; e < i; e++) n = s[e], o = o.concat(n);
						for (e = 0, i = o.length; e < i; e++) {
							var h = o[e];
							g.push(h.x, h.y, 0), v.push(0, 0, 1), y.push(h.x, h.y)
						}
						for (e = 0, i = c.length; e < i; e++) {
							var l = c[e],
								u = l[0] + r,
								p = l[1] + r,
								d = l[2] + r;
							m.push(u, p, d), x += 3
						}
					}
					this.setIndex(m), this.addAttribute("position", new jn(g, 3)), this.addAttribute("normal",
						new jn(v, 3)), this.addAttribute("uv", new jn(y, 2))
				}

				function Cc(t, e) {
					if (e.shapes = [], Array.isArray(t))
						for (var i = 0, n = t.length; i < n; i++) {
							var r = t[i];
							e.shapes.push(r.uuid)
						} else e.shapes.push(t.uuid);
					return e
				}

				function Oc(t, e) {
					nr.call(this), this.type = "EdgesGeometry", this.parameters = {
						thresholdAngle: e
					}, e = void 0 !== e ? e : 1;
					var i, n, r, a, o = [],
						s = Math.cos(oi.DEG2RAD * e),
						c = [0, 0],
						h = {},
						l = ["a", "b", "c"];
					t.isBufferGeometry ? (a = new In).fromBufferGeometry(t) : a = t.clone(), a.mergeVertices(), a
						.computeFaceNormals();
					for (var u = a.vertices, p = a.faces, d = 0, f = p.length; d < f; d++)
						for (var m = p[d], g = 0; g < 3; g++) i = m[l[g]], n = m[l[(g + 1) % 3]], c[0] = Math.min(
							i, n), c[1] = Math.max(i, n), void 0 === h[r = c[0] + "," + c[1]] ? h[r] = {
							index1: c[0],
							index2: c[1],
							face1: d,
							face2: void 0
						} : h[r].face2 = d;
					for (r in h) {
						var v = h[r];
						if (void 0 === v.face2 || p[v.face1].normal.dot(p[v.face2].normal) <= s) {
							var y = u[v.index1];
							o.push(y.x, y.y, y.z), y = u[v.index2], o.push(y.x, y.y, y.z)
						}
					}
					this.addAttribute("position", new jn(o, 3))
				}

				function Ic(t, e, i, n, r, a, o, s) {
					In.call(this), this.type = "CylinderGeometry", this.parameters = {
						radiusTop: t,
						radiusBottom: e,
						height: i,
						radialSegments: n,
						heightSegments: r,
						openEnded: a,
						thetaStart: o,
						thetaLength: s
					}, this.fromBufferGeometry(new Dc(t, e, i, n, r, a, o, s)), this.mergeVertices()
				}

				function Dc(v, y, x, b, _, t, w, M) {
					nr.call(this), this.type = "CylinderBufferGeometry", this.parameters = {
						radiusTop: v,
						radiusBottom: y,
						height: x,
						radialSegments: b,
						heightSegments: _,
						openEnded: t,
						thetaStart: w,
						thetaLength: M
					};
					var S = this;
					v = void 0 !== v ? v : 1, y = void 0 !== y ? y : 1, x = x || 1, b = Math.floor(b) || 8, _ =
						Math.floor(_) || 1, t = void 0 !== t && t, w = void 0 !== w ? w : 0, M = void 0 !== M ?
						M : 2 * Math.PI;
					var E = [],
						T = [],
						A = [],
						L = [],
						P = 0,
						R = [],
						C = x / 2,
						O = 0;

					function e() {
						var t, e, i = new li,
							n = new li,
							r = 0,
							a = (y - v) / x;
						for (e = 0; e <= _; e++) {
							var o = [],
								s = e / _,
								c = s * (y - v) + v;
							for (t = 0; t <= b; t++) {
								var h = t / b,
									l = h * M + w,
									u = Math.sin(l),
									p = Math.cos(l);
								n.x = c * u, n.y = -s * x + C, n.z = c * p, T.push(n.x, n.y, n.z), i.set(u, a, p)
									.normalize(), A.push(i.x, i.y, i.z), L.push(h, 1 - s), o.push(P++)
							}
							R.push(o)
						}
						for (t = 0; t < b; t++)
							for (e = 0; e < _; e++) {
								var d = R[e][t],
									f = R[e + 1][t],
									m = R[e + 1][t + 1],
									g = R[e][t + 1];
								E.push(d, f, g), E.push(f, m, g), r += 6
							}
						S.addGroup(O, r, 0), O += r
					}

					function i(t) {
						var e, i, n, r = new si,
							a = new li,
							o = 0,
							s = !0 === t ? v : y,
							c = !0 === t ? 1 : -1;
						for (i = P, e = 1; e <= b; e++) T.push(0, C * c, 0), A.push(0, c, 0), L.push(.5, .5), P++;
						for (n = P, e = 0; e <= b; e++) {
							var h = e / b * M + w,
								l = Math.cos(h),
								u = Math.sin(h);
							a.x = s * u, a.y = C * c, a.z = s * l, T.push(a.x, a.y, a.z), A.push(0, c, 0), r.x =
								.5 * l + .5, r.y = .5 * u * c + .5, L.push(r.x, r.y), P++
						}
						for (e = 0; e < b; e++) {
							var p = i + e,
								d = n + e;
							!0 === t ? E.push(d, d + 1, p) : E.push(d + 1, d, p), o += 3
						}
						S.addGroup(O, o, !0 === t ? 1 : 2), O += o
					}
					e(), !1 === t && (0 < v && i(!0), 0 < y && i(!1)), this.setIndex(E), this.addAttribute(
							"position", new jn(T, 3)), this.addAttribute("normal", new jn(A, 3)), this
						.addAttribute("uv", new jn(L, 2))
				}

				function Bc(t, e, i, n, r, a, o) {
					Ic.call(this, 0, t, e, i, n, r, a, o), this.type = "ConeGeometry", this.parameters = {
						radius: t,
						height: e,
						radialSegments: i,
						heightSegments: n,
						openEnded: r,
						thetaStart: a,
						thetaLength: o
					}
				}

				function zc(t, e, i, n, r, a, o) {
					Dc.call(this, 0, t, e, i, n, r, a, o), this.type = "ConeBufferGeometry", this.parameters = {
						radius: t,
						height: e,
						radialSegments: i,
						heightSegments: n,
						openEnded: r,
						thetaStart: a,
						thetaLength: o
					}
				}

				function Nc(t, e, i, n) {
					In.call(this), this.type = "CircleGeometry", this.parameters = {
						radius: t,
						segments: e,
						thetaStart: i,
						thetaLength: n
					}, this.fromBufferGeometry(new Gc(t, e, i, n)), this.mergeVertices()
				}

				function Gc(t, e, i, n) {
					nr.call(this), this.type = "CircleBufferGeometry", this.parameters = {
							radius: t,
							segments: e,
							thetaStart: i,
							thetaLength: n
						}, t = t || 1, e = void 0 !== e ? Math.max(3, e) : 8, i = void 0 !== i ? i : 0, n =
						void 0 !== n ? n : 2 * Math.PI;
					var r, a, o = [],
						s = [],
						c = [],
						h = [],
						l = new li,
						u = new si;
					for (s.push(0, 0, 0), c.push(0, 0, 1), h.push(.5, .5), a = 0, r = 3; a <= e; a++, r += 3) {
						var p = i + a / e * n;
						l.x = t * Math.cos(p), l.y = t * Math.sin(p), s.push(l.x, l.y, l.z), c.push(0, 0, 1), u
							.x = (s[r] / t + 1) / 2, u.y = (s[r + 1] / t + 1) / 2, h.push(u.x, u.y)
					}
					for (r = 1; r <= e; r++) o.push(r, r + 1, 0);
					this.setIndex(o), this.addAttribute("position", new jn(s, 3)), this.addAttribute("normal",
						new jn(c, 3)), this.addAttribute("uv", new jn(h, 2))
				}
				_c.prototype = Object.create(In.prototype), _c.prototype.constructor = _c, wc.prototype = Object
					.create(yc.prototype), wc.prototype.constructor = wc, Mc.prototype = Object.create(In
						.prototype), Mc.prototype.constructor = Mc, Sc.prototype = Object.create(nr.prototype), Sc
					.prototype.constructor = Sc, Ec.prototype = Object.create(In.prototype), Ec.prototype
					.constructor = Ec, Tc.prototype = Object.create(nr.prototype), Tc.prototype.constructor = Tc,
					Ac.prototype = Object.create(In.prototype), Ac.prototype.constructor = Ac, Lc.prototype =
					Object.create(nr.prototype), Lc.prototype.constructor = Lc, Pc.prototype = Object.create(In
						.prototype), (Pc.prototype.constructor = Pc).prototype.toJSON = function () {
						var t = In.prototype.toJSON.call(this);
						return Cc(this.parameters.shapes, t)
					}, Rc.prototype = Object.create(nr.prototype), (Rc.prototype.constructor = Rc).prototype
					.toJSON = function () {
						var t = nr.prototype.toJSON.call(this);
						return Cc(this.parameters.shapes, t)
					}, Oc.prototype = Object.create(nr.prototype), Oc.prototype.constructor = Oc, Ic.prototype =
					Object.create(In.prototype), Ic.prototype.constructor = Ic, Dc.prototype = Object.create(nr
						.prototype), Dc.prototype.constructor = Dc, Bc.prototype = Object.create(Ic.prototype), Bc
					.prototype.constructor = Bc, zc.prototype = Object.create(Dc.prototype), zc.prototype
					.constructor = zc, Nc.prototype = Object.create(In.prototype), Nc.prototype.constructor = Nc,
					Gc.prototype = Object.create(nr.prototype), Gc.prototype.constructor = Gc;
				var Uc = Object.freeze({
					WireframeGeometry: bs,
					ParametricGeometry: _s,
					ParametricBufferGeometry: ws,
					TetrahedronGeometry: Es,
					TetrahedronBufferGeometry: Ts,
					OctahedronGeometry: As,
					OctahedronBufferGeometry: Ls,
					IcosahedronGeometry: Ps,
					IcosahedronBufferGeometry: Rs,
					DodecahedronGeometry: Cs,
					DodecahedronBufferGeometry: Os,
					PolyhedronGeometry: Ms,
					PolyhedronBufferGeometry: Ss,
					TubeGeometry: Is,
					TubeBufferGeometry: Ds,
					TorusKnotGeometry: Bs,
					TorusKnotBufferGeometry: zs,
					TorusGeometry: Ns,
					TorusBufferGeometry: Gs,
					TextGeometry: _c,
					TextBufferGeometry: wc,
					SphereGeometry: Mc,
					SphereBufferGeometry: Sc,
					RingGeometry: Ec,
					RingBufferGeometry: Tc,
					PlaneGeometry: or,
					PlaneBufferGeometry: sr,
					LatheGeometry: Ac,
					LatheBufferGeometry: Lc,
					ShapeGeometry: Pc,
					ShapeBufferGeometry: Rc,
					ExtrudeGeometry: vc,
					ExtrudeBufferGeometry: yc,
					EdgesGeometry: Oc,
					ConeGeometry: Bc,
					ConeBufferGeometry: zc,
					CylinderGeometry: Ic,
					CylinderBufferGeometry: Dc,
					CircleGeometry: Nc,
					CircleBufferGeometry: Gc,
					BoxGeometry: rr,
					BoxBufferGeometry: ar
				});

				function Fc(t) {
					hr.call(this), this.type = "ShadowMaterial", this.color = new Yi(0), this.transparent = !0,
						this.setValues(t)
				}

				function Hc(t) {
					Nr.call(this, t), this.type = "RawShaderMaterial"
				}

				function jc(t) {
					hr.call(this), this.defines = {
							STANDARD: ""
						}, this.type = "MeshStandardMaterial", this.color = new Yi(16777215), this.roughness = .5,
						this.metalness = .5, this.map = null, this.lightMap = null, this.lightMapIntensity = 1,
						this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Yi(0), this
						.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1,
						this.normalMap = null, this.normalMapType = ri, this.normalScale = new si(1, 1), this
						.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this
						.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null,
						this.envMapIntensity = 1, this.refractionRatio = .98, this.wireframe = !1, this
						.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin =
						"round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this
						.setValues(t)
				}

				function kc(t) {
					jc.call(this), this.defines = {
							PHYSICAL: ""
						}, this.type = "MeshPhysicalMaterial", this.reflectivity = .5, this.clearCoat = 0, this
						.clearCoatRoughness = 0, this.setValues(t)
				}

				function Vc(t) {
					hr.call(this), this.type = "MeshPhongMaterial", this.color = new Yi(16777215), this.specular =
						new Yi(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this
						.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive =
						new Yi(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this
						.bumpScale = 1, this.normalMap = null, this.normalMapType = ri, this.normalScale = new si(
							1, 1), this.displacementMap = null, this.displacementScale = 1, this
						.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null,
						this.combine = $, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1,
						this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin =
						"round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this
						.setValues(t)
				}

				function Wc(t) {
					Vc.call(this), this.defines = {
						TOON: ""
					}, this.type = "MeshToonMaterial", this.gradientMap = null, this.setValues(t)
				}

				function qc(t) {
					hr.call(this), this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this
						.normalMap = null, this.normalMapType = ri, this.normalScale = new si(1, 1), this
						.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this
						.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this
						.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(t)
				}

				function Xc(t) {
					hr.call(this), this.type = "MeshLambertMaterial", this.color = new Yi(16777215), this.map =
						null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this
						.aoMapIntensity = 1, this.emissive = new Yi(0), this.emissiveIntensity = 1, this
						.emissiveMap = null, this.specularMap = null, this.alphaMap = null, this.envMap = null,
						this.combine = $, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1,
						this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin =
						"round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this
						.setValues(t)
				}

				function Yc(t) {
					hr.call(this), this.defines = {
							MATCAP: ""
						}, this.type = "MeshMatcapMaterial", this.color = new Yi(16777215), this.matcap = null,
						this.map = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this
						.normalMapType = ri, this.normalScale = new si(1, 1), this.displacementMap = null, this
						.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.skinning = !
						1, this.morphTargets = !1, this.morphNormals = !1, this.lights = !1, this.setValues(t)
				}

				function Zc(t) {
					ls.call(this), this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this
						.gapSize = 1, this.setValues(t)
				}
				Fc.prototype = Object.create(hr.prototype), (Fc.prototype.constructor = Fc).prototype
					.isShadowMaterial = !0, Fc.prototype.copy = function (t) {
						return hr.prototype.copy.call(this, t), this.color.copy(t.color), this
					}, Hc.prototype = Object.create(Nr.prototype), (Hc.prototype.constructor = Hc).prototype
					.isRawShaderMaterial = !0, jc.prototype = Object.create(hr.prototype), (jc.prototype
						.constructor = jc).prototype.isMeshStandardMaterial = !0, jc.prototype.copy = function (
					t) {
						return hr.prototype.copy.call(this, t), this.defines = {
								STANDARD: ""
							}, this.color.copy(t.color), this.roughness = t.roughness, this.metalness = t
							.metalness, this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t
							.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this
							.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity =
							t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this
							.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(
								t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale =
							t.displacementScale, this.displacementBias = t.displacementBias, this.roughnessMap = t
							.roughnessMap, this.metalnessMap = t.metalnessMap, this.alphaMap = t.alphaMap, this
							.envMap = t.envMap, this.envMapIntensity = t.envMapIntensity, this.refractionRatio = t
							.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t
							.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this
							.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this
							.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this
					}, kc.prototype = Object.create(jc.prototype), (kc.prototype.constructor = kc).prototype
					.isMeshPhysicalMaterial = !0, kc.prototype.copy = function (t) {
						return jc.prototype.copy.call(this, t), this.defines = {
								PHYSICAL: ""
							}, this.reflectivity = t.reflectivity, this.clearCoat = t.clearCoat, this
							.clearCoatRoughness = t.clearCoatRoughness, this
					}, Vc.prototype = Object.create(hr.prototype), (Vc.prototype.constructor = Vc).prototype
					.isMeshPhongMaterial = !0, Vc.prototype.copy = function (t) {
						return hr.prototype.copy.call(this, t), this.color.copy(t.color), this.specular.copy(t
								.specular), this.shininess = t.shininess, this.map = t.map, this.lightMap = t
							.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this
							.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap =
							t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap,
							this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t
							.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t
							.displacementMap, this.displacementScale = t.displacementScale, this
							.displacementBias = t.displacementBias, this.specularMap = t.specularMap, this
							.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this
							.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this
							.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this
							.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin,
							this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t
							.morphNormals, this
					}, Wc.prototype = Object.create(Vc.prototype), (Wc.prototype.constructor = Wc).prototype
					.isMeshToonMaterial = !0, Wc.prototype.copy = function (t) {
						return Vc.prototype.copy.call(this, t), this.gradientMap = t.gradientMap, this
					}, qc.prototype = Object.create(hr.prototype), (qc.prototype.constructor = qc).prototype
					.isMeshNormalMaterial = !0, qc.prototype.copy = function (t) {
						return hr.prototype.copy.call(this, t), this.bumpMap = t.bumpMap, this.bumpScale = t
							.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this
							.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this
							.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias,
							this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this
							.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t
							.morphNormals, this
					}, Xc.prototype = Object.create(hr.prototype), (Xc.prototype.constructor = Xc).prototype
					.isMeshLambertMaterial = !0, Xc.prototype.copy = function (t) {
						return hr.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this
							.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t
							.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this
							.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this
							.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this
							.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t
							.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t
							.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this
							.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this
							.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this
					}, Yc.prototype = Object.create(hr.prototype), (Yc.prototype.constructor = Yc).prototype
					.isMeshMatcapMaterial = !0, Yc.prototype.copy = function (t) {
						return hr.prototype.copy.call(this, t), this.defines = {
								MATCAP: ""
							}, this.color.copy(t.color), this.matcap = t.matcap, this.map = t.map, this.bumpMap =
							t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this
							.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this
							.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale,
							this.displacementBias = t.displacementBias, this.alphaMap = t.alphaMap, this
							.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t
							.morphNormals, this
					}, Zc.prototype = Object.create(ls.prototype), (Zc.prototype.constructor = Zc).prototype
					.isLineDashedMaterial = !0, Zc.prototype.copy = function (t) {
						return ls.prototype.copy.call(this, t), this.scale = t.scale, this.dashSize = t.dashSize,
							this.gapSize = t.gapSize, this
					};
				var Jc = Object.freeze({
						ShadowMaterial: Fc,
						SpriteMaterial: rs,
						RawShaderMaterial: Hc,
						ShaderMaterial: Nr,
						PointsMaterial: fs,
						MeshPhysicalMaterial: kc,
						MeshStandardMaterial: jc,
						MeshPhongMaterial: Vc,
						MeshToonMaterial: Wc,
						MeshNormalMaterial: qc,
						MeshLambertMaterial: Xc,
						MeshDepthMaterial: _o,
						MeshDistanceMaterial: wo,
						MeshBasicMaterial: Fr,
						MeshMatcapMaterial: Yc,
						LineDashedMaterial: Zc,
						LineBasicMaterial: ls,
						Material: hr
					}),
					Qc = {
						arraySlice: function (t, e, i) {
							return Qc.isTypedArray(t) ? new t.constructor(t.subarray(e, void 0 !== i ? i : t
								.length)) : t.slice(e, i)
						},
						convertArray: function (t, e, i) {
							return !t || !i && t.constructor === e ? t : "number" == typeof e
								.BYTES_PER_ELEMENT ? new e(t) : Array.prototype.slice.call(t)
						},
						isTypedArray: function (t) {
							return ArrayBuffer.isView(t) && !(t instanceof DataView)
						},
						getKeyframeOrder: function (i) {
							function t(t, e) {
								return i[t] - i[e]
							}
							for (var e = i.length, n = new Array(e), r = 0; r !== e; ++r) n[r] = r;
							return n.sort(t), n
						},
						sortedArray: function (t, e, i) {
							for (var n = t.length, r = new t.constructor(n), a = 0, o = 0; o !== n; ++a)
								for (var s = i[a] * e, c = 0; c !== e; ++c) r[o++] = t[s + c];
							return r
						},
						flattenJSON: function (t, e, i, n) {
							for (var r = 1, a = t[0]; void 0 !== a && void 0 === a[n];) a = t[r++];
							if (void 0 !== a) {
								var o = a[n];
								if (void 0 !== o)
									if (Array.isArray(o))
										for (; void 0 !== (o = a[n]) && (e.push(a.time), i.push.apply(i, o)),
											void 0 !== (a = t[r++]););
									else if (void 0 !== o.toArray)
									for (; void 0 !== (o = a[n]) && (e.push(a.time), o.toArray(i, i.length)),
										void 0 !== (a = t[r++]););
								else
									for (; void 0 !== (o = a[n]) && (e.push(a.time), i.push(o)), void 0 !== (
											a = t[r++]););
							}
						}
					};

				function Kc(t, e, i, n) {
					this.parameterPositions = t, this._cachedIndex = 0, this.resultBuffer = void 0 !== n ? n :
						new e.constructor(i), this.sampleValues = e, this.valueSize = i
				}

				function $c(t, e, i, n) {
					Kc.call(this, t, e, i, n), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -
						0, this._offsetNext = -0
				}

				function th(t, e, i, n) {
					Kc.call(this, t, e, i, n)
				}

				function eh(t, e, i, n) {
					Kc.call(this, t, e, i, n)
				}

				function ih(t, e, i, n) {
					if (void 0 === t) throw new Error("THREE.KeyframeTrack: track name is undefined");
					if (void 0 === e || 0 === e.length) throw new Error(
						"THREE.KeyframeTrack: no keyframes in track named " + t);
					this.name = t, this.times = Qc.convertArray(e, this.TimeBufferType), this.values = Qc
						.convertArray(i, this.ValueBufferType), this.setInterpolation(n || this
							.DefaultInterpolation)
				}

				function nh(t, e, i) {
					ih.call(this, t, e, i)
				}

				function rh(t, e, i, n) {
					ih.call(this, t, e, i, n)
				}

				function ah(t, e, i, n) {
					ih.call(this, t, e, i, n)
				}

				function oh(t, e, i, n) {
					Kc.call(this, t, e, i, n)
				}

				function sh(t, e, i, n) {
					ih.call(this, t, e, i, n)
				}

				function ch(t, e, i, n) {
					ih.call(this, t, e, i, n)
				}

				function hh(t, e, i, n) {
					ih.call(this, t, e, i, n)
				}

				function lh(t, e, i) {
					this.name = t, this.tracks = i, this.duration = void 0 !== e ? e : -1, this.uuid = oi
						.generateUUID(), this.duration < 0 && this.resetDuration()
				}

				function uh(t) {
					switch (t.toLowerCase()) {
						case "scalar":
						case "double":
						case "float":
						case "number":
						case "integer":
							return ah;
						case "vector":
						case "vector2":
						case "vector3":
						case "vector4":
							return hh;
						case "color":
							return rh;
						case "quaternion":
							return sh;
						case "bool":
						case "boolean":
							return nh;
						case "string":
							return ch
					}
					throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + t)
				}

				function ph(t) {
					if (void 0 === t.type) throw new Error(
						"THREE.KeyframeTrack: track type undefined, can not parse");
					var e = uh(t.type);
					if (void 0 === t.times) {
						var i = [],
							n = [];
						Qc.flattenJSON(t.keys, i, n, "value"), t.times = i, t.values = n
					}
					return void 0 !== e.parse ? e.parse(t) : new e(t.name, t.times, t.values, t.interpolation)
				}
				Object.assign(Kc.prototype, {
					evaluate: function (t) {
						var e = this.parameterPositions,
							i = this._cachedIndex,
							n = e[i],
							r = e[i - 1];
						t: {
							e: {
								var a;i: {
									n: if (!(t < n)) {
										for (var o = i + 2;;) {
											if (void 0 === n) {
												if (t < r) break n;
												return i = e.length, this._cachedIndex = i,
													this.afterEnd_(i - 1, t, r)
											}
											if (i === o) break;
											if (r = n, t < (n = e[++i])) break e
										}
										a = e.length;
										break i
									}if (r <= t) break t;
									var s = e[1];t < s && (i = 2, r = s);
									for (o = i - 2;;) {
										if (void 0 === r) return this._cachedIndex = 0, this
											.beforeStart_(0, t, n);
										if (i === o) break;
										if (n = r, (r = e[--i - 1]) <= t) break e
									}
									a = i,
									i = 0
								}
								for (; i < a;) {
									var c = i + a >>> 1;
									t < e[c] ? a = c : i = c + 1
								}
								if (n = e[i], void 0 === (r = e[i - 1])) return this
									._cachedIndex = 0,
								this.beforeStart_(0, t, n);
								if (void 0 === n) return i = e.length,
								this._cachedIndex = i,
								this.afterEnd_(i - 1, r, t)
							}
							this._cachedIndex = i,
							this.intervalChanged_(i, r, n)
						}
						return this.interpolate_(i, r, t, n)
					},
					settings: null,
					DefaultSettings_: {},
					getSettings_: function () {
						return this.settings || this.DefaultSettings_
					},
					copySampleValue_: function (t) {
						for (var e = this.resultBuffer, i = this.sampleValues, n = this.valueSize, r =
								t * n, a = 0; a !== n; ++a) e[a] = i[r + a];
						return e
					},
					interpolate_: function () {
						throw new Error("call to abstract method")
					},
					intervalChanged_: function () {}
				}), Object.assign(Kc.prototype, {
					beforeStart_: Kc.prototype.copySampleValue_,
					afterEnd_: Kc.prototype.copySampleValue_
				}), $c.prototype = Object.assign(Object.create(Kc.prototype), {
					constructor: $c,
					DefaultSettings_: {
						endingStart: je,
						endingEnd: je
					},
					intervalChanged_: function (t, e, i) {
						var n = this.parameterPositions,
							r = t - 2,
							a = t + 1,
							o = n[r],
							s = n[a];
						if (void 0 === o) switch (this.getSettings_().endingStart) {
							case ke:
								r = t, o = 2 * e - i;
								break;
							case Ve:
								o = e + n[r = n.length - 2] - n[r + 1];
								break;
							default:
								r = t, o = i
						}
						if (void 0 === s) switch (this.getSettings_().endingEnd) {
							case ke:
								a = t, s = 2 * i - e;
								break;
							case Ve:
								s = i + n[a = 1] - n[0];
								break;
							default:
								a = t - 1, s = e
						}
						var c = .5 * (i - e),
							h = this.valueSize;
						this._weightPrev = c / (e - o), this._weightNext = c / (s - i), this
							._offsetPrev = r * h, this._offsetNext = a * h
					},
					interpolate_: function (t, e, i, n) {
						for (var r = this.resultBuffer, a = this.sampleValues, o = this.valueSize, s =
								t * o, c = s - o, h = this._offsetPrev, l = this._offsetNext, u = this
								._weightPrev, p = this._weightNext, d = (i - e) / (n - e), f = d * d,
								m = f * d, g = -u * m + 2 * u * f - u * d, v = (1 + u) * m + (-1.5 -
									2 * u) * f + (-.5 + u) * d + 1, y = (-1 - p) * m + (1.5 + p) * f +
								.5 * d, x = p * m - p * f, b = 0; b !== o; ++b) r[b] = g * a[h + b] +
							v * a[c + b] + y * a[s + b] + x * a[l + b];
						return r
					}
				}), th.prototype = Object.assign(Object.create(Kc.prototype), {
					constructor: th,
					interpolate_: function (t, e, i, n) {
						for (var r = this.resultBuffer, a = this.sampleValues, o = this.valueSize, s =
								t * o, c = s - o, h = (i - e) / (n - e), l = 1 - h, u = 0; u !== o; ++
							u) r[u] = a[c + u] * l + a[s + u] * h;
						return r
					}
				}), eh.prototype = Object.assign(Object.create(Kc.prototype), {
					constructor: eh,
					interpolate_: function (t) {
						return this.copySampleValue_(t - 1)
					}
				}), Object.assign(ih, {
					toJSON: function (t) {
						var e, i = t.constructor;
						if (void 0 !== i.toJSON) e = i.toJSON(t);
						else {
							e = {
								name: t.name,
								times: Qc.convertArray(t.times, Array),
								values: Qc.convertArray(t.values, Array)
							};
							var n = t.getInterpolation();
							n !== t.DefaultInterpolation && (e.interpolation = n)
						}
						return e.type = t.ValueTypeName, e
					}
				}), Object.assign(ih.prototype, {
					constructor: ih,
					TimeBufferType: Float32Array,
					ValueBufferType: Float32Array,
					DefaultInterpolation: Fe,
					InterpolantFactoryMethodDiscrete: function (t) {
						return new eh(this.times, this.values, this.getValueSize(), t)
					},
					InterpolantFactoryMethodLinear: function (t) {
						return new th(this.times, this.values, this.getValueSize(), t)
					},
					InterpolantFactoryMethodSmooth: function (t) {
						return new $c(this.times, this.values, this.getValueSize(), t)
					},
					setInterpolation: function (t) {
						var e;
						switch (t) {
							case Ue:
								e = this.InterpolantFactoryMethodDiscrete;
								break;
							case Fe:
								e = this.InterpolantFactoryMethodLinear;
								break;
							case He:
								e = this.InterpolantFactoryMethodSmooth
						}
						if (void 0 !== e) return this.createInterpolant = e, this;
						var i = "unsupported interpolation for " + this.ValueTypeName +
							" keyframe track named " + this.name;
						if (void 0 === this.createInterpolant) {
							if (t === this.DefaultInterpolation) throw new Error(i);
							this.setInterpolation(this.DefaultInterpolation)
						}
						return console.warn("THREE.KeyframeTrack:", i), this
					},
					getInterpolation: function () {
						switch (this.createInterpolant) {
							case this.InterpolantFactoryMethodDiscrete:
								return Ue;
							case this.InterpolantFactoryMethodLinear:
								return Fe;
							case this.InterpolantFactoryMethodSmooth:
								return He
						}
					},
					getValueSize: function () {
						return this.values.length / this.times.length
					},
					shift: function (t) {
						if (0 !== t)
							for (var e = this.times, i = 0, n = e.length; i !== n; ++i) e[i] += t;
						return this
					},
					scale: function (t) {
						if (1 !== t)
							for (var e = this.times, i = 0, n = e.length; i !== n; ++i) e[i] *= t;
						return this
					},
					trim: function (t, e) {
						for (var i = this.times, n = i.length, r = 0, a = n - 1; r !== n && i[r] < t;)
							++r;
						for (; - 1 !== a && i[a] > e;) --a;
						if (++a, 0 !== r || a !== n) {
							a <= r && (r = (a = Math.max(a, 1)) - 1);
							var o = this.getValueSize();
							this.times = Qc.arraySlice(i, r, a), this.values = Qc.arraySlice(this
								.values, r * o, a * o)
						}
						return this
					},
					validate: function () {
						var t = !0,
							e = this.getValueSize();
						e - Math.floor(e) != 0 && (console.error(
								"THREE.KeyframeTrack: Invalid value size in track.", this), t = !
							1);
						var i = this.times,
							n = this.values,
							r = i.length;
						0 === r && (console.error("THREE.KeyframeTrack: Track is empty.", this), t = !
							1);
						for (var a = null, o = 0; o !== r; o++) {
							var s = i[o];
							if ("number" == typeof s && isNaN(s)) {
								console.error("THREE.KeyframeTrack: Time is not a valid number.",
									this, o, s), t = !1;
								break
							}
							if (null !== a && s < a) {
								console.error("THREE.KeyframeTrack: Out of order keys.", this, o, s,
									a), t = !1;
								break
							}
							a = s
						}
						if (void 0 !== n && Qc.isTypedArray(n)) {
							o = 0;
							for (var c = n.length; o !== c; ++o) {
								var h = n[o];
								if (isNaN(h)) {
									console.error("THREE.KeyframeTrack: Value is not a valid number.",
										this, o, h), t = !1;
									break
								}
							}
						}
						return t
					},
					optimize: function () {
						for (var t = this.times, e = this.values, i = this.getValueSize(), n = this
								.getInterpolation() === He, r = 1, a = t.length - 1, o = 1; o < a; ++
							o) {
							var s = !1,
								c = t[o];
							if (c !== t[o + 1] && (1 !== o || c !== c[0]))
								if (n) s = !0;
								else
									for (var h = o * i, l = h - i, u = h + i, p = 0; p !== i; ++p) {
										var d = e[h + p];
										if (d !== e[l + p] || d !== e[u + p]) {
											s = !0;
											break
										}
									}
							if (s) {
								if (o !== r) {
									t[r] = t[o];
									var f = o * i,
										m = r * i;
									for (p = 0; p !== i; ++p) e[m + p] = e[f + p]
								}++r
							}
						}
						if (0 < a) {
							t[r] = t[a];
							for (f = a * i, m = r * i, p = 0; p !== i; ++p) e[m + p] = e[f + p];
							++r
						}
						return r !== t.length && (this.times = Qc.arraySlice(t, 0, r), this.values =
							Qc.arraySlice(e, 0, r * i)), this
					},
					clone: function () {
						var t = Qc.arraySlice(this.times, 0),
							e = Qc.arraySlice(this.values, 0),
							i = new this.constructor(this.name, t, e);
						return i.createInterpolant = this.createInterpolant, i
					}
				}), nh.prototype = Object.assign(Object.create(ih.prototype), {
					constructor: nh,
					ValueTypeName: "bool",
					ValueBufferType: Array,
					DefaultInterpolation: Ue,
					InterpolantFactoryMethodLinear: void 0,
					InterpolantFactoryMethodSmooth: void 0
				}), rh.prototype = Object.assign(Object.create(ih.prototype), {
					constructor: rh,
					ValueTypeName: "color"
				}), ah.prototype = Object.assign(Object.create(ih.prototype), {
					constructor: ah,
					ValueTypeName: "number"
				}), oh.prototype = Object.assign(Object.create(Kc.prototype), {
					constructor: oh,
					interpolate_: function (t, e, i, n) {
						for (var r = this.resultBuffer, a = this.sampleValues, o = this.valueSize, s =
								t * o, c = (i - e) / (n - e), h = s + o; s !== h; s += 4) hi
							.slerpFlat(r, 0, a, s - o, a, s, c);
						return r
					}
				}), sh.prototype = Object.assign(Object.create(ih.prototype), {
					constructor: sh,
					ValueTypeName: "quaternion",
					DefaultInterpolation: Fe,
					InterpolantFactoryMethodLinear: function (t) {
						return new oh(this.times, this.values, this.getValueSize(), t)
					},
					InterpolantFactoryMethodSmooth: void 0
				}), ch.prototype = Object.assign(Object.create(ih.prototype), {
					constructor: ch,
					ValueTypeName: "string",
					ValueBufferType: Array,
					DefaultInterpolation: Ue,
					InterpolantFactoryMethodLinear: void 0,
					InterpolantFactoryMethodSmooth: void 0
				}), hh.prototype = Object.assign(Object.create(ih.prototype), {
					constructor: hh,
					ValueTypeName: "vector"
				}), Object.assign(lh, {
					parse: function (t) {
						for (var e = [], i = t.tracks, n = 1 / (t.fps || 1), r = 0, a = i
							.length; r !== a; ++r) e.push(ph(i[r]).scale(n));
						return new lh(t.name, t.duration, e)
					},
					toJSON: function (t) {
						for (var e = [], i = t.tracks, n = {
								name: t.name,
								duration: t.duration,
								tracks: e,
								uuid: t.uuid
							}, r = 0, a = i.length; r !== a; ++r) e.push(ih.toJSON(i[r]));
						return n
					},
					CreateFromMorphTargetSequence: function (t, e, i, n) {
						for (var r = e.length, a = [], o = 0; o < r; o++) {
							var s = [],
								c = [];
							s.push((o + r - 1) % r, o, (o + 1) % r), c.push(0, 1, 0);
							var h = Qc.getKeyframeOrder(s);
							s = Qc.sortedArray(s, 1, h), c = Qc.sortedArray(c, 1, h), n || 0 !== s[
								0] || (s.push(r), c.push(c[0])), a.push(new ah(
									".morphTargetInfluences[" + e[o].name + "]", s, c).scale(1 /
									i))
						}
						return new lh(t, -1, a)
					},
					findByName: function (t, e) {
						var i = t;
						if (!Array.isArray(t)) {
							var n = t;
							i = n.geometry && n.geometry.animations || n.animations
						}
						for (var r = 0; r < i.length; r++)
							if (i[r].name === e) return i[r];
						return null
					},
					CreateClipsFromMorphTargetSequences: function (t, e, i) {
						for (var n = {}, r = /^([\w-]*?)([\d]+)$/, a = 0, o = t.length; a < o; a++) {
							var s = t[a],
								c = s.name.match(r);
							if (c && 1 < c.length) {
								var h = n[u = c[1]];
								h || (n[u] = h = []), h.push(s)
							}
						}
						var l = [];
						for (var u in n) l.push(lh.CreateFromMorphTargetSequence(u, n[u], e, i));
						return l
					},
					parseAnimation: function (t, e) {
						if (!t) return console.error(
							"THREE.AnimationClip: No animation in JSONLoader data."), null;
						for (var i = function (t, e, i, n, r) {
									if (0 !== i.length) {
										var a = [],
											o = [];
										Qc.flattenJSON(i, a, o, n), 0 !== a.length && r.push(new t(e,
											a, o))
									}
								}, n = [], r = t.name || "default", a = t.length || -1, o = t.fps ||
								30, s = t.hierarchy || [], c = 0; c < s.length; c++) {
							var h = s[c].keys;
							if (h && 0 !== h.length)
								if (h[0].morphTargets) {
									for (var l = {}, u = 0; u < h.length; u++)
										if (h[u].morphTargets)
											for (var p = 0; p < h[u].morphTargets.length; p++) l[h[u]
												.morphTargets[p]] = -1;
									for (var d in l) {
										var f = [],
											m = [];
										for (p = 0; p !== h[u].morphTargets.length; ++p) {
											var g = h[u];
											f.push(g.time), m.push(g.morphTarget === d ? 1 : 0)
										}
										n.push(new ah(".morphTargetInfluence[" + d + "]", f, m))
									}
									a = l.length * (o || 1)
								} else {
									var v = ".bones[" + e[c].name + "]";
									i(hh, v + ".position", h, "pos", n), i(sh, v + ".quaternion", h,
										"rot", n), i(hh, v + ".scale", h, "scl", n)
								}
						}
						return 0 === n.length ? null : new lh(r, a, n)
					}
				}), Object.assign(lh.prototype, {
					resetDuration: function () {
						for (var t = 0, e = 0, i = this.tracks.length; e !== i; ++e) {
							var n = this.tracks[e];
							t = Math.max(t, n.times[n.times.length - 1])
						}
						return this.duration = t, this
					},
					trim: function () {
						for (var t = 0; t < this.tracks.length; t++) this.tracks[t].trim(0, this
							.duration);
						return this
					},
					validate: function () {
						for (var t = !0, e = 0; e < this.tracks.length; e++) t = t && this.tracks[e]
							.validate();
						return t
					},
					optimize: function () {
						for (var t = 0; t < this.tracks.length; t++) this.tracks[t].optimize();
						return this
					},
					clone: function () {
						for (var t = [], e = 0; e < this.tracks.length; e++) t.push(this.tracks[e]
							.clone());
						return new lh(this.name, this.duration, t)
					}
				});
				var dh = {
					enabled: !1,
					files: {},
					add: function (t, e) {
						!1 !== this.enabled && (this.files[t] = e)
					},
					get: function (t) {
						if (!1 !== this.enabled) return this.files[t]
					},
					remove: function (t) {
						delete this.files[t]
					},
					clear: function () {
						this.files = {}
					}
				};

				function fh(t, e, i) {
					var n = this,
						r = !1,
						a = 0,
						o = 0,
						s = void 0;
					this.onStart = void 0, this.onLoad = t, this.onProgress = e, this.onError = i, this
						.itemStart = function (t) {
							o++, !1 === r && void 0 !== n.onStart && n.onStart(t, a, o), r = !0
						}, this.itemEnd = function (t) {
							a++, void 0 !== n.onProgress && n.onProgress(t, a, o), a === o && (r = !1, void 0 !==
								n.onLoad && n.onLoad())
						}, this.itemError = function (t) {
							void 0 !== n.onError && n.onError(t)
						}, this.resolveURL = function (t) {
							return s ? s(t) : t
						}, this.setURLModifier = function (t) {
							return s = t, this
						}
				}
				var mh = new fh,
					gh = {};

				function vh(t) {
					this.manager = void 0 !== t ? t : mh
				}

				function yh(t) {
					this.manager = void 0 !== t ? t : mh
				}

				function xh(t) {
					this.manager = void 0 !== t ? t : mh, this._parser = null
				}

				function bh(t) {
					this.manager = void 0 !== t ? t : mh, this._parser = null
				}

				function _h(t) {
					this.manager = void 0 !== t ? t : mh
				}

				function wh(t) {
					this.manager = void 0 !== t ? t : mh
				}

				function Mh(t) {
					this.manager = void 0 !== t ? t : mh
				}

				function Sh() {
					this.type = "Curve", this.arcLengthDivisions = 200
				}

				function Eh(t, e, i, n, r, a, o, s) {
					Sh.call(this), this.type = "EllipseCurve", this.aX = t || 0, this.aY = e || 0, this.xRadius =
						i || 1, this.yRadius = n || 1, this.aStartAngle = r || 0, this.aEndAngle = a || 2 * Math
						.PI, this.aClockwise = o || !1, this.aRotation = s || 0
				}

				function Th(t, e, i, n, r, a) {
					Eh.call(this, t, e, i, i, n, r, a), this.type = "ArcCurve"
				}

				function Ah() {
					var r = 0,
						a = 0,
						o = 0,
						s = 0;

					function h(t, e, i, n) {
						o = -3 * (r = t) + 3 * e - 2 * (a = i) - n, s = 2 * t - 2 * e + i + n
					}
					return {
						initCatmullRom: function (t, e, i, n, r) {
							h(e, i, r * (i - t), r * (n - e))
						},
						initNonuniformCatmullRom: function (t, e, i, n, r, a, o) {
							var s = (e - t) / r - (i - t) / (r + a) + (i - e) / a,
								c = (i - e) / a - (n - e) / (a + o) + (n - i) / o;
							h(e, i, s *= a, c *= a)
						},
						calc: function (t) {
							var e = t * t;
							return r + a * t + o * e + s * (e * t)
						}
					}
				}
				Object.assign(vh.prototype, {
						load: function (o, t, e, i) {
							void 0 === o && (o = ""), void 0 !== this.path && (o = this.path + o), o =
								this.manager.resolveURL(o);
							var s = this,
								n = dh.get(o);
							if (void 0 !== n) return s.manager.itemStart(o), setTimeout(function () {
								t && t(n), s.manager.itemEnd(o)
							}, 0), n;
							if (void 0 === gh[o]) {
								var r = /^data:(.*?)(;base64)?,(.*)$/,
									a = o.match(r);
								if (a) {
									var c = a[1],
										h = !!a[2],
										l = a[3];
									l = decodeURIComponent(l), h && (l = atob(l));
									try {
										var u, p = (this.responseType || "").toLowerCase();
										switch (p) {
											case "arraybuffer":
											case "blob":
												for (var d = new Uint8Array(l.length), f = 0; f < l
													.length; f++) d[f] = l.charCodeAt(f);
												u = "blob" === p ? new Blob([d.buffer], {
													type: c
												}) : d.buffer;
												break;
											case "document":
												var m = new DOMParser;
												u = m.parseFromString(l, c);
												break;
											case "json":
												u = JSON.parse(l);
												break;
											default:
												u = l
										}
										setTimeout(function () {
											t && t(u), s.manager.itemEnd(o)
										}, 0)
									} catch (t) {
										setTimeout(function () {
											i && i(t), s.manager.itemError(o), s.manager.itemEnd(
												o)
										}, 0)
									}
								} else {
									gh[o] = [], gh[o].push({
										onLoad: t,
										onProgress: e,
										onError: i
									});
									var g = new XMLHttpRequest;
									for (var v in g.open("GET", o, !0), g.addEventListener("load",
												function (t) {
													var e = this.response;
													dh.add(o, e);
													var i = gh[o];
													if (delete gh[o], 200 === this.status || 0 === this
														.status) {
														0 === this.status && console.warn(
															"THREE.FileLoader: HTTP Status 0 received."
															);
														for (var n = 0, r = i.length; n < r; n++) {
															(a = i[n]).onLoad && a.onLoad(e)
														}
														s.manager.itemEnd(o)
													} else {
														for (n = 0, r = i.length; n < r; n++) {
															var a;
															(a = i[n]).onError && a.onError(t)
														}
														s.manager.itemError(o), s.manager.itemEnd(o)
													}
												}, !1), g.addEventListener("progress", function (t) {
												for (var e = gh[o], i = 0, n = e.length; i < n; i++) {
													var r = e[i];
													r.onProgress && r.onProgress(t)
												}
											}, !1), g.addEventListener("error", function (t) {
												var e = gh[o];
												delete gh[o];
												for (var i = 0, n = e.length; i < n; i++) {
													var r = e[i];
													r.onError && r.onError(t)
												}
												s.manager.itemError(o), s.manager.itemEnd(o)
											}, !1), g.addEventListener("abort", function (t) {
												var e = gh[o];
												delete gh[o];
												for (var i = 0, n = e.length; i < n; i++) {
													var r = e[i];
													r.onError && r.onError(t)
												}
												s.manager.itemError(o), s.manager.itemEnd(o)
											}, !1), void 0 !== this.responseType && (g.responseType = this
												.responseType), void 0 !== this.withCredentials && (g
												.withCredentials = this.withCredentials), g
											.overrideMimeType && g.overrideMimeType(void 0 !== this
												.mimeType ? this.mimeType : "text/plain"), this
											.requestHeader) g.setRequestHeader(v, this.requestHeader[v]);
									g.send(null)
								}
								return s.manager.itemStart(o), g
							}
							gh[o].push({
								onLoad: t,
								onProgress: e,
								onError: i
							})
						},
						setPath: function (t) {
							return this.path = t, this
						},
						setResponseType: function (t) {
							return this.responseType = t, this
						},
						setWithCredentials: function (t) {
							return this.withCredentials = t, this
						},
						setMimeType: function (t) {
							return this.mimeType = t, this
						},
						setRequestHeader: function (t) {
							return this.requestHeader = t, this
						}
					}), Object.assign(yh.prototype, {
						load: function (t, e, i, n) {
							var r = this,
								a = new vh(r.manager);
							a.setPath(r.path), a.load(t, function (t) {
								e(r.parse(JSON.parse(t)))
							}, i, n)
						},
						parse: function (t, e) {
							for (var i = [], n = 0; n < t.length; n++) {
								var r = lh.parse(t[n]);
								i.push(r)
							}
							e(i)
						},
						setPath: function (t) {
							return this.path = t, this
						}
					}), Object.assign(xh.prototype, {
						load: function (t, a, e, n) {
							var o = this,
								s = [],
								c = new vs;
							c.image = s;
							var r = new vh(this.manager);

							function i(i) {
								r.load(t[i], function (t) {
									var e = o._parser(t, !0);
									s[i] = {
										width: e.width,
										height: e.height,
										format: e.format,
										mipmaps: e.mipmaps
									}, 6 === (h += 1) && (1 === e.mipmapCount && (c
											.minFilter = Ft), c.format = e.format, c
										.needsUpdate = !0, a && a(c))
								}, e, n)
							}
							if (r.setPath(this.path), r.setResponseType("arraybuffer"), Array.isArray(t))
								for (var h = 0, l = 0, u = t.length; l < u; ++l) i(l);
							else r.load(t, function (t) {
								var e = o._parser(t, !0);
								if (e.isCubemap)
									for (var i = e.mipmaps.length / e.mipmapCount, n = 0; n <
										i; n++) {
										s[n] = {
											mipmaps: []
										};
										for (var r = 0; r < e.mipmapCount; r++) s[n].mipmaps.push(
												e.mipmaps[n * e.mipmapCount + r]), s[n].format = e
											.format, s[n].width = e.width, s[n].height = e.height
									} else c.image.width = e.width, c.image.height = e.height, c
										.mipmaps = e.mipmaps;
								1 === e.mipmapCount && (c.minFilter = Ft), c.format = e.format, c
									.needsUpdate = !0, a && a(c)
							}, e, n);
							return c
						},
						setPath: function (t) {
							return this.path = t, this
						}
					}), Object.assign(bh.prototype, {
						load: function (t, i, e, n) {
							var r = this,
								a = new Bi,
								o = new vh(this.manager);
							return o.setResponseType("arraybuffer"), o.setPath(this.path), o.load(t,
								function (t) {
									var e = r._parser(t);
									e && (void 0 !== e.image ? a.image = e.image : void 0 !== e
										.data && (a.image.width = e.width, a.image.height = e
											.height, a.image.data = e.data), a.wrapS = void 0 !==
										e.wrapS ? e.wrapS : Bt, a.wrapT = void 0 !== e.wrapT ? e
										.wrapT : Bt, a.magFilter = void 0 !== e.magFilter ? e
										.magFilter : Ft, a.minFilter = void 0 !== e.minFilter ? e
										.minFilter : Wt, a.anisotropy = void 0 !== e.anisotropy ?
										e.anisotropy : 1, void 0 !== e.format && (a.format = e
											.format), void 0 !== e.type && (a.type = e.type),
										void 0 !== e.mipmaps && (a.mipmaps = e.mipmaps), 1 === e
										.mipmapCount && (a.minFilter = Ft), a.needsUpdate = !0,
										i && i(a, e))
								}, e, n), a
						},
						setPath: function (t) {
							return this.path = t, this
						}
					}), Object.assign(_h.prototype, {
						crossOrigin: "anonymous",
						load: function (e, t, i, n) {
							void 0 === e && (e = ""), void 0 !== this.path && (e = this.path + e), e =
								this.manager.resolveURL(e);
							var r = this,
								a = dh.get(e);
							if (void 0 !== a) return r.manager.itemStart(e), setTimeout(function () {
								t && t(a), r.manager.itemEnd(e)
							}, 0), a;
							var o = document.createElement("img");

							function s() {
								o.removeEventListener("load", s, !1), o.removeEventListener("error", c, !
									1), dh.add(e, this), t && t(this), r.manager.itemEnd(e)
							}

							function c(t) {
								o.removeEventListener("load", s, !1), o.removeEventListener("error", c, !
									1), n && n(t), r.manager.itemError(e), r.manager.itemEnd(e)
							}
							return o.addEventListener("load", s, !1), o.addEventListener("error", c, !1),
								"data:" !== e.substr(0, 5) && void 0 !== this.crossOrigin && (o
									.crossOrigin = this.crossOrigin), r.manager.itemStart(e), o.src = e, o
						},
						setCrossOrigin: function (t) {
							return this.crossOrigin = t, this
						},
						setPath: function (t) {
							return this.path = t, this
						}
					}), Object.assign(wh.prototype, {
						crossOrigin: "anonymous",
						load: function (t, i, e, n) {
							var r = new $r,
								a = new _h(this.manager);
							a.setCrossOrigin(this.crossOrigin), a.setPath(this.path);
							var o = 0;

							function s(e) {
								a.load(t[e], function (t) {
									r.images[e] = t, 6 === ++o && (r.needsUpdate = !0, i && i(r))
								}, void 0, n)
							}
							for (var c = 0; c < t.length; ++c) s(c);
							return r
						},
						setCrossOrigin: function (t) {
							return this.crossOrigin = t, this
						},
						setPath: function (t) {
							return this.path = t, this
						}
					}), Object.assign(Mh.prototype, {
						crossOrigin: "anonymous",
						load: function (i, n, t, e) {
							var r = new Ri,
								a = new _h(this.manager);
							return a.setCrossOrigin(this.crossOrigin), a.setPath(this.path), a.load(i,
								function (t) {
									r.image = t;
									var e = 0 < i.search(/\.jpe?g($|\?)/i) || 0 === i.search(
										/^data\:image\/jpeg/);
									r.format = e ? ae : oe, r.needsUpdate = !0, void 0 !== n && n(r)
								}, t, e), r
						},
						setCrossOrigin: function (t) {
							return this.crossOrigin = t, this
						},
						setPath: function (t) {
							return this.path = t, this
						}
					}), Object.assign(Sh.prototype, {
						getPoint: function () {
							return console.warn("THREE.Curve: .getPoint() not implemented."), null
						},
						getPointAt: function (t, e) {
							var i = this.getUtoTmapping(t);
							return this.getPoint(i, e)
						},
						getPoints: function (t) {
							void 0 === t && (t = 5);
							for (var e = [], i = 0; i <= t; i++) e.push(this.getPoint(i / t));
							return e
						},
						getSpacedPoints: function (t) {
							void 0 === t && (t = 5);
							for (var e = [], i = 0; i <= t; i++) e.push(this.getPointAt(i / t));
							return e
						},
						getLength: function () {
							var t = this.getLengths();
							return t[t.length - 1]
						},
						getLengths: function (t) {
							if (void 0 === t && (t = this.arcLengthDivisions), this.cacheArcLengths &&
								this.cacheArcLengths.length === t + 1 && !this.needsUpdate) return this
								.cacheArcLengths;
							this.needsUpdate = !1;
							var e, i, n = [],
								r = this.getPoint(0),
								a = 0;
							for (n.push(0), i = 1; i <= t; i++) a += (e = this.getPoint(i / t))
								.distanceTo(r), n.push(a), r = e;
							return this.cacheArcLengths = n
						},
						updateArcLengths: function () {
							this.needsUpdate = !0, this.getLengths()
						},
						getUtoTmapping: function (t, e) {
							var i, n = this.getLengths(),
								r = 0,
								a = n.length;
							i = e || t * n[a - 1];
							for (var o, s = 0, c = a - 1; s <= c;)
								if ((o = n[r = Math.floor(s + (c - s) / 2)] - i) < 0) s = r + 1;
								else {
									if (!(0 < o)) {
										c = r;
										break
									}
									c = r - 1
								} if (n[r = c] === i) return r / (a - 1);
							var h = n[r];
							return (r + (i - h) / (n[r + 1] - h)) / (a - 1)
						},
						getTangent: function (t) {
							var e = 1e-4,
								i = t - e,
								n = t + e;
							i < 0 && (i = 0), 1 < n && (n = 1);
							var r = this.getPoint(i);
							return this.getPoint(n).clone().sub(r).normalize()
						},
						getTangentAt: function (t) {
							var e = this.getUtoTmapping(t);
							return this.getTangent(e)
						},
						computeFrenetFrames: function (t, e) {
							var i, n, r, a = new li,
								o = [],
								s = [],
								c = [],
								h = new li,
								l = new ci;
							for (i = 0; i <= t; i++) n = i / t, o[i] = this.getTangentAt(n), o[i]
								.normalize();
							s[0] = new li, c[0] = new li;
							var u = Number.MAX_VALUE,
								p = Math.abs(o[0].x),
								d = Math.abs(o[0].y),
								f = Math.abs(o[0].z);
							for (p <= u && (u = p, a.set(1, 0, 0)), d <= u && (u = d, a.set(0, 1, 0)),
								f <= u && a.set(0, 0, 1), h.crossVectors(o[0], a).normalize(), s[0]
								.crossVectors(o[0], h), c[0].crossVectors(o[0], s[0]), i = 1; i <= t; i++)
								s[i] = s[i - 1].clone(), c[i] = c[i - 1].clone(), h.crossVectors(o[i - 1],
									o[i]), h.length() > Number.EPSILON && (h.normalize(), r = Math.acos(oi
									.clamp(o[i - 1].dot(o[i]), -1, 1)), s[i].applyMatrix4(l
									.makeRotationAxis(h, r))), c[i].crossVectors(o[i], s[i]);
							if (!0 === e)
								for (r = Math.acos(oi.clamp(s[0].dot(s[t]), -1, 1)), r /= t, 0 < o[0].dot(
										h.crossVectors(s[0], s[t])) && (r = -r), i = 1; i <= t; i++) s[i]
									.applyMatrix4(l.makeRotationAxis(o[i], r * i)), c[i].crossVectors(o[
										i], s[i]);
							return {
								tangents: o,
								normals: s,
								binormals: c
							}
						},
						clone: function () {
							return (new this.constructor).copy(this)
						},
						copy: function (t) {
							return this.arcLengthDivisions = t.arcLengthDivisions, this
						},
						toJSON: function () {
							var t = {
								metadata: {
									version: 4.5,
									type: "Curve",
									generator: "Curve.toJSON"
								}
							};
							return t.arcLengthDivisions = this.arcLengthDivisions, t.type = this.type, t
						},
						fromJSON: function (t) {
							return this.arcLengthDivisions = t.arcLengthDivisions, this
						}
					}), Eh.prototype = Object.create(Sh.prototype), (Eh.prototype.constructor = Eh).prototype
					.isEllipseCurve = !0, Eh.prototype.getPoint = function (t, e) {
						for (var i = e || new si, n = 2 * Math.PI, r = this.aEndAngle - this.aStartAngle, a = Math
								.abs(r) < Number.EPSILON; r < 0;) r += n;
						for (; n < r;) r -= n;
						r < Number.EPSILON && (r = a ? 0 : n), !0 !== this.aClockwise || a || (r === n ? r = -n :
							r -= n);
						var o = this.aStartAngle + t * r,
							s = this.aX + this.xRadius * Math.cos(o),
							c = this.aY + this.yRadius * Math.sin(o);
						if (0 !== this.aRotation) {
							var h = Math.cos(this.aRotation),
								l = Math.sin(this.aRotation),
								u = s - this.aX,
								p = c - this.aY;
							s = u * h - p * l + this.aX, c = u * l + p * h + this.aY
						}
						return i.set(s, c)
					}, Eh.prototype.copy = function (t) {
						return Sh.prototype.copy.call(this, t), this.aX = t.aX, this.aY = t.aY, this.xRadius = t
							.xRadius, this.yRadius = t.yRadius, this.aStartAngle = t.aStartAngle, this.aEndAngle =
							t.aEndAngle, this.aClockwise = t.aClockwise, this.aRotation = t.aRotation, this
					}, Eh.prototype.toJSON = function () {
						var t = Sh.prototype.toJSON.call(this);
						return t.aX = this.aX, t.aY = this.aY, t.xRadius = this.xRadius, t.yRadius = this.yRadius,
							t.aStartAngle = this.aStartAngle, t.aEndAngle = this.aEndAngle, t.aClockwise = this
							.aClockwise, t.aRotation = this.aRotation, t
					}, Eh.prototype.fromJSON = function (t) {
						return Sh.prototype.fromJSON.call(this, t), this.aX = t.aX, this.aY = t.aY, this.xRadius =
							t.xRadius, this.yRadius = t.yRadius, this.aStartAngle = t.aStartAngle, this
							.aEndAngle = t.aEndAngle, this.aClockwise = t.aClockwise, this.aRotation = t
							.aRotation, this
					}, Th.prototype = Object.create(Eh.prototype), (Th.prototype.constructor = Th).prototype
					.isArcCurve = !0;
				var Lh = new li,
					Ph = new Ah,
					Rh = new Ah,
					Ch = new Ah;

				function Oh(t, e, i, n) {
					Sh.call(this), this.type = "CatmullRomCurve3", this.points = t || [], this.closed = e || !1,
						this.curveType = i || "centripetal", this.tension = n || .5
				}

				function Ih(t, e, i, n, r) {
					var a = .5 * (n - e),
						o = .5 * (r - i),
						s = t * t;
					return (2 * i - 2 * n + a + o) * (t * s) + (-3 * i + 3 * n - 2 * a - o) * s + a * t + i
				}

				function Dh(t, e) {
					var i = 1 - t;
					return i * i * e
				}

				function Bh(t, e) {
					return 2 * (1 - t) * t * e
				}

				function zh(t, e) {
					return t * t * e
				}

				function Nh(t, e, i, n) {
					return Dh(t, e) + Bh(t, i) + zh(t, n)
				}

				function Gh(t, e) {
					var i = 1 - t;
					return i * i * i * e
				}

				function Uh(t, e) {
					var i = 1 - t;
					return 3 * i * i * t * e
				}

				function Fh(t, e) {
					return 3 * (1 - t) * t * t * e
				}

				function Hh(t, e) {
					return t * t * t * e
				}

				function jh(t, e, i, n, r) {
					return Gh(t, e) + Uh(t, i) + Fh(t, n) + Hh(t, r)
				}

				function kh(t, e, i, n) {
					Sh.call(this), this.type = "CubicBezierCurve", this.v0 = t || new si, this.v1 = e || new si,
						this.v2 = i || new si, this.v3 = n || new si
				}

				function Vh(t, e, i, n) {
					Sh.call(this), this.type = "CubicBezierCurve3", this.v0 = t || new li, this.v1 = e || new li,
						this.v2 = i || new li, this.v3 = n || new li
				}

				function Wh(t, e) {
					Sh.call(this), this.type = "LineCurve", this.v1 = t || new si, this.v2 = e || new si
				}

				function qh(t, e) {
					Sh.call(this), this.type = "LineCurve3", this.v1 = t || new li, this.v2 = e || new li
				}

				function Xh(t, e, i) {
					Sh.call(this), this.type = "QuadraticBezierCurve", this.v0 = t || new si, this.v1 = e ||
						new si, this.v2 = i || new si
				}

				function Yh(t, e, i) {
					Sh.call(this), this.type = "QuadraticBezierCurve3", this.v0 = t || new li, this.v1 = e ||
						new li, this.v2 = i || new li
				}

				function Zh(t) {
					Sh.call(this), this.type = "SplineCurve", this.points = t || []
				}
				Oh.prototype = Object.create(Sh.prototype), (Oh.prototype.constructor = Oh).prototype
					.isCatmullRomCurve3 = !0, Oh.prototype.getPoint = function (t, e) {
						var i, n, r, a, o = e || new li,
							s = this.points,
							c = s.length,
							h = (c - (this.closed ? 0 : 1)) * t,
							l = Math.floor(h),
							u = h - l;
						if (this.closed ? l += 0 < l ? 0 : (Math.floor(Math.abs(l) / c) + 1) * c : 0 === u &&
							l === c - 1 && (l = c - 2, u = 1), i = this.closed || 0 < l ? s[(l - 1) % c] : (Lh
								.subVectors(s[0], s[1]).add(s[0]), Lh), n = s[l % c], r = s[(l + 1) % c], a = this
							.closed || l + 2 < c ? s[(l + 2) % c] : (Lh.subVectors(s[c - 1], s[c - 2]).add(s[c -
								1]), Lh), "centripetal" === this.curveType || "chordal" === this.curveType) {
							var p = "chordal" === this.curveType ? .5 : .25,
								d = Math.pow(i.distanceToSquared(n), p),
								f = Math.pow(n.distanceToSquared(r), p),
								m = Math.pow(r.distanceToSquared(a), p);
							f < 1e-4 && (f = 1), d < 1e-4 && (d = f), m < 1e-4 && (m = f), Ph
								.initNonuniformCatmullRom(i.x, n.x, r.x, a.x, d, f, m), Rh
								.initNonuniformCatmullRom(i.y, n.y, r.y, a.y, d, f, m), Ch
								.initNonuniformCatmullRom(i.z, n.z, r.z, a.z, d, f, m)
						} else "catmullrom" === this.curveType && (Ph.initCatmullRom(i.x, n.x, r.x, a.x, this
								.tension), Rh.initCatmullRom(i.y, n.y, r.y, a.y, this.tension), Ch
							.initCatmullRom(i.z, n.z, r.z, a.z, this.tension));
						return o.set(Ph.calc(u), Rh.calc(u), Ch.calc(u)), o
					}, Oh.prototype.copy = function (t) {
						Sh.prototype.copy.call(this, t), this.points = [];
						for (var e = 0, i = t.points.length; e < i; e++) {
							var n = t.points[e];
							this.points.push(n.clone())
						}
						return this.closed = t.closed, this.curveType = t.curveType, this.tension = t.tension,
							this
					}, Oh.prototype.toJSON = function () {
						var t = Sh.prototype.toJSON.call(this);
						t.points = [];
						for (var e = 0, i = this.points.length; e < i; e++) {
							var n = this.points[e];
							t.points.push(n.toArray())
						}
						return t.closed = this.closed, t.curveType = this.curveType, t.tension = this.tension, t
					}, Oh.prototype.fromJSON = function (t) {
						Sh.prototype.fromJSON.call(this, t), this.points = [];
						for (var e = 0, i = t.points.length; e < i; e++) {
							var n = t.points[e];
							this.points.push((new li).fromArray(n))
						}
						return this.closed = t.closed, this.curveType = t.curveType, this.tension = t.tension,
							this
					}, kh.prototype = Object.create(Sh.prototype), (kh.prototype.constructor = kh).prototype
					.isCubicBezierCurve = !0, kh.prototype.getPoint = function (t, e) {
						var i = e || new si,
							n = this.v0,
							r = this.v1,
							a = this.v2,
							o = this.v3;
						return i.set(jh(t, n.x, r.x, a.x, o.x), jh(t, n.y, r.y, a.y, o.y)), i
					}, kh.prototype.copy = function (t) {
						return Sh.prototype.copy.call(this, t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2
							.copy(t.v2), this.v3.copy(t.v3), this
					}, kh.prototype.toJSON = function () {
						var t = Sh.prototype.toJSON.call(this);
						return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
							.v3 = this.v3.toArray(), t
					}, kh.prototype.fromJSON = function (t) {
						return Sh.prototype.fromJSON.call(this, t), this.v0.fromArray(t.v0), this.v1.fromArray(t
							.v1), this.v2.fromArray(t.v2), this.v3.fromArray(t.v3), this
					}, Vh.prototype = Object.create(Sh.prototype), (Vh.prototype.constructor = Vh).prototype
					.isCubicBezierCurve3 = !0, Vh.prototype.getPoint = function (t, e) {
						var i = e || new li,
							n = this.v0,
							r = this.v1,
							a = this.v2,
							o = this.v3;
						return i.set(jh(t, n.x, r.x, a.x, o.x), jh(t, n.y, r.y, a.y, o.y), jh(t, n.z, r.z, a.z, o
							.z)), i
					}, Vh.prototype.copy = function (t) {
						return Sh.prototype.copy.call(this, t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2
							.copy(t.v2), this.v3.copy(t.v3), this
					}, Vh.prototype.toJSON = function () {
						var t = Sh.prototype.toJSON.call(this);
						return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
							.v3 = this.v3.toArray(), t
					}, Vh.prototype.fromJSON = function (t) {
						return Sh.prototype.fromJSON.call(this, t), this.v0.fromArray(t.v0), this.v1.fromArray(t
							.v1), this.v2.fromArray(t.v2), this.v3.fromArray(t.v3), this
					}, Wh.prototype = Object.create(Sh.prototype), (Wh.prototype.constructor = Wh).prototype
					.isLineCurve = !0, Wh.prototype.getPoint = function (t, e) {
						var i = e || new si;
						return 1 === t ? i.copy(this.v2) : (i.copy(this.v2).sub(this.v1), i.multiplyScalar(t).add(
							this.v1)), i
					}, Wh.prototype.getPointAt = function (t, e) {
						return this.getPoint(t, e)
					}, Wh.prototype.getTangent = function () {
						return this.v2.clone().sub(this.v1).normalize()
					}, Wh.prototype.copy = function (t) {
						return Sh.prototype.copy.call(this, t), this.v1.copy(t.v1), this.v2.copy(t.v2), this
					}, Wh.prototype.toJSON = function () {
						var t = Sh.prototype.toJSON.call(this);
						return t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
					}, Wh.prototype.fromJSON = function (t) {
						return Sh.prototype.fromJSON.call(this, t), this.v1.fromArray(t.v1), this.v2.fromArray(t
							.v2), this
					}, qh.prototype = Object.create(Sh.prototype), (qh.prototype.constructor = qh).prototype
					.isLineCurve3 = !0, qh.prototype.getPoint = function (t, e) {
						var i = e || new li;
						return 1 === t ? i.copy(this.v2) : (i.copy(this.v2).sub(this.v1), i.multiplyScalar(t).add(
							this.v1)), i
					}, qh.prototype.getPointAt = function (t, e) {
						return this.getPoint(t, e)
					}, qh.prototype.copy = function (t) {
						return Sh.prototype.copy.call(this, t), this.v1.copy(t.v1), this.v2.copy(t.v2), this
					}, qh.prototype.toJSON = function () {
						var t = Sh.prototype.toJSON.call(this);
						return t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
					}, qh.prototype.fromJSON = function (t) {
						return Sh.prototype.fromJSON.call(this, t), this.v1.fromArray(t.v1), this.v2.fromArray(t
							.v2), this
					}, Xh.prototype = Object.create(Sh.prototype), (Xh.prototype.constructor = Xh).prototype
					.isQuadraticBezierCurve = !0, Xh.prototype.getPoint = function (t, e) {
						var i = e || new si,
							n = this.v0,
							r = this.v1,
							a = this.v2;
						return i.set(Nh(t, n.x, r.x, a.x), Nh(t, n.y, r.y, a.y)), i
					}, Xh.prototype.copy = function (t) {
						return Sh.prototype.copy.call(this, t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2
							.copy(t.v2), this
					}, Xh.prototype.toJSON = function () {
						var t = Sh.prototype.toJSON.call(this);
						return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
					}, Xh.prototype.fromJSON = function (t) {
						return Sh.prototype.fromJSON.call(this, t), this.v0.fromArray(t.v0), this.v1.fromArray(t
							.v1), this.v2.fromArray(t.v2), this
					}, Yh.prototype = Object.create(Sh.prototype), (Yh.prototype.constructor = Yh).prototype
					.isQuadraticBezierCurve3 = !0, Yh.prototype.getPoint = function (t, e) {
						var i = e || new li,
							n = this.v0,
							r = this.v1,
							a = this.v2;
						return i.set(Nh(t, n.x, r.x, a.x), Nh(t, n.y, r.y, a.y), Nh(t, n.z, r.z, a.z)), i
					}, Yh.prototype.copy = function (t) {
						return Sh.prototype.copy.call(this, t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2
							.copy(t.v2), this
					}, Yh.prototype.toJSON = function () {
						var t = Sh.prototype.toJSON.call(this);
						return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
					}, Yh.prototype.fromJSON = function (t) {
						return Sh.prototype.fromJSON.call(this, t), this.v0.fromArray(t.v0), this.v1.fromArray(t
							.v1), this.v2.fromArray(t.v2), this
					}, Zh.prototype = Object.create(Sh.prototype), (Zh.prototype.constructor = Zh).prototype
					.isSplineCurve = !0, Zh.prototype.getPoint = function (t, e) {
						var i = e || new si,
							n = this.points,
							r = (n.length - 1) * t,
							a = Math.floor(r),
							o = r - a,
							s = n[0 === a ? a : a - 1],
							c = n[a],
							h = n[a > n.length - 2 ? n.length - 1 : a + 1],
							l = n[a > n.length - 3 ? n.length - 1 : a + 2];
						return i.set(Ih(o, s.x, c.x, h.x, l.x), Ih(o, s.y, c.y, h.y, l.y)), i
					}, Zh.prototype.copy = function (t) {
						Sh.prototype.copy.call(this, t), this.points = [];
						for (var e = 0, i = t.points.length; e < i; e++) {
							var n = t.points[e];
							this.points.push(n.clone())
						}
						return this
					}, Zh.prototype.toJSON = function () {
						var t = Sh.prototype.toJSON.call(this);
						t.points = [];
						for (var e = 0, i = this.points.length; e < i; e++) {
							var n = this.points[e];
							t.points.push(n.toArray())
						}
						return t
					}, Zh.prototype.fromJSON = function (t) {
						Sh.prototype.fromJSON.call(this, t), this.points = [];
						for (var e = 0, i = t.points.length; e < i; e++) {
							var n = t.points[e];
							this.points.push((new si).fromArray(n))
						}
						return this
					};
				var Jh = Object.freeze({
					ArcCurve: Th,
					CatmullRomCurve3: Oh,
					CubicBezierCurve: kh,
					CubicBezierCurve3: Vh,
					EllipseCurve: Eh,
					LineCurve: Wh,
					LineCurve3: qh,
					QuadraticBezierCurve: Xh,
					QuadraticBezierCurve3: Yh,
					SplineCurve: Zh
				});

				function Qh() {
					Sh.call(this), this.type = "CurvePath", this.curves = [], this.autoClose = !1
				}

				function Kh(t) {
					Qh.call(this), this.type = "Path", this.currentPoint = new si, t && this.setFromPoints(t)
				}

				function $h(t) {
					Kh.call(this, t), this.uuid = oi.generateUUID(), this.type = "Shape", this.holes = []
				}

				function tl(t, e) {
					Sn.call(this), this.type = "Light", this.color = new Yi(t), this.intensity = void 0 !== e ?
						e : 1, this.receiveShadow = void 0
				}

				function el(t, e, i) {
					tl.call(this, t, i), this.type = "HemisphereLight", this.castShadow = void 0, this.position
						.copy(Sn.DefaultUp), this.updateMatrix(), this.groundColor = new Yi(e)
				}

				function il(t) {
					this.camera = t, this.bias = 0, this.radius = 1, this.mapSize = new si(512, 512), this.map =
						null, this.matrix = new ci
				}

				function nl() {
					il.call(this, new Po(50, 1, .5, 500))
				}

				function rl(t, e, i, n, r, a) {
					tl.call(this, t, e), this.type = "SpotLight", this.position.copy(Sn.DefaultUp), this
						.updateMatrix(), this.target = new Sn, Object.defineProperty(this, "power", {
							get: function () {
								return this.intensity * Math.PI
							},
							set: function (t) {
								this.intensity = t / Math.PI
							}
						}), this.distance = void 0 !== i ? i : 0, this.angle = void 0 !== n ? n : Math.PI / 3,
						this.penumbra = void 0 !== r ? r : 0, this.decay = void 0 !== a ? a : 1, this.shadow =
						new nl
				}

				function al(t, e, i, n) {
					tl.call(this, t, e), this.type = "PointLight", Object.defineProperty(this, "power", {
							get: function () {
								return 4 * this.intensity * Math.PI
							},
							set: function (t) {
								this.intensity = t / (4 * Math.PI)
							}
						}), this.distance = void 0 !== i ? i : 0, this.decay = void 0 !== n ? n : 1, this.shadow =
						new il(new Po(90, 1, .5, 500))
				}

				function ol(t, e, i, n, r, a) {
					Lo.call(this), this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left =
						void 0 !== t ? t : -1, this.right = void 0 !== e ? e : 1, this.top = void 0 !== i ? i : 1,
						this.bottom = void 0 !== n ? n : -1, this.near = void 0 !== r ? r : .1, this.far =
						void 0 !== a ? a : 2e3, this.updateProjectionMatrix()
				}

				function sl() {
					il.call(this, new ol(-5, 5, 5, -5, .5, 500))
				}

				function cl(t, e) {
					tl.call(this, t, e), this.type = "DirectionalLight", this.position.copy(Sn.DefaultUp), this
						.updateMatrix(), this.target = new Sn, this.shadow = new sl
				}

				function hl(t, e) {
					tl.call(this, t, e), this.type = "AmbientLight", this.castShadow = void 0
				}

				function ll(t, e, i, n) {
					tl.call(this, t, e), this.type = "RectAreaLight", this.width = void 0 !== i ? i : 10, this
						.height = void 0 !== n ? n : 10
				}

				function ul(t) {
					this.manager = void 0 !== t ? t : mh, this.textures = {}
				}
				Qh.prototype = Object.assign(Object.create(Sh.prototype), {
					constructor: Qh,
					add: function (t) {
						this.curves.push(t)
					},
					closePath: function () {
						var t = this.curves[0].getPoint(0),
							e = this.curves[this.curves.length - 1].getPoint(1);
						t.equals(e) || this.curves.push(new Wh(e, t))
					},
					getPoint: function (t) {
						for (var e = t * this.getLength(), i = this.getCurveLengths(), n = 0; n < i
							.length;) {
							if (i[n] >= e) {
								var r = i[n] - e,
									a = this.curves[n],
									o = a.getLength(),
									s = 0 === o ? 0 : 1 - r / o;
								return a.getPointAt(s)
							}
							n++
						}
						return null
					},
					getLength: function () {
						var t = this.getCurveLengths();
						return t[t.length - 1]
					},
					updateArcLengths: function () {
						this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths()
					},
					getCurveLengths: function () {
						if (this.cacheLengths && this.cacheLengths.length === this.curves.length)
							return this.cacheLengths;
						for (var t = [], e = 0, i = 0, n = this.curves.length; i < n; i++) e += this
							.curves[i].getLength(), t.push(e);
						return this.cacheLengths = t
					},
					getSpacedPoints: function (t) {
						void 0 === t && (t = 40);
						for (var e = [], i = 0; i <= t; i++) e.push(this.getPoint(i / t));
						return this.autoClose && e.push(e[0]), e
					},
					getPoints: function (t) {
						t = t || 12;
						for (var e, i = [], n = 0, r = this.curves; n < r.length; n++)
							for (var a = r[n], o = a && a.isEllipseCurve ? 2 * t : a && (a
										.isLineCurve || a.isLineCurve3) ? 1 : a && a.isSplineCurve ?
									t * a.points.length : t, s = a.getPoints(o), c = 0; c < s
								.length; c++) {
								var h = s[c];
								e && e.equals(h) || (i.push(h), e = h)
							}
						return this.autoClose && 1 < i.length && !i[i.length - 1].equals(i[0]) && i
							.push(i[0]), i
					},
					copy: function (t) {
						Sh.prototype.copy.call(this, t), this.curves = [];
						for (var e = 0, i = t.curves.length; e < i; e++) {
							var n = t.curves[e];
							this.curves.push(n.clone())
						}
						return this.autoClose = t.autoClose, this
					},
					toJSON: function () {
						var t = Sh.prototype.toJSON.call(this);
						t.autoClose = this.autoClose, t.curves = [];
						for (var e = 0, i = this.curves.length; e < i; e++) {
							var n = this.curves[e];
							t.curves.push(n.toJSON())
						}
						return t
					},
					fromJSON: function (t) {
						Sh.prototype.fromJSON.call(this, t), this.autoClose = t.autoClose, this
							.curves = [];
						for (var e = 0, i = t.curves.length; e < i; e++) {
							var n = t.curves[e];
							this.curves.push((new Jh[n.type]).fromJSON(n))
						}
						return this
					}
				}), Kh.prototype = Object.assign(Object.create(Qh.prototype), {
					constructor: Kh,
					setFromPoints: function (t) {
						this.moveTo(t[0].x, t[0].y);
						for (var e = 1, i = t.length; e < i; e++) this.lineTo(t[e].x, t[e].y)
					},
					moveTo: function (t, e) {
						this.currentPoint.set(t, e)
					},
					lineTo: function (t, e) {
						var i = new Wh(this.currentPoint.clone(), new si(t, e));
						this.curves.push(i), this.currentPoint.set(t, e)
					},
					quadraticCurveTo: function (t, e, i, n) {
						var r = new Xh(this.currentPoint.clone(), new si(t, e), new si(i, n));
						this.curves.push(r), this.currentPoint.set(i, n)
					},
					bezierCurveTo: function (t, e, i, n, r, a) {
						var o = new kh(this.currentPoint.clone(), new si(t, e), new si(i, n), new si(
							r, a));
						this.curves.push(o), this.currentPoint.set(r, a)
					},
					splineThru: function (t) {
						var e = new Zh([this.currentPoint.clone()].concat(t));
						this.curves.push(e), this.currentPoint.copy(t[t.length - 1])
					},
					arc: function (t, e, i, n, r, a) {
						var o = this.currentPoint.x,
							s = this.currentPoint.y;
						this.absarc(t + o, e + s, i, n, r, a)
					},
					absarc: function (t, e, i, n, r, a) {
						this.absellipse(t, e, i, i, n, r, a)
					},
					ellipse: function (t, e, i, n, r, a, o, s) {
						var c = this.currentPoint.x,
							h = this.currentPoint.y;
						this.absellipse(t + c, e + h, i, n, r, a, o, s)
					},
					absellipse: function (t, e, i, n, r, a, o, s) {
						var c = new Eh(t, e, i, n, r, a, o, s);
						if (0 < this.curves.length) {
							var h = c.getPoint(0);
							h.equals(this.currentPoint) || this.lineTo(h.x, h.y)
						}
						this.curves.push(c);
						var l = c.getPoint(1);
						this.currentPoint.copy(l)
					},
					copy: function (t) {
						return Qh.prototype.copy.call(this, t), this.currentPoint.copy(t
							.currentPoint), this
					},
					toJSON: function () {
						var t = Qh.prototype.toJSON.call(this);
						return t.currentPoint = this.currentPoint.toArray(), t
					},
					fromJSON: function (t) {
						return Qh.prototype.fromJSON.call(this, t), this.currentPoint.fromArray(t
							.currentPoint), this
					}
				}), $h.prototype = Object.assign(Object.create(Kh.prototype), {
					constructor: $h,
					getPointsHoles: function (t) {
						for (var e = [], i = 0, n = this.holes.length; i < n; i++) e[i] = this.holes[
							i].getPoints(t);
						return e
					},
					extractPoints: function (t) {
						return {
							shape: this.getPoints(t),
							holes: this.getPointsHoles(t)
						}
					},
					copy: function (t) {
						Kh.prototype.copy.call(this, t), this.holes = [];
						for (var e = 0, i = t.holes.length; e < i; e++) {
							var n = t.holes[e];
							this.holes.push(n.clone())
						}
						return this
					},
					toJSON: function () {
						var t = Kh.prototype.toJSON.call(this);
						t.uuid = this.uuid, t.holes = [];
						for (var e = 0, i = this.holes.length; e < i; e++) {
							var n = this.holes[e];
							t.holes.push(n.toJSON())
						}
						return t
					},
					fromJSON: function (t) {
						Kh.prototype.fromJSON.call(this, t), this.uuid = t.uuid, this.holes = [];
						for (var e = 0, i = t.holes.length; e < i; e++) {
							var n = t.holes[e];
							this.holes.push((new Kh).fromJSON(n))
						}
						return this
					}
				}), tl.prototype = Object.assign(Object.create(Sn.prototype), {
					constructor: tl,
					isLight: !0,
					copy: function (t) {
						return Sn.prototype.copy.call(this, t), this.color.copy(t.color), this
							.intensity = t.intensity, this
					},
					toJSON: function (t) {
						var e = Sn.prototype.toJSON.call(this, t);
						return e.object.color = this.color.getHex(), e.object.intensity = this
							.intensity, void 0 !== this.groundColor && (e.object.groundColor = this
								.groundColor.getHex()), void 0 !== this.distance && (e.object
								.distance = this.distance), void 0 !== this.angle && (e.object.angle =
								this.angle), void 0 !== this.decay && (e.object.decay = this.decay),
							void 0 !== this.penumbra && (e.object.penumbra = this.penumbra),
							void 0 !== this.shadow && (e.object.shadow = this.shadow.toJSON()), e
					}
				}), el.prototype = Object.assign(Object.create(tl.prototype), {
					constructor: el,
					isHemisphereLight: !0,
					copy: function (t) {
						return tl.prototype.copy.call(this, t), this.groundColor.copy(t.groundColor),
							this
					}
				}), Object.assign(il.prototype, {
					copy: function (t) {
						return this.camera = t.camera.clone(), this.bias = t.bias, this.radius = t
							.radius, this.mapSize.copy(t.mapSize), this
					},
					clone: function () {
						return (new this.constructor).copy(this)
					},
					toJSON: function () {
						var t = {};
						return 0 !== this.bias && (t.bias = this.bias), 1 !== this.radius && (t
								.radius = this.radius), 512 === this.mapSize.x && 512 === this.mapSize
							.y || (t.mapSize = this.mapSize.toArray()), t.camera = this.camera.toJSON(
								!1).object, delete t.camera.matrix, t
					}
				}), nl.prototype = Object.assign(Object.create(il.prototype), {
					constructor: nl,
					isSpotLightShadow: !0,
					update: function (t) {
						var e = this.camera,
							i = 2 * oi.RAD2DEG * t.angle,
							n = this.mapSize.width / this.mapSize.height,
							r = t.distance || e.far;
						i === e.fov && n === e.aspect && r === e.far || (e.fov = i, e.aspect = n, e
							.far = r, e.updateProjectionMatrix())
					}
				}), rl.prototype = Object.assign(Object.create(tl.prototype), {
					constructor: rl,
					isSpotLight: !0,
					copy: function (t) {
						return tl.prototype.copy.call(this, t), this.distance = t.distance, this
							.angle = t.angle, this.penumbra = t.penumbra, this.decay = t.decay, this
							.target = t.target.clone(), this.shadow = t.shadow.clone(), this
					}
				}), al.prototype = Object.assign(Object.create(tl.prototype), {
					constructor: al,
					isPointLight: !0,
					copy: function (t) {
						return tl.prototype.copy.call(this, t), this.distance = t.distance, this
							.decay = t.decay, this.shadow = t.shadow.clone(), this
					}
				}), ol.prototype = Object.assign(Object.create(Lo.prototype), {
					constructor: ol,
					isOrthographicCamera: !0,
					copy: function (t, e) {
						return Lo.prototype.copy.call(this, t, e), this.left = t.left, this.right = t
							.right, this.top = t.top, this.bottom = t.bottom, this.near = t.near, this
							.far = t.far, this.zoom = t.zoom, this.view = null === t.view ? null :
							Object.assign({}, t.view), this
					},
					setViewOffset: function (t, e, i, n, r, a) {
						null === this.view && (this.view = {
								enabled: !0,
								fullWidth: 1,
								fullHeight: 1,
								offsetX: 0,
								offsetY: 0,
								width: 1,
								height: 1
							}), this.view.enabled = !0, this.view.fullWidth = t, this.view
							.fullHeight = e, this.view.offsetX = i, this.view.offsetY = n, this.view
							.width = r, this.view.height = a, this.updateProjectionMatrix()
					},
					clearViewOffset: function () {
						null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
					},
					updateProjectionMatrix: function () {
						var t = (this.right - this.left) / (2 * this.zoom),
							e = (this.top - this.bottom) / (2 * this.zoom),
							i = (this.right + this.left) / 2,
							n = (this.top + this.bottom) / 2,
							r = i - t,
							a = i + t,
							o = n + e,
							s = n - e;
						if (null !== this.view && this.view.enabled) {
							var c = this.zoom / (this.view.width / this.view.fullWidth),
								h = this.zoom / (this.view.height / this.view.fullHeight),
								l = (this.right - this.left) / this.view.width,
								u = (this.top - this.bottom) / this.view.height;
							a = (r += l * (this.view.offsetX / c)) + l * (this.view.width / c), s = (
								o -= u * (this.view.offsetY / h)) - u * (this.view.height / h)
						}
						this.projectionMatrix.makeOrthographic(r, a, o, s, this.near, this.far), this
							.projectionMatrixInverse.getInverse(this.projectionMatrix)
					},
					toJSON: function (t) {
						var e = Sn.prototype.toJSON.call(this, t);
						return e.object.zoom = this.zoom, e.object.left = this.left, e.object.right =
							this.right, e.object.top = this.top, e.object.bottom = this.bottom, e
							.object.near = this.near, e.object.far = this.far, null !== this.view && (
								e.object.view = Object.assign({}, this.view)), e
					}
				}), sl.prototype = Object.assign(Object.create(il.prototype), {
					constructor: sl
				}), cl.prototype = Object.assign(Object.create(tl.prototype), {
					constructor: cl,
					isDirectionalLight: !0,
					copy: function (t) {
						return tl.prototype.copy.call(this, t), this.target = t.target.clone(), this
							.shadow = t.shadow.clone(), this
					}
				}), hl.prototype = Object.assign(Object.create(tl.prototype), {
					constructor: hl,
					isAmbientLight: !0
				}), ll.prototype = Object.assign(Object.create(tl.prototype), {
					constructor: ll,
					isRectAreaLight: !0,
					copy: function (t) {
						return tl.prototype.copy.call(this, t), this.width = t.width, this.height = t
							.height, this
					},
					toJSON: function (t) {
						var e = tl.prototype.toJSON.call(this, t);
						return e.object.width = this.width, e.object.height = this.height, e
					}
				}), Object.assign(ul.prototype, {
					load: function (t, e, i, n) {
						var r = this,
							a = new vh(r.manager);
						a.setPath(r.path), a.load(t, function (t) {
							e(r.parse(JSON.parse(t)))
						}, i, n)
					},
					parse: function (t) {
						var e = this.textures;

						function i(t) {
							return void 0 === e[t] && console.warn(
								"THREE.MaterialLoader: Undefined texture", t), e[t]
						}
						var n = new Jc[t.type];
						if (void 0 !== t.uuid && (n.uuid = t.uuid), void 0 !== t.name && (n.name = t
								.name), void 0 !== t.color && n.color.setHex(t.color), void 0 !== t
							.roughness && (n.roughness = t.roughness), void 0 !== t.metalness && (n
								.metalness = t.metalness), void 0 !== t.emissive && n.emissive.setHex(
								t.emissive), void 0 !== t.specular && n.specular.setHex(t.specular),
							void 0 !== t.shininess && (n.shininess = t.shininess), void 0 !== t
							.clearCoat && (n.clearCoat = t.clearCoat), void 0 !== t
							.clearCoatRoughness && (n.clearCoatRoughness = t.clearCoatRoughness),
							void 0 !== t.vertexColors && (n.vertexColors = t.vertexColors), void 0 !==
							t.fog && (n.fog = t.fog), void 0 !== t.flatShading && (n.flatShading = t
								.flatShading), void 0 !== t.blending && (n.blending = t.blending),
							void 0 !== t.combine && (n.combine = t.combine), void 0 !== t.side && (n
								.side = t.side), void 0 !== t.opacity && (n.opacity = t.opacity),
							void 0 !== t.transparent && (n.transparent = t.transparent), void 0 !== t
							.alphaTest && (n.alphaTest = t.alphaTest), void 0 !== t.depthTest && (n
								.depthTest = t.depthTest), void 0 !== t.depthWrite && (n.depthWrite =
								t.depthWrite), void 0 !== t.colorWrite && (n.colorWrite = t
								.colorWrite), void 0 !== t.wireframe && (n.wireframe = t.wireframe),
							void 0 !== t.wireframeLinewidth && (n.wireframeLinewidth = t
								.wireframeLinewidth), void 0 !== t.wireframeLinecap && (n
								.wireframeLinecap = t.wireframeLinecap), void 0 !== t
							.wireframeLinejoin && (n.wireframeLinejoin = t.wireframeLinejoin),
							void 0 !== t.rotation && (n.rotation = t.rotation), 1 !== t.linewidth && (
								n.linewidth = t.linewidth), void 0 !== t.dashSize && (n.dashSize = t
								.dashSize), void 0 !== t.gapSize && (n.gapSize = t.gapSize),
							void 0 !== t.scale && (n.scale = t.scale), void 0 !== t.polygonOffset && (
								n.polygonOffset = t.polygonOffset), void 0 !== t
							.polygonOffsetFactor && (n.polygonOffsetFactor = t.polygonOffsetFactor),
							void 0 !== t.polygonOffsetUnits && (n.polygonOffsetUnits = t
								.polygonOffsetUnits), void 0 !== t.skinning && (n.skinning = t
								.skinning), void 0 !== t.morphTargets && (n.morphTargets = t
								.morphTargets), void 0 !== t.dithering && (n.dithering = t.dithering),
							void 0 !== t.visible && (n.visible = t.visible), void 0 !== t.userData &&
							(n.userData = t.userData), void 0 !== t.uniforms)
							for (var r in t.uniforms) {
								var a = t.uniforms[r];
								switch (n.uniforms[r] = {}, a.type) {
									case "t":
										n.uniforms[r].value = i(a.value);
										break;
									case "c":
										n.uniforms[r].value = (new Yi).setHex(a.value);
										break;
									case "v2":
										n.uniforms[r].value = (new si).fromArray(a.value);
										break;
									case "v3":
										n.uniforms[r].value = (new li).fromArray(a.value);
										break;
									case "v4":
										n.uniforms[r].value = (new Ci).fromArray(a.value);
										break;
									case "m3":
										n.uniforms[r].value = (new ui).fromArray(a.value);
									case "m4":
										n.uniforms[r].value = (new ci).fromArray(a.value);
										break;
									default:
										n.uniforms[r].value = a.value
								}
							}
						if (void 0 !== t.defines && (n.defines = t.defines), void 0 !== t
							.vertexShader && (n.vertexShader = t.vertexShader), void 0 !== t
							.fragmentShader && (n.fragmentShader = t.fragmentShader), void 0 !== t
							.extensions)
							for (var o in t.extensions) n.extensions[o] = t.extensions[o];
						if (void 0 !== t.shading && (n.flatShading = 1 === t.shading), void 0 !== t
							.size && (n.size = t.size), void 0 !== t.sizeAttenuation && (n
								.sizeAttenuation = t.sizeAttenuation), void 0 !== t.map && (n.map = i(
								t.map)), void 0 !== t.alphaMap && (n.alphaMap = i(t.alphaMap), n
								.transparent = !0), void 0 !== t.bumpMap && (n.bumpMap = i(t
							.bumpMap)), void 0 !== t.bumpScale && (n.bumpScale = t.bumpScale),
							void 0 !== t.normalMap && (n.normalMap = i(t.normalMap)), void 0 !== t
							.normalMapType && (n.normalMapType = t.normalMapType), void 0 !== t
							.normalScale) {
							var s = t.normalScale;
							!1 === Array.isArray(s) && (s = [s, s]), n.normalScale = (new si)
								.fromArray(s)
						}
						return void 0 !== t.displacementMap && (n.displacementMap = i(t
								.displacementMap)), void 0 !== t.displacementScale && (n
								.displacementScale = t.displacementScale), void 0 !== t
							.displacementBias && (n.displacementBias = t.displacementBias), void 0 !==
							t.roughnessMap && (n.roughnessMap = i(t.roughnessMap)), void 0 !== t
							.metalnessMap && (n.metalnessMap = i(t.metalnessMap)), void 0 !== t
							.emissiveMap && (n.emissiveMap = i(t.emissiveMap)), void 0 !== t
							.emissiveIntensity && (n.emissiveIntensity = t.emissiveIntensity),
							void 0 !== t.specularMap && (n.specularMap = i(t.specularMap)), void 0 !==
							t.envMap && (n.envMap = i(t.envMap)), void 0 !== t.envMapIntensity && (n
								.envMapIntensity = t.envMapIntensity), void 0 !== t.reflectivity && (n
								.reflectivity = t.reflectivity), void 0 !== t.lightMap && (n
								.lightMap = i(t.lightMap)), void 0 !== t.lightMapIntensity && (n
								.lightMapIntensity = t.lightMapIntensity), void 0 !== t.aoMap && (n
								.aoMap = i(t.aoMap)), void 0 !== t.aoMapIntensity && (n
								.aoMapIntensity = t.aoMapIntensity), void 0 !== t.gradientMap && (n
								.gradientMap = i(t.gradientMap)), n
					},
					setPath: function (t) {
						return this.path = t, this
					},
					setTextures: function (t) {
						return this.textures = t, this
					}
				});
				var pl = {
					decodeText: function (t) {
						if ("undefined" != typeof TextDecoder) return (new TextDecoder).decode(t);
						for (var e = "", i = 0, n = t.length; i < n; i++) e += String.fromCharCode(t[i]);
						return decodeURIComponent(escape(e))
					},
					extractUrlBase: function (t) {
						var e = t.lastIndexOf("/");
						return -1 === e ? "./" : t.substr(0, e + 1)
					}
				};

				function dl(t) {
					this.manager = void 0 !== t ? t : mh
				}
				Object.assign(dl.prototype, {
					load: function (t, e, i, n) {
						var r = this,
							a = new vh(r.manager);
						a.setPath(r.path), a.load(t, function (t) {
							e(r.parse(JSON.parse(t)))
						}, i, n)
					},
					parse: function (t) {
						var e = new nr,
							i = t.data.index;
						if (void 0 !== i) {
							var n = new fl[i.type](i.array);
							e.setIndex(new Dn(n, 1))
						}
						var r = t.data.attributes;
						for (var a in r) {
							var o = r[a],
								s = new Dn(n = new fl[o.type](o.array), o.itemSize, o.normalized);
							void 0 !== o.name && (s.name = o.name), e.addAttribute(a, s)
						}
						var c = t.data.morphAttributes;
						if (c)
							for (var a in c) {
								for (var h = c[a], l = [], u = 0, p = h.length; u < p; u++) {
									o = h[u], s = new Dn(n = new fl[o.type](o.array), o.itemSize, o
										.normalized);
									void 0 !== o.name && (s.name = o.name), l.push(s)
								}
								e.morphAttributes[a] = l
							}
						var d = t.data.groups || t.data.drawcalls || t.data.offsets;
						if (void 0 !== d) {
							u = 0;
							for (var f = d.length; u !== f; ++u) {
								var m = d[u];
								e.addGroup(m.start, m.count, m.materialIndex)
							}
						}
						var g = t.data.boundingSphere;
						if (void 0 !== g) {
							var v = new li;
							void 0 !== g.center && v.fromArray(g.center), e.boundingSphere = new Ni(v,
								g.radius)
						}
						return t.name && (e.name = t.name), t.userData && (e.userData = t.userData), e
					},
					setPath: function (t) {
						return this.path = t, this
					}
				});
				var fl = {
					Int8Array: Int8Array,
					Uint8Array: Uint8Array,
					Uint8ClampedArray: "undefined" != typeof Uint8ClampedArray ? Uint8ClampedArray :
						Uint8Array,
					Int16Array: Int16Array,
					Uint16Array: Uint16Array,
					Int32Array: Int32Array,
					Uint32Array: Uint32Array,
					Float32Array: Float32Array,
					Float64Array: Float64Array
				};

				function ml(t) {
					this.manager = void 0 !== t ? t : mh, this.resourcePath = ""
				}
				Object.assign(ml.prototype, {
					crossOrigin: "anonymous",
					load: function (n, r, t, a) {
						var o = this,
							e = void 0 === this.path ? pl.extractUrlBase(n) : this.path;
						this.resourcePath = this.resourcePath || e;
						var i = new vh(o.manager);
						i.setPath(this.path), i.load(n, function (t) {
							var e = null;
							try {
								e = JSON.parse(t)
							} catch (t) {
								return void 0 !== a && a(t), void console.error(
									"THREE:ObjectLoader: Can't parse " + n + ".", t
									.message)
							}
							var i = e.metadata;
							void 0 !== i && void 0 !== i.type && "geometry" !== i.type
								.toLowerCase() ? o.parse(e, r) : console.error(
									"THREE.ObjectLoader: Can't load " + n)
						}, t, a)
					},
					setPath: function (t) {
						return this.path = t, this
					},
					setResourcePath: function (t) {
						return this.resourcePath = t, this
					},
					setCrossOrigin: function (t) {
						return this.crossOrigin = t, this
					},
					parse: function (t, e) {
						var i = this.parseShape(t.shapes),
							n = this.parseGeometries(t.geometries, i),
							r = this.parseImages(t.images, function () {
								void 0 !== e && e(s)
							}),
							a = this.parseTextures(t.textures, r),
							o = this.parseMaterials(t.materials, a),
							s = this.parseObject(t.object, n, o);
						return t.animations && (s.animations = this.parseAnimations(t.animations)),
							void 0 !== t.images && 0 !== t.images.length || void 0 !== e && e(s), s
					},
					parseShape: function (t) {
						var e = {};
						if (void 0 !== t)
							for (var i = 0, n = t.length; i < n; i++) {
								var r = (new $h).fromJSON(t[i]);
								e[r.uuid] = r
							}
						return e
					},
					parseGeometries: function (t, e) {
						var i = {};
						if (void 0 !== t)
							for (var n = new dl, r = 0, a = t.length; r < a; r++) {
								var o, s = t[r];
								switch (s.type) {
									case "PlaneGeometry":
									case "PlaneBufferGeometry":
										o = new Uc[s.type](s.width, s.height, s.widthSegments, s
											.heightSegments);
										break;
									case "BoxGeometry":
									case "BoxBufferGeometry":
									case "CubeGeometry":
										o = new Uc[s.type](s.width, s.height, s.depth, s
											.widthSegments, s.heightSegments, s.depthSegments);
										break;
									case "CircleGeometry":
									case "CircleBufferGeometry":
										o = new Uc[s.type](s.radius, s.segments, s.thetaStart, s
											.thetaLength);
										break;
									case "CylinderGeometry":
									case "CylinderBufferGeometry":
										o = new Uc[s.type](s.radiusTop, s.radiusBottom, s.height, s
											.radialSegments, s.heightSegments, s.openEnded, s
											.thetaStart, s.thetaLength);
										break;
									case "ConeGeometry":
									case "ConeBufferGeometry":
										o = new Uc[s.type](s.radius, s.height, s.radialSegments, s
											.heightSegments, s.openEnded, s.thetaStart, s
											.thetaLength);
										break;
									case "SphereGeometry":
									case "SphereBufferGeometry":
										o = new Uc[s.type](s.radius, s.widthSegments, s
											.heightSegments, s.phiStart, s.phiLength, s
											.thetaStart, s.thetaLength);
										break;
									case "DodecahedronGeometry":
									case "DodecahedronBufferGeometry":
									case "IcosahedronGeometry":
									case "IcosahedronBufferGeometry":
									case "OctahedronGeometry":
									case "OctahedronBufferGeometry":
									case "TetrahedronGeometry":
									case "TetrahedronBufferGeometry":
										o = new Uc[s.type](s.radius, s.detail);
										break;
									case "RingGeometry":
									case "RingBufferGeometry":
										o = new Uc[s.type](s.innerRadius, s.outerRadius, s
											.thetaSegments, s.phiSegments, s.thetaStart, s
											.thetaLength);
										break;
									case "TorusGeometry":
									case "TorusBufferGeometry":
										o = new Uc[s.type](s.radius, s.tube, s.radialSegments, s
											.tubularSegments, s.arc);
										break;
									case "TorusKnotGeometry":
									case "TorusKnotBufferGeometry":
										o = new Uc[s.type](s.radius, s.tube, s.tubularSegments, s
											.radialSegments, s.p, s.q);
										break;
									case "TubeGeometry":
									case "TubeBufferGeometry":
										o = new Uc[s.type]((new Jh[s.path.type]).fromJSON(s.path), s
											.tubularSegments, s.radius, s.radialSegments, s.closed
											);
										break;
									case "LatheGeometry":
									case "LatheBufferGeometry":
										o = new Uc[s.type](s.points, s.segments, s.phiStart, s
											.phiLength);
										break;
									case "PolyhedronGeometry":
									case "PolyhedronBufferGeometry":
										o = new Uc[s.type](s.vertices, s.indices, s.radius, s
										.details);
										break;
									case "ShapeGeometry":
									case "ShapeBufferGeometry":
										for (var c = [], h = 0, l = s.shapes.length; h < l; h++) {
											var u = e[s.shapes[h]];
											c.push(u)
										}
										o = new Uc[s.type](c, s.curveSegments);
										break;
									case "ExtrudeGeometry":
									case "ExtrudeBufferGeometry":
										for (c = [], h = 0, l = s.shapes.length; h < l; h++) {
											u = e[s.shapes[h]];
											c.push(u)
										}
										var p = s.options.extrudePath;
										void 0 !== p && (s.options.extrudePath = (new Jh[p.type])
											.fromJSON(p)), o = new Uc[s.type](c, s.options);
										break;
									case "BufferGeometry":
										o = n.parse(s);
										break;
									case "Geometry":
										if ("THREE" in window && "LegacyJSONLoader" in THREE) o = (
											new THREE.LegacyJSONLoader).parse(s, this
											.resourcePath).geometry;
										else console.error(
											'THREE.ObjectLoader: You have to import LegacyJSONLoader in order load geometry data of type "Geometry".'
											);
										break;
									default:
										console.warn(
											'THREE.ObjectLoader: Unsupported geometry type "' + s
											.type + '"');
										continue
								}
								o.uuid = s.uuid, void 0 !== s.name && (o.name = s.name), !0 === o
									.isBufferGeometry && void 0 !== s.userData && (o.userData = s
										.userData), i[s.uuid] = o
							}
						return i
					},
					parseMaterials: function (t, e) {
						var i = {},
							n = {};
						if (void 0 !== t) {
							var r = new ul;
							r.setTextures(e);
							for (var a = 0, o = t.length; a < o; a++) {
								var s = t[a];
								if ("MultiMaterial" === s.type) {
									for (var c = [], h = 0; h < s.materials.length; h++) {
										var l = s.materials[h];
										void 0 === i[l.uuid] && (i[l.uuid] = r.parse(l)), c.push(i[l
											.uuid])
									}
									n[s.uuid] = c
								} else void 0 === i[s.uuid] && (i[s.uuid] = r.parse(s)), n[s.uuid] =
									i[s.uuid]
							}
						}
						return n
					},
					parseAnimations: function (t) {
						for (var e = [], i = 0; i < t.length; i++) {
							var n = t[i],
								r = lh.parse(n);
							void 0 !== n.uuid && (r.uuid = n.uuid), e.push(r)
						}
						return e
					},
					parseImages: function (t, e) {
						var i = this,
							n = {};

						function r(t) {
							return i.manager.itemStart(t), a.load(t, function () {
								i.manager.itemEnd(t)
							}, void 0, function () {
								i.manager.itemError(t), i.manager.itemEnd(t)
							})
						}
						if (void 0 !== t && 0 < t.length) {
							var a = new _h(new fh(e));
							a.setCrossOrigin(this.crossOrigin);
							for (var o = 0, s = t.length; o < s; o++) {
								var c = t[o],
									h = c.url;
								if (Array.isArray(h)) {
									n[c.uuid] = [];
									for (var l = 0, u = h.length; l < u; l++) {
										var p = h[l],
											d = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(p) ? p : i
											.resourcePath + p;
										n[c.uuid].push(r(d))
									}
								} else {
									d = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(c.url) ? c.url : i
										.resourcePath + c.url;
									n[c.uuid] = r(d)
								}
							}
						}
						return n
					},
					parseTextures: function (t, e) {
						function i(t, e) {
							return "number" == typeof t ? t : (console.warn(
								"THREE.ObjectLoader.parseTexture: Constant should be in numeric form.",
								t), e[t])
						}
						var n = {};
						if (void 0 !== t)
							for (var r = 0, a = t.length; r < a; r++) {
								var o, s = t[r];
								void 0 === s.image && console.warn(
										'THREE.ObjectLoader: No "image" specified for', s.uuid),
									void 0 === e[s.image] && console.warn(
										"THREE.ObjectLoader: Undefined image", s.image), (o = Array
										.isArray(e[s.image]) ? new $r(e[s.image]) : new Ri(e[s.image])
										).needsUpdate = !0, o.uuid = s.uuid, void 0 !== s.name && (o
										.name = s.name), void 0 !== s.mapping && (o.mapping = i(s
										.mapping, _l)), void 0 !== s.offset && o.offset.fromArray(s
										.offset), void 0 !== s.repeat && o.repeat.fromArray(s.repeat),
									void 0 !== s.center && o.center.fromArray(s.center), void 0 !== s
									.rotation && (o.rotation = s.rotation), void 0 !== s.wrap && (o
										.wrapS = i(s.wrap[0], wl), o.wrapT = i(s.wrap[1], wl)),
									void 0 !== s.format && (o.format = s.format), void 0 !== s.type &&
									(o.type = s.type), void 0 !== s.encoding && (o.encoding = s
										.encoding), void 0 !== s.minFilter && (o.minFilter = i(s
										.minFilter, Ml)), void 0 !== s.magFilter && (o.magFilter = i(s
										.magFilter, Ml)), void 0 !== s.anisotropy && (o.anisotropy = s
										.anisotropy), void 0 !== s.flipY && (o.flipY = s.flipY),
									void 0 !== s.premultiplyAlpha && (o.premultiplyAlpha = s
										.premultiplyAlpha), void 0 !== s.unpackAlignment && (o
										.unpackAlignment = s.unpackAlignment), n[s.uuid] = o
							}
						return n
					},
					parseObject: function (t, e, a) {
						var i;

						function n(t) {
							return void 0 === e[t] && console.warn(
								"THREE.ObjectLoader: Undefined geometry", t), e[t]
						}

						function r(t) {
							if (void 0 !== t) {
								if (Array.isArray(t)) {
									for (var e = [], i = 0, n = t.length; i < n; i++) {
										var r = t[i];
										void 0 === a[r] && console.warn(
											"THREE.ObjectLoader: Undefined material", r), e.push(
											a[r])
									}
									return e
								}
								return void 0 === a[t] && console.warn(
									"THREE.ObjectLoader: Undefined material", t), a[t]
							}
						}
						switch (t.type) {
							case "Scene":
								i = new es, void 0 !== t.background && Number.isInteger(t
									.background) && (i.background = new Yi(t.background)), void 0 !==
									t.fog && ("Fog" === t.fog.type ? i.fog = new ts(t.fog.color, t.fog
										.near, t.fog.far) : "FogExp2" === t.fog.type && (i.fog =
										new $o(t.fog.color, t.fog.density)));
								break;
							case "PerspectiveCamera":
								i = new Po(t.fov, t.aspect, t.near, t.far), void 0 !== t.focus && (i
										.focus = t.focus), void 0 !== t.zoom && (i.zoom = t.zoom),
									void 0 !== t.filmGauge && (i.filmGauge = t.filmGauge), void 0 !==
									t.filmOffset && (i.filmOffset = t.filmOffset), void 0 !== t
									.view && (i.view = Object.assign({}, t.view));
								break;
							case "OrthographicCamera":
								i = new ol(t.left, t.right, t.top, t.bottom, t.near, t.far),
									void 0 !== t.zoom && (i.zoom = t.zoom), void 0 !== t.view && (i
										.view = Object.assign({}, t.view));
								break;
							case "AmbientLight":
								i = new hl(t.color, t.intensity);
								break;
							case "DirectionalLight":
								i = new cl(t.color, t.intensity);
								break;
							case "PointLight":
								i = new al(t.color, t.intensity, t.distance, t.decay);
								break;
							case "RectAreaLight":
								i = new ll(t.color, t.intensity, t.width, t.height);
								break;
							case "SpotLight":
								i = new rl(t.color, t.intensity, t.distance, t.angle, t.penumbra, t
									.decay);
								break;
							case "HemisphereLight":
								i = new el(t.color, t.groundColor, t.intensity);
								break;
							case "SkinnedMesh":
								console.warn(
									"THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet."
									);
							case "Mesh":
								var o = n(t.geometry),
									s = r(t.material);
								i = o.bones && 0 < o.bones.length ? new ss(o, s) : new Hr(o, s),
									void 0 !== t.drawMode && i.setDrawMode(t.drawMode);
								break;
							case "LOD":
								i = new os;
								break;
							case "Line":
								i = new us(n(t.geometry), r(t.material), t.mode);
								break;
							case "LineLoop":
								i = new ds(n(t.geometry), r(t.material));
								break;
							case "LineSegments":
								i = new ps(n(t.geometry), r(t.material));
								break;
							case "PointCloud":
							case "Points":
								i = new ms(n(t.geometry), r(t.material));
								break;
							case "Sprite":
								i = new as(r(t.material));
								break;
							case "Group":
								i = new Ao;
								break;
							default:
								i = new Sn
						}
						if (i.uuid = t.uuid, void 0 !== t.name && (i.name = t.name), void 0 !== t
							.matrix ? (i.matrix.fromArray(t.matrix), void 0 !== t.matrixAutoUpdate &&
								(i.matrixAutoUpdate = t.matrixAutoUpdate), i.matrixAutoUpdate && i
								.matrix.decompose(i.position, i.quaternion, i.scale)) : (void 0 !== t
								.position && i.position.fromArray(t.position), void 0 !== t
								.rotation && i.rotation.fromArray(t.rotation), void 0 !== t
								.quaternion && i.quaternion.fromArray(t.quaternion), void 0 !== t
								.scale && i.scale.fromArray(t.scale)), void 0 !== t.castShadow && (i
								.castShadow = t.castShadow), void 0 !== t.receiveShadow && (i
								.receiveShadow = t.receiveShadow), t.shadow && (void 0 !== t.shadow
								.bias && (i.shadow.bias = t.shadow.bias), void 0 !== t.shadow
								.radius && (i.shadow.radius = t.shadow.radius), void 0 !== t.shadow
								.mapSize && i.shadow.mapSize.fromArray(t.shadow.mapSize), void 0 !== t
								.shadow.camera && (i.shadow.camera = this.parseObject(t.shadow
									.camera))), void 0 !== t.visible && (i.visible = t.visible),
							void 0 !== t.frustumCulled && (i.frustumCulled = t.frustumCulled),
							void 0 !== t.renderOrder && (i.renderOrder = t.renderOrder), void 0 !== t
							.userData && (i.userData = t.userData), void 0 !== t.layers && (i.layers
								.mask = t.layers), void 0 !== t.children)
							for (var c = t.children, h = 0; h < c.length; h++) i.add(this.parseObject(
								c[h], e, a));
						if ("LOD" === t.type)
							for (var l = t.levels, u = 0; u < l.length; u++) {
								var p = l[u],
									d = i.getObjectByProperty("uuid", p.object);
								void 0 !== d && i.addLevel(d, p.distance)
							}
						return i
					}
				});
				var gl, vl, yl, xl, bl, _l = {
						UVMapping: st,
						CubeReflectionMapping: ct,
						CubeRefractionMapping: ht,
						EquirectangularReflectionMapping: Pt,
						EquirectangularRefractionMapping: Rt,
						SphericalReflectionMapping: Ct,
						CubeUVReflectionMapping: Ot,
						CubeUVRefractionMapping: It
					},
					wl = {
						RepeatWrapping: Dt,
						ClampToEdgeWrapping: Bt,
						MirroredRepeatWrapping: zt
					},
					Ml = {
						NearestFilter: Nt,
						NearestMipMapNearestFilter: Gt,
						NearestMipMapLinearFilter: Ut,
						LinearFilter: Ft,
						LinearMipMapNearestFilter: Vt,
						LinearMipMapLinearFilter: Wt
					};

				function Sl(t) {
					"undefined" == typeof createImageBitmap && console.warn(
							"THREE.ImageBitmapLoader: createImageBitmap() not supported."), "undefined" ==
						typeof fetch && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), this
						.manager = void 0 !== t ? t : mh, this.options = void 0
				}

				function El() {
					this.type = "ShapePath", this.color = new Yi, this.subPaths = [], this.currentPath = null
				}

				function Tl(t) {
					this.type = "Font", this.data = t
				}

				function Al(t, e, i) {
					for (var n = Array.from ? Array.from(t) : String(t).split(""), r = e / i.resolution, a = (i
								.boundingBox.yMax - i.boundingBox.yMin + i.underlineThickness) * r, o = [], s = 0,
							c = 0, h = 0; h < n.length; h++) {
						var l = n[h];
						if ("\n" === l) s = 0, c -= a;
						else {
							var u = Ll(l, r, s, c, i);
							s += u.offsetX, o.push(u.path)
						}
					}
					return o
				}

				function Ll(t, e, i, n, r) {
					var a = r.glyphs[t] || r.glyphs["?"];
					if (a) {
						var o, s, c, h, l, u, p, d, f = new El;
						if (a.o)
							for (var m = a._cachedOutline || (a._cachedOutline = a.o.split(" ")), g = 0, v = m
									.length; g < v;) {
								switch (m[g++]) {
									case "m":
										o = m[g++] * e + i, s = m[g++] * e + n, f.moveTo(o, s);
										break;
									case "l":
										o = m[g++] * e + i, s = m[g++] * e + n, f.lineTo(o, s);
										break;
									case "q":
										c = m[g++] * e + i, h = m[g++] * e + n, l = m[g++] * e + i, u = m[g++] *
											e + n, f.quadraticCurveTo(l, u, c, h);
										break;
									case "b":
										c = m[g++] * e + i, h = m[g++] * e + n, l = m[g++] * e + i, u = m[g++] *
											e + n, p = m[g++] * e + i, d = m[g++] * e + n, f.bezierCurveTo(l, u,
												p, d, c, h)
								}
							}
						return {
							offsetX: a.ha * e,
							path: f
						}
					}
				}

				function Pl(t) {
					this.manager = void 0 !== t ? t : mh
				}

				function Rl() {}
				Sl.prototype = {
					constructor: Sl,
					setOptions: function (t) {
						return this.options = t, this
					},
					load: function (e, i, t, n) {
						void 0 === e && (e = ""), void 0 !== this.path && (e = this.path + e), e = this
							.manager.resolveURL(e);
						var r = this,
							a = dh.get(e);
						if (void 0 !== a) return r.manager.itemStart(e), setTimeout(function () {
							i && i(a), r.manager.itemEnd(e)
						}, 0), a;
						fetch(e).then(function (t) {
							return t.blob()
						}).then(function (t) {
							return createImageBitmap(t, r.options)
						}).then(function (t) {
							dh.add(e, t), i && i(t), r.manager.itemEnd(e)
						}).catch(function (t) {
							n && n(t), r.manager.itemError(e), r.manager.itemEnd(e)
						}), r.manager.itemStart(e)
					},
					setCrossOrigin: function () {
						return this
					},
					setPath: function (t) {
						return this.path = t, this
					}
				}, Object.assign(El.prototype, {
					moveTo: function (t, e) {
						this.currentPath = new Kh, this.subPaths.push(this.currentPath), this
							.currentPath.moveTo(t, e)
					},
					lineTo: function (t, e) {
						this.currentPath.lineTo(t, e)
					},
					quadraticCurveTo: function (t, e, i, n) {
						this.currentPath.quadraticCurveTo(t, e, i, n)
					},
					bezierCurveTo: function (t, e, i, n, r, a) {
						this.currentPath.bezierCurveTo(t, e, i, n, r, a)
					},
					splineThru: function (t) {
						this.currentPath.splineThru(t)
					},
					toShapes: function (t, e) {
						function i(t) {
							for (var e = [], i = 0, n = t.length; i < n; i++) {
								var r = t[i],
									a = new $h;
								a.curves = r.curves, e.push(a)
							}
							return e
						}

						function n(t, e) {
							for (var i = e.length, n = !1, r = i - 1, a = 0; a < i; r = a++) {
								var o = e[r],
									s = e[a],
									c = s.x - o.x,
									h = s.y - o.y;
								if (Math.abs(h) > Number.EPSILON) {
									if (h < 0 && (o = e[a], c = -c, s = e[r], h = -h), t.y < o.y || t
										.y > s.y) continue;
									if (t.y === o.y) {
										if (t.x === o.x) return !0
									} else {
										var l = h * (t.x - o.x) - c * (t.y - o.y);
										if (0 === l) return !0;
										if (l < 0) continue;
										n = !n
									}
								} else {
									if (t.y !== o.y) continue;
									if (s.x <= t.x && t.x <= o.x || o.x <= t.x && t.x <= s.x) return !
										0
								}
							}
							return n
						}
						var r = fc.isClockWise,
							a = this.subPaths;
						if (0 === a.length) return [];
						if (!0 === e) return i(a);
						var o, s, c, h = [];
						if (1 === a.length) return s = a[0], (c = new $h).curves = s.curves, h.push(
							c), h;
						var l = !r(a[0].getPoints());
						l = t ? !l : l;
						var u, p, d = [],
							f = [],
							m = [],
							g = 0;
						f[g] = void 0, m[g] = [];
						for (var v = 0, y = a.length; v < y; v++) o = r(u = (s = a[v]).getPoints()), (
							o = t ? !o : o) ? (!l && f[g] && g++, f[g] = {
							s: new $h,
							p: u
						}, f[g].s.curves = s.curves, l && g++, m[g] = []) : m[g].push({
							h: s,
							p: u[0]
						});
						if (!f[0]) return i(a);
						if (1 < f.length) {
							for (var x = !1, b = [], _ = 0, w = f.length; _ < w; _++) d[_] = [];
							for (_ = 0, w = f.length; _ < w; _++)
								for (var M = m[_], S = 0; S < M.length; S++) {
									for (var E = M[S], T = !0, A = 0; A < f.length; A++) n(E.p, f[A]
										.p) && (_ !== A && b.push({
										froms: _,
										tos: A,
										hole: S
									}), T ? (T = !1, d[A].push(E)) : x = !0);
									T && d[_].push(E)
								}
							0 < b.length && (x || (m = d))
						}
						v = 0;
						for (var L = f.length; v < L; v++) {
							c = f[v].s, h.push(c);
							for (var P = 0, R = (p = m[v]).length; P < R; P++) c.holes.push(p[P].h)
						}
						return h
					}
				}), Object.assign(Tl.prototype, {
					isFont: !0,
					generateShapes: function (t, e) {
						void 0 === e && (e = 100);
						for (var i = [], n = Al(t, e, this.data), r = 0, a = n.length; r < a; r++)
							Array.prototype.push.apply(i, n[r].toShapes());
						return i
					}
				}), Object.assign(Pl.prototype, {
					load: function (t, n, e, i) {
						var r = this,
							a = new vh(this.manager);
						a.setPath(this.path), a.load(t, function (e) {
							var i;
							try {
								i = JSON.parse(e)
							} catch (t) {
								console.warn(
									"THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."
									), i = JSON.parse(e.substring(65, e.length - 2))
							}
							var t = r.parse(i);
							n && n(t)
						}, e, i)
					},
					parse: function (t) {
						return new Tl(t)
					},
					setPath: function (t) {
						return this.path = t, this
					}
				}), Rl.Handlers = {
					handlers: [],
					add: function (t, e) {
						this.handlers.push(t, e)
					},
					get: function (t) {
						for (var e = this.handlers, i = 0, n = e.length; i < n; i += 2) {
							var r = e[i],
								a = e[i + 1];
							if (r.test(t)) return a
						}
						return null
					}
				}, Object.assign(Rl.prototype, {
					crossOrigin: "anonymous",
					onLoadStart: function () {},
					onLoadProgress: function () {},
					onLoadComplete: function () {},
					initMaterials: function (t, e, i) {
						for (var n = [], r = 0; r < t.length; ++r) n[r] = this.createMaterial(t[r], e,
							i);
						return n
					},
					createMaterial: (gl = {
						NoBlending: ft,
						NormalBlending: mt,
						AdditiveBlending: gt,
						SubtractiveBlending: vt,
						MultiplyBlending: yt,
						CustomBlending: xt
					}, vl = new Yi, yl = new Mh, xl = new ul, function (t, h, l) {
						var u = {};

						function e(t, e, i, n, r) {
							var a, o = h + t,
								s = Rl.Handlers.get(o);
							a = null !== s ? s.load(o) : (yl.setCrossOrigin(l), yl.load(o)),
								void 0 !== e && (a.repeat.fromArray(e), 1 !== e[0] && (a.wrapS =
									Dt), 1 !== e[1] && (a.wrapT = Dt)), void 0 !== i && a.offset
								.fromArray(i), void 0 !== n && ("repeat" === n[0] && (a.wrapS =
									Dt), "mirror" === n[0] && (a.wrapS = zt), "repeat" === n[
									1] && (a.wrapT = Dt), "mirror" === n[1] && (a.wrapT = zt)),
								void 0 !== r && (a.anisotropy = r);
							var c = oi.generateUUID();
							return u[c] = a, c
						}
						var i = {
							uuid: oi.generateUUID(),
							type: "MeshLambertMaterial"
						};
						for (var n in t) {
							var r = t[n];
							switch (n) {
								case "DbgColor":
								case "DbgIndex":
								case "opticalDensity":
								case "illumination":
									break;
								case "DbgName":
									i.name = r;
									break;
								case "blending":
									i.blending = gl[r];
									break;
								case "colorAmbient":
								case "mapAmbient":
									console.warn("THREE.Loader.createMaterial:", n,
										"is no longer supported.");
									break;
								case "colorDiffuse":
									i.color = vl.fromArray(r).getHex();
									break;
								case "colorSpecular":
									i.specular = vl.fromArray(r).getHex();
									break;
								case "colorEmissive":
									i.emissive = vl.fromArray(r).getHex();
									break;
								case "specularCoef":
									i.shininess = r;
									break;
								case "shading":
									"basic" === r.toLowerCase() && (i.type = "MeshBasicMaterial"),
										"phong" === r.toLowerCase() && (i.type =
											"MeshPhongMaterial"), "standard" === r
									.toLowerCase() && (i.type = "MeshStandardMaterial");
									break;
								case "mapDiffuse":
									i.map = e(r, t.mapDiffuseRepeat, t.mapDiffuseOffset, t
										.mapDiffuseWrap, t.mapDiffuseAnisotropy);
									break;
								case "mapDiffuseRepeat":
								case "mapDiffuseOffset":
								case "mapDiffuseWrap":
								case "mapDiffuseAnisotropy":
									break;
								case "mapEmissive":
									i.emissiveMap = e(r, t.mapEmissiveRepeat, t.mapEmissiveOffset,
										t.mapEmissiveWrap, t.mapEmissiveAnisotropy);
									break;
								case "mapEmissiveRepeat":
								case "mapEmissiveOffset":
								case "mapEmissiveWrap":
								case "mapEmissiveAnisotropy":
									break;
								case "mapLight":
									i.lightMap = e(r, t.mapLightRepeat, t.mapLightOffset, t
										.mapLightWrap, t.mapLightAnisotropy);
									break;
								case "mapLightRepeat":
								case "mapLightOffset":
								case "mapLightWrap":
								case "mapLightAnisotropy":
									break;
								case "mapAO":
									i.aoMap = e(r, t.mapAORepeat, t.mapAOOffset, t.mapAOWrap, t
										.mapAOAnisotropy);
									break;
								case "mapAORepeat":
								case "mapAOOffset":
								case "mapAOWrap":
								case "mapAOAnisotropy":
									break;
								case "mapBump":
									i.bumpMap = e(r, t.mapBumpRepeat, t.mapBumpOffset, t
										.mapBumpWrap, t.mapBumpAnisotropy);
									break;
								case "mapBumpScale":
									i.bumpScale = r;
									break;
								case "mapBumpRepeat":
								case "mapBumpOffset":
								case "mapBumpWrap":
								case "mapBumpAnisotropy":
									break;
								case "mapNormal":
									i.normalMap = e(r, t.mapNormalRepeat, t.mapNormalOffset, t
										.mapNormalWrap, t.mapNormalAnisotropy);
									break;
								case "mapNormalFactor":
									i.normalScale = r;
									break;
								case "mapNormalRepeat":
								case "mapNormalOffset":
								case "mapNormalWrap":
								case "mapNormalAnisotropy":
									break;
								case "mapSpecular":
									i.specularMap = e(r, t.mapSpecularRepeat, t.mapSpecularOffset,
										t.mapSpecularWrap, t.mapSpecularAnisotropy);
									break;
								case "mapSpecularRepeat":
								case "mapSpecularOffset":
								case "mapSpecularWrap":
								case "mapSpecularAnisotropy":
									break;
								case "mapMetalness":
									i.metalnessMap = e(r, t.mapMetalnessRepeat, t
										.mapMetalnessOffset, t.mapMetalnessWrap, t
										.mapMetalnessAnisotropy);
									break;
								case "mapMetalnessRepeat":
								case "mapMetalnessOffset":
								case "mapMetalnessWrap":
								case "mapMetalnessAnisotropy":
									break;
								case "mapRoughness":
									i.roughnessMap = e(r, t.mapRoughnessRepeat, t
										.mapRoughnessOffset, t.mapRoughnessWrap, t
										.mapRoughnessAnisotropy);
									break;
								case "mapRoughnessRepeat":
								case "mapRoughnessOffset":
								case "mapRoughnessWrap":
								case "mapRoughnessAnisotropy":
									break;
								case "mapAlpha":
									i.alphaMap = e(r, t.mapAlphaRepeat, t.mapAlphaOffset, t
										.mapAlphaWrap, t.mapAlphaAnisotropy);
									break;
								case "mapAlphaRepeat":
								case "mapAlphaOffset":
								case "mapAlphaWrap":
								case "mapAlphaAnisotropy":
									break;
								case "flipSided":
									i.side = jt;
									break;
								case "doubleSided":
									i.side = dt;
									break;
								case "transparency":
									console.warn(
										"THREE.Loader.createMaterial: transparency has been renamed to opacity"
										), i.opacity = r;
									break;
								case "depthTest":
								case "depthWrite":
								case "colorWrite":
								case "opacity":
								case "reflectivity":
								case "transparent":
								case "visible":
								case "wireframe":
									i[n] = r;
									break;
								case "vertexColors":
									!0 === r && (i.vertexColors = N), "face" === r && (i
										.vertexColors = D);
									break;
								default:
									console.error("THREE.Loader.createMaterial: Unsupported", n,
										r)
							}
						}
						return "MeshBasicMaterial" === i.type && delete i.emissive,
							"MeshPhongMaterial" !== i.type && delete i.specular, i.opacity < 1 &&
							(i.transparent = !0), xl.setTextures(u), xl.parse(i)
					})
				});
				var Cl, Ol, Il, Dl, Bl, zl, Nl, Gl, Ul, Fl, Hl, jl, kl, Vl, Wl, ql, Xl, Yl, Zl, Jl = {
					getContext: function () {
						return void 0 === bl && (bl = new(window.AudioContext || window
							.webkitAudioContext)), bl
					},
					setContext: function (t) {
						bl = t
					}
				};

				function Ql(t) {
					this.manager = void 0 !== t ? t : mh
				}

				function Kl() {
					this.type = "StereoCamera", this.aspect = 1, this.eyeSep = .064, this.cameraL = new Po, this
						.cameraL.layers.enable(1), this.cameraL.matrixAutoUpdate = !1, this.cameraR = new Po, this
						.cameraR.layers.enable(2), this.cameraR.matrixAutoUpdate = !1
				}

				function $l(t, e, i, n) {
					Sn.call(this), this.type = "CubeCamera";
					var r = 90,
						a = 1,
						o = new Po(r, a, t, e);
					o.up.set(0, -1, 0), o.lookAt(new li(1, 0, 0)), this.add(o);
					var s = new Po(r, a, t, e);
					s.up.set(0, -1, 0), s.lookAt(new li(-1, 0, 0)), this.add(s);
					var c = new Po(r, a, t, e);
					c.up.set(0, 0, 1), c.lookAt(new li(0, 1, 0)), this.add(c);
					var h = new Po(r, a, t, e);
					h.up.set(0, 0, -1), h.lookAt(new li(0, -1, 0)), this.add(h);
					var l = new Po(r, a, t, e);
					l.up.set(0, -1, 0), l.lookAt(new li(0, 0, 1)), this.add(l);
					var u = new Po(r, a, t, e);
					u.up.set(0, -1, 0), u.lookAt(new li(0, 0, -1)), this.add(u), n = n || {
							format: ae,
							magFilter: Ft,
							minFilter: Ft
						}, this.renderTarget = new Di(i, i, n), this.renderTarget.texture.name = "CubeCamera",
						this.update = function (t, e) {
							null === this.parent && this.updateMatrixWorld();
							var i = t.getRenderTarget(),
								n = this.renderTarget,
								r = n.texture.generateMipmaps;
							n.texture.generateMipmaps = !1, t.setRenderTarget(n, 0), t.render(e, o), t
								.setRenderTarget(n, 1), t.render(e, s), t.setRenderTarget(n, 2), t.render(e, c), t
								.setRenderTarget(n, 3), t.render(e, h), t.setRenderTarget(n, 4), t.render(e, l), n
								.texture.generateMipmaps = r, t.setRenderTarget(n, 5), t.render(e, u), t
								.setRenderTarget(i)
						}, this.clear = function (t, e, i, n) {
							for (var r = t.getRenderTarget(), a = this.renderTarget, o = 0; o < 6; o++) a
								.activeCubeFace = o, t.setRenderTarget(a), t.clear(e, i, n);
							t.setRenderTarget(r)
						}
				}

				function tu(t) {
					this.autoStart = void 0 === t || t, this.startTime = 0, this.oldTime = 0, this.elapsedTime =
						0, this.running = !1
				}

				function eu() {
					Sn.call(this), this.type = "AudioListener", this.context = Jl.getContext(), this.gain = this
						.context.createGain(), this.gain.connect(this.context.destination), this.filter = null,
						this.timeDelta = 0
				}

				function iu(t) {
					Sn.call(this), this.type = "Audio", this.listener = t, this.context = t.context, this.gain =
						this.context.createGain(), this.gain.connect(t.getInput()), this.autoplay = !1, this
						.buffer = null, this.detune = 0, this.loop = !1, this.startTime = 0, this.offset = 0, this
						.playbackRate = 1, this.isPlaying = !1, this.hasPlaybackControl = !0, this.sourceType =
						"empty", this.filters = []
				}

				function nu(t) {
					iu.call(this, t), this.panner = this.context.createPanner(), this.panner.connect(this.gain)
				}

				function ru(t, e) {
					this.analyser = t.context.createAnalyser(), this.analyser.fftSize = void 0 !== e ? e : 2048,
						this.data = new Uint8Array(this.analyser.frequencyBinCount), t.getOutput().connect(this
							.analyser)
				}

				function au(t, e, i) {
					this.binding = t, this.valueSize = i;
					var n, r = Float64Array;
					switch (e) {
						case "quaternion":
							n = this._slerp;
							break;
						case "string":
						case "bool":
							r = Array, n = this._select;
							break;
						default:
							n = this._lerp
					}
					this.buffer = new r(4 * i), this._mixBufferRegion = n, this.cumulativeWeight = 0, this
						.useCount = 0, this.referenceCount = 0
				}
				Object.assign(Ql.prototype, {
					load: function (t, i, e, n) {
						var r = new vh(this.manager);
						r.setResponseType("arraybuffer"), r.setPath(this.path), r.load(t, function (
						t) {
							var e = t.slice(0);
							Jl.getContext().decodeAudioData(e, function (t) {
								i(t)
							})
						}, e, n)
					},
					setPath: function (t) {
						return this.path = t, this
					}
				}), Object.assign(Kl.prototype, {
					update: (Ul = new ci, Fl = new ci, function (t) {
						if (Cl !== this || Ol !== t.focus || Il !== t.fov || Dl !== t.aspect *
							this.aspect || Bl !== t.near || zl !== t.far || Nl !== t.zoom ||
							Gl !== this.eyeSep) {
							Cl = this, Ol = t.focus, Il = t.fov, Dl = t.aspect * this.aspect, Bl =
								t.near, zl = t.far, Nl = t.zoom;
							var e, i, n = t.projectionMatrix.clone(),
								r = (Gl = this.eyeSep / 2) * Bl / Ol,
								a = Bl * Math.tan(oi.DEG2RAD * Il * .5) / Nl;
							Fl.elements[12] = -Gl, Ul.elements[12] = Gl, e = -a * Dl + r, i = a *
								Dl + r, n.elements[0] = 2 * Bl / (i - e), n.elements[8] = (i +
								e) / (i - e), this.cameraL.projectionMatrix.copy(n), e = -a * Dl -
								r, i = a * Dl - r, n.elements[0] = 2 * Bl / (i - e), n.elements[
								8] = (i + e) / (i - e), this.cameraR.projectionMatrix.copy(n)
						}
						this.cameraL.matrixWorld.copy(t.matrixWorld).multiply(Fl), this.cameraR
							.matrixWorld.copy(t.matrixWorld).multiply(Ul)
					})
				}), $l.prototype = Object.create(Sn.prototype), $l.prototype.constructor = $l, Object.assign(
					tu.prototype, {
						start: function () {
							this.startTime = ("undefined" == typeof performance ? Date : performance)
								.now(), this.oldTime = this.startTime, this.elapsedTime = 0, this
								.running = !0
						},
						stop: function () {
							this.getElapsedTime(), this.running = !1, this.autoStart = !1
						},
						getElapsedTime: function () {
							return this.getDelta(), this.elapsedTime
						},
						getDelta: function () {
							var t = 0;
							if (this.autoStart && !this.running) return this.start(), 0;
							if (this.running) {
								var e = ("undefined" == typeof performance ? Date : performance).now();
								t = (e - this.oldTime) / 1e3, this.oldTime = e, this.elapsedTime += t
							}
							return t
						}
					}), eu.prototype = Object.assign(Object.create(Sn.prototype), {
					constructor: eu,
					getInput: function () {
						return this.gain
					},
					removeFilter: function () {
						return null !== this.filter && (this.gain.disconnect(this.filter), this.filter
							.disconnect(this.context.destination), this.gain.connect(this.context
								.destination), this.filter = null), this
					},
					getFilter: function () {
						return this.filter
					},
					setFilter: function (t) {
						return null !== this.filter ? (this.gain.disconnect(this.filter), this.filter
								.disconnect(this.context.destination)) : this.gain.disconnect(this
								.context.destination), this.filter = t, this.gain.connect(this
							.filter), this.filter.connect(this.context.destination), this
					},
					getMasterVolume: function () {
						return this.gain.gain.value
					},
					setMasterVolume: function (t) {
						return this.gain.gain.setTargetAtTime(t, this.context.currentTime, .01), this
					},
					updateMatrixWorld: (Hl = new li, jl = new hi, kl = new li, Vl = new li, Wl = new tu,
						function (t) {
							Sn.prototype.updateMatrixWorld.call(this, t);
							var e = this.context.listener,
								i = this.up;
							if (this.timeDelta = Wl.getDelta(), this.matrixWorld.decompose(Hl, jl,
								kl), Vl.set(0, 0, -1).applyQuaternion(jl), e.positionX) {
								var n = this.context.currentTime + this.timeDelta;
								e.positionX.linearRampToValueAtTime(Hl.x, n), e.positionY
									.linearRampToValueAtTime(Hl.y, n), e.positionZ
									.linearRampToValueAtTime(Hl.z, n), e.forwardX
									.linearRampToValueAtTime(Vl.x, n), e.forwardY
									.linearRampToValueAtTime(Vl.y, n), e.forwardZ
									.linearRampToValueAtTime(Vl.z, n), e.upX.linearRampToValueAtTime(i
										.x, n), e.upY.linearRampToValueAtTime(i.y, n), e.upZ
									.linearRampToValueAtTime(i.z, n)
							} else e.setPosition(Hl.x, Hl.y, Hl.z), e.setOrientation(Vl.x, Vl.y, Vl.z,
								i.x, i.y, i.z)
						})
				}), iu.prototype = Object.assign(Object.create(Sn.prototype), {
					constructor: iu,
					getOutput: function () {
						return this.gain
					},
					setNodeSource: function (t) {
						return this.hasPlaybackControl = !1, this.sourceType = "audioNode", this
							.source = t, this.connect(), this
					},
					setMediaElementSource: function (t) {
						return this.hasPlaybackControl = !1, this.sourceType = "mediaNode", this
							.source = this.context.createMediaElementSource(t), this.connect(), this
					},
					setBuffer: function (t) {
						return this.buffer = t, this.sourceType = "buffer", this.autoplay && this
							.play(), this
					},
					play: function () {
						if (!0 !== this.isPlaying) {
							if (!1 !== this.hasPlaybackControl) {
								var t = this.context.createBufferSource();
								return t.buffer = this.buffer, t.loop = this.loop, t.onended = this
									.onEnded.bind(this), this.startTime = this.context.currentTime, t
									.start(this.startTime, this.offset), this.isPlaying = !0, this
									.source = t, this.setDetune(this.detune), this.setPlaybackRate(
										this.playbackRate), this.connect()
							}
							console.warn("THREE.Audio: this Audio has no playback control.")
						} else console.warn("THREE.Audio: Audio is already playing.")
					},
					pause: function () {
						if (!1 !== this.hasPlaybackControl) return !0 === this.isPlaying && (this
							.source.stop(), this.source.onended = null, this.offset += (this
								.context.currentTime - this.startTime) * this.playbackRate,
							this.isPlaying = !1), this;
						console.warn("THREE.Audio: this Audio has no playback control.")
					},
					stop: function () {
						if (!1 !== this.hasPlaybackControl) return this.source.stop(), this.source
							.onended = null, this.offset = 0, this.isPlaying = !1, this;
						console.warn("THREE.Audio: this Audio has no playback control.")
					},
					connect: function () {
						if (0 < this.filters.length) {
							this.source.connect(this.filters[0]);
							for (var t = 1, e = this.filters.length; t < e; t++) this.filters[t - 1]
								.connect(this.filters[t]);
							this.filters[this.filters.length - 1].connect(this.getOutput())
						} else this.source.connect(this.getOutput());
						return this
					},
					disconnect: function () {
						if (0 < this.filters.length) {
							this.source.disconnect(this.filters[0]);
							for (var t = 1, e = this.filters.length; t < e; t++) this.filters[t - 1]
								.disconnect(this.filters[t]);
							this.filters[this.filters.length - 1].disconnect(this.getOutput())
						} else this.source.disconnect(this.getOutput());
						return this
					},
					getFilters: function () {
						return this.filters
					},
					setFilters: function (t) {
						return t || (t = []), !0 === this.isPlaying ? (this.disconnect(), this
							.filters = t, this.connect()) : this.filters = t, this
					},
					setDetune: function (t) {
						if (this.detune = t, void 0 !== this.source.detune) return !0 === this
							.isPlaying && this.source.detune.setTargetAtTime(this.detune, this
								.context.currentTime, .01), this
					},
					getDetune: function () {
						return this.detune
					},
					getFilter: function () {
						return this.getFilters()[0]
					},
					setFilter: function (t) {
						return this.setFilters(t ? [t] : [])
					},
					setPlaybackRate: function (t) {
						if (!1 !== this.hasPlaybackControl) return this.playbackRate = t, !0 === this
							.isPlaying && this.source.playbackRate.setTargetAtTime(this
								.playbackRate, this.context.currentTime, .01), this;
						console.warn("THREE.Audio: this Audio has no playback control.")
					},
					getPlaybackRate: function () {
						return this.playbackRate
					},
					onEnded: function () {
						this.isPlaying = !1
					},
					getLoop: function () {
						return !1 === this.hasPlaybackControl ? (console.warn(
							"THREE.Audio: this Audio has no playback control."), !1) : this.loop
					},
					setLoop: function (t) {
						if (!1 !== this.hasPlaybackControl) return this.loop = t, !0 === this
							.isPlaying && (this.source.loop = this.loop), this;
						console.warn("THREE.Audio: this Audio has no playback control.")
					},
					getVolume: function () {
						return this.gain.gain.value
					},
					setVolume: function (t) {
						return this.gain.gain.setTargetAtTime(t, this.context.currentTime, .01), this
					}
				}), nu.prototype = Object.assign(Object.create(iu.prototype), {
					constructor: nu,
					getOutput: function () {
						return this.panner
					},
					getRefDistance: function () {
						return this.panner.refDistance
					},
					setRefDistance: function (t) {
						return this.panner.refDistance = t, this
					},
					getRolloffFactor: function () {
						return this.panner.rolloffFactor
					},
					setRolloffFactor: function (t) {
						return this.panner.rolloffFactor = t, this
					},
					getDistanceModel: function () {
						return this.panner.distanceModel
					},
					setDistanceModel: function (t) {
						return this.panner.distanceModel = t, this
					},
					getMaxDistance: function () {
						return this.panner.maxDistance
					},
					setMaxDistance: function (t) {
						return this.panner.maxDistance = t, this
					},
					setDirectionalCone: function (t, e, i) {
						return this.panner.coneInnerAngle = t, this.panner.coneOuterAngle = e, this
							.panner.coneOuterGain = i, this
					},
					updateMatrixWorld: (ql = new li, Xl = new hi, Yl = new li, Zl = new li, function (t) {
						if (Sn.prototype.updateMatrixWorld.call(this, t), !0 !== this
							.hasPlaybackControl || !1 !== this.isPlaying) {
							this.matrixWorld.decompose(ql, Xl, Yl), Zl.set(0, 0, 1)
								.applyQuaternion(Xl);
							var e = this.panner;
							if (e.positionX) {
								var i = this.context.currentTime + this.listener.timeDelta;
								e.positionX.linearRampToValueAtTime(ql.x, i), e.positionY
									.linearRampToValueAtTime(ql.y, i), e.positionZ
									.linearRampToValueAtTime(ql.z, i), e.orientationX
									.linearRampToValueAtTime(Zl.x, i), e.orientationY
									.linearRampToValueAtTime(Zl.y, i), e.orientationZ
									.linearRampToValueAtTime(Zl.z, i)
							} else e.setPosition(ql.x, ql.y, ql.z), e.setOrientation(Zl.x, Zl.y,
								Zl.z)
						}
					})
				}), Object.assign(ru.prototype, {
					getFrequencyData: function () {
						return this.analyser.getByteFrequencyData(this.data), this.data
					},
					getAverageFrequency: function () {
						for (var t = 0, e = this.getFrequencyData(), i = 0; i < e.length; i++) t += e[
							i];
						return t / e.length
					}
				}), Object.assign(au.prototype, {
					accumulate: function (t, e) {
						var i = this.buffer,
							n = this.valueSize,
							r = t * n + n,
							a = this.cumulativeWeight;
						if (0 === a) {
							for (var o = 0; o !== n; ++o) i[r + o] = i[o];
							a = e
						} else {
							var s = e / (a += e);
							this._mixBufferRegion(i, r, 0, s, n)
						}
						this.cumulativeWeight = a
					},
					apply: function (t) {
						var e = this.valueSize,
							i = this.buffer,
							n = t * e + e,
							r = this.cumulativeWeight,
							a = this.binding;
						if (this.cumulativeWeight = 0, r < 1) {
							var o = 3 * e;
							this._mixBufferRegion(i, n, o, 1 - r, e)
						}
						for (var s = e, c = e + e; s !== c; ++s)
							if (i[s] !== i[s + e]) {
								a.setValue(i, n);
								break
							}
					},
					saveOriginalState: function () {
						var t = this.binding,
							e = this.buffer,
							i = this.valueSize,
							n = 3 * i;
						t.getValue(e, n);
						for (var r = i, a = n; r !== a; ++r) e[r] = e[n + r % i];
						this.cumulativeWeight = 0
					},
					restoreOriginalState: function () {
						var t = 3 * this.valueSize;
						this.binding.setValue(this.buffer, t)
					},
					_select: function (t, e, i, n, r) {
						if (.5 <= n)
							for (var a = 0; a !== r; ++a) t[e + a] = t[i + a]
					},
					_slerp: function (t, e, i, n) {
						hi.slerpFlat(t, e, t, e, t, i, n)
					},
					_lerp: function (t, e, i, n, r) {
						for (var a = 1 - n, o = 0; o !== r; ++o) {
							var s = e + o;
							t[s] = t[s] * a + t[i + o] * n
						}
					}
				});
				var ou, su, cu, hu, lu, uu, pu, du, fu, mu, gu, vu, yu, xu, bu, _u, wu, Mu, Su, Eu, Tu, Au, Lu,
					Pu, Ru, Cu, Ou, Iu, Du, Bu, zu, Nu, Gu, Uu, Fu = "\\[\\]\\.:\\/";

				function Hu(t, e, i) {
					var n = i || ju.parseTrackName(e);
					this._targetGroup = t, this._bindings = t.subscribe_(e, n)
				}

				function ju(t, e, i) {
					this.path = e, this.parsedPath = i || ju.parseTrackName(e), this.node = ju.findNode(t, this
						.parsedPath.nodeName) || t, this.rootNode = t
				}

				function ku() {
					this.uuid = oi.generateUUID(), this._objects = Array.prototype.slice.call(arguments), this
						.nCachedObjects_ = 0;
					var t = {};
					this._indicesByUUID = t;
					for (var e = 0, i = arguments.length; e !== i; ++e) t[arguments[e].uuid] = e;
					this._paths = [], this._parsedPaths = [], this._bindings = [], this
						._bindingsIndicesByPath = {};
					var n = this;
					this.stats = {
						objects: {
							get total() {
								return n._objects.length
							},
							get inUse() {
								return this.total - n.nCachedObjects_
							}
						},
						get bindingsPerObject() {
							return n._bindings.length
						}
					}
				}

				function Vu(t, e, i) {
					this._mixer = t, this._clip = e, this._localRoot = i || null;
					for (var n = e.tracks, r = n.length, a = new Array(r), o = {
							endingStart: je,
							endingEnd: je
						}, s = 0; s !== r; ++s) {
						var c = n[s].createInterpolant(null);
						(a[s] = c).settings = o
					}
					this._interpolantSettings = o, this._interpolants = a, this._propertyBindings = new Array(r),
						this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null,
						this._weightInterpolant = null, this.loop = Ne, this._loopCount = -1, this._startTime =
						null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1,
						this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0,
						this.clampWhenFinished = !1, this.zeroSlopeAtStart = !0, this.zeroSlopeAtEnd = !0
				}

				function Wu(t) {
					this._root = t, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this
						.timeScale = 1
				}

				function qu(t) {
					"string" == typeof t && (console.warn("THREE.Uniform: Type parameter is no longer needed."),
						t = arguments[1]), this.value = t
				}

				function Xu() {
					nr.call(this), this.type = "InstancedBufferGeometry", this.maxInstancedCount = void 0
				}

				function Yu(t, e, i) {
					is.call(this, t, e), this.meshPerAttribute = i || 1
				}

				function Zu(t, e, i, n) {
					"number" == typeof i && (n = i, i = !1, console.error(
						"THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument."
						)), Dn.call(this, t, e, i), this.meshPerAttribute = n || 1
				}

				function Ju(t, e, i, n) {
					this.ray = new Gr(t, e), this.near = i || 0, this.far = n || 1 / 0, this.params = {
						Mesh: {},
						Line: {},
						LOD: {},
						Points: {
							threshold: 1
						},
						Sprite: {}
					}, Object.defineProperties(this.params, {
						PointCloud: {
							get: function () {
								return console.warn(
									"THREE.Raycaster: params.PointCloud has been renamed to params.Points."
									), this.Points
							}
						}
					})
				}

				function Qu(t, e) {
					return t.distance - e.distance
				}

				function Ku(t, e, i, n) {
					if (!1 !== t.visible && (t.raycast(e, i), !0 === n))
						for (var r = t.children, a = 0, o = r.length; a < o; a++) Ku(r[a], e, i, !0)
				}

				function $u(t, e, i) {
					return this.radius = void 0 !== t ? t : 1, this.phi = void 0 !== e ? e : 0, this.theta =
						void 0 !== i ? i : 0, this
				}

				function tp(t, e, i) {
					return this.radius = void 0 !== t ? t : 1, this.theta = void 0 !== e ? e : 0, this.y =
						void 0 !== i ? i : 0, this
				}

				function ep(t, e) {
					this.min = void 0 !== t ? t : new si(1 / 0, 1 / 0), this.max = void 0 !== e ? e : new si(-1 /
						0, -1 / 0)
				}

				function ip(t, e) {
					this.start = void 0 !== t ? t : new li, this.end = void 0 !== e ? e : new li
				}

				function np(t) {
					Sn.call(this), this.material = t, this.render = function () {}
				}

				function rp(t, e, i, n) {
					this.object = t, this.size = void 0 !== e ? e : 1;
					var r = void 0 !== i ? i : 16711680,
						a = void 0 !== n ? n : 1,
						o = 0,
						s = this.object.geometry;
					s && s.isGeometry ? o = 3 * s.faces.length : s && s.isBufferGeometry && (o = s.attributes
						.normal.count);
					var c = new nr,
						h = new jn(2 * o * 3, 3);
					c.addAttribute("position", h), ps.call(this, c, new ls({
						color: r,
						linewidth: a
					})), this.matrixAutoUpdate = !1, this.update()
				}

				function ap(t, e) {
					Sn.call(this), this.light = t, this.light.updateMatrixWorld(), this.matrix = t.matrixWorld,
						this.matrixAutoUpdate = !1, this.color = e;
					for (var i = new nr, n = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0,
							1, 1, 0, 0, 0, 0, -1, 1
						], r = 0, a = 1, o = 32; r < o; r++, a++) {
						var s = r / o * Math.PI * 2,
							c = a / o * Math.PI * 2;
						n.push(Math.cos(s), Math.sin(s), 1, Math.cos(c), Math.sin(c), 1)
					}
					i.addAttribute("position", new jn(n, 3));
					var h = new ls({
						fog: !1
					});
					this.cone = new ps(i, h), this.add(this.cone), this.update()
				}

				function op(t) {
					var e = [];
					t && t.isBone && e.push(t);
					for (var i = 0; i < t.children.length; i++) e.push.apply(e, op(t.children[i]));
					return e
				}

				function sp(t) {
					for (var e = op(t), i = new nr, n = [], r = [], a = new Yi(0, 0, 1), o = new Yi(0, 1, 0), s =
							0; s < e.length; s++) {
						var c = e[s];
						c.parent && c.parent.isBone && (n.push(0, 0, 0), n.push(0, 0, 0), r.push(a.r, a.g, a.b), r
							.push(o.r, o.g, o.b))
					}
					i.addAttribute("position", new jn(n, 3)), i.addAttribute("color", new jn(r, 3));
					var h = new ls({
						vertexColors: N,
						depthTest: !1,
						depthWrite: !1,
						transparent: !0
					});
					ps.call(this, i, h), this.root = t, this.bones = e, this.matrix = t.matrixWorld, this
						.matrixAutoUpdate = !1
				}

				function cp(t, e, i) {
					this.light = t, this.light.updateMatrixWorld(), this.color = i;
					var n = new Sc(e, 4, 2),
						r = new Fr({
							wireframe: !0,
							fog: !1
						});
					Hr.call(this, n, r), this.matrix = this.light.matrixWorld, this.matrixAutoUpdate = !1, this
						.update()
				}

				function hp(t, e) {
					this.type = "RectAreaLightHelper", this.light = t, this.color = e;
					var i = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0, 1, 1, 0],
						n = new nr;
					n.addAttribute("position", new jn(i, 3)), n.computeBoundingSphere();
					var r = new ls({
						fog: !1
					});
					us.call(this, n, r);
					var a = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0],
						o = new nr;
					o.addAttribute("position", new jn(a, 3)), o.computeBoundingSphere(), this.add(new Hr(o,
						new Fr({
							side: jt,
							fog: !1
						}))), this.update()
				}

				function lp(t, e, i) {
					Sn.call(this), this.light = t, this.light.updateMatrixWorld(), this.matrix = t.matrixWorld,
						this.matrixAutoUpdate = !1, this.color = i;
					var n = new Ls(e);
					n.rotateY(.5 * Math.PI), this.material = new Fr({
						wireframe: !0,
						fog: !1
					}), void 0 === this.color && (this.material.vertexColors = N);
					var r = n.getAttribute("position"),
						a = new Float32Array(3 * r.count);
					n.addAttribute("color", new Dn(a, 3)), this.add(new Hr(n, this.material)), this.update()
				}

				function up(t, e, i, n) {
					t = t || 10, e = e || 10, i = new Yi(void 0 !== i ? i : 4473924), n = new Yi(void 0 !== n ?
						n : 8947848);
					for (var r = e / 2, a = t / e, o = t / 2, s = [], c = [], h = 0, l = 0, u = -o; h <= e; h++,
						u += a) {
						s.push(-o, 0, u, o, 0, u), s.push(u, 0, -o, u, 0, o);
						var p = h === r ? i : n;
						p.toArray(c, l), l += 3, p.toArray(c, l), l += 3, p.toArray(c, l), l += 3, p.toArray(c,
							l), l += 3
					}
					var d = new nr;
					d.addAttribute("position", new jn(s, 3)), d.addAttribute("color", new jn(c, 3));
					var f = new ls({
						vertexColors: N
					});
					ps.call(this, d, f)
				}

				function pp(t, e, i, n, r, a) {
					t = t || 10, e = e || 16, i = i || 8, n = n || 64, r = new Yi(void 0 !== r ? r : 4473924), a =
						new Yi(void 0 !== a ? a : 8947848);
					var o, s, c, h, l, u, p, d = [],
						f = [];
					for (h = 0; h <= e; h++) c = h / e * (2 * Math.PI), o = Math.sin(c) * t, s = Math.cos(c) * t,
						d.push(0, 0, 0), d.push(o, 0, s), p = 1 & h ? r : a, f.push(p.r, p.g, p.b), f.push(p.r, p
							.g, p.b);
					for (h = 0; h <= i; h++)
						for (p = 1 & h ? r : a, u = t - t / i * h, l = 0; l < n; l++) c = l / n * (2 * Math.PI),
							o = Math.sin(c) * u, s = Math.cos(c) * u, d.push(o, 0, s), f.push(p.r, p.g, p.b), c =
							(l + 1) / n * (2 * Math.PI), o = Math.sin(c) * u, s = Math.cos(c) * u, d.push(o, 0,
							s), f.push(p.r, p.g, p.b);
					var m = new nr;
					m.addAttribute("position", new jn(d, 3)), m.addAttribute("color", new jn(f, 3));
					var g = new ls({
						vertexColors: N
					});
					ps.call(this, m, g)
				}

				function dp(t, e, i, n) {
					this.audio = t, this.range = e || 1, this.divisionsInnerAngle = i || 16, this
						.divisionsOuterAngle = n || 2;
					var r = new nr,
						a = this.divisionsInnerAngle + 2 * this.divisionsOuterAngle,
						o = new Float32Array(3 * (3 * a + 3));
					r.addAttribute("position", new Dn(o, 3));
					var s = new ls({
							color: 65280
						}),
						c = new ls({
							color: 16776960
						});
					us.call(this, r, [c, s]), this.update()
				}

				function fp(t, e, i, n) {
					this.object = t, this.size = void 0 !== e ? e : 1;
					var r = void 0 !== i ? i : 16776960,
						a = void 0 !== n ? n : 1,
						o = 0,
						s = this.object.geometry;
					s && s.isGeometry ? o = s.faces.length : console.warn(
						"THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead."
						);
					var c = new nr,
						h = new jn(2 * o * 3, 3);
					c.addAttribute("position", h), ps.call(this, c, new ls({
						color: r,
						linewidth: a
					})), this.matrixAutoUpdate = !1, this.update()
				}

				function mp(t, e, i) {
					Sn.call(this), this.light = t, this.light.updateMatrixWorld(), this.matrix = t.matrixWorld,
						this.matrixAutoUpdate = !1, this.color = i, void 0 === e && (e = 1);
					var n = new nr;
					n.addAttribute("position", new jn([-e, e, 0, e, e, 0, e, -e, 0, -e, -e, 0, -e, e, 0], 3));
					var r = new ls({
						fog: !1
					});
					this.lightPlane = new us(n, r), this.add(this.lightPlane), (n = new nr).addAttribute(
						"position", new jn([0, 0, 0, 0, 0, 1], 3)), this.targetLine = new us(n, r), this.add(
						this.targetLine), this.update()
				}

				function gp(t) {
					var e = new nr,
						i = new ls({
							color: 16777215,
							vertexColors: D
						}),
						n = [],
						r = [],
						a = {},
						o = new Yi(16755200),
						s = new Yi(16711680),
						c = new Yi(43775),
						h = new Yi(16777215),
						l = new Yi(3355443);

					function u(t, e, i) {
						p(t, i), p(e, i)
					}

					function p(t, e) {
						n.push(0, 0, 0), r.push(e.r, e.g, e.b), void 0 === a[t] && (a[t] = []), a[t].push(n
							.length / 3 - 1)
					}
					u("n1", "n2", o), u("n2", "n4", o), u("n4", "n3", o), u("n3", "n1", o), u("f1", "f2", o), u(
							"f2", "f4", o), u("f4", "f3", o), u("f3", "f1", o), u("n1", "f1", o), u("n2", "f2",
						o), u("n3", "f3", o), u("n4", "f4", o), u("p", "n1", s), u("p", "n2", s), u("p", "n3", s),
						u("p", "n4", s), u("u1", "u2", c), u("u2", "u3", c), u("u3", "u1", c), u("c", "t", h), u(
							"p", "c", l), u("cn1", "cn2", l), u("cn3", "cn4", l), u("cf1", "cf2", l), u("cf3",
							"cf4", l), e.addAttribute("position", new jn(n, 3)), e.addAttribute("color", new jn(r,
							3)), ps.call(this, e, i), this.camera = t, this.camera.updateProjectionMatrix && this
						.camera.updateProjectionMatrix(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1,
						this.pointMap = a, this.update()
				}

				function vp(t, e) {
					this.object = t, void 0 === e && (e = 16776960);
					var i = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3,
							7
						]),
						n = new Float32Array(24),
						r = new nr;
					r.setIndex(new Dn(i, 1)), r.addAttribute("position", new Dn(n, 3)), ps.call(this, r, new ls({
						color: e
					})), this.matrixAutoUpdate = !1, this.update()
				}

				function yp(t, e) {
					this.type = "Box3Helper", this.box = t;
					var i = void 0 !== e ? e : 16776960,
						n = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3,
							7
						]),
						r = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1],
						a = new nr;
					a.setIndex(new Dn(n, 1)), a.addAttribute("position", new jn(r, 3)), ps.call(this, a, new ls({
						color: i
					})), this.geometry.computeBoundingSphere()
				}

				function xp(t, e, i) {
					this.type = "PlaneHelper", this.plane = t, this.size = void 0 === e ? 1 : e;
					var n = void 0 !== i ? i : 16776960,
						r = [1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 0, 0,
							1, 0, 0, 0
						],
						a = new nr;
					a.addAttribute("position", new jn(r, 3)), a.computeBoundingSphere(), us.call(this, a, new ls({
						color: n
					}));
					var o = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1],
						s = new nr;
					s.addAttribute("position", new jn(o, 3)), s.computeBoundingSphere(), this.add(new Hr(s,
						new Fr({
							color: n,
							opacity: .2,
							transparent: !0,
							depthWrite: !1
						})))
				}

				function bp(t, e, i, n, r, a) {
					Sn.call(this), void 0 === t && (t = new li(0, 0, 1)), void 0 === e && (e = new li(0, 0, 0)),
						void 0 === i && (i = 1), void 0 === n && (n = 16776960), void 0 === r && (r = .2 * i),
						void 0 === a && (a = .2 * r), void 0 === zu && ((zu = new nr).addAttribute("position",
								new jn([0, 0, 0, 0, 1, 0], 3)), (Nu = new Dc(0, .5, 1, 5, 1)).translate(0, -.5,
							0)), this.position.copy(e), this.line = new us(zu, new ls({
							color: n
						})), this.line.matrixAutoUpdate = !1, this.add(this.line), this.cone = new Hr(Nu, new Fr({
							color: n
						})), this.cone.matrixAutoUpdate = !1, this.add(this.cone), this.setDirection(t), this
						.setLength(i, r, a)
				}

				function _p(t) {
					var e = [0, 0, 0, t = t || 1, 0, 0, 0, 0, 0, 0, t, 0, 0, 0, 0, 0, 0, t],
						i = [1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1],
						n = new nr;
					n.addAttribute("position", new jn(e, 3)), n.addAttribute("color", new jn(i, 3));
					var r = new ls({
						vertexColors: N
					});
					ps.call(this, n, r)
				}

				function wp(t, e, i, n, r, a, o) {
					return console.warn("THREE.Face4 has been removed. A THREE.Face3 will be created instead."),
						new en(t, e, i, r, a, o)
				}
				Object.assign(Hu.prototype, {
						getValue: function (t, e) {
							this.bind();
							var i = this._targetGroup.nCachedObjects_,
								n = this._bindings[i];
							void 0 !== n && n.getValue(t, e)
						},
						setValue: function (t, e) {
							for (var i = this._bindings, n = this._targetGroup.nCachedObjects_, r = i
									.length; n !== r; ++n) i[n].setValue(t, e)
						},
						bind: function () {
							for (var t = this._bindings, e = this._targetGroup.nCachedObjects_, i = t
									.length; e !== i; ++e) t[e].bind()
						},
						unbind: function () {
							for (var t = this._bindings, e = this._targetGroup.nCachedObjects_, i = t
									.length; e !== i; ++e) t[e].unbind()
						}
					}), Object.assign(ju, {
						Composite: Hu,
						create: function (t, e, i) {
							return t && t.isAnimationObjectGroup ? new ju.Composite(t, e, i) : new ju(t,
								e, i)
						},
						sanitizeNodeName: (fu = new RegExp("[" + Fu + "]", "g"), function (t) {
							return t.replace(/\s/g, "_").replace(fu, "")
						}),
						parseTrackName: (ou = "[^" + Fu + "]", su = "[^" + Fu.replace("\\.", "") + "]", cu =
							/((?:WC+[\/:])*)/.source.replace("WC", ou), hu = /(WCOD+)?/.source.replace(
								"WCOD", su), lu = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", ou),
							uu = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", ou), pu = new RegExp("^" +
								cu + hu + lu + uu + "$"), du = ["material", "materials", "bones"],
							function (t) {
								var e = pu.exec(t);
								if (!e) throw new Error("PropertyBinding: Cannot parse trackName: " + t);
								var i = {
										nodeName: e[2],
										objectName: e[3],
										objectIndex: e[4],
										propertyName: e[5],
										propertyIndex: e[6]
									},
									n = i.nodeName && i.nodeName.lastIndexOf(".");
								if (void 0 !== n && -1 !== n) {
									var r = i.nodeName.substring(n + 1); - 1 !== du.indexOf(r) && (i
										.nodeName = i.nodeName.substring(0, n), i.objectName = r)
								}
								if (null === i.propertyName || 0 === i.propertyName.length)
								throw new Error(
										"PropertyBinding: can not parse propertyName from trackName: " +
										t);
								return i
							}),
						findNode: function (t, r) {
							if (!r || "" === r || "root" === r || "." === r || -1 === r || r === t.name ||
								r === t.uuid) return t;
							if (t.skeleton) {
								var e = t.skeleton.getBoneByName(r);
								if (void 0 !== e) return e
							}
							if (t.children) {
								var a = function (t) {
										for (var e = 0; e < t.length; e++) {
											var i = t[e];
											if (i.name === r || i.uuid === r) return i;
											var n = a(i.children);
											if (n) return n
										}
										return null
									},
									i = a(t.children);
								if (i) return i
							}
							return null
						}
					}), Object.assign(ju.prototype, {
						_getValue_unavailable: function () {},
						_setValue_unavailable: function () {},
						BindingType: {
							Direct: 0,
							EntireArray: 1,
							ArrayElement: 2,
							HasFromToArray: 3
						},
						Versioning: {
							None: 0,
							NeedsUpdate: 1,
							MatrixWorldNeedsUpdate: 2
						},
						GetterByBindingType: [function (t, e) {
							t[e] = this.node[this.propertyName]
						}, function (t, e) {
							for (var i = this.resolvedProperty, n = 0, r = i.length; n !== r; ++n) t[
								e++] = i[n]
						}, function (t, e) {
							t[e] = this.resolvedProperty[this.propertyIndex]
						}, function (t, e) {
							this.resolvedProperty.toArray(t, e)
						}],
						SetterByBindingTypeAndVersioning: [
							[function (t, e) {
								this.targetObject[this.propertyName] = t[e]
							}, function (t, e) {
								this.targetObject[this.propertyName] = t[e], this.targetObject
									.needsUpdate = !0
							}, function (t, e) {
								this.targetObject[this.propertyName] = t[e], this.targetObject
									.matrixWorldNeedsUpdate = !0
							}],
							[function (t, e) {
								for (var i = this.resolvedProperty, n = 0, r = i.length; n !== r; ++n)
									i[n] = t[e++]
							}, function (t, e) {
								for (var i = this.resolvedProperty, n = 0, r = i.length; n !== r; ++n)
									i[n] = t[e++];
								this.targetObject.needsUpdate = !0
							}, function (t, e) {
								for (var i = this.resolvedProperty, n = 0, r = i.length; n !== r; ++n)
									i[n] = t[e++];
								this.targetObject.matrixWorldNeedsUpdate = !0
							}],
							[function (t, e) {
								this.resolvedProperty[this.propertyIndex] = t[e]
							}, function (t, e) {
								this.resolvedProperty[this.propertyIndex] = t[e], this.targetObject
									.needsUpdate = !0
							}, function (t, e) {
								this.resolvedProperty[this.propertyIndex] = t[e], this.targetObject
									.matrixWorldNeedsUpdate = !0
							}],
							[function (t, e) {
								this.resolvedProperty.fromArray(t, e)
							}, function (t, e) {
								this.resolvedProperty.fromArray(t, e), this.targetObject
									.needsUpdate = !0
							}, function (t, e) {
								this.resolvedProperty.fromArray(t, e), this.targetObject
									.matrixWorldNeedsUpdate = !0
							}]
						],
						getValue: function (t, e) {
							this.bind(), this.getValue(t, e)
						},
						setValue: function (t, e) {
							this.bind(), this.setValue(t, e)
						},
						bind: function () {
							var t = this.node,
								e = this.parsedPath,
								i = e.objectName,
								n = e.propertyName,
								r = e.propertyIndex;
							if (t || (t = ju.findNode(this.rootNode, e.nodeName) || this.rootNode, this
									.node = t), this.getValue = this._getValue_unavailable, this
								.setValue = this._setValue_unavailable, t) {
								if (i) {
									var a = e.objectIndex;
									switch (i) {
										case "materials":
											if (!t.material) return void console.error(
												"THREE.PropertyBinding: Can not bind to material as node does not have a material.",
												this);
											if (!t.material.materials) return void console.error(
												"THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",
												this);
											t = t.material.materials;
											break;
										case "bones":
											if (!t.skeleton) return void console.error(
												"THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",
												this);
											t = t.skeleton.bones;
											for (var o = 0; o < t.length; o++)
												if (t[o].name === a) {
													a = o;
													break
												} break;
										default:
											if (void 0 === t[i]) return void console.error(
												"THREE.PropertyBinding: Can not bind to objectName of node undefined.",
												this);
											t = t[i]
									}
									if (void 0 !== a) {
										if (void 0 === t[a]) return void console.error(
											"THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",
											this, t);
										t = t[a]
									}
								}
								var s = t[n];
								if (void 0 !== s) {
									var c = this.Versioning.None;
									void 0 !== (this.targetObject = t).needsUpdate ? c = this.Versioning
										.NeedsUpdate : void 0 !== t.matrixWorldNeedsUpdate && (c = this
											.Versioning.MatrixWorldNeedsUpdate);
									var h = this.BindingType.Direct;
									if (void 0 !== r) {
										if ("morphTargetInfluences" === n) {
											if (!t.geometry) return void console.error(
												"THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",
												this);
											if (t.geometry.isBufferGeometry) {
												if (!t.geometry.morphAttributes) return void console
													.error(
														"THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",
														this);
												for (o = 0; o < this.node.geometry.morphAttributes
													.position.length; o++)
													if (t.geometry.morphAttributes.position[o].name ===
														r) {
														r = o;
														break
													}
											} else {
												if (!t.geometry.morphTargets) return void console.error(
													"THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphTargets.",
													this);
												for (o = 0; o < this.node.geometry.morphTargets
													.length; o++)
													if (t.geometry.morphTargets[o].name === r) {
														r = o;
														break
													}
											}
										}
										h = this.BindingType.ArrayElement, this.resolvedProperty = s, this
											.propertyIndex = r
									} else void 0 !== s.fromArray && void 0 !== s.toArray ? (h = this
											.BindingType.HasFromToArray, this.resolvedProperty = s) :
										Array.isArray(s) ? (h = this.BindingType.EntireArray, this
											.resolvedProperty = s) : this.propertyName = n;
									this.getValue = this.GetterByBindingType[h], this.setValue = this
										.SetterByBindingTypeAndVersioning[h][c]
								} else {
									var l = e.nodeName;
									console.error(
										"THREE.PropertyBinding: Trying to update property for track: " +
										l + "." + n + " but it wasn't found.", t)
								}
							} else console.error(
								"THREE.PropertyBinding: Trying to update node for track: " + this
								.path + " but it wasn't found.")
						},
						unbind: function () {
							this.node = null, this.getValue = this._getValue_unbound, this.setValue = this
								._setValue_unbound
						}
					}), Object.assign(ju.prototype, {
						_getValue_unbound: ju.prototype.getValue,
						_setValue_unbound: ju.prototype.setValue
					}), Object.assign(ku.prototype, {
						isAnimationObjectGroup: !0,
						add: function () {
							for (var t = this._objects, e = t.length, i = this.nCachedObjects_, n = this
									._indicesByUUID, r = this._paths, a = this._parsedPaths, o = this
									._bindings, s = o.length, c = void 0, h = 0, l = arguments
									.length; h !== l; ++h) {
								var u = arguments[h],
									p = u.uuid,
									d = n[p];
								if (void 0 === d) {
									d = e++, n[p] = d, t.push(u);
									for (var f = 0, m = s; f !== m; ++f) o[f].push(new ju(u, r[f], a[f]))
								} else if (d < i) {
									c = t[d];
									var g = --i,
										v = t[g];
									t[n[v.uuid] = d] = v, t[n[p] = g] = u;
									for (f = 0, m = s; f !== m; ++f) {
										var y = o[f],
											x = y[g],
											b = y[d];
										y[d] = x, void 0 === b && (b = new ju(u, r[f], a[f])), y[g] = b
									}
								} else t[d] !== c && console.error(
									"THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes."
									)
							}
							this.nCachedObjects_ = i
						},
						remove: function () {
							for (var t = this._objects, e = this.nCachedObjects_, i = this._indicesByUUID,
									n = this._bindings, r = n.length, a = 0, o = arguments.length; a !==
								o; ++a) {
								var s = arguments[a],
									c = s.uuid,
									h = i[c];
								if (void 0 !== h && e <= h) {
									var l = e++,
										u = t[l];
									t[i[u.uuid] = h] = u, t[i[c] = l] = s;
									for (var p = 0, d = r; p !== d; ++p) {
										var f = n[p],
											m = f[l],
											g = f[h];
										f[h] = m, f[l] = g
									}
								}
							}
							this.nCachedObjects_ = e
						},
						uncache: function () {
							for (var t = this._objects, e = t.length, i = this.nCachedObjects_, n = this
									._indicesByUUID, r = this._bindings, a = r.length, o = 0, s =
									arguments.length; o !== s; ++o) {
								var c = arguments[o].uuid,
									h = n[c];
								if (void 0 !== h)
									if (delete n[c], h < i) {
										var l = --i,
											u = t[l],
											p = t[v = --e];
										t[n[u.uuid] = h] = u, t[n[p.uuid] = l] = p, t.pop();
										for (var d = 0, f = a; d !== f; ++d) {
											var m = (y = r[d])[l],
												g = y[v];
											y[h] = m, y[l] = g, y.pop()
										}
									} else {
										var v;
										t[n[(p = t[v = --e]).uuid] = h] = p, t.pop();
										for (d = 0, f = a; d !== f; ++d) {
											var y;
											(y = r[d])[h] = y[v], y.pop()
										}
									}
							}
							this.nCachedObjects_ = i
						},
						subscribe_: function (t, e) {
							var i = this._bindingsIndicesByPath,
								n = i[t],
								r = this._bindings;
							if (void 0 !== n) return r[n];
							var a = this._paths,
								o = this._parsedPaths,
								s = this._objects,
								c = s.length,
								h = this.nCachedObjects_,
								l = new Array(c);
							n = r.length, i[t] = n, a.push(t), o.push(e), r.push(l);
							for (var u = h, p = s.length; u !== p; ++u) {
								var d = s[u];
								l[u] = new ju(d, t, e)
							}
							return l
						},
						unsubscribe_: function (t) {
							var e = this._bindingsIndicesByPath,
								i = e[t];
							if (void 0 !== i) {
								var n = this._paths,
									r = this._parsedPaths,
									a = this._bindings,
									o = a.length - 1,
									s = a[o];
								a[e[t[o]] = i] = s, a.pop(), r[i] = r[o], r.pop(), n[i] = n[o], n.pop()
							}
						}
					}), Object.assign(Vu.prototype, {
						play: function () {
							return this._mixer._activateAction(this), this
						},
						stop: function () {
							return this._mixer._deactivateAction(this), this.reset()
						},
						reset: function () {
							return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -
								1, this._startTime = null, this.stopFading().stopWarping()
						},
						isRunning: function () {
							return this.enabled && !this.paused && 0 !== this.timeScale && null === this
								._startTime && this._mixer._isActiveAction(this)
						},
						isScheduled: function () {
							return this._mixer._isActiveAction(this)
						},
						startAt: function (t) {
							return this._startTime = t, this
						},
						setLoop: function (t, e) {
							return this.loop = t, this.repetitions = e, this
						},
						setEffectiveWeight: function (t) {
							return this.weight = t, this._effectiveWeight = this.enabled ? t : 0, this
								.stopFading()
						},
						getEffectiveWeight: function () {
							return this._effectiveWeight
						},
						fadeIn: function (t) {
							return this._scheduleFading(t, 0, 1)
						},
						fadeOut: function (t) {
							return this._scheduleFading(t, 1, 0)
						},
						crossFadeFrom: function (t, e, i) {
							if (t.fadeOut(e), this.fadeIn(e), i) {
								var n = this._clip.duration,
									r = t._clip.duration,
									a = r / n,
									o = n / r;
								t.warp(1, a, e), this.warp(o, 1, e)
							}
							return this
						},
						crossFadeTo: function (t, e, i) {
							return t.crossFadeFrom(this, e, i)
						},
						stopFading: function () {
							var t = this._weightInterpolant;
							return null !== t && (this._weightInterpolant = null, this._mixer
								._takeBackControlInterpolant(t)), this
						},
						setEffectiveTimeScale: function (t) {
							return this.timeScale = t, this._effectiveTimeScale = this.paused ? 0 : t,
								this.stopWarping()
						},
						getEffectiveTimeScale: function () {
							return this._effectiveTimeScale
						},
						setDuration: function (t) {
							return this.timeScale = this._clip.duration / t, this.stopWarping()
						},
						syncWith: function (t) {
							return this.time = t.time, this.timeScale = t.timeScale, this.stopWarping()
						},
						halt: function (t) {
							return this.warp(this._effectiveTimeScale, 0, t)
						},
						warp: function (t, e, i) {
							var n = this._mixer,
								r = n.time,
								a = this._timeScaleInterpolant,
								o = this.timeScale;
							null === a && (a = n._lendControlInterpolant(), this._timeScaleInterpolant =
								a);
							var s = a.parameterPositions,
								c = a.sampleValues;
							return s[0] = r, s[1] = r + i, c[0] = t / o, c[1] = e / o, this
						},
						stopWarping: function () {
							var t = this._timeScaleInterpolant;
							return null !== t && (this._timeScaleInterpolant = null, this._mixer
								._takeBackControlInterpolant(t)), this
						},
						getMixer: function () {
							return this._mixer
						},
						getClip: function () {
							return this._clip
						},
						getRoot: function () {
							return this._localRoot || this._mixer._root
						},
						_update: function (t, e, i, n) {
							if (this.enabled) {
								var r = this._startTime;
								if (null !== r) {
									var a = (t - r) * i;
									if (a < 0 || 0 === i) return;
									this._startTime = null, e = i * a
								}
								e *= this._updateTimeScale(t);
								var o = this._updateTime(e),
									s = this._updateWeight(t);
								if (0 < s)
									for (var c = this._interpolants, h = this._propertyBindings, l = 0,
											u = c.length; l !== u; ++l) c[l].evaluate(o), h[l].accumulate(
										n, s)
							} else this._updateWeight(t)
						},
						_updateWeight: function (t) {
							var e = 0;
							if (this.enabled) {
								e = this.weight;
								var i = this._weightInterpolant;
								if (null !== i) {
									var n = i.evaluate(t)[0];
									e *= n, t > i.parameterPositions[1] && (this.stopFading(), 0 === n &&
										(this.enabled = !1))
								}
							}
							return this._effectiveWeight = e
						},
						_updateTimeScale: function (t) {
							var e = 0;
							if (!this.paused) {
								e = this.timeScale;
								var i = this._timeScaleInterpolant;
								if (null !== i) e *= i.evaluate(t)[0], t > i.parameterPositions[1] && (
									this.stopWarping(), 0 === e ? this.paused = !0 : this.timeScale =
									e)
							}
							return this._effectiveTimeScale = e
						},
						_updateTime: function (t) {
							var e = this.time + t,
								i = this._clip.duration,
								n = this.loop,
								r = this._loopCount,
								a = n === Ge;
							if (0 === t) return -1 === r ? e : a && 1 == (1 & r) ? i - e : e;
							if (n === ze) {
								-1 === r && (this._loopCount = 0, this._setEndings(!0, !0, !1));
								t: {
									if (i <= e) e = i;
									else {
										if (!(e < 0)) break t;
										e = 0
									}
									this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
									this._mixer.dispatchEvent({
										type: "finished",
										action: this,
										direction: t < 0 ? -1 : 1
									})
								}
							} else {
								if (-1 === r && (0 <= t ? (r = 0, this._setEndings(!0, 0 === this
										.repetitions, a)) : this._setEndings(0 === this.repetitions, !
										0, a)), i <= e || e < 0) {
									var o = Math.floor(e / i);
									e -= i * o, r += Math.abs(o);
									var s = this.repetitions - r;
									if (s <= 0) this.clampWhenFinished ? this.paused = !0 : this
										.enabled = !1, e = 0 < t ? i : 0, this._mixer.dispatchEvent({
											type: "finished",
											action: this,
											direction: 0 < t ? 1 : -1
										});
									else {
										if (1 === s) {
											var c = t < 0;
											this._setEndings(c, !c, a)
										} else this._setEndings(!1, !1, a);
										this._loopCount = r, this._mixer.dispatchEvent({
											type: "loop",
											action: this,
											loopDelta: o
										})
									}
								}
								if (a && 1 == (1 & r)) return i - (this.time = e)
							}
							return this.time = e
						},
						_setEndings: function (t, e, i) {
							var n = this._interpolantSettings;
							n.endingEnd = i ? n.endingStart = ke : (n.endingStart = t ? this
								.zeroSlopeAtStart ? ke : je : Ve, e ? this.zeroSlopeAtEnd ? ke : je :
								Ve)
						},
						_scheduleFading: function (t, e, i) {
							var n = this._mixer,
								r = n.time,
								a = this._weightInterpolant;
							null === a && (a = n._lendControlInterpolant(), this._weightInterpolant = a);
							var o = a.parameterPositions,
								s = a.sampleValues;
							return o[0] = r, s[0] = e, o[1] = r + t, s[1] = i, this
						}
					}), Wu.prototype = Object.assign(Object.create(e.prototype), {
						constructor: Wu,
						_bindAction: function (t, e) {
							var i = t._localRoot || this._root,
								n = t._clip.tracks,
								r = n.length,
								a = t._propertyBindings,
								o = t._interpolants,
								s = i.uuid,
								c = this._bindingsByRootAndName,
								h = c[s];
							void 0 === h && (h = {}, c[s] = h);
							for (var l = 0; l !== r; ++l) {
								var u = n[l],
									p = u.name,
									d = h[p];
								if (void 0 !== d) a[l] = d;
								else {
									if (void 0 !== (d = a[l])) {
										null === d._cacheIndex && (++d.referenceCount, this
											._addInactiveBinding(d, s, p));
										continue
									}
									var f = e && e._propertyBindings[l].binding.parsedPath;
									++(d = new au(ju.create(i, p, f), u.ValueTypeName, u.getValueSize()))
									.referenceCount, this._addInactiveBinding(d, s, p), a[l] = d
								}
								o[l].resultBuffer = d.buffer
							}
						},
						_activateAction: function (t) {
							if (!this._isActiveAction(t)) {
								if (null === t._cacheIndex) {
									var e = (t._localRoot || this._root).uuid,
										i = t._clip.uuid,
										n = this._actionsByClip[i];
									this._bindAction(t, n && n.knownActions[0]), this._addInactiveAction(
										t, i, e)
								}
								for (var r = t._propertyBindings, a = 0, o = r.length; a !== o; ++a) {
									var s = r[a];
									0 == s.useCount++ && (this._lendBinding(s), s.saveOriginalState())
								}
								this._lendAction(t)
							}
						},
						_deactivateAction: function (t) {
							if (this._isActiveAction(t)) {
								for (var e = t._propertyBindings, i = 0, n = e.length; i !== n; ++i) {
									var r = e[i];
									0 == --r.useCount && (r.restoreOriginalState(), this._takeBackBinding(
										r))
								}
								this._takeBackAction(t)
							}
						},
						_initMemoryManager: function () {
							this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this
								._bindings = [], this._nActiveBindings = 0, this
								._bindingsByRootAndName = {}, this._controlInterpolants = [], this
								._nActiveControlInterpolants = 0;
							var t = this;
							this.stats = {
								actions: {
									get total() {
										return t._actions.length
									},
									get inUse() {
										return t._nActiveActions
									}
								},
								bindings: {
									get total() {
										return t._bindings.length
									},
									get inUse() {
										return t._nActiveBindings
									}
								},
								controlInterpolants: {
									get total() {
										return t._controlInterpolants.length
									},
									get inUse() {
										return t._nActiveControlInterpolants
									}
								}
							}
						},
						_isActiveAction: function (t) {
							var e = t._cacheIndex;
							return null !== e && e < this._nActiveActions
						},
						_addInactiveAction: function (t, e, i) {
							var n = this._actions,
								r = this._actionsByClip,
								a = r[e];
							if (void 0 === a) a = {
								knownActions: [t],
								actionByRoot: {}
							}, t._byClipCacheIndex = 0, r[e] = a;
							else {
								var o = a.knownActions;
								t._byClipCacheIndex = o.length, o.push(t)
							}
							t._cacheIndex = n.length, n.push(t), a.actionByRoot[i] = t
						},
						_removeInactiveAction: function (t) {
							var e = this._actions,
								i = e[e.length - 1],
								n = t._cacheIndex;
							e[i._cacheIndex = n] = i, e.pop(), t._cacheIndex = null;
							var r = t._clip.uuid,
								a = this._actionsByClip,
								o = a[r],
								s = o.knownActions,
								c = s[s.length - 1],
								h = t._byClipCacheIndex;
							s[c._byClipCacheIndex = h] = c, s.pop(), t._byClipCacheIndex = null, delete o
								.actionByRoot[(t._localRoot || this._root).uuid], 0 === s.length &&
								delete a[r], this._removeInactiveBindingsForAction(t)
						},
						_removeInactiveBindingsForAction: function (t) {
							for (var e = t._propertyBindings, i = 0, n = e.length; i !== n; ++i) {
								var r = e[i];
								0 == --r.referenceCount && this._removeInactiveBinding(r)
							}
						},
						_lendAction: function (t) {
							var e = this._actions,
								i = t._cacheIndex,
								n = this._nActiveActions++,
								r = e[n];
							e[t._cacheIndex = n] = t, e[r._cacheIndex = i] = r
						},
						_takeBackAction: function (t) {
							var e = this._actions,
								i = t._cacheIndex,
								n = --this._nActiveActions,
								r = e[n];
							e[t._cacheIndex = n] = t, e[r._cacheIndex = i] = r
						},
						_addInactiveBinding: function (t, e, i) {
							var n = this._bindingsByRootAndName,
								r = n[e],
								a = this._bindings;
							void 0 === r && (r = {}, n[e] = r), (r[i] = t)._cacheIndex = a.length, a.push(
								t)
						},
						_removeInactiveBinding: function (t) {
							var e = this._bindings,
								i = t.binding,
								n = i.rootNode.uuid,
								r = i.path,
								a = this._bindingsByRootAndName,
								o = a[n],
								s = e[e.length - 1],
								c = t._cacheIndex;
							e[s._cacheIndex = c] = s, e.pop(), delete o[r];
							t: {
								for (var h in o) break t;delete a[n]
							}
						},
						_lendBinding: function (t) {
							var e = this._bindings,
								i = t._cacheIndex,
								n = this._nActiveBindings++,
								r = e[n];
							e[t._cacheIndex = n] = t, e[r._cacheIndex = i] = r
						},
						_takeBackBinding: function (t) {
							var e = this._bindings,
								i = t._cacheIndex,
								n = --this._nActiveBindings,
								r = e[n];
							e[t._cacheIndex = n] = t, e[r._cacheIndex = i] = r
						},
						_lendControlInterpolant: function () {
							var t = this._controlInterpolants,
								e = this._nActiveControlInterpolants++,
								i = t[e];
							return void 0 === i && (t[(i = new th(new Float32Array(2), new Float32Array(
									2), 1, this._controlInterpolantsResultBuffer)).__cacheIndex =
								e] = i), i
						},
						_takeBackControlInterpolant: function (t) {
							var e = this._controlInterpolants,
								i = t.__cacheIndex,
								n = --this._nActiveControlInterpolants,
								r = e[n];
							e[t.__cacheIndex = n] = t, e[r.__cacheIndex = i] = r
						},
						_controlInterpolantsResultBuffer: new Float32Array(1),
						clipAction: function (t, e) {
							var i = e || this._root,
								n = i.uuid,
								r = "string" == typeof t ? lh.findByName(i, t) : t,
								a = null !== r ? r.uuid : t,
								o = this._actionsByClip[a],
								s = null;
							if (void 0 !== o) {
								var c = o.actionByRoot[n];
								if (void 0 !== c) return c;
								s = o.knownActions[0], null === r && (r = s._clip)
							}
							if (null === r) return null;
							var h = new Vu(this, r, e);
							return this._bindAction(h, s), this._addInactiveAction(h, a, n), h
						},
						existingAction: function (t, e) {
							var i = e || this._root,
								n = i.uuid,
								r = "string" == typeof t ? lh.findByName(i, t) : t,
								a = r ? r.uuid : t,
								o = this._actionsByClip[a];
							return void 0 !== o && o.actionByRoot[n] || null
						},
						stopAllAction: function () {
							var t = this._actions,
								e = this._nActiveActions,
								i = this._bindings,
								n = this._nActiveBindings;
							this._nActiveActions = 0;
							for (var r = this._nActiveBindings = 0; r !== e; ++r) t[r].reset();
							for (r = 0; r !== n; ++r) i[r].useCount = 0;
							return this
						},
						update: function (t) {
							t *= this.timeScale;
							for (var e = this._actions, i = this._nActiveActions, n = this.time += t, r =
									Math.sign(t), a = this._accuIndex ^= 1, o = 0; o !== i; ++o) {
								e[o]._update(n, t, r, a)
							}
							var s = this._bindings,
								c = this._nActiveBindings;
							for (o = 0; o !== c; ++o) s[o].apply(a);
							return this
						},
						getRoot: function () {
							return this._root
						},
						uncacheClip: function (t) {
							var e = this._actions,
								i = t.uuid,
								n = this._actionsByClip,
								r = n[i];
							if (void 0 !== r) {
								for (var a = r.knownActions, o = 0, s = a.length; o !== s; ++o) {
									var c = a[o];
									this._deactivateAction(c);
									var h = c._cacheIndex,
										l = e[e.length - 1];
									c._cacheIndex = null, c._byClipCacheIndex = null, e[l._cacheIndex =
										h] = l, e.pop(), this._removeInactiveBindingsForAction(c)
								}
								delete n[i]
							}
						},
						uncacheRoot: function (t) {
							var e = t.uuid,
								i = this._actionsByClip;
							for (var n in i) {
								var r = i[n].actionByRoot[e];
								void 0 !== r && (this._deactivateAction(r), this._removeInactiveAction(r))
							}
							var a = this._bindingsByRootAndName[e];
							if (void 0 !== a)
								for (var o in a) {
									var s = a[o];
									s.restoreOriginalState(), this._removeInactiveBinding(s)
								}
						},
						uncacheAction: function (t, e) {
							var i = this.existingAction(t, e);
							null !== i && (this._deactivateAction(i), this._removeInactiveAction(i))
						}
					}), qu.prototype.clone = function () {
						return new qu(void 0 === this.value.clone ? this.value : this.value.clone())
					}, Xu.prototype = Object.assign(Object.create(nr.prototype), {
						constructor: Xu,
						isInstancedBufferGeometry: !0,
						copy: function (t) {
							return nr.prototype.copy.call(this, t), this.maxInstancedCount = t
								.maxInstancedCount, this
						},
						clone: function () {
							return (new this.constructor).copy(this)
						}
					}), Yu.prototype = Object.assign(Object.create(is.prototype), {
						constructor: Yu,
						isInstancedInterleavedBuffer: !0,
						copy: function (t) {
							return is.prototype.copy.call(this, t), this.meshPerAttribute = t
								.meshPerAttribute, this
						}
					}), Zu.prototype = Object.assign(Object.create(Dn.prototype), {
						constructor: Zu,
						isInstancedBufferAttribute: !0,
						copy: function (t) {
							return Dn.prototype.copy.call(this, t), this.meshPerAttribute = t
								.meshPerAttribute, this
						}
					}), Object.assign(Ju.prototype, {
						linePrecision: 1,
						set: function (t, e) {
							this.ray.set(t, e)
						},
						setFromCamera: function (t, e) {
							e && e.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(e
									.matrixWorld), this.ray.direction.set(t.x, t.y, .5).unproject(e)
								.sub(this.ray.origin).normalize()) : e && e.isOrthographicCamera ? (
								this.ray.origin.set(t.x, t.y, (e.near + e.far) / (e.near - e.far))
								.unproject(e), this.ray.direction.set(0, 0, -1).transformDirection(e
									.matrixWorld)) : console.error(
								"THREE.Raycaster: Unsupported camera type.")
						},
						intersectObject: function (t, e, i) {
							var n = i || [];
							return Ku(t, this, n, e), n.sort(Qu), n
						},
						intersectObjects: function (t, e, i) {
							var n = i || [];
							if (!1 === Array.isArray(t)) return console.warn(
								"THREE.Raycaster.intersectObjects: objects is not an Array."), n;
							for (var r = 0, a = t.length; r < a; r++) Ku(t[r], this, n, e);
							return n.sort(Qu), n
						}
					}), Object.assign($u.prototype, {
						set: function (t, e, i) {
							return this.radius = t, this.phi = e, this.theta = i, this
						},
						clone: function () {
							return (new this.constructor).copy(this)
						},
						copy: function (t) {
							return this.radius = t.radius, this.phi = t.phi, this.theta = t.theta, this
						},
						makeSafe: function () {
							var t = 1e-6;
							return this.phi = Math.max(t, Math.min(Math.PI - t, this.phi)), this
						},
						setFromVector3: function (t) {
							return this.setFromCartesianCoords(t.x, t.y, t.z)
						},
						setFromCartesianCoords: function (t, e, i) {
							return this.radius = Math.sqrt(t * t + e * e + i * i), 0 === this.radius ? (
								this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(t, i), this
								.phi = Math.acos(oi.clamp(e / this.radius, -1, 1))), this
						}
					}), Object.assign(tp.prototype, {
						set: function (t, e, i) {
							return this.radius = t, this.theta = e, this.y = i, this
						},
						clone: function () {
							return (new this.constructor).copy(this)
						},
						copy: function (t) {
							return this.radius = t.radius, this.theta = t.theta, this.y = t.y, this
						},
						setFromVector3: function (t) {
							return this.setFromCartesianCoords(t.x, t.y, t.z)
						},
						setFromCartesianCoords: function (t, e, i) {
							return this.radius = Math.sqrt(t * t + i * i), this.theta = Math.atan2(t, i),
								this.y = e, this
						}
					}), Object.assign(ep.prototype, {
						set: function (t, e) {
							return this.min.copy(t), this.max.copy(e), this
						},
						setFromPoints: function (t) {
							this.makeEmpty();
							for (var e = 0, i = t.length; e < i; e++) this.expandByPoint(t[e]);
							return this
						},
						setFromCenterAndSize: (gu = new si, function (t, e) {
							var i = gu.copy(e).multiplyScalar(.5);
							return this.min.copy(t).sub(i), this.max.copy(t).add(i), this
						}),
						clone: function () {
							return (new this.constructor).copy(this)
						},
						copy: function (t) {
							return this.min.copy(t.min), this.max.copy(t.max), this
						},
						makeEmpty: function () {
							return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this
						},
						isEmpty: function () {
							return this.max.x < this.min.x || this.max.y < this.min.y
						},
						getCenter: function (t) {
							return void 0 === t && (console.warn(
									"THREE.Box2: .getCenter() target is now required"), t = new si), this
								.isEmpty() ? t.set(0, 0) : t.addVectors(this.min, this.max)
								.multiplyScalar(.5)
						},
						getSize: function (t) {
							return void 0 === t && (console.warn(
									"THREE.Box2: .getSize() target is now required"), t = new si), this
								.isEmpty() ? t.set(0, 0) : t.subVectors(this.max, this.min)
						},
						expandByPoint: function (t) {
							return this.min.min(t), this.max.max(t), this
						},
						expandByVector: function (t) {
							return this.min.sub(t), this.max.add(t), this
						},
						expandByScalar: function (t) {
							return this.min.addScalar(-t), this.max.addScalar(t), this
						},
						containsPoint: function (t) {
							return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y >
								this.max.y)
						},
						containsBox: function (t) {
							return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min
								.y && t.max.y <= this.max.y
						},
						getParameter: function (t, e) {
							return void 0 === e && (console.warn(
									"THREE.Box2: .getParameter() target is now required"), e = new si), e
								.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) /
									(this.max.y - this.min.y))
						},
						intersectsBox: function (t) {
							return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min
								.y || t.min.y > this.max.y)
						},
						clampPoint: function (t, e) {
							return void 0 === e && (console.warn(
									"THREE.Box2: .clampPoint() target is now required"), e = new si), e
								.copy(t).clamp(this.min, this.max)
						},
						distanceToPoint: (mu = new si, function (t) {
							return mu.copy(t).clamp(this.min, this.max).sub(t).length()
						}),
						intersect: function (t) {
							return this.min.max(t.min), this.max.min(t.max), this
						},
						union: function (t) {
							return this.min.min(t.min), this.max.max(t.max), this
						},
						translate: function (t) {
							return this.min.add(t), this.max.add(t), this
						},
						equals: function (t) {
							return t.min.equals(this.min) && t.max.equals(this.max)
						}
					}), Object.assign(ip.prototype, {
						set: function (t, e) {
							return this.start.copy(t), this.end.copy(e), this
						},
						clone: function () {
							return (new this.constructor).copy(this)
						},
						copy: function (t) {
							return this.start.copy(t.start), this.end.copy(t.end), this
						},
						getCenter: function (t) {
							return void 0 === t && (console.warn(
									"THREE.Line3: .getCenter() target is now required"), t = new li), t
								.addVectors(this.start, this.end).multiplyScalar(.5)
						},
						delta: function (t) {
							return void 0 === t && (console.warn(
									"THREE.Line3: .delta() target is now required"), t = new li), t
								.subVectors(this.end, this.start)
						},
						distanceSq: function () {
							return this.start.distanceToSquared(this.end)
						},
						distance: function () {
							return this.start.distanceTo(this.end)
						},
						at: function (t, e) {
							return void 0 === e && (console.warn(
								"THREE.Line3: .at() target is now required"), e = new li), this.delta(
								e).multiplyScalar(t).add(this.start)
						},
						closestPointToPointParameter: (vu = new li, yu = new li, function (t, e) {
							vu.subVectors(t, this.start), yu.subVectors(this.end, this.start);
							var i = yu.dot(yu),
								n = yu.dot(vu) / i;
							return e && (n = oi.clamp(n, 0, 1)), n
						}),
						closestPointToPoint: function (t, e, i) {
							var n = this.closestPointToPointParameter(t, e);
							return void 0 === i && (console.warn(
									"THREE.Line3: .closestPointToPoint() target is now required"), i =
								new li), this.delta(i).multiplyScalar(n).add(this.start)
						},
						applyMatrix4: function (t) {
							return this.start.applyMatrix4(t), this.end.applyMatrix4(t), this
						},
						equals: function (t) {
							return t.start.equals(this.start) && t.end.equals(this.end)
						}
					}), np.prototype = Object.create(Sn.prototype), (np.prototype.constructor = np).prototype
					.isImmediateRenderObject = !0, rp.prototype = Object.create(ps.prototype), (rp.prototype
						.constructor = rp).prototype.update = (xu = new li, bu = new li, _u = new ui,
				function () {
						var t = ["a", "b", "c"];
						this.object.updateMatrixWorld(!0), _u.getNormalMatrix(this.object.matrixWorld);
						var e = this.object.matrixWorld,
							i = this.geometry.attributes.position,
							n = this.object.geometry;
						if (n && n.isGeometry)
							for (var r = n.vertices, a = n.faces, o = 0, s = 0, c = a.length; s < c; s++)
								for (var h = a[s], l = 0, u = h.vertexNormals.length; l < u; l++) {
									var p = r[h[t[l]]],
										d = h.vertexNormals[l];
									xu.copy(p).applyMatrix4(e), bu.copy(d).applyMatrix3(_u).normalize()
										.multiplyScalar(this.size).add(xu), i.setXYZ(o, xu.x, xu.y, xu.z),
										o += 1, i.setXYZ(o, bu.x, bu.y, bu.z), o += 1
								} else if (n && n.isBufferGeometry) {
									var f = n.attributes.position,
										m = n.attributes.normal;
									for (l = o = 0, u = f.count; l < u; l++) xu.set(f.getX(l), f.getY(l), f
											.getZ(l)).applyMatrix4(e), bu.set(m.getX(l), m.getY(l), m.getZ(
										l)), bu.applyMatrix3(_u).normalize().multiplyScalar(this.size).add(
										xu), i.setXYZ(o, xu.x, xu.y, xu.z), o += 1, i.setXYZ(o, bu.x, bu.y, bu
											.z), o += 1
								} i.needsUpdate = !0
					}), ap.prototype = Object.create(Sn.prototype), (ap.prototype.constructor = ap).prototype
					.dispose = function () {
						this.cone.geometry.dispose(), this.cone.material.dispose()
					}, ap.prototype.update = (wu = new li, function () {
						this.light.updateMatrixWorld();
						var t = this.light.distance ? this.light.distance : 1e3,
							e = t * Math.tan(this.light.angle);
						this.cone.scale.set(e, e, t), wu.setFromMatrixPosition(this.light.target.matrixWorld),
							this.cone.lookAt(wu), void 0 !== this.color ? this.cone.material.color.set(this
								.color) : this.cone.material.color.copy(this.light.color)
					}), sp.prototype = Object.create(ps.prototype), (sp.prototype.constructor = sp).prototype
					.updateMatrixWorld = (Mu = new li, Su = new ci, Eu = new ci, function (t) {
						var e = this.bones,
							i = this.geometry,
							n = i.getAttribute("position");
						Eu.getInverse(this.root.matrixWorld);
						for (var r = 0, a = 0; r < e.length; r++) {
							var o = e[r];
							o.parent && o.parent.isBone && (Su.multiplyMatrices(Eu, o.matrixWorld), Mu
								.setFromMatrixPosition(Su), n.setXYZ(a, Mu.x, Mu.y, Mu.z), Su
								.multiplyMatrices(Eu, o.parent.matrixWorld), Mu.setFromMatrixPosition(Su),
								n.setXYZ(a + 1, Mu.x, Mu.y, Mu.z), a += 2)
						}
						i.getAttribute("position").needsUpdate = !0, Sn.prototype.updateMatrixWorld.call(this,
							t)
					}), cp.prototype = Object.create(Hr.prototype), (cp.prototype.constructor = cp).prototype
					.dispose = function () {
						this.geometry.dispose(), this.material.dispose()
					}, cp.prototype.update = function () {
						void 0 !== this.color ? this.material.color.set(this.color) : this.material.color.copy(
							this.light.color)
					}, hp.prototype = Object.create(us.prototype), (hp.prototype.constructor = hp).prototype
					.update = function () {
						if (this.scale.set(.5 * this.light.width, .5 * this.light.height, 1), void 0 !== this
							.color) this.material.color.set(this.color), this.children[0].material.color.set(this
							.color);
						else {
							this.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
							var t = this.material.color,
								e = Math.max(t.r, t.g, t.b);
							1 < e && t.multiplyScalar(1 / e), this.children[0].material.color.copy(this.material
								.color)
						}
					}, hp.prototype.dispose = function () {
						this.geometry.dispose(), this.material.dispose(), this.children[0].geometry.dispose(),
							this.children[0].material.dispose()
					}, lp.prototype = Object.create(Sn.prototype), (lp.prototype.constructor = lp).prototype
					.dispose = function () {
						this.children[0].geometry.dispose(), this.children[0].material.dispose()
					}, lp.prototype.update = (Tu = new li, Au = new Yi, Lu = new Yi, function () {
						var t = this.children[0];
						if (void 0 !== this.color) this.material.color.set(this.color);
						else {
							var e = t.geometry.getAttribute("color");
							Au.copy(this.light.color), Lu.copy(this.light.groundColor);
							for (var i = 0, n = e.count; i < n; i++) {
								var r = i < n / 2 ? Au : Lu;
								e.setXYZ(i, r.r, r.g, r.b)
							}
							e.needsUpdate = !0
						}
						t.lookAt(Tu.setFromMatrixPosition(this.light.matrixWorld).negate())
					}), up.prototype = Object.create(ps.prototype), up.prototype.constructor = up, pp.prototype =
					Object.create(ps.prototype), pp.prototype.constructor = pp, dp.prototype = Object.create(us
						.prototype), (dp.prototype.constructor = dp).prototype.update = function () {
						var a, o, t = this.audio,
							s = this.range,
							e = this.divisionsInnerAngle,
							i = this.divisionsOuterAngle,
							n = oi.degToRad(t.panner.coneInnerAngle),
							r = oi.degToRad(t.panner.coneOuterAngle),
							c = n / 2,
							h = r / 2,
							l = 0,
							u = 0,
							p = this.geometry,
							d = p.attributes.position;

						function f(t, e, i, n) {
							var r = (e - t) / i;
							for (d.setXYZ(l, 0, 0, 0), u++, a = t; a < e; a += r) o = l + u, d.setXYZ(o, Math.sin(
								a) * s, 0, Math.cos(a) * s), d.setXYZ(o + 1, Math.sin(Math.min(a + r, e)) * s,
								0, Math.cos(Math.min(a + r, e)) * s), d.setXYZ(o + 2, 0, 0, 0), u += 3;
							p.addGroup(l, u, n), l += u, u = 0
						}
						p.clearGroups(), f(-h, -c, i, 0), f(-c, c, e, 1), f(c, h, i, 0), d.needsUpdate = !0, n ===
							r && (this.material[0].visible = !1)
					}, dp.prototype.dispose = function () {
						this.geometry.dispose(), this.material[0].dispose(), this.material[1].dispose()
					}, fp.prototype = Object.create(ps.prototype), (fp.prototype.constructor = fp).prototype
					.update = (Pu = new li, Ru = new li, Cu = new ui, function () {
						this.object.updateMatrixWorld(!0), Cu.getNormalMatrix(this.object.matrixWorld);
						for (var t = this.object.matrixWorld, e = this.geometry.attributes.position, i = this
								.object.geometry, n = i.vertices, r = i.faces, a = 0, o = 0, s = r.length; o <
							s; o++) {
							var c = r[o],
								h = c.normal;
							Pu.copy(n[c.a]).add(n[c.b]).add(n[c.c]).divideScalar(3).applyMatrix4(t), Ru.copy(
									h).applyMatrix3(Cu).normalize().multiplyScalar(this.size).add(Pu), e
								.setXYZ(a, Pu.x, Pu.y, Pu.z), a += 1, e.setXYZ(a, Ru.x, Ru.y, Ru.z), a += 1
						}
						e.needsUpdate = !0
					}), mp.prototype = Object.create(Sn.prototype), (mp.prototype.constructor = mp).prototype
					.dispose = function () {
						this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine
							.geometry.dispose(), this.targetLine.material.dispose()
					}, mp.prototype.update = (Ou = new li, Iu = new li, Du = new li, function () {
						Ou.setFromMatrixPosition(this.light.matrixWorld), Iu.setFromMatrixPosition(this.light
								.target.matrixWorld), Du.subVectors(Iu, Ou), this.lightPlane.lookAt(Iu),
							void 0 !== this.color ? (this.lightPlane.material.color.set(this.color), this
								.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color
								.copy(this.light.color), this.targetLine.material.color.copy(this.light.color)
								), this.targetLine.lookAt(Iu), this.targetLine.scale.z = Du.length()
					}), gp.prototype = Object.create(ps.prototype), (gp.prototype.constructor = gp).prototype
					.update = function () {
						var c, h, l = new li,
							u = new Lo;

						function i(t, e, i, n) {
							l.set(e, i, n).unproject(u);
							var r = h[t];
							if (void 0 !== r)
								for (var a = c.getAttribute("position"), o = 0, s = r.length; o < s; o++) a
									.setXYZ(r[o], l.x, l.y, l.z)
						}
						return function () {
							c = this.geometry, h = this.pointMap;
							var t = 1,
								e = 1;
							u.projectionMatrix.copy(this.camera.projectionMatrix), i("c", 0, 0, -1), i("t", 0,
									0, 1), i("n1", -t, -e, -1), i("n2", t, -e, -1), i("n3", -t, e, -1), i(
									"n4", t, e, -1), i("f1", -t, -e, 1), i("f2", t, -e, 1), i("f3", -t, e, 1),
								i("f4", t, e, 1), i("u1", .7 * t, 1.1 * e, -1), i("u2", .7 * -t, 1.1 * e, -1),
								i("u3", 0, 2 * e, -1), i("cf1", -t, 0, 1), i("cf2", t, 0, 1), i("cf3", 0, -e,
									1), i("cf4", 0, e, 1), i("cn1", -t, 0, -1), i("cn2", t, 0, -1), i("cn3",
									0, -e, -1), i("cn4", 0, e, -1), c.getAttribute("position").needsUpdate = !
								0
						}
					}(), vp.prototype = Object.create(ps.prototype), (vp.prototype.constructor = vp).prototype
					.update = (Bu = new zi, function (t) {
						if (void 0 !== t && console.warn(
								"THREE.BoxHelper: .update() has no longer arguments."), void 0 !== this
							.object && Bu.setFromObject(this.object), !Bu.isEmpty()) {
							var e = Bu.min,
								i = Bu.max,
								n = this.geometry.attributes.position,
								r = n.array;
							r[0] = i.x, r[1] = i.y, r[2] = i.z, r[3] = e.x, r[4] = i.y, r[5] = i.z, r[6] = e
								.x, r[7] = e.y, r[8] = i.z, r[9] = i.x, r[10] = e.y, r[11] = i.z, r[12] = i.x,
								r[13] = i.y, r[14] = e.z, r[15] = e.x, r[16] = i.y, r[17] = e.z, r[18] = e.x,
								r[19] = e.y, r[20] = e.z, r[21] = i.x, r[22] = e.y, r[23] = e.z, n
								.needsUpdate = !0, this.geometry.computeBoundingSphere()
						}
					}), vp.prototype.setFromObject = function (t) {
						return this.object = t, this.update(), this
					}, vp.prototype.copy = function (t) {
						return ps.prototype.copy.call(this, t), this.object = t.object, this
					}, vp.prototype.clone = function () {
						return (new this.constructor).copy(this)
					}, yp.prototype = Object.create(ps.prototype), (yp.prototype.constructor = yp).prototype
					.updateMatrixWorld = function (t) {
						var e = this.box;
						e.isEmpty() || (e.getCenter(this.position), e.getSize(this.scale), this.scale
							.multiplyScalar(.5), Sn.prototype.updateMatrixWorld.call(this, t))
					}, xp.prototype = Object.create(us.prototype), (xp.prototype.constructor = xp).prototype
					.updateMatrixWorld = function (t) {
						var e = -this.plane.constant;
						Math.abs(e) < 1e-8 && (e = 1e-8), this.scale.set(.5 * this.size, .5 * this.size, e), this
							.children[0].material.side = e < 0 ? jt : z, this.lookAt(this.plane.normal), Sn
							.prototype.updateMatrixWorld.call(this, t)
					}, bp.prototype = Object.create(Sn.prototype), (bp.prototype.constructor = bp).prototype
					.setDirection = (Uu = new li, function (t) {
						.99999 < t.y ? this.quaternion.set(0, 0, 0, 1) : t.y < -.99999 ? this.quaternion.set(
							1, 0, 0, 0) : (Uu.set(t.z, 0, -t.x).normalize(), Gu = Math.acos(t.y), this
							.quaternion.setFromAxisAngle(Uu, Gu))
					}), bp.prototype.setLength = function (t, e, i) {
						void 0 === e && (e = .2 * t), void 0 === i && (i = .2 * e), this.line.scale.set(1, Math
								.max(0, t - e), 1), this.line.updateMatrix(), this.cone.scale.set(i, e, i), this
							.cone.position.y = t, this.cone.updateMatrix()
					}, bp.prototype.setColor = function (t) {
						this.line.material.color.copy(t), this.cone.material.color.copy(t)
					}, bp.prototype.copy = function (t) {
						return Sn.prototype.copy.call(this, t, !1), this.line.copy(t.line), this.cone.copy(t
							.cone), this
					}, bp.prototype.clone = function () {
						return (new this.constructor).copy(this)
					}, _p.prototype = Object.create(ps.prototype), _p.prototype.constructor = _p;
				var Mp, Sp = 0,
					Ep = 1;

				function Tp(t) {
					return console.warn("THREE.MeshFaceMaterial has been removed. Use an Array instead."), t
				}

				function Ap(t) {
					return void 0 === t && (t = []), console.warn(
							"THREE.MultiMaterial has been removed. Use an Array instead."), t.isMultiMaterial = !
						0, (t.materials = t).clone = function () {
							return t.slice()
						}, t
				}

				function Lp(t, e) {
					return console.warn("THREE.PointCloud has been renamed to THREE.Points."), new ms(t, e)
				}

				function Pp(t) {
					return console.warn("THREE.Particle has been renamed to THREE.Sprite."), new as(t)
				}

				function Rp(t, e) {
					return console.warn("THREE.ParticleSystem has been renamed to THREE.Points."), new ms(t, e)
				}

				function Cp(t) {
					return console.warn("THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial."),
						new fs(t)
				}

				function Op(t) {
					return console.warn("THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial."),
						new fs(t)
				}

				function Ip(t) {
					return console.warn("THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial."),
						new fs(t)
				}

				function Dp(t, e, i) {
					return console.warn("THREE.Vertex has been removed. Use THREE.Vector3 instead."), new li(t, e,
						i)
				}

				function Bp(t, e) {
					return console.warn(
						"THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead."
						), new Dn(t, e).setDynamic(!0)
				}

				function zp(t, e) {
					return console.warn(
							"THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead."),
						new Bn(t, e)
				}

				function Np(t, e) {
					return console.warn(
						"THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead."
						), new zn(t, e)
				}

				function Gp(t, e) {
					return console.warn(
						"THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead."
						), new Nn(t, e)
				}

				function Up(t, e) {
					return console.warn(
						"THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead."
						), new Gn(t, e)
				}

				function Fp(t, e) {
					return console.warn(
						"THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead."
						), new Un(t, e)
				}

				function Hp(t, e) {
					return console.warn(
						"THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead."
						), new Fn(t, e)
				}

				function jp(t, e) {
					return console.warn(
						"THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead."
						), new Hn(t, e)
				}

				function kp(t, e) {
					return console.warn(
						"THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead."
						), new jn(t, e)
				}

				function Vp(t, e) {
					return console.warn(
						"THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead."
						), new kn(t, e)
				}

				function Wp(t) {
					console.warn(
							"THREE.ClosedSplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."),
						Oh.call(this, t), this.type = "catmullrom", this.closed = !0
				}

				function qp(t) {
					console.warn("THREE.SplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."),
						Oh.call(this, t), this.type = "catmullrom"
				}

				function Xp(t) {
					console.warn("THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead."), Oh.call(
						this, t), this.type = "catmullrom"
				}

				function Yp(t) {
					return console.warn("THREE.AxisHelper has been renamed to THREE.AxesHelper."), new _p(t)
				}

				function Zp(t, e) {
					return console.warn(
							"THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead."),
						new vp(t, e)
				}

				function Jp(t, e) {
					return console.warn("THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead."),
						new ps(new Oc(t.geometry), new ls({
							color: void 0 !== e ? e : 16777215
						}))
				}

				function Qp(t, e) {
					return console.warn(
							"THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead."),
						new ps(new bs(t.geometry), new ls({
							color: void 0 !== e ? e : 16777215
						}))
				}

				function Kp(t) {
					return console.warn("THREE.XHRLoader has been renamed to THREE.FileLoader."), new vh(t)
				}

				function $p(t) {
					return console.warn("THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader."),
						new bh(t)
				}
				Sh.create = function (t, e) {
						return console.log("THREE.Curve.create() has been deprecated"), t.prototype = Object
							.create(Sh.prototype), (t.prototype.constructor = t).prototype.getPoint = e, t
					}, Object.assign(Qh.prototype, {
						createPointsGeometry: function (t) {
							console.warn(
								"THREE.CurvePath: .createPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead."
								);
							var e = this.getPoints(t);
							return this.createGeometry(e)
						},
						createSpacedPointsGeometry: function (t) {
							console.warn(
								"THREE.CurvePath: .createSpacedPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead."
								);
							var e = this.getSpacedPoints(t);
							return this.createGeometry(e)
						},
						createGeometry: function (t) {
							console.warn(
								"THREE.CurvePath: .createGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead."
								);
							for (var e = new In, i = 0, n = t.length; i < n; i++) {
								var r = t[i];
								e.vertices.push(new li(r.x, r.y, r.z || 0))
							}
							return e
						}
					}), Object.assign(Kh.prototype, {
						fromPoints: function (t) {
							console.warn(
									"THREE.Path: .fromPoints() has been renamed to .setFromPoints()."),
								this.setFromPoints(t)
						}
					}), Wp.prototype = Object.create(Oh.prototype), qp.prototype = Object.create(Oh.prototype), Xp
					.prototype = Object.create(Oh.prototype), Object.assign(Xp.prototype, {
						initFromArray: function () {
							console.error("THREE.Spline: .initFromArray() has been removed.")
						},
						getControlPointsArray: function () {
							console.error("THREE.Spline: .getControlPointsArray() has been removed.")
						},
						reparametrizeByArcLength: function () {
							console.error("THREE.Spline: .reparametrizeByArcLength() has been removed.")
						}
					}), up.prototype.setColors = function () {
						console.error(
							"THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead."
							)
					}, sp.prototype.update = function () {
						console.error("THREE.SkeletonHelper: update() no longer needs to be called.")
					}, Object.assign(Rl.prototype, {
						extractUrlBase: function (t) {
							return console.warn(
								"THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."
								), pl.extractUrlBase(t)
						}
					}), Object.assign(ml.prototype, {
						setTexturePath: function (t) {
							return console.warn(
								"THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath()."
								), this.setResourcePath(t)
						}
					}), Object.assign(ep.prototype, {
						center: function (t) {
							return console.warn(
								"THREE.Box2: .center() has been renamed to .getCenter()."), this
								.getCenter(t)
						},
						empty: function () {
							return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."),
								this.isEmpty()
						},
						isIntersectionBox: function (t) {
							return console.warn(
								"THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."
								), this.intersectsBox(t)
						},
						size: function (t) {
							return console.warn("THREE.Box2: .size() has been renamed to .getSize()."),
								this.getSize(t)
						}
					}), Object.assign(zi.prototype, {
						center: function (t) {
							return console.warn(
								"THREE.Box3: .center() has been renamed to .getCenter()."), this
								.getCenter(t)
						},
						empty: function () {
							return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."),
								this.isEmpty()
						},
						isIntersectionBox: function (t) {
							return console.warn(
								"THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."
								), this.intersectsBox(t)
						},
						isIntersectionSphere: function (t) {
							return console.warn(
								"THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."
								), this.intersectsSphere(t)
						},
						size: function (t) {
							return console.warn("THREE.Box3: .size() has been renamed to .getSize()."),
								this.getSize(t)
						}
					}), ip.prototype.center = function (t) {
						return console.warn("THREE.Line3: .center() has been renamed to .getCenter()."), this
							.getCenter(t)
					}, Object.assign(oi, {
						random16: function () {
							return console.warn(
								"THREE.Math: .random16() has been deprecated. Use Math.random() instead."
								), Math.random()
						},
						nearestPowerOfTwo: function (t) {
							return console.warn(
								"THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo()."
								), oi.floorPowerOfTwo(t)
						},
						nextPowerOfTwo: function (t) {
							return console.warn(
								"THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo()."
								), oi.ceilPowerOfTwo(t)
						}
					}), Object.assign(ui.prototype, {
						flattenToArrayOffset: function (t, e) {
							return console.warn(
								"THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."
								), this.toArray(t, e)
						},
						multiplyVector3: function (t) {
							return console.warn(
								"THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."
								), t.applyMatrix3(this)
						},
						multiplyVector3Array: function () {
							console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.")
						},
						applyToBuffer: function (t) {
							return console.warn(
								"THREE.Matrix3: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead."
								), this.applyToBufferAttribute(t)
						},
						applyToVector3Array: function () {
							console.error("THREE.Matrix3: .applyToVector3Array() has been removed.")
						}
					}), Object.assign(ci.prototype, {
						extractPosition: function (t) {
							return console.warn(
								"THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."
								), this.copyPosition(t)
						},
						flattenToArrayOffset: function (t, e) {
							return console.warn(
								"THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."
								), this.toArray(t, e)
						},
						getPosition: function () {
							return void 0 === Mp && (Mp = new li), console.warn(
								"THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."
								), Mp.setFromMatrixColumn(this, 3)
						},
						setRotationFromQuaternion: function (t) {
							return console.warn(
								"THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."
								), this.makeRotationFromQuaternion(t)
						},
						multiplyToArray: function () {
							console.warn("THREE.Matrix4: .multiplyToArray() has been removed.")
						},
						multiplyVector3: function (t) {
							return console.warn(
								"THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."
								), t.applyMatrix4(this)
						},
						multiplyVector4: function (t) {
							return console.warn(
								"THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."
								), t.applyMatrix4(this)
						},
						multiplyVector3Array: function () {
							console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.")
						},
						rotateAxis: function (t) {
							console.warn(
								"THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."
								), t.transformDirection(this)
						},
						crossVector: function (t) {
							return console.warn(
								"THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."
								), t.applyMatrix4(this)
						},
						translate: function () {
							console.error("THREE.Matrix4: .translate() has been removed.")
						},
						rotateX: function () {
							console.error("THREE.Matrix4: .rotateX() has been removed.")
						},
						rotateY: function () {
							console.error("THREE.Matrix4: .rotateY() has been removed.")
						},
						rotateZ: function () {
							console.error("THREE.Matrix4: .rotateZ() has been removed.")
						},
						rotateByAxis: function () {
							console.error("THREE.Matrix4: .rotateByAxis() has been removed.")
						},
						applyToBuffer: function (t) {
							return console.warn(
								"THREE.Matrix4: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead."
								), this.applyToBufferAttribute(t)
						},
						applyToVector3Array: function () {
							console.error("THREE.Matrix4: .applyToVector3Array() has been removed.")
						},
						makeFrustum: function (t, e, i, n, r, a) {
							return console.warn(
								"THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."
								), this.makePerspective(t, e, n, i, r, a)
						}
					}), Gi.prototype.isIntersectionLine = function (t) {
						return console.warn(
								"THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."), this
							.intersectsLine(t)
					}, hi.prototype.multiplyVector3 = function (t) {
						return console.warn(
							"THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."
							), t.applyQuaternion(this)
					}, Object.assign(Gr.prototype, {
						isIntersectionBox: function (t) {
							return console.warn(
								"THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."
								), this.intersectsBox(t)
						},
						isIntersectionPlane: function (t) {
							return console.warn(
								"THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."
								), this.intersectsPlane(t)
						},
						isIntersectionSphere: function (t) {
							return console.warn(
								"THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."
								), this.intersectsSphere(t)
						}
					}), Object.assign(Ur.prototype, {
						area: function () {
							return console.warn(
								"THREE.Triangle: .area() has been renamed to .getArea()."), this.getArea()
						},
						barycoordFromPoint: function (t, e) {
							return console.warn(
								"THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."
								), this.getBarycoord(t, e)
						},
						midpoint: function (t) {
							return console.warn(
									"THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."),
								this.getMidpoint(t)
						},
						normal: function (t) {
							return console.warn(
									"THREE.Triangle: .normal() has been renamed to .getNormal()."), this
								.getNormal(t)
						},
						plane: function (t) {
							return console.warn(
									"THREE.Triangle: .plane() has been renamed to .getPlane()."), this
								.getPlane(t)
						}
					}), Object.assign(Ur, {
						barycoordFromPoint: function (t, e, i, n, r) {
							return console.warn(
								"THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."
								), Ur.getBarycoord(t, e, i, n, r)
						},
						normal: function (t, e, i, n) {
							return console.warn(
									"THREE.Triangle: .normal() has been renamed to .getNormal()."), Ur
								.getNormal(t, e, i, n)
						}
					}), Object.assign($h.prototype, {
						extractAllPoints: function (t) {
							return console.warn(
								"THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."
								), this.extractPoints(t)
						},
						extrude: function (t) {
							return console.warn(
								"THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."
								), new vc(this, t)
						},
						makeGeometry: function (t) {
							return console.warn(
								"THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."
								), new Pc(this, t)
						}
					}), Object.assign(si.prototype, {
						fromAttribute: function (t, e, i) {
							return console.warn(
								"THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."
								), this.fromBufferAttribute(t, e, i)
						},
						distanceToManhattan: function (t) {
							return console.warn(
								"THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."
								), this.manhattanDistanceTo(t)
						},
						lengthManhattan: function () {
							return console.warn(
								"THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."
								), this.manhattanLength()
						}
					}), Object.assign(li.prototype, {
						setEulerFromRotationMatrix: function () {
							console.error(
								"THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead."
								)
						},
						setEulerFromQuaternion: function () {
							console.error(
								"THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead."
								)
						},
						getPositionFromMatrix: function (t) {
							return console.warn(
								"THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."
								), this.setFromMatrixPosition(t)
						},
						getScaleFromMatrix: function (t) {
							return console.warn(
								"THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."
								), this.setFromMatrixScale(t)
						},
						getColumnFromMatrix: function (t, e) {
							return console.warn(
								"THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."
								), this.setFromMatrixColumn(e, t)
						},
						applyProjection: function (t) {
							return console.warn(
								"THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."
								), this.applyMatrix4(t)
						},
						fromAttribute: function (t, e, i) {
							return console.warn(
								"THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."
								), this.fromBufferAttribute(t, e, i)
						},
						distanceToManhattan: function (t) {
							return console.warn(
								"THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."
								), this.manhattanDistanceTo(t)
						},
						lengthManhattan: function () {
							return console.warn(
								"THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."
								), this.manhattanLength()
						}
					}), Object.assign(Ci.prototype, {
						fromAttribute: function (t, e, i) {
							return console.warn(
								"THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."
								), this.fromBufferAttribute(t, e, i)
						},
						lengthManhattan: function () {
							return console.warn(
								"THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."
								), this.manhattanLength()
						}
					}), Object.assign(In.prototype, {
						computeTangents: function () {
							console.error("THREE.Geometry: .computeTangents() has been removed.")
						},
						computeLineDistances: function () {
							console.error(
								"THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead."
								)
						}
					}), Object.assign(Sn.prototype, {
						getChildByName: function (t) {
							return console.warn(
								"THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."
								), this.getObjectByName(t)
						},
						renderDepth: function () {
							console.warn(
								"THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead."
								)
						},
						translate: function (t, e) {
							return console.warn(
								"THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."
								), this.translateOnAxis(e, t)
						},
						getWorldRotation: function () {
							console.error(
								"THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead."
								)
						}
					}), Object.defineProperties(Sn.prototype, {
						eulerOrder: {
							get: function () {
								return console.warn(
									"THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation
									.order
							},
							set: function (t) {
								console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this
									.rotation.order = t
							}
						},
						useQuaternion: {
							get: function () {
								console.warn(
									"THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default."
									)
							},
							set: function () {
								console.warn(
									"THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default."
									)
							}
						}
					}), Object.defineProperties(os.prototype, {
						objects: {
							get: function () {
								return console.warn("THREE.LOD: .objects has been renamed to .levels."),
									this.levels
							}
						}
					}), Object.defineProperty(cs.prototype, "useVertexTexture", {
						get: function () {
							console.warn("THREE.Skeleton: useVertexTexture has been removed.")
						},
						set: function () {
							console.warn("THREE.Skeleton: useVertexTexture has been removed.")
						}
					}), ss.prototype.initBones = function () {
						console.error("THREE.SkinnedMesh: initBones() has been removed.")
					}, Object.defineProperty(Sh.prototype, "__arcLengthDivisions", {
						get: function () {
							return console.warn(
									"THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."),
								this.arcLengthDivisions
						},
						set: function (t) {
							console.warn(
								"THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."), this
								.arcLengthDivisions = t
						}
					}), Po.prototype.setLens = function (t, e) {
						console.warn(
							"THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."
							), void 0 !== e && (this.filmGauge = e), this.setFocalLength(t)
					}, Object.defineProperties(tl.prototype, {
						onlyShadow: {
							set: function () {
								console.warn("THREE.Light: .onlyShadow has been removed.")
							}
						},
						shadowCameraFov: {
							set: function (t) {
								console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."),
									this.shadow.camera.fov = t
							}
						},
						shadowCameraLeft: {
							set: function (t) {
								console.warn(
									"THREE.Light: .shadowCameraLeft is now .shadow.camera.left."), this
									.shadow.camera.left = t
							}
						},
						shadowCameraRight: {
							set: function (t) {
								console.warn(
										"THREE.Light: .shadowCameraRight is now .shadow.camera.right."),
									this.shadow.camera.right = t
							}
						},
						shadowCameraTop: {
							set: function (t) {
								console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."),
									this.shadow.camera.top = t
							}
						},
						shadowCameraBottom: {
							set: function (t) {
								console.warn(
										"THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."),
									this.shadow.camera.bottom = t
							}
						},
						shadowCameraNear: {
							set: function (t) {
								console.warn(
									"THREE.Light: .shadowCameraNear is now .shadow.camera.near."), this
									.shadow.camera.near = t
							}
						},
						shadowCameraFar: {
							set: function (t) {
								console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."),
									this.shadow.camera.far = t
							}
						},
						shadowCameraVisible: {
							set: function () {
								console.warn(
									"THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead."
									)
							}
						},
						shadowBias: {
							set: function (t) {
								console.warn("THREE.Light: .shadowBias is now .shadow.bias."), this.shadow
									.bias = t
							}
						},
						shadowDarkness: {
							set: function () {
								console.warn("THREE.Light: .shadowDarkness has been removed.")
							}
						},
						shadowMapWidth: {
							set: function (t) {
								console.warn(
									"THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."), this
									.shadow.mapSize.width = t
							}
						},
						shadowMapHeight: {
							set: function (t) {
								console.warn(
										"THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."),
									this.shadow.mapSize.height = t
							}
						}
					}), Object.defineProperties(Dn.prototype, {
						length: {
							get: function () {
								return console.warn(
									"THREE.BufferAttribute: .length has been deprecated. Use .count instead."
									), this.array.length
							}
						},
						copyIndicesArray: function () {
							console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.")
						}
					}), Object.assign(nr.prototype, {
						addIndex: function (t) {
							console.warn(
									"THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."),
								this.setIndex(t)
						},
						addDrawCall: function (t, e, i) {
							void 0 !== i && console.warn(
									"THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."
									), console.warn(
									"THREE.BufferGeometry: .addDrawCall() is now .addGroup()."), this
								.addGroup(t, e)
						},
						clearDrawCalls: function () {
							console.warn(
								"THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."), this
								.clearGroups()
						},
						computeTangents: function () {
							console.warn("THREE.BufferGeometry: .computeTangents() has been removed.")
						},
						computeOffsets: function () {
							console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.")
						}
					}), Object.defineProperties(nr.prototype, {
						drawcalls: {
							get: function () {
								return console.error(
										"THREE.BufferGeometry: .drawcalls has been renamed to .groups."),
									this.groups
							}
						},
						offsets: {
							get: function () {
								return console.warn(
										"THREE.BufferGeometry: .offsets has been renamed to .groups."),
									this.groups
							}
						}
					}), Object.assign(yc.prototype, {
						getArrays: function () {
							console.error("THREE.ExtrudeBufferGeometry: .getArrays() has been removed.")
						},
						addShapeList: function () {
							console.error(
								"THREE.ExtrudeBufferGeometry: .addShapeList() has been removed.")
						},
						addShape: function () {
							console.error("THREE.ExtrudeBufferGeometry: .addShape() has been removed.")
						}
					}), Object.defineProperties(qu.prototype, {
						dynamic: {
							set: function () {
								console.warn(
									"THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead."
									)
							}
						},
						onUpdate: {
							value: function () {
								return console.warn(
									"THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."
									), this
							}
						}
					}), Object.defineProperties(hr.prototype, {
						wrapAround: {
							get: function () {
								console.warn("THREE.Material: .wrapAround has been removed.")
							},
							set: function () {
								console.warn("THREE.Material: .wrapAround has been removed.")
							}
						},
						overdraw: {
							get: function () {
								console.warn("THREE.Material: .overdraw has been removed.")
							},
							set: function () {
								console.warn("THREE.Material: .overdraw has been removed.")
							}
						},
						wrapRGB: {
							get: function () {
								return console.warn("THREE.Material: .wrapRGB has been removed."), new Yi
							}
						},
						shading: {
							get: function () {
								console.error("THREE." + this.type +
									": .shading has been removed. Use the boolean .flatShading instead."
									)
							},
							set: function (t) {
								console.warn("THREE." + this.type +
									": .shading has been removed. Use the boolean .flatShading instead."
									), this.flatShading = t === R
							}
						}
					}), Object.defineProperties(Vc.prototype, {
						metal: {
							get: function () {
								return console.warn(
									"THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead."
									), !1
							},
							set: function () {
								console.warn(
									"THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead"
									)
							}
						}
					}), Object.defineProperties(Nr.prototype, {
						derivatives: {
							get: function () {
								return console.warn(
									"THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."
									), this.extensions.derivatives
							},
							set: function (t) {
								console.warn(
									"THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."
									), this.extensions.derivatives = t
							}
						}
					}), Object.assign(Ko.prototype, {
						clearTarget: function (t, e, i, n) {
							console.warn(
								"THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."
								), this.setRenderTarget(t), this.clear(e, i, n)
						},
						animate: function (t) {
							console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."),
								this.setAnimationLoop(t)
						},
						getCurrentRenderTarget: function () {
							return console.warn(
								"THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."
								), this.getRenderTarget()
						},
						getMaxAnisotropy: function () {
							return console.warn(
								"THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."
								), this.capabilities.getMaxAnisotropy()
						},
						getPrecision: function () {
							return console.warn(
								"THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."
								), this.capabilities.precision
						},
						resetGLState: function () {
							return console.warn(
									"THREE.WebGLRenderer: .resetGLState() is now .state.reset()."), this
								.state.reset()
						},
						supportsFloatTextures: function () {
							return console.warn(
								"THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."
								), this.extensions.get("OES_texture_float")
						},
						supportsHalfFloatTextures: function () {
							return console.warn(
								"THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."
								), this.extensions.get("OES_texture_half_float")
						},
						supportsStandardDerivatives: function () {
							return console.warn(
								"THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."
								), this.extensions.get("OES_standard_derivatives")
						},
						supportsCompressedTextureS3TC: function () {
							return console.warn(
								"THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."
								), this.extensions.get("WEBGL_compressed_texture_s3tc")
						},
						supportsCompressedTexturePVRTC: function () {
							return console.warn(
								"THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."
								), this.extensions.get("WEBGL_compressed_texture_pvrtc")
						},
						supportsBlendMinMax: function () {
							return console.warn(
								"THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."
								), this.extensions.get("EXT_blend_minmax")
						},
						supportsVertexTextures: function () {
							return console.warn(
								"THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."
								), this.capabilities.vertexTextures
						},
						supportsInstancedArrays: function () {
							return console.warn(
								"THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."
								), this.extensions.get("ANGLE_instanced_arrays")
						},
						enableScissorTest: function (t) {
							console.warn(
									"THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."
									), this.setScissorTest(t)
						},
						initMaterial: function () {
							console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.")
						},
						addPrePlugin: function () {
							console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.")
						},
						addPostPlugin: function () {
							console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.")
						},
						updateShadowMap: function () {
							console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.")
						},
						setFaceCulling: function () {
							console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.")
						}
					}), Object.defineProperties(Ko.prototype, {
						shadowMapEnabled: {
							get: function () {
								return this.shadowMap.enabled
							},
							set: function (t) {
								console.warn(
									"THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."
									), this.shadowMap.enabled = t
							}
						},
						shadowMapType: {
							get: function () {
								return this.shadowMap.type
							},
							set: function (t) {
								console.warn(
										"THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."),
									this.shadowMap.type = t
							}
						},
						shadowMapCullFace: {
							get: function () {
								console.warn(
									"THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead."
									)
							},
							set: function () {
								console.warn(
									"THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead."
									)
							}
						}
					}), Object.defineProperties(Mo.prototype, {
						cullFace: {
							get: function () {
								console.warn(
									"THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead."
									)
							},
							set: function () {
								console.warn(
									"THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead."
									)
							}
						},
						renderReverseSided: {
							get: function () {
								console.warn(
									"THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead."
									)
							},
							set: function () {
								console.warn(
									"THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead."
									)
							}
						},
						renderSingleSided: {
							get: function () {
								console.warn(
									"THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead."
									)
							},
							set: function () {
								console.warn(
									"THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead."
									)
							}
						}
					}), Object.defineProperties(Di.prototype, {
						activeCubeFace: {
							set: function () {
								console.warn(
									"THREE.WebGLRenderTargetCube: .activeCubeFace has been removed. It is now the second parameter of WebGLRenderer.setRenderTarget()."
									)
							}
						},
						activeMipMapLevel: {
							set: function () {
								console.warn(
									"THREE.WebGLRenderTargetCube: .activeMipMapLevel has been removed. It is now the third parameter of WebGLRenderer.setRenderTarget()."
									)
							}
						}
					}), Object.defineProperties(Oi.prototype, {
						wrapS: {
							get: function () {
								return console.warn(
										"THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this
									.texture.wrapS
							},
							set: function (t) {
								console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."),
									this.texture.wrapS = t
							}
						},
						wrapT: {
							get: function () {
								return console.warn(
										"THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this
									.texture.wrapT
							},
							set: function (t) {
								console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."),
									this.texture.wrapT = t
							}
						},
						magFilter: {
							get: function () {
								return console.warn(
										"THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."),
									this.texture.magFilter
							},
							set: function (t) {
								console.warn(
										"THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."),
									this.texture.magFilter = t
							}
						},
						minFilter: {
							get: function () {
								return console.warn(
										"THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."),
									this.texture.minFilter
							},
							set: function (t) {
								console.warn(
										"THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."),
									this.texture.minFilter = t
							}
						},
						anisotropy: {
							get: function () {
								return console.warn(
									"THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."
									), this.texture.anisotropy
							},
							set: function (t) {
								console.warn(
									"THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."
									), this.texture.anisotropy = t
							}
						},
						offset: {
							get: function () {
								return console.warn(
										"THREE.WebGLRenderTarget: .offset is now .texture.offset."), this
									.texture.offset
							},
							set: function (t) {
								console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."),
									this.texture.offset = t
							}
						},
						repeat: {
							get: function () {
								return console.warn(
										"THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this
									.texture.repeat
							},
							set: function (t) {
								console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."),
									this.texture.repeat = t
							}
						},
						format: {
							get: function () {
								return console.warn(
										"THREE.WebGLRenderTarget: .format is now .texture.format."), this
									.texture.format
							},
							set: function (t) {
								console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."),
									this.texture.format = t
							}
						},
						type: {
							get: function () {
								return console.warn(
										"THREE.WebGLRenderTarget: .type is now .texture.type."), this
									.texture.type
							},
							set: function (t) {
								console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this
									.texture.type = t
							}
						},
						generateMipmaps: {
							get: function () {
								return console.warn(
									"THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."
									), this.texture.generateMipmaps
							},
							set: function (t) {
								console.warn(
									"THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."
									), this.texture.generateMipmaps = t
							}
						}
					}), Object.defineProperties(Jo.prototype, {
						standing: {
							set: function () {
								console.warn("THREE.WebVRManager: .standing has been removed.")
							}
						},
						userHeight: {
							set: function () {
								console.warn("THREE.WebVRManager: .userHeight has been removed.")
							}
						}
					}), iu.prototype.load = function (t) {
						console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");
						var e = this;
						return (new Ql).load(t, function (t) {
							e.setBuffer(t)
						}), this
					}, ru.prototype.getData = function () {
						return console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData()."), this
							.getFrequencyData()
					}, $l.prototype.updateCubeMap = function (t, e) {
						return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."), this.update(
							t, e)
					};
				var td = {
					merge: function (t, e, i) {
						var n;
						console.warn(
							"THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead."
							), e.isMesh && (e.matrixAutoUpdate && e.updateMatrix(), n = e.matrix, e =
							e.geometry), t.merge(e, n, i)
					},
					center: function (t) {
						return console.warn(
							"THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead."
							), t.center()
					}
				};

				function ed() {
					console.error("THREE.Projector has been moved to /examples/js/renderers/Projector.js."), this
						.projectVector = function (t, e) {
							console.warn("THREE.Projector: .projectVector() is now vector.project()."), t.project(
								e)
						}, this.unprojectVector = function (t, e) {
							console.warn("THREE.Projector: .unprojectVector() is now vector.unproject()."), t
								.unproject(e)
						}, this.pickingRay = function () {
							console.error("THREE.Projector: .pickingRay() is now raycaster.setFromCamera().")
						}
				}

				function id() {
					console.error("THREE.CanvasRenderer has been removed")
				}

				function nd() {
					console.error("THREE.JSONLoader has been removed.")
				}
				Li.crossOrigin = void 0, Li.loadTexture = function (t, e, i, n) {
					console.warn(
						"THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead."
						);
					var r = new Mh;
					r.setCrossOrigin(this.crossOrigin);
					var a = r.load(t, i, void 0, n);
					return e && (a.mapping = e), a
				}, Li.loadTextureCube = function (t, e, i, n) {
					console.warn(
						"THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead."
						);
					var r = new wh;
					r.setCrossOrigin(this.crossOrigin);
					var a = r.load(t, i, void 0, n);
					return e && (a.mapping = e), a
				}, Li.loadCompressedTexture = function () {
					console.error(
						"THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead."
						)
				}, Li.loadCompressedTextureCube = function () {
					console.error(
						"THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead."
						)
				};
				var rd = {
					createMultiMaterialObject: function () {
						console.error(
							"THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js")
					},
					detach: function () {
						console.error(
							"THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js")
					},
					attach: function () {
						console.error(
							"THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js")
					}
				};

				function ad() {
					console.error("THREE.LensFlare has been moved to /examples/js/objects/Lensflare.js")
				}
				t.WebGLMultisampleRenderTarget = Ii, t.WebGLRenderTargetCube = Di, t.WebGLRenderTarget = Oi, t
					.WebGLRenderer = Ko, t.ShaderLib = Ki, t.UniformsLib = Qi, t.UniformsUtils = qi, t
					.ShaderChunk = Fi, t.FogExp2 = $o, t.Fog = ts, t.Scene = es, t.Sprite = as, t.LOD = os, t
					.SkinnedMesh = ss, t.Skeleton = cs, t.Bone = hs, t.Mesh = Hr, t.LineSegments = ps, t
					.LineLoop = ds, t.Line = us, t.Points = ms, t.Group = Ao, t.VideoTexture = gs, t.DataTexture =
					Bi, t.DataTexture3D = ta, t.CompressedTexture = vs, t.CubeTexture = $r, t.CanvasTexture = ys,
					t.DepthTexture = xs, t.Texture = Ri, t.AnimationLoader = yh, t.CompressedTextureLoader = xh, t
					.DataTextureLoader = bh, t.CubeTextureLoader = wh, t.TextureLoader = Mh, t.ObjectLoader = ml,
					t.MaterialLoader = ul, t.BufferGeometryLoader = dl, t.DefaultLoadingManager = mh, t
					.LoadingManager = fh, t.ImageLoader = _h, t.ImageBitmapLoader = Sl, t.FontLoader = Pl, t
					.FileLoader = vh, t.Loader = Rl, t.LoaderUtils = pl, t.Cache = dh, t.AudioLoader = Ql, t
					.SpotLightShadow = nl, t.SpotLight = rl, t.PointLight = al, t.RectAreaLight = ll, t
					.HemisphereLight = el, t.DirectionalLightShadow = sl, t.DirectionalLight = cl, t
					.AmbientLight = hl, t.LightShadow = il, t.Light = tl, t.StereoCamera = Kl, t
					.PerspectiveCamera = Po, t.OrthographicCamera = ol, t.CubeCamera = $l, t.ArrayCamera = Ro, t
					.Camera = Lo, t.AudioListener = eu, t.PositionalAudio = nu, t.AudioContext = Jl, t
					.AudioAnalyser = ru, t.Audio = iu, t.VectorKeyframeTrack = hh, t.StringKeyframeTrack = ch, t
					.QuaternionKeyframeTrack = sh, t.NumberKeyframeTrack = ah, t.ColorKeyframeTrack = rh, t
					.BooleanKeyframeTrack = nh, t.PropertyMixer = au, t.PropertyBinding = ju, t.KeyframeTrack =
					ih, t.AnimationUtils = Qc, t.AnimationObjectGroup = ku, t.AnimationMixer = Wu, t
					.AnimationClip = lh, t.Uniform = qu, t.InstancedBufferGeometry = Xu, t.BufferGeometry = nr, t
					.Geometry = In, t.InterleavedBufferAttribute = ns, t.InstancedInterleavedBuffer = Yu, t
					.InterleavedBuffer = is, t.InstancedBufferAttribute = Zu, t.Face3 = en, t.Object3D = Sn, t
					.Raycaster = Ju, t.Layers = rn, t.EventDispatcher = e, t.Clock = tu, t
					.QuaternionLinearInterpolant = oh, t.LinearInterpolant = th, t.DiscreteInterpolant = eh, t
					.CubicInterpolant = $c, t.Interpolant = Kc, t.Triangle = Ur, t.Math = oi, t.Spherical = $u, t
					.Cylindrical = tp, t.Plane = Gi, t.Frustum = Ui, t.Sphere = Ni, t.Ray = Gr, t.Matrix4 = ci, t
					.Matrix3 = ui, t.Box3 = zi, t.Box2 = ep, t.Line3 = ip, t.Euler = nn, t.Vector4 = Ci, t
					.Vector3 = li, t.Vector2 = si, t.Quaternion = hi, t.Color = Yi, t.ImmediateRenderObject = np,
					t.VertexNormalsHelper = rp, t.SpotLightHelper = ap, t.SkeletonHelper = sp, t
					.PointLightHelper = cp, t.RectAreaLightHelper = hp, t.HemisphereLightHelper = lp, t
					.GridHelper = up, t.PolarGridHelper = pp, t.PositionalAudioHelper = dp, t.FaceNormalsHelper =
					fp, t.DirectionalLightHelper = mp, t.CameraHelper = gp, t.BoxHelper = vp, t.Box3Helper = yp, t
					.PlaneHelper = xp, t.ArrowHelper = bp, t.AxesHelper = _p, t.Shape = $h, t.Path = Kh, t
					.ShapePath = El, t.Font = Tl, t.CurvePath = Qh, t.Curve = Sh, t.ImageUtils = Li, t
					.ShapeUtils = fc, t.WebGLUtils = To, t.WireframeGeometry = bs, t.ParametricGeometry = _s, t
					.ParametricBufferGeometry = ws, t.TetrahedronGeometry = Es, t.TetrahedronBufferGeometry = Ts,
					t.OctahedronGeometry = As, t.OctahedronBufferGeometry = Ls, t.IcosahedronGeometry = Ps, t
					.IcosahedronBufferGeometry = Rs, t.DodecahedronGeometry = Cs, t.DodecahedronBufferGeometry =
					Os, t.PolyhedronGeometry = Ms, t.PolyhedronBufferGeometry = Ss, t.TubeGeometry = Is, t
					.TubeBufferGeometry = Ds, t.TorusKnotGeometry = Bs, t.TorusKnotBufferGeometry = zs, t
					.TorusGeometry = Ns, t.TorusBufferGeometry = Gs, t.TextGeometry = _c, t.TextBufferGeometry =
					wc, t.SphereGeometry = Mc, t.SphereBufferGeometry = Sc, t.RingGeometry = Ec, t
					.RingBufferGeometry = Tc, t.PlaneGeometry = or, t.PlaneBufferGeometry = sr, t.LatheGeometry =
					Ac, t.LatheBufferGeometry = Lc, t.ShapeGeometry = Pc, t.ShapeBufferGeometry = Rc, t
					.ExtrudeGeometry = vc, t.ExtrudeBufferGeometry = yc, t.EdgesGeometry = Oc, t.ConeGeometry =
					Bc, t.ConeBufferGeometry = zc, t.CylinderGeometry = Ic, t.CylinderBufferGeometry = Dc, t
					.CircleGeometry = Nc, t.CircleBufferGeometry = Gc, t.BoxGeometry = rr, t.CubeGeometry = rr, t
					.BoxBufferGeometry = ar, t.ShadowMaterial = Fc, t.SpriteMaterial = rs, t.RawShaderMaterial =
					Hc, t.ShaderMaterial = Nr, t.PointsMaterial = fs, t.MeshPhysicalMaterial = kc, t
					.MeshStandardMaterial = jc, t.MeshPhongMaterial = Vc, t.MeshToonMaterial = Wc, t
					.MeshNormalMaterial = qc, t.MeshLambertMaterial = Xc, t.MeshDepthMaterial = _o, t
					.MeshDistanceMaterial = wo, t.MeshBasicMaterial = Fr, t.MeshMatcapMaterial = Yc, t
					.LineDashedMaterial = Zc, t.LineBasicMaterial = ls, t.Material = hr, t
					.Float64BufferAttribute = kn, t.Float32BufferAttribute = jn, t.Uint32BufferAttribute = Hn, t
					.Int32BufferAttribute = Fn, t.Uint16BufferAttribute = Un, t.Int16BufferAttribute = Gn, t
					.Uint8ClampedBufferAttribute = Nn, t.Uint8BufferAttribute = zn, t.Int8BufferAttribute = Bn, t
					.BufferAttribute = Dn, t.ArcCurve = Th, t.CatmullRomCurve3 = Oh, t.CubicBezierCurve = kh, t
					.CubicBezierCurve3 = Vh, t.EllipseCurve = Eh, t.LineCurve = Wh, t.LineCurve3 = qh, t
					.QuadraticBezierCurve = Xh, t.QuadraticBezierCurve3 = Yh, t.SplineCurve = Zh, t.REVISION = Ht,
					t.MOUSE = E, t.CullFaceNone = lt, t.CullFaceBack = ut, t.CullFaceFront = pt, t
					.CullFaceFrontBack = T, t.FrontFaceDirectionCW = A, t.FrontFaceDirectionCCW = L, t
					.BasicShadowMap = P, t.PCFShadowMap = B, t.PCFSoftShadowMap = I, t.FrontSide = z, t.BackSide =
					jt, t.DoubleSide = dt, t.FlatShading = R, t.SmoothShading = C, t.NoColors = O, t.FaceColors =
					D, t.VertexColors = N, t.NoBlending = ft, t.NormalBlending = mt, t.AdditiveBlending = gt, t
					.SubtractiveBlending = vt, t.MultiplyBlending = yt, t.CustomBlending = xt, t.AddEquation = bt,
					t.SubtractEquation = G, t.ReverseSubtractEquation = U, t.MinEquation = F, t.MaxEquation = H, t
					.ZeroFactor = j, t.OneFactor = k, t.SrcColorFactor = V, t.OneMinusSrcColorFactor = W, t
					.SrcAlphaFactor = q, t.OneMinusSrcAlphaFactor = X, t.DstAlphaFactor = Y, t
					.OneMinusDstAlphaFactor = Z, t.DstColorFactor = J, t.OneMinusDstColorFactor = Q, t
					.SrcAlphaSaturateFactor = K, t.NeverDepth = _t, t.AlwaysDepth = wt, t.LessDepth = Mt, t
					.LessEqualDepth = St, t.EqualDepth = Et, t.GreaterEqualDepth = Tt, t.GreaterDepth = At, t
					.NotEqualDepth = Lt, t.MultiplyOperation = $, t.MixOperation = tt, t.AddOperation = et, t
					.NoToneMapping = it, t.LinearToneMapping = kt, t.ReinhardToneMapping = nt, t
					.Uncharted2ToneMapping = rt, t.CineonToneMapping = at, t.ACESFilmicToneMapping = ot, t
					.UVMapping = st, t.CubeReflectionMapping = ct, t.CubeRefractionMapping = ht, t
					.EquirectangularReflectionMapping = Pt, t.EquirectangularRefractionMapping = Rt, t
					.SphericalReflectionMapping = Ct, t.CubeUVReflectionMapping = Ot, t.CubeUVRefractionMapping =
					It, t.RepeatWrapping = Dt, t.ClampToEdgeWrapping = Bt, t.MirroredRepeatWrapping = zt, t
					.NearestFilter = Nt, t.NearestMipMapNearestFilter = Gt, t.NearestMipMapLinearFilter = Ut, t
					.LinearFilter = Ft, t.LinearMipMapNearestFilter = Vt, t.LinearMipMapLinearFilter = Wt, t
					.UnsignedByteType = qt, t.ByteType = Xt, t.ShortType = Yt, t.UnsignedShortType = Zt, t
					.IntType = Jt, t.UnsignedIntType = Qt, t.FloatType = Kt, t.HalfFloatType = $t, t
					.UnsignedShort4444Type = te, t.UnsignedShort5551Type = ee, t.UnsignedShort565Type = ie, t
					.UnsignedInt248Type = ne, t.AlphaFormat = re, t.RGBFormat = ae, t.RGBAFormat = oe, t
					.LuminanceFormat = se, t.LuminanceAlphaFormat = ce, t.RGBEFormat = he, t.DepthFormat = le, t
					.DepthStencilFormat = ue, t.RedFormat = pe, t.RGB_S3TC_DXT1_Format = de, t
					.RGBA_S3TC_DXT1_Format = fe, t.RGBA_S3TC_DXT3_Format = me, t.RGBA_S3TC_DXT5_Format = ge, t
					.RGB_PVRTC_4BPPV1_Format = ve, t.RGB_PVRTC_2BPPV1_Format = ye, t.RGBA_PVRTC_4BPPV1_Format =
					xe, t.RGBA_PVRTC_2BPPV1_Format = be, t.RGB_ETC1_Format = _e, t.RGBA_ASTC_4x4_Format = we, t
					.RGBA_ASTC_5x4_Format = Me, t.RGBA_ASTC_5x5_Format = Se, t.RGBA_ASTC_6x5_Format = Ee, t
					.RGBA_ASTC_6x6_Format = Te, t.RGBA_ASTC_8x5_Format = Ae, t.RGBA_ASTC_8x6_Format = Le, t
					.RGBA_ASTC_8x8_Format = Pe, t.RGBA_ASTC_10x5_Format = Re, t.RGBA_ASTC_10x6_Format = Ce, t
					.RGBA_ASTC_10x8_Format = Oe, t.RGBA_ASTC_10x10_Format = Ie, t.RGBA_ASTC_12x10_Format = De, t
					.RGBA_ASTC_12x12_Format = Be, t.LoopOnce = ze, t.LoopRepeat = Ne, t.LoopPingPong = Ge, t
					.InterpolateDiscrete = Ue, t.InterpolateLinear = Fe, t.InterpolateSmooth = He, t
					.ZeroCurvatureEnding = je, t.ZeroSlopeEnding = ke, t.WrapAroundEnding = Ve, t
					.TrianglesDrawMode = We, t.TriangleStripDrawMode = qe, t.TriangleFanDrawMode = Xe, t
					.LinearEncoding = Ye, t.sRGBEncoding = Ze, t.GammaEncoding = Je, t.RGBEEncoding = Qe, t
					.LogLuvEncoding = Ke, t.RGBM7Encoding = $e, t.RGBM16Encoding = ti, t.RGBDEncoding = ei, t
					.BasicDepthPacking = ii, t.RGBADepthPacking = ni, t.TangentSpaceNormalMap = ri, t
					.ObjectSpaceNormalMap = ai, t.Face4 = wp, t.LineStrip = Sp, t.LinePieces = Ep, t
					.MeshFaceMaterial = Tp, t.MultiMaterial = Ap, t.PointCloud = Lp, t.Particle = Pp, t
					.ParticleSystem = Rp, t.PointCloudMaterial = Cp, t.ParticleBasicMaterial = Op, t
					.ParticleSystemMaterial = Ip, t.Vertex = Dp, t.DynamicBufferAttribute = Bp, t.Int8Attribute =
					zp, t.Uint8Attribute = Np, t.Uint8ClampedAttribute = Gp, t.Int16Attribute = Up, t
					.Uint16Attribute = Fp, t.Int32Attribute = Hp, t.Uint32Attribute = jp, t.Float32Attribute = kp,
					t.Float64Attribute = Vp, t.ClosedSplineCurve3 = Wp, t.SplineCurve3 = qp, t.Spline = Xp, t
					.AxisHelper = Yp, t.BoundingBoxHelper = Zp, t.EdgesHelper = Jp, t.WireframeHelper = Qp, t
					.XHRLoader = Kp, t.BinaryTextureLoader = $p, t.GeometryUtils = td, t.Projector = ed, t
					.CanvasRenderer = id, t.JSONLoader = nd, t.SceneUtils = rd, t.LensFlare = ad, Object
					.defineProperty(t, "__esModule", {
						value: !0
					})
			})(e)
		}, function (t, e, i) {
			"use strict";
			i.r(e);
			var n = i(5);

			function r(t) {
				n.default.call(this, t), this._domScore = this._app.querySelectorAll(".obj-interface .score"), this
					._domBestScore = this._app.querySelectorAll(".obj-interface .best-score span:last-child"), this
					._domWagon = this._app.querySelectorAll(".obj-interface .wagon span:last-child"), this
					._domBestWagon = this._app.querySelectorAll(".obj-interface .best-wagon span:last-child"), this
					._score = 0, this._bestScore = 0, this._wagon = 0, this._bestWagon = 0, this.updateDomWagon()
					.updateDomScore()
			}

			function a(t, e) {
				var i;
				for (i = 0; i < t.length; i++) e(t[i])
			}
			Object.assign(r.prototype, n.default.prototype, {
				reset: function () {
					return this._score = 0, this._wagon = 0, this.updateDomWagon().updateDomScore(), this
				},
				updateWagon: function (t) {
					return this._wagon = t, this._bestWagon = Math.max(this._wagon, this._bestWagon), this
						.updateDomWagon(), this
				},
				updateDomWagon: function () {
					var e = this;
					return a(this._domWagon, function (t) {
						t.innerHTML = e._wagon
					}), a(this._domBestWagon, function (t) {
						t.innerHTML = e._bestWagon
					}), this
				},
				updateScore: function (t) {
					return this._score += t, this._bestScore = Math.max(this._score, this._bestScore),
						this.updateDomScore(), this
				},
				updateDomScore: function () {
					var e = this;
					return a(this._domScore, function (t) {
						t.innerHTML = Math.round(e._score)
					}), a(this._domBestScore, function (t) {
						t.innerHTML = Math.round(e._bestScore)
					}), this
				}
			}), e.default = r
		}, function (t, e, i) {
			"use strict";

			function n(t) {
				var e = function () {},
					i = this;
				this._settings = Object.assign({
						app: "#App",
						onResize: e,
						onClickRetry: e,
						onClickStartScreen: e,
						onClickEndOfLevelScreen: e,
						onShowScreen: e,
						onHideScreen: e
					}, t), this._body = document.body, this._app = r("App"), this._header = o("obj-header"), this
					._screens = {
						loading: o("screen-loading"),
						start: o("screen-start"),
						game: o("screen-game"),
						"end-of-level": o("screen-end-of-level"),
						end: o("screen-end")
					}, this._banner = o("obj-banner"), this._retry = a("retry"), this._retryContainer = a(
						"retry-container"), this._looseTxt = a("txt-loose"), this._winTxt = a("txt-win"), this
					._classes = {
						hidden: "is-hidden",
						visible: "is-visible",
						landscape: "landscape",
						portrait: "portrait"
					}, this._height = 0, this._width = 0, window.onresize = d.bind(this), this._screens.start
					.addEventListener("click", function (t) {
						t.preventDefault(), t.stopImmediatePropagation(), i._settings.onClickStartScreen.call(i,
							t)
					}), this._screens.end.addEventListener("click", function () {
						_voodooExit()
					}), h(this._retry, function (t) {
						t.addEventListener("click", function (t) {
							t.preventDefault(), t.stopImmediatePropagation(), i._settings.onClickRetry
								.call(i, t)
						})
					}), this._banner && this._banner.addEventListener("click", function () {
						_voodooExit()
					}), this._screens["end-of-level"] && this._screens["end-of-level"].addEventListener("click",
						function (t) {
							t.preventDefault(), t.stopImmediatePropagation(), i._settings.onClickEndOfLevelScreen
								.call(i, t)
						})
			}

			function r(t, e) {
				return (e || document).getElementById(t)
			}

			function a(t, e) {
				return (e || document).getElementsByClassName(t)
			}

			function o(t, e) {
				return a(t, e)[0]
			}

			function s(t, e) {
				t.classList.add(e)
			}

			function c(t, e) {
				t.classList.remove(e)
			}

			function h(t, e) {
				var i;
				for (i = 0; i < t.length; i++) e(t[i])
			}

			function l() {
				return document.body.clientHeight
			}

			function u() {
				return document.body.clientWidth
			}
			i.r(e), n.prototype = {
				getEvents: function () {
					return this.isMobile() ? {
						pointerdown: "touchstart",
						pointermove: "touchmove",
						pointerup: "touchend"
					} : {
						pointerdown: "pointerdown",
						pointermove: "pointermove",
						pointerup: "pointerup"
					}
				},
				triggerResize: function () {
					return window.dispatchEvent(new Event("resize")), this
				},
				switchScreen: function (t, e) {
					return this.hideScreen(t).showScreen(e)
				},
				showScreen: function (t) {
					return this._settings.onShowScreen(t), this._app.setAttribute("data-current-screen", t),
						this.showElement(this._screens[t])
				},
				hideScreen: function (t) {
					return this._settings.onHideScreen(t), this.hideElement(this._screens[t])
				},
				currentScreenIs: function (t) {
					return this._app.getAttribute("data-current-screen") === t
				},
				showElement: function (t) {
					return s(t, this._classes.visible), this
				},
				hideElement: function (t) {
					return c(t, this._classes.visible), this
				},
				isMobile: function () {
					return p()
				},
				getHeight: function () {
					return this._height
				},
				getWidth: function () {
					return this._width
				},
				hideRetry: function () {
					var e = this;
					return h(this._retryContainer, function (t) {
						e.hideElement(t)
					}), this
				},
				showFinalTxt: function (e) {
					var i = this;
					return h(this._looseTxt, function (t) {
						i[e ? "hideElement" : "showElement"](t)
					}), h(this._winTxt, function (t) {
						i[e ? "showElement" : "hideElement"](t)
					}), this
				}
			};
			var p = function () {
				var t = /iPad|iPhone|iPod|Android/i.test(navigator.userAgent);
				return p = function () {
					return t
				}, t
			};

			function d(t) {
				var e = this._app,
					i = this._classes,
					n = i.landscape,
					r = i.portrait,
					a = l(),
					o = u();
				(this._height = a) < (this._width = o) ? (this._body.style.fontSize = a / 540 * 16 + "px", s(e, n), c(
					e, r)) : (this._body.style.fontSize = o / 360 * 16 + "px", s(e, r), c(e, n)), this._settings
					.onResize(t, o, a)
			}
			e.default = n
		}, function (t, e, i) {
			"use strict";

			function n(t) {
				this._states = t
			}
			i.r(e), n.prototype = {
				set: function (t) {
					return this._states[t] || console.error("[Game] _setGameState : state " + t +
						" doesn't exist"), this._state.game !== t && this._state.debugMode && console.log(
						"[Game] _setGameState : " + states[t]), this._state.game = t, this
				},
				is: function (t) {
					return this._currentState === t
				}
			}, e.default = n
		}, function (t, e, i) {
			"use strict";
			i.r(e);
			var n = i(3),
				r = i(8),
				a = i(10),
				o = i(11),
				s = i(13),
				c = i(14),
				h = i(15),
				l = i(16);

			function u(t) {
				r.default.call(this, t), this._object = new n.Group, this._currentLevel = -1, this
					._hasReachLastDoor = !1, this._rockEnd = null, this.generate()
			}
			Object.assign(u.prototype, r.default.prototype, {
				reset: function () {
					return this._currentLevel = -1, this.generate(), this
				},
				generate: function () {
					var t, e;
					for (this._currentLevel++, this._hasReachLastDoor = !1, this._rockEnd = null; 0 < this
						._object.children.length;) this._object.remove(this._object.children[0]);
					for (this._railway = new a.default({
							color1: this._settings.railwayColor1,
							color2: this._settings.railwayColor2,
							path: d[this._currentLevel].path
						}), this._object.add(this._railway.getObject()), e = d[this._currentLevel]
						.rocks || [], t = 0; t < e.length; t++) this._object.add(new p[e[t].name](this
						._settings.rockColor, e[t]).getObject());
					return this._rockEnd = new l.default(this._settings.rockColor, {
						position: this._railway.getRockEndPosition()
					}), this._object.add(this._rockEnd.getObject()), this._object.updateMatrixWorld(!
						0), this
				},
				hasNextLevel: function () {
					return this._currentLevel < d.length - 1
				},
				getPathInfos: function (t) {
					return this._railway.getPathInfos(t)
				},
				getNearestInfos: function (t) {
					return this._railway.getNearestInfos(t)
				},
				getJumpTrigger: function (t) {
					return this._railway.getJumpTrigger(t)
				},
				hasReachLastDoor: function (t) {
					return this._rockEnd.checkCollision(t) && !this._hasReachLastDoor && (this
						._hasReachLastDoor = !0), this._hasReachLastDoor
				},
				hasReachEnd: function () {
					return this._railway.hasReachEnd()
				},
				update: function (t, e) {
					return this._rockEnd.update(t, e), this
				}
			});
			var p = {
					Rock1: o.default,
					Rock2: s.default,
					Rock3: c.default,
					Rock4: h.default,
					RockEnd: l.default
				},
				d = [{
					path: ["line", 8, "line", 8, "bridge-down", "line", "right", 4, "line", 3, "left", 2,
						"bridge-up", 4, "down", 3, "line", 24
					],
					rocks: [{
						name: "Rock1",
						position: new n.Vector3(256, 0, 0)
					}, {
						name: "Rock1",
						position: new n.Vector3(630, -11, 75),
						rotation: new n.Euler(0, 2.8, 0, "XYZ"),
						scale: new n.Vector3(3, 3, 3)
					}, {
						name: "Rock3",
						position: new n.Vector3(850, -100, 220),
						rotation: new n.Euler(0, 2.8, 0, "XYZ"),
						scale: new n.Vector3(3, 3, 3)
					}, {
						name: "Rock2",
						position: new n.Vector3(200, -100, -600),
						scale: new n.Vector3(5, 2.5, 1)
					}]
				}, {
					path: ["line", 8, "line", 8, "left", 3, "right", 3, "down-soft", "line", "up-soft", "line", 2,
						"bridge-down", "right", 2, "left", 2, "bridge-up", 10, "down", "line", "line", 16
					],
					rocks: [{
						name: "Rock1",
						position: new n.Vector3(256, 0, 0),
						rotation: new n.Euler(0, Math.PI / 2, 0, "XYZ"),
						scale: new n.Vector3(4, 2, 5)
					}, {
						name: "Rock3",
						position: new n.Vector3(620, -50, -20),
						rotation: new n.Euler(0, Math.PI / 2, 0, "XYZ"),
						scale: new n.Vector3(4, 2, 5)
					}, {
						name: "Rock2",
						position: new n.Vector3(200, -100, -600),
						scale: new n.Vector3(3, 1.5, 1)
					}, {
						name: "Rock4",
						position: new n.Vector3(850, -120, -60),
						scale: new n.Vector3(3, 2.5, 1)
					}]
				}, {
					path: ["line", 8, "line", 8, "left", 5, "line", "right", 5, "line", "down", 2, "line", "line",
						5, "bridge-up", "left", "line", "left", "line", "up-soft", "line", "down-soft",
						"line", "bridge-down", "left", "right", "right", "left", "line", "down", 2, "right",
						"line", "left", "right", "bridge-up", "bridge-down", "right", "left", "line", "right",
						"up", 2, "line", 2, "down", 2, "line", 4, "line", 16
					],
					rocks: [{
						name: "Rock4",
						position: new n.Vector3(130, -5, 0),
						scale: new n.Vector3(1.8, 1, 1)
					}, {
						name: "Rock3",
						position: new n.Vector3(700, -50, -100),
						scale: new n.Vector3(4, 4, 4)
					}, {
						name: "Rock1",
						position: new n.Vector3(880, -130, -260),
						scale: new n.Vector3(4, 8, 4)
					}, {
						name: "Rock3",
						position: new n.Vector3(840, -50, -300),
						scale: new n.Vector3(4, 1, 1)
					}, {
						name: "Rock3",
						position: new n.Vector3(580, -260, -360),
						scale: new n.Vector3(2, 2, 2)
					}, {
						name: "Rock1",
						position: new n.Vector3(635, -125, -470),
						scale: new n.Vector3(.6, 5, .6)
					}, {
						name: "Rock1",
						position: new n.Vector3(635, -305, -470),
						rotation: new n.Euler(0, Math.PI / 8, 0, "XYZ")
					}, {
						name: "Rock2",
						position: new n.Vector3(400, 0, -1e3),
						scale: new n.Vector3(3, 3, 1)
					}]
				}];
			e.default = u
		}, function (t, e, i) {
			"use strict";
			i.r(e);
			var r = i(3),
				n = i(9);

			function a(t) {
				this._settings = t, this._animations = {}, this._runningAnimations = []
			}
			a.prototype = {
				removeAnimation: function (t) {
					var e;
					if (1 < arguments.length)
						for (e = 0; e < arguments.length; e++) this.removeAnimation(arguments[e]);
					return delete this._animations[t], this
				},
				addAnimation: function (t, e) {
					return this._animations[t] ? console.error("[Object3dWrapper] Animation" + t +
						" already exists", this) : this._animations[t] = new n.default(t, e), this
				},
				playAnimation: function (t) {
					var e, i = Array.prototype.slice.call(arguments),
						n = i[i.length - 1],
						r = this._runningAnimations.indexOf(this._animations[t]);
					if ("string" != typeof n ? i.splice(-1, 1) : n = void 0, 1 < i.length)
						for (e = 0; e < i.length; e++) this.playAnimation(i[e], n);
					return 0 <= r && !this._animations[t].isMultiple() ? this._animations[t].kill().play(n) :
						(this._runningAnimations.push(this._animations[t]), this._animations[t].play(n)), this
				},
				_animate: function (t) {
					var e, i;
					for (i = 0; i < this._runningAnimations.length; i++)(e = this._runningAnimations[i])
						.update(t), e.isAlive() || (this._runningAnimations.splice(i, 1), i--);
					return this
				},
				setPosition: function (t) {
					return this._object.position.copy(t), this
				},
				getPosition: function (t) {
					return t ? this._object.position.clone() : this._object.position
				},
				getObject: function () {
					return this._object
				},
				update: function () {
					return this
				},
				base64ToTexture: function (t, e) {
					var i = new Image,
						n = new r.Texture;
					return i.src = t, (n.image = i).onload = function () {
						n.needsUpdate = !0, e && e(n)
					}, n
				}
			}, e.default = a
		}, function (t, e, i) {
			"use strict";

			function n(t, e) {
				this._settings = Object.assign({
					duration: 1e3,
					easing: "linear",
					completeOnKill: !0,
					multiple: !1,
					onStart: r,
					onUpdate: r,
					onComplete: r
				}, e), this._start = null, this._isAlive = !1, this._name = t
			}
			i.r(e), n.prototype = {
				isMultiple: function () {
					return this._settings.multiple
				},
				kill: function () {
					return this._start = null, this._isAlive = !1, this._settings.completeOnKill && (this
						._settings.onUpdate(1), this._settings.onComplete(1)), this
				},
				isAlive: function () {
					return this._isAlive
				},
				play: function (t) {
					return this._playOptions = Object.assign({
						onStart: r,
						onUpdate: r,
						onComplete: r
					}, t), this._isAlive = !0, this
				},
				update: function (t) {
					var e, i;
					this.isAlive() && (null === this._start && (this._start = t, this._settings.onStart(0),
						this._playOptions.onStart(0)), e = t - this._start, i = Math.min(n.easing[this
						._settings.easing](e / this._settings.duration), 1), this._settings.onUpdate(
						i), this._playOptions.onUpdate(i), e >= this._settings.duration && (this
						._isAlive = !1, this._start = null, this._settings.onUpdate(1), this
						._playOptions.onUpdate(1), this._settings.onComplete(1), this._playOptions
						.onComplete(1)))
				}
			}, n.easing = {
				linear: function (t) {
					return t
				},
				easeInQuad: function (t) {
					return t * t
				},
				easeOutQuad: function (t) {
					return t * (2 - t)
				},
				easeInOutQuad: function (t) {
					return t < .5 ? 2 * t * t : (4 - 2 * t) * t - 1
				},
				easeInCubic: function (t) {
					return t * t * t
				},
				easeOutCubic: function (t) {
					return --t * t * t + 1
				},
				easeInOutCubic: function (t) {
					return t < .5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1
				},
				easeInQuart: function (t) {
					return t * t * t * t
				},
				easeOutQuart: function (t) {
					return 1 - --t * t * t * t
				},
				easeInOutQuart: function (t) {
					return t < .5 ? 8 * t * t * t * t : 1 - 8 * --t * t * t * t
				},
				easeInQuint: function (t) {
					return t * t * t * t * t
				},
				easeOutQuint: function (t) {
					return 1 + --t * t * t * t * t
				},
				easeInOutQuint: function (t) {
					return t < .5 ? 16 * t * t * t * t * t : 1 + 16 * --t * t * t * t * t
				}
			};
			var r = function () {};
			e.default = n
		}, function (t, e, i) {
			"use strict";
			i.r(e);
			var f = i(3),
				o = i(8);

			function n(t) {
				o.default.call(this, t);
				var e, i = new c,
					n = this._settings.path,
					r = new f.MeshBasicMaterial({
						color: this._settings.color2
					}),
					a = new f.MeshBasicMaterial({
						color: this._settings.color1
					});
				for (e = 0; e < n.length; e++) h[n[e]](i, 0 < n[e + 1] ? n[++e] : 1);
				this._currentPosition = 0, this._object = l(i, r, a), this._lastDistance = 0, this._lastIndex = 0,
					this._jumpTrigger = null
			}

			function s(t, e) {
				return Math.sqrt(Math.pow(e.x - t.x, 2) + Math.pow(e.z - t.z, 2))
			}

			function c() {
				this._angle = 0, this._vectors = [new f.Vector3], this._axis = new f.Vector3(0, 1, 0), this._length =
					0, this._triggers = []
			}
			Object.assign(n.prototype, o.default.prototype, {
				getRockEndPosition: function () {
					var t = this._object.userData.geometry.parameters.path,
						e = this.getPathInfos(t.getLength() - 512).position;
					return e.y -= 2, e
				},
				getPathInfos: function (t) {
					var e = this._object.userData.geometry.parameters.path,
						i = Math.min(t / e.getLength(), 1),
						n = e.getPointAt(i),
						r = e.getPointAt(Math.min(i + 1 / e.getLength(), 1));
					return this._lastDistance = i, {
						position: n,
						lookAt: r,
						rotation: {
							z: new f.Vector2(new f.Vector2(r.x - n.x, r.z - n.z).length(), r.y - n.y)
								.angle(),
							y: new f.Vector2(r.z - n.z, r.x - n.x).angle() - Math.PI / 2
						}
					}
				},
				getNearestInfos: function (t) {
					var e, i, n = this._object.userData.points,
						r = 1 / 0,
						a = 0,
						o = n[0].length();
					for (a = 0; a < n.length; a++)(i = s(t, n[a])) <= r && (r = i, e = a);
					for (a = 1; a <= e; a++) o += n[a].clone().sub(n[a - 1]).length();
					return {
						position: n[e].clone(),
						distance: o,
						canConnect: r < 20
					}
				},
				hasReachEnd: function () {
					return 1 === this._lastDistance
				},
				getJumpTrigger: function (t) {
					var e, i = this._object.userData.triggers,
						n = null;
					for (e = 0; e < i.length; e++)
						if (!i[e].isReached && t.clone().sub(i[e].position).length() <= 5) {
							i[e].isReached = !0, n = i[e].position;
							break
						} return n
				}
			}), c.prototype = {
				angle: function (t) {
					if (void 0 === t) return this._angle;
					this._angle += t
				},
				getVectors: function () {
					return this._vectors
				},
				getTriggers: function () {
					return this._triggers
				},
				addTrigger: function (t) {
					return t = t || -1, this._triggers.push({
						isReached: !1,
						position: this._vectors[this._vectors.length + t]
					}), this
				},
				addArray: function (t, e) {
					var i;
					for (i = 0; i < t.length; i += 3) this.addVector(new f.Vector3(t[i], t[i + 1], t[i + 2])
						.multiplyScalar(e));
					return this._length += e - 1, this
				},
				addVector: function (t) {
					var e = this._vectors[this._vectors.length - 1];
					return t.applyAxisAngle(this._axis, this._angle), this._vectors.push(t.add(e)), this
						._length++, this
				},
				length: function () {
					return this._length
				}
			};
			var h = {
				line: function (t, e) {
					t.addArray([32, 0, 0], e)
				},
				left: function (t, e) {
					t.addArray([11.551, 0, -4.449, 4.449, 0, -11.551], e), t.angle(Math.PI / 2)
				},
				right: function (t, e) {
					t.addArray([11.551, 0, 4.449, 4.449, 0, 11.551], e), t.angle(Math.PI / -2)
				},
				"bridge-up": function (t, e) {
					t.addArray([2.246, .629, 0, 4, 2, 0, 5.8545, 3.371, 0, 8, 4, 0], e)
				},
				"bridge-down": function (t, e) {
					t.addArray([2.246, -.629, 0, 4, -2, 0, 5.8545, -3.371, 0, 8, -4, 0], e)
				},
				down: function (t, e) {
					t.addTrigger().addArray([5.772, -2.221, 0, 2.227, -5.779, 0, 2, -48, 0, 2.226, -5.777, 0,
						5.773, -2.222, 0
					], e)
				},
				up: function (t, e) {
					t.addArray([5.772, 2.221, 0, 2.227, 5.779, 0, 2, 48, 0, 2.226, 5.777, 0, 5.773, 2.222, 0],
						e)
				},
				"down-soft": function (t, e) {
					t.addArray([16, -8, 0, 16, -24, 0, 16, -24, 0, 16, -8, 0], e)
				},
				"up-soft": function (t, e) {
					t.addArray([16, 8, 0, 16, 24, 0, 16, 24, 0, 16, 8, 0], e).addTrigger(-2)
				}
			};

			function l(t, e, i) {
				var n, r, a = new f.Group,
					o = new f.CatmullRomCurve3(t.getVectors()),
					s = new f.TubeGeometry(o, 4 * t.length(), 2, 4, !1),
					c = new f.BoxBufferGeometry(1, .25, 6),
					h = new f.Vector2,
					l = new f.Vector3,
					u = new f.Vector3,
					p = [],
					d = [];
				for (c.translate(0, -.25, 0), a.userData.geometry = s, a.userData.points = [], a.userData.triggers = t
					.getTriggers(), r = 0; r < s.vertices.length; r += 4) l.copy(s.vertices[r]), u.copy(s.vertices[r +
						2]), p.push(l.clone()), d.push(u.clone()), (n = new f.Mesh(c, i)).position.copy(l.clone().add(
						u).divideScalar(2)), n.rotation.y = h.setX(l.z - u.z).setY(l.x - u.x).angle(), a.userData
					.points.push(n.position), 0 !== r && r < s.vertices.length - 4 && (n.rotation.z = h.setX(new f
						.Vector2(s.vertices[r + 4].x - s.vertices[r - 4].x, s.vertices[r + 4].z - s.vertices[r -
							4].z).length()).setY(s.vertices[r + 4].y - s.vertices[r - 4].y).angle()), a.add(n);
				return a.add(new f.Mesh(new f.TubeBufferGeometry(new f.CatmullRomCurve3(p), 4 * p.length, .25, 4, !1),
					e)), a.add(new f.Mesh(new f.TubeBufferGeometry(new f.CatmullRomCurve3(d), 4 * d.length, .25,
					4, !1), e)), a
			}
			e.default = n
		}, function (t, e, i) {
			"use strict";
			i.r(e);
			var s = i(3),
				c = i(12);

			function n(t, e) {
				c.default.call(this, t, e);
				var i, n, r = new s.Mesh(new s.CylinderGeometry(10, 10, 40, 5, 2), this._material),
					a = new s.Mesh(new s.CylinderGeometry(10, 10, 30, 5, 3), this._material),
					o = new s.Mesh(new s.CylinderGeometry(4, 4, 5, 5, 3), this._material);
				r.geometry.translate(0, -21, 0), r.scale.set(5, 1, 3), r.position.z = -5, a.position.x = 10, a
					.position.y = 10, a.position.z = -15, (i = r.clone()).position.x = 30, i.position.y = -2, i
					.position.z = 4, o.position.x = -7, o.position.z = 8, (n = a.clone()).scale.set(.5, .5, .5), n
					.position.y = 30, this._randomizeVerticesPosition(r.geometry.vertices, 1), this
					._randomizeVerticesPosition(a.geometry.vertices, 1), this._randomizeVerticesPosition(o.geometry
						.vertices, .5), this._object.add(r, a, i, o, n)
			}
			Object.assign(n.prototype, c.default.prototype, {}), e.default = n
		}, function (t, e, i) {
			"use strict";
			i.r(e);
			var n = i(3),
				r = i(8);

			function a(t, e) {
				r.default.call(this, e), this._settings = Object.assign({}, this._settings, a.defaults, e), this
					._material = new n.MeshToonMaterial({
						color: t,
						wireframe: !1
					}), this._object = new n.Group, this._object.position.copy(this._settings.position), this._object
					.rotation.copy(this._settings.rotation), this._object.scale.copy(this._settings.scale)
			}
			a.defaults = {
				position: new n.Vector3,
				rotation: new n.Euler(0, 0, 0, "XYZ"),
				scale: new n.Vector3(1, 1, 1)
			}, Object.assign(a.prototype, r.default.prototype, {
				_randomizeVerticesPosition: function (t, e) {
					var i;
					for (i = 0; i < t.length; i++) t[i].x += Math.random() * e - e / 2, t[i].z += Math
						.random() * e - e / 2, t[i].y += Math.random() * e - e / 2;
					return this
				},
				checkCollision: function () {
					return !1
				}
			}), e.default = a
		}, function (t, e, i) {
			"use strict";
			i.r(e);
			var n = i(3),
				r = i(12);

			function a(t, e) {
				r.default.call(this, t, e);
				var i = new n.Mesh(new n.PlaneGeometry(200, 300, 2, 3), new n.MeshBasicMaterial({
					color: "#ffffff",
					opacity: .3,
					transparent: !0,
					wireframe: !1
				}));
				i.geometry.vertices[0].x += 10, i.geometry.vertices[0].y -= 10, i.geometry.vertices[2].x -= 10, i
					.geometry.vertices[2].y -= 20, i.geometry.vertices[6].x += 5, i.geometry.vertices[9].y += 7, i
					.geometry.vertices[9].y += 5, i.geometry.vertices[10].y -= 30, i.geometry.vertices[11].y -= 10, i
					.scale.set(2, 1, 1), this._randomizeVerticesPosition(i.geometry.vertices, 60), this._object.add(i)
			}
			Object.assign(a.prototype, r.default.prototype, {}), e.default = a
		}, function (t, e, i) {
			"use strict";
			i.r(e);
			var a = i(3),
				o = i(12);

			function n(t, e) {
				o.default.call(this, t, e);
				var i = new a.Mesh(new a.CylinderGeometry(10, 20, 120, 5, 1), this._material),
					n = new a.Mesh(new a.CylinderGeometry(2.5, 5, 30, 5, 1), this._material),
					r = new a.Mesh(new a.CylinderGeometry(.5, 1, 5, 5, 1), this._material);
				this._randomizeVerticesPosition(i.geometry.vertices, 4), this._randomizeVerticesPosition(n.geometry
						.vertices, 2), this._randomizeVerticesPosition(r.geometry.vertices, 1), i.position.y = -55, n
					.position.y = 15, r.position.y = 30, this._object.add(i, n, r)
			}
			Object.assign(n.prototype, o.default.prototype, {}), e.default = n
		}, function (t, e, i) {
			"use strict";
			i.r(e);
			var s = i(3),
				c = i(12);

			function n(t, e) {
				c.default.call(this, t, e);
				var i, n, r, a, o = new s.Mesh(new s.CylinderGeometry(10, 10, 40, 5, 2), this._material);
				o.geometry.translate(0, -21, 0), o.scale.set(5, 1, 3), o.position.z = -5, this
					._randomizeVerticesPosition(o.geometry.vertices, 2), i = o.clone(), n = o.clone(), r = o.clone(),
					a = o.clone(), i.position.x = 60, i.position.y = -1, i.rotation.y = Math.PI / 2, n.position.x =
					160, n.position.y = 1, n.scale.set(10, 1, 3), r.scale.x = 10, r.position.z = -50, r.position.x =
					100, r.position.y = 30, a.scale.x = 10, a.position.z = -55, a.position.x = 130, a.position.y = 50,
					a.rotation.y = Math.PI, this._object.add(o, i, n, r, a)
			}
			Object.assign(n.prototype, c.default.prototype, {}), e.default = n
		}, function (t, e, i) {
			"use strict";
			i.r(e);
			var c = i(3),
				h = i(12),
				l = i(17);

			function n(t, e) {
				h.default.call(this, t, e);
				var i, n, r, a, o, s = new c.Mesh(new c.CylinderGeometry(10, 10, 40, 5, 2), this._material);
				for (s.geometry.translate(0, -21, 0), s.scale.set(5, 1, 3), s.position.z = -5, this
					._randomizeVerticesPosition(s.geometry.vertices, 1), i = s.clone(), n = s.clone(), r = s.clone(),
					a = s.clone(), i.position.x = 60, i.position.y = -1, i.rotation.y = Math.PI / 2, n.position.x =
					160, n.position.y = 1, n.scale.set(10, 1, 3), r.scale.x = 10, r.position.z = -50, r.position.x =
					100, r.position.y = 30, a.scale.x = 10, a.position.z = -55, a.position.x = 130, a.position.y = 50,
					a.rotation.y = Math.PI, this._object.add(s, i, n, r, a), this._doors = [], o = 0; o < 4; o++) this
					._doors.push(new l.default({
						position: new c.Vector3(100 + 30 * o, 0, 0)
					})), this._object.add(this._doors[o].getObject())
			}
			Object.assign(n.prototype, h.default.prototype, {
				checkCollision: function (t) {
					var e, i = !1;
					for (e = 0; e < this._doors.length; e++) e !== this._doors.length - 1 ? this._doors[e]
						.checkCollision(t) : i = this._doors[e].checkCollision(t);
					return i
				},
				update: function (t, e) {
					var i;
					for (i = 0; i < this._doors.length; i++) this._doors[i].update(t, e);
					return this
				}
			}), e.default = n
		}, function (t, e, i) {
			"use strict";
			i.r(e);
			var s = i(3),
				n = i(8);

			function r(t) {
				n.default.call(this, t);
				var o = this,
					e = a(),
					i = e.clone();
				this._object = new s.Group, this._object.position.copy(this._settings.position), e.position.z = -5, i
					.position.z = 5, this._object.add(e, i), this._object.rotation.z = Math.PI / -2, this
					._worldPosition = null, this._isReached = !1, this.addAnimation("end", {
						duration: 150,
						easing: "easeOutQuad",
						onUpdate: function (t) {
							o._object.rotation.z = Math.PI / -2 + Math.PI / 2 * t
						},
						onComplete: function () {
							o.playAnimation("explode")
						}
					}), this.addAnimation("explode", function () {
						var t, e, i, n = [16711680, 65280, 255],
							r = new s.Group,
							a = [];
						for (t = 0; t < n.length; t++) a.push(new s.MeshBasicMaterial({
							color: n[t],
							transparent: !0,
							visible: !1
						}));
						for (r.position.y = 10, t = 0; t < 100; t++) i = 2 * Math.random() + 1, (e = new s.Mesh(
								new s.PlaneBufferGeometry(i, i), a[Math.floor(Math.random() * a.length)]))
							.userData.position = new s.Vector3(2 * Math.random() - 1, 2 * Math.random(), 2 * Math
								.random() - 1).normalize().multiplyScalar(60 * Math.random()), e.userData
							.rotation = new s.Euler(Math.random() - .5, Math.random() - .5, Math.random() - .5,
								"XYZ"), r.add(e);
						return o._object.add(r), {
							duration: 1e3,
							easing: "easeInOutQuad",
							onStart: function () {
								var t;
								for (t = 0; t < a.length; t++) a[t].visible = !0
							},
							onUpdate: function (t) {
								var e, i;
								for (i = 0; i < r.children.length; i++)(e = r.children[i]).position.copy(e
										.userData.position.clone().multiplyScalar(t)), e.userData.position
									.y -= 1 * t, e.rotation.x += e.userData.rotation.x, e.rotation.y += e
									.userData.rotation.y, e.rotation.z += e.userData.rotation.z;
								for (i = 0; i < a.length; i++) a[i].opacity = 1 - t
							}
						}
					}())
			}

			function a() {
				var t = new s.Mesh(new s.CylinderBufferGeometry(2, 2, .5, 3), new s.MeshToonMaterial({
						color: 16711680
					})),
					e = new s.Mesh(new s.BoxBufferGeometry(.8, 16, .8), new s.MeshToonMaterial({
						color: 6710886
					}));
				return t.position.y = 14, t.position.x = 2, t.rotation.x = Math.PI / 2, t.rotation.y = Math.PI / 2, t
					.scale.z = 1.5, e.geometry.translate(0, 8, 0), e.add(t), e
			}
			Object.assign(r.prototype, n.default.prototype, {
				checkCollision: function (t) {
					var e;
					return this._worldPosition || (this._worldPosition = new s.Vector3, this._object
						.getWorldPosition(this._worldPosition)), e = this._worldPosition.clone().sub(
						t).length(), !this._isReached && e < 10 && (this._isReached = !0, this
						.playAnimation("end")), this._isReached
				},
				update: function (t, e) {
					return this._animate(t), this
				}
			}), e.default = r
		}, function (t, e, i) {
			"use strict";
			i.r(e);
			var h = i(3),
				n = i(8),
				r = i(19);

			function a(t) {
				n.default.call(this, t), this._object = new h.Group, this._train = new r.default({
						points: this._settings.points
					}), this._camera = new h.PerspectiveCamera(75, 1, 1, 5e3), this._speed = .5, this._minSpeed = 1,
					this._maxSpeed = 3, this._distance = 256, this._minRotationZSpeed = .025, this._rotationZSpeed =
					.025, this._maxRotationZSpeed = .2, this._totalRotation = 0, this._isDead = !1, this
					._isJumping = !1, this._jumpStart = null, this._jumpRotationZ = 0, this._jumpPosition = new h
					.Vector3, this._isCameraFree = !0, this._userRotationZ = 0, this._forces = new h.Group;
				var e = new h.Mesh(new h.BoxBufferGeometry(.4, 10, .4), new h.MeshBasicMaterial({
						color: 65280,
						visible: !1
					})),
					i = new h.Mesh(new h.BoxBufferGeometry(10, .4, .4), new h.MeshBasicMaterial({
						color: 16711680,
						visible: !1
					}));
				e.geometry.translate(0, -5, 0), i.geometry.translate(5, 0, 0), this._forces.add(e, i), this._object
					.add(this._train.getObject(), this._forces, this._camera), this.setCameraPosition(new h.Vector3(0,
						0, 0))
			}
			Object.assign(a.prototype, n.default.prototype, {
				replace: function () {
					return this._speed = 0, this._distance = 256, this._isCameraFree = !0, this
						._isDead = !1, this
				},
				reset: function () {
					return this.replace(), this._train.removeWagon(), this
				},
				getSpeed: function () {
					return this._speed
				},
				getPosition: function (t) {
					return t ? this._forces.position.clone() : this._forces.position
				},
				getCamera: function () {
					return this._camera
				},
				updateCamera: function (t) {
					return this._camera.aspect = t, this._camera.updateProjectionMatrix(), this
				},
				lockCameraPosition: function () {
					return this._isCameraFree = !1, this
				},
				setCameraPosition: function (t) {
					return this._isCameraFree && (this._camera.position.copy(t).add({
						x: 0,
						y: 40,
						z: 100
					}), this._camera.lookAt(t)), this
				},
				getDistance: function () {
					return this._distance
				},
				accelerate: function (t) {
					return this._accelerate = t, this
				},
				tryToJump: function (t, e) {
					return t && this._speed >= this._maxSpeed - .5 && (this._isJumping = !0, this
						._jumpStart = e, this._jumpRotationZ = this._forces.children[1].rotation.z,
						this._jumpPosition.copy(t)), this
				},
				isJumping: function () {
					return this._isJumping
				},
				isDead: function () {
					return this._isDead
				},
				setPositionFromPathInfos: function (t) {
					return this.setCameraPosition(t.position), this._forces.position.copy(t.position),
						this._forces.rotation.y = t.rotation.y, this._forces.children[1].rotation.z = t
						.rotation.z, this._train.setPositionFromPathInfos(t), this
				},
				setJumpingPosition: function (t, e) {
					var i = this._jumpPosition.clone(),
						n = this._forces.rotation.y,
						r = this._jumpRotationZ,
						a = (t - this._jumpStart) / 100,
						o = 18,
						s = 3.5,
						c = new h.Vector3(o * a * Math.cos(r), o * a * Math.sin(r) - .5 * s * a * a, 0);
					return c.applyAxisAngle(new h.Vector3(0, 1, 0), n), i.add(c), this.setCameraPosition(
							i), this._forces.position.copy(i), 1 < a && i.y < e.position.y && ((this
								._userRotationZ > Math.PI / 2 && this._userRotationZ < Math.PI + Math.PI /
								2 || !e.canConnect) && (this._isDead = !0), this._isJumping = !1, this
							._userRotationZ = 0, this._totalRotation = 0, this._rotationZSpeed = this
							._minRotationZSpeed, this._distance = e.distance), this._train
						.setPositionFromPathInfos({
							position: i,
							lookAt: i,
							rotation: {
								z: r + this._userRotationZ,
								y: n
							}
						}), this
				},
				rotate: function (t) {
					return this._rotationZSpeed = Math.min(this._rotationZSpeed + this._rotationZSpeed /
							10, this._maxRotationZSpeed), this._userRotationZ += this._rotationZSpeed * t,
						this._userRotationZ + this._jumpRotationZ >= 1.5 * Math.PI && (this
							._totalRotation += 1, this._userRotationZ -= 2 * Math.PI, this._train
							.showPoints(this._totalRotation).addWagon(), this._settings.onAddWagon(this
								._train.getNbWagon(), this._totalRotation)), this
				},
				update: function (t, e) {
					return 0 === this._speed && this._accelerate ? this._speed = this._minSpeed : this
						._accelerate && this._speed !== this._maxSpeed ? this._speed = Math.min(this
							._speed + this._speed / 10 * e, this._maxSpeed) : this._speed > this
						._minSpeed && (this._speed = Math.max(this._speed - this._speed / 10 * e, this
							._minSpeed)), this._distance += e * this._speed, this._train.update(t, e),
						this
				}
			}), e.default = a
		}, function (t, e, i) {
			"use strict";
			i.r(e);
			var n = i(3),
				r = i(8),
				a = i(20),
				o = i(21);

			function s(t) {
				var e;
				for (r.default.call(this, t), this._pointsMap = [], e = 0; e < this._settings.points.length; e++) this
					._pointsMap.push(this.base64ToTexture(this._settings.points[e]));
				this._infos = {
					array: [],
					delta: 10,
					count: 0,
					limit: 300
				}, this._wagons = [new a.default({
					pointsMap: this._pointsMap
				})], this._object = new n.Group, this._object.add(this._wagons[0].getObject())
			}
			Object.assign(s.prototype, r.default.prototype, {
				showPoints: function (t) {
					var e;
					for (e = 1; e < this._wagons.length; e++) this._wagons[e].showPoints(t);
					return this
				},
				getPosition: function (t) {
					return this._wagons[0].getPosition(t)
				},
				addWagon: function () {
					var t = new o.default({
						pointsMap: this._pointsMap
					});
					return this._wagons.push(t), this._object.add(t.getObject()), this
				},
				removeWagon: function () {
					for (; 1 < this._object.children.length;) this._object.remove(this._object.children[
						this._object.children.length - 1]);
					return this._wagons = [this._wagons[0]], this
				},
				getNbWagon: function () {
					return this._wagons.length - 1
				},
				setPositionFromPathInfos: function (t) {
					var e, i;
					for (this._infos.array.unshift(t), this._infos.array.splice(this._infos.limit - 1, 1),
						e = 0; e < this._wagons.length; e++) i = Math.min(8 * e, this._infos.array
							.length - 1), this._wagons[e].setPosition(this._infos.array[i].position)
						.setRotation(this._infos.array[i].rotation);
					return this
				},
				update: function (t, e) {
					var i;
					for (i = 0; i < this._wagons.length; i++) this._wagons[i].update(t, e);
					return this
				}
			}), e.default = s
		}, function (t, e, i) {
			"use strict";
			i.r(e);
			i(3);
			var n = i(21),
				r = i(22);

			function a(t) {
				n.default.call(this, t), this._perso = new r.default, this._roll.add(this._perso.getObject())
			}
			Object.assign(a.prototype, n.default.prototype, {
				update: function (t, e) {
					return this._perso.update(t, e), this
				}
			}), e.default = a
		}, function (t, e, i) {
			"use strict";
			i.r(e);
			var d = i(3),
				f = i(8);

			function n(t) {
				f.default.call(this, t);
				var e, i, n, r, a = new d.Sprite(new d.SpriteMaterial({
						color: "#666666",
						map: this._settings.pointsMap[0],
						opacity: 0,
						transparent: !0,
						visible: !1
					})),
					o = new d.MeshToonMaterial({
						color: 6710886,
						wireframe: !1
					}),
					s = new d.MeshToonMaterial({
						color: 16711680
					}),
					c = new d.Mesh(new d.CylinderBufferGeometry(.6, .6, .4, 16), new d.MeshToonMaterial({
						color: 3355443
					})),
					h = new d.CylinderBufferGeometry(3, 1.6, 3, 4, 1, !1),
					l = new d.Mesh(new d.BoxBufferGeometry(6.4, .8, 4.8), o),
					u = new d.Mesh(new d.BoxBufferGeometry(4.6, .8, 3.2), o),
					p = 1.6;
				l.position.y = 3.4, u.position.y = .9, h.rotateY(Math.PI / 4), h.scale(1.5, 1, 1), h.translate(0, 2,
						0), e = new d.Mesh(h, s), c.position.y = .3, c.rotation.x = Math.PI / 2, i = c.clone(), n = c
					.clone(), r = c.clone(), c.position.x = -p, c.position.z = 1.5, i.position.x = -p, i.position
					.z = -1.5, n.position.x = p, n.position.z = 1.5, r.position.x = p, r.position.z = -1.5, a.scale
					.set(15, 15, 1), this._object = new d.Group, this._pitch = new d.Group, this._roll = new d.Group,
					this._pointsPlane = a, this._lastRotationY = 0, this._object.add(this._pitch, a), this._pitch.add(
						this._roll), this._roll.add(l, e, u, c, i, n, r), this.addAnimation("points", {
						duration: 1e3,
						easing: "easeInOutQuad",
						onStart: function () {
							a.material.visible = !0, a.material.opacity = 0, a.position.y = 5
						},
						onUpdate: function (t) {
							a.material.opacity = t <= .2 ? 5 * t : 1 - 1.25 * (t - .2), a.position.y = 5 +
								10 * t
						},
						onComplete: function () {
							a.material.visible = !1
						}
					})
			}
			Object.assign(n.prototype, f.default.prototype, {
				showPoints: function (t) {
					return this._pointsPlane.material.map = this._settings.pointsMap[t - 1], this
						.playAnimation("points"), this
				},
				setRotation: function (t) {
					return this._object.rotation.y = t.y, this._pitch.rotation.z = t.z, this._roll
						.rotation.x = 2 * (t.y - this._lastRotationY), this._lastRotationY = t.y, this
				},
				update: function (t, e) {
					return this._animate(t), this
				}
			}), e.default = n
		}, function (t, e, i) {
			"use strict";
			i.r(e);
			var h = i(3),
				a = i(8);

			function n() {
				a.default.call(this);
				var t = new h.MeshToonMaterial({
						color: 16711680,
						wireframe: !1
					}),
					e = new h.Mesh(new h.CylinderBufferGeometry(1, 1.5, 4, 16), t),
					i = o(t),
					n = s(t),
					r = s(t);
				i.position.y = 5.5, n.position.y = 3, n.position.z = -1.5, n.rotation.x = Math.PI / 8, r.position.y =
					3, r.position.z = 1.5, r.rotation.x = Math.PI / -8, e.geometry.translate(0, 2, 0), e
					.updateMatrix(), e.position.y = 3, e.add(i, n, r), this._object = e
			}

			function o(t) {
				var e, i = new h.Mesh(new h.SphereBufferGeometry(2, 16, 16), t),
					n = new h.Mesh(new h.SphereBufferGeometry(.5, 8, 8), new h.MeshToonMaterial);
				return e = n.clone(), n.position.x = 1.8, n.position.z = -.7, e.position.x = 1.8, e.position.z = .7, i
					.add(n, e), i
			}

			function s(t) {
				var e = .75,
					i = 2,
					n = 8,
					r = new h.Mesh(new h.SphereBufferGeometry(e, n, n), t),
					a = new h.Mesh(new h.CylinderBufferGeometry(e, e, i, n), t),
					o = r.clone(),
					s = a.clone(),
					c = r.clone();
				return a.geometry.translate(0, -e / 2, 0), s.geometry.translate(0, -e / 2, 0), o.position.y = -i, c
					.position.y = -i, o.rotation.z = Math.PI / 4, r.add(a), a.add(o), o.add(s), s.add(c), r
			}
			Object.assign(n.prototype, a.default.prototype, {
				update: function (t, e) {
					return this
				}
			}), e.default = n
		}]);
	</script>
</body>

</html>