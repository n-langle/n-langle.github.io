<!DOCTYPE html>
<html>

<head>
	<meta name="viewport" content="initial-scale=1.0,maximum-scale=1.0,user-scalable=no" />
	<meta charset="utf-8">
	<link rel="icon" type="image/png"
		href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAMAAAAoyzS7AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyhpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTQwIDc5LjE2MDQ1MSwgMjAxNy8wNS8wNi0wMTowODoyMSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTggKE1hY2ludG9zaCkiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6NjI2QjdCNzk5MzA5MTFFOEFERERDQ0U0Njc3NUIzODciIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6NjI2QjdCN0E5MzA5MTFFOEFERERDQ0U0Njc3NUIzODciPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo2MjZCN0I3NzkzMDkxMUU4QURERENDRTQ2Nzc1QjM4NyIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo2MjZCN0I3ODkzMDkxMUU4QURERENDRTQ2Nzc1QjM4NyIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/Ppp54RwAAAAGUExURf///wAAAFXC034AAAAMSURBVHjaYmAACDAAAAIAAU9tWeEAAAAASUVORK5CYII=" />

	<style>
		a,
		abbr,
		acronym,
		address,
		applet,
		article,
		aside,
		audio,
		b,
		big,
		blockquote,
		body,
		canvas,
		caption,
		center,
		cite,
		code,
		dd,
		del,
		details,
		dfn,
		div,
		dl,
		dt,
		em,
		embed,
		fieldset,
		figcaption,
		figure,
		footer,
		form,
		h1,
		h2,
		h3,
		h4,
		h5,
		h6,
		header,
		hgroup,
		html,
		i,
		iframe,
		img,
		ins,
		kbd,
		label,
		legend,
		li,
		mark,
		menu,
		nav,
		object,
		ol,
		output,
		p,
		pre,
		q,
		ruby,
		s,
		samp,
		section,
		small,
		span,
		strike,
		strong,
		sub,
		summary,
		sup,
		table,
		tbody,
		td,
		tfoot,
		th,
		thead,
		time,
		tr,
		tt,
		u,
		ul,
		var,
		video {
			margin: 0;
			padding: 0;
			border: 0;
			font: inherit;
			vertical-align: baseline
		}

		.obj-banner,
		.obj-header {
			font-family: Helvetica, Arial, sans-serif;
			box-sizing: border-box
		}

		article,
		aside,
		details,
		figcaption,
		figure,
		footer,
		header,
		hgroup,
		menu,
		nav,
		section {
			display: block
		}

		body {
			-webkit-user-select: none;
			-moz-user-select: none;
			-ms-user-select: none;
			user-select: none;
			line-height: 1
		}

		ol,
		ul {
			list-style: none
		}

		blockquote,
		q {
			quotes: none
		}

		blockquote:after,
		blockquote:before,
		q:after,
		q:before {
			content: '';
			content: none
		}

		table {
			border-collapse: collapse;
			border-spacing: 0
		}

		@font-face {
			font-family: Kodchasan-Bold;
			src: url('data:application/x-font-woff;charset=utf-8;base64,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') format('woff2');
			font-weight: 400;
			font-style: normal
		}

		button {
			-webkit-appearance: none;
			-moz-appearance: none;
			appearance: none;
			background: 0 0;
			border: 0;
			padding: 0
		}

		.button {
			background: #ff5151;
			border-radius: 5px;
			color: #fff;
			cursor: pointer;
			display: inline-block;
			font-size: .625em;
			font-weight: 700;
			padding: 1em
		}

		#App,
		body,
		html {
			background-color: #e3e3e3;
			background-image: none;
			background-position: center center;
			background-repeat: no-repeat;
			background-size: cover;
			height: 100%;
			overflow: hidden;
			width: 100%
		}

		.obj-banner::before,
		.obj-header::before {
			background: #000;
			height: 100%;
			opacity: .5;
			content: ""
		}

		#App>svg:first-child {
			left: -10000px;
			position: absolute;
			top: -10000px
		}

		#App {
			position: relative;
			z-index: 0
		}

		#App canvas {
			height: 100%;
			width: 100%
		}

		.obj-banner {
			bottom: 0;
			color: #fff;
			display: table;
			left: 0;
			padding: 1em 1.5em;
			position: fixed;
			text-align: center;
			-webkit-transition: -webkit-transform .25s ease-out;
			transition: transform .25s ease-out;
			width: 100%;
			z-index: 100
		}

		.obj-banner::before {
			left: 0;
			position: absolute;
			top: 0;
			width: 100%
		}

		.obj-banner>div {
			display: table-cell;
			position: relative;
			vertical-align: middle;
			z-index: 2
		}

		.obj-banner h1 br,
		.obj-header {
			display: none
		}

		.obj-banner>div:first-child {
			width: 3em
		}

		.obj-banner>div:nth-child(2) {
			line-height: 1em;
			padding: 0 1em;
			text-align: left
		}

		.obj-banner small {
			font-size: .75em;
			font-weight: 700
		}

		.obj-banner img {
			border-radius: .25em;
			vertical-align: text-bottom;
			width: 100%
		}

		#App[data-current-screen=end] .obj-banner {
			-webkit-transform: translateY(100%);
			-ms-transform: translateY(100%);
			transform: translateY(100%)
		}

		.obj-header {
			left: 0;
			padding: 1em 1.5em;
			position: fixed;
			text-align: center;
			top: 0;
			-webkit-transition: -webkit-transform .25s ease-out;
			transition: transform .25s ease-out;
			width: 100%;
			z-index: 100
		}

		.obj-header::before {
			left: 0;
			position: absolute;
			top: 0;
			width: 100%
		}

		.obj-header.is-visible {
			display: block
		}

		.obj-header p {
			color: #fff;
			font-size: 1em;
			font-weight: 900;
			position: relative;
			z-index: 1
		}

		#App[data-current-screen=end] .obj-header {
			-webkit-transform: translateY(-100%);
			-ms-transform: translateY(-100%);
			transform: translateY(-100%)
		}

		.obj-loader {
			-webkit-animation: loader 1s infinite ease-in-out;
			animation: loader 1s infinite ease-in-out;
			border: 6px solid #fff;
			border-radius: .75em;
			height: 2em;
			margin: 0 auto;
			width: 2em
		}

		@-webkit-keyframes loader {
			0% {
				opacity: .25;
				-webkit-transform: rotate(0);
				transform: rotate(0)
			}

			50% {
				opacity: 1
			}

			100% {
				opacity: .25;
				-webkit-transform: rotate(360deg);
				transform: rotate(360deg)
			}
		}

		@keyframes loader {
			0% {
				opacity: .25;
				-webkit-transform: rotate(0);
				transform: rotate(0)
			}

			50% {
				opacity: 1
			}

			100% {
				opacity: .25;
				-webkit-transform: rotate(360deg);
				transform: rotate(360deg)
			}
		}

		.screen-container {
			height: 100%;
			position: relative;
			width: 100%;
			z-index: 1
		}

		.obj-screen {
			font-family: Kodchasan-Bold;
			left: -100%;
			opacity: 0;
			position: absolute;
			text-align: center;
			width: 100%;
			z-index: 2
		}

		.obj-screen.is-visible {
			left: 0;
			opacity: 1
		}

		.obj-screen.is-hidden {
			left: -100%;
			opacity: 0
		}

		.obj-screen .v-align-center {
			position: absolute;
			top: 50%;
			-webkit-transform: translateY(-50%);
			-ms-transform: translateY(-50%);
			transform: translateY(-50%);
			width: 100%
		}

		.background-before::before {
			background-color: #000;
			background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR4AWNwL/BhAAADCQEEiiqnjQAAAABJRU5ErkJggg==);
			background-repeat: repeat;
			background-size: auto;
			content: "";
			height: 100%;
			left: 0;
			opacity: .3;
			position: absolute;
			top: 0;
			width: 100%
		}

		.background-before>* {
			position: relative
		}

		.screen-container.perspective-enabled {
			-webkit-perspective: 500px;
			perspective: 500px
		}

		.screen-container.perspective-enabled>* {
			-webkit-transform: translateY(-5em) rotateY(20deg) rotateX(45deg) rotateZ(-10deg);
			transform: translateY(-5em) rotateY(20deg) rotateX(45deg) rotateZ(-10deg)
		}

		.obj-screen.screen-end-of-level {
			height: 100%
		}

		.obj-screen.screen-end-of-level.background-before::before {
			opacity: 0
		}

		.obj-screen.screen-end-of-level>div {
			left: 45%;
			position: absolute;
			top: 40%;
			-webkit-transform: translate(-50%, -50%) rotate(-10deg);
			-ms-transform: translate(-50%, -50%) rotate(-10deg);
			transform: translate(-50%, -50%) rotate(-10deg);
			width: 20.155068em
		}

		.obj-screen.screen-end-of-level .ctn-txt {
			height: 100%;
			overflow: hidden;
			position: absolute;
			right: 0;
			top: 0;
			-webkit-transition: width .6s .5s cubic-bezier(.165, .84, .44, 1);
			transition: width .6s .5s cubic-bezier(.165, .84, .44, 1);
			width: 0
		}

		.obj-screen.screen-end-of-level p {
			color: #fff;
			-webkit-font-smoothing: antialiased;
			font-size: 2em;
			line-height: 1.5em;
			padding: 0 0 0 .604627em;
			position: absolute;
			right: 0;
			top: 3.1em;
			text-transform: uppercase;
			width: 9.474801em;
			z-index: 2
		}

		.obj-screen.screen-end-of-level .ctn-svg {
			overflow: hidden;
			padding-top: 77.416904%;
			position: relative;
			-webkit-transition: width .4s cubic-bezier(.785, .135, .15, .86);
			transition: width .4s cubic-bezier(.785, .135, .15, .86);
			width: 0
		}

		.obj-screen.screen-end-of-level svg {
			fill: #f78f00;
			height: 100%;
			left: 0;
			position: absolute;
			top: 0;
			width: 20.155068em
		}

		.obj-screen.screen-end-of-level.is-visible .ctn-svg,
		.obj-screen.screen-end-of-level.is-visible .ctn-txt {
			width: 100%
		}

		.obj-screen.screen-end {
			color: #fff;
			height: 100%;
			line-height: 2em;
			width: 100%
		}

		.obj-screen.screen-end.background-before::before {
			opacity: .75
		}

		.obj-screen.screen-end .landscape {
			font-size: .5em
		}

		.obj-screen.screen-end img {
			border-radius: 1em;
			margin-bottom: .75em;
			width: 5em
		}

		.obj-screen.screen-end h2 {
			font-size: 1.5em;
			font-weight: 700;
			margin-bottom: .5em
		}

		.obj-screen.screen-end .txt {
			line-height: 1.1em;
			margin-bottom: 1em
		}

		.obj-screen.screen-end .button {
			line-height: 1em;
			margin: .75em 0
		}

		.obj-screen.screen-end .button~.button {
			margin-bottom: 0
		}

		.obj-screen.screen-end .v-align-center>* {
			opacity: 0;
			-webkit-transform: translateY(100px);
			-ms-transform: translateY(100px);
			transform: translateY(100px);
			-webkit-transition: -webkit-transform .25s ease-out, opacity .25s ease-out;
			transition: transform .25s ease-out, opacity .25s ease-out
		}

		.obj-screen.screen-end .v-align-center .txt {
			-webkit-transition-delay: .1s;
			transition-delay: .1s
		}

		.obj-screen.screen-end .v-align-center .button {
			-webkit-transition-delay: .2s;
			transition-delay: .2s
		}

		.obj-screen.screen-end .v-align-center .or {
			-webkit-transition-delay: .3s;
			transition-delay: .3s
		}

		.obj-screen.screen-end .v-align-center .or+.button {
			-webkit-transition-delay: .4s;
			transition-delay: .4s
		}

		.obj-screen.screen-end.is-visible .v-align-center>* {
			opacity: 1;
			-webkit-transform: translateY(0);
			-ms-transform: translateY(0);
			transform: translateY(0)
		}

		.obj-screen.screen-game p {
			color: #fff;
			font-size: 1.5em;
			left: 50%;
			position: absolute;
			text-transform: uppercase;
			top: 3em;
			-webkit-transform: translateX(-50%);
			-ms-transform: translateX(-50%);
			transform: translateX(-50%)
		}

		.obj-screen.screen-loading {
			background: #000;
			color: #fff;
			height: 100%;
			text-align: center;
			width: 100%;
			z-index: 200
		}

		.obj-screen.screen-loading h1 {
			font-weight: 900;
			margin: 0 0 1em;
			text-transform: uppercase
		}

		.obj-screen.screen-start {
			height: 100%
		}

		.obj-screen.screen-start h1 {
			margin: 0 auto;
			width: 80%
		}

		.landscape .obj-screen.screen-start h1 {
			width: 20%
		}

		.obj-screen.screen-start h1 img {
			width: 100%
		}

		.obj-screen.screen-start .modal {
			box-sizing: border-box;
			color: #fff;
			margin: 0 auto 1em;
			padding: .5em 1.5em 1.5em;
			width: 80%
		}

		.obj-screen.screen-start .modal::before {
			border-radius: .5em
		}

		.obj-screen.screen-start .touch {
			position: relative
		}

		.obj-screen.screen-start .touch-finger {
			-webkit-animation: touchX 2s infinite ease-in-out;
			animation: touchX 2s infinite ease-in-out;
			height: 4em
		}

		.obj-screen.screen-start .touch-finger img {
			height: 100%
		}

		@-webkit-keyframes touchX {

			0%,
			100% {
				-webkit-transform: translateX(-45%);
				transform: translateX(-45%)
			}

			50% {
				-webkit-transform: translateX(45%);
				transform: translateX(45%)
			}
		}

		@keyframes touchX {

			0%,
			100% {
				-webkit-transform: translateX(-45%);
				transform: translateX(-45%)
			}

			50% {
				-webkit-transform: translateX(45%);
				transform: translateX(45%)
			}
		}

		.obj-screen.screen-start .modal p {
			line-height: 1.2em
		}

		@-webkit-keyframes blink {

			0%,
			100% {
				opacity: 0
			}

			50% {
				opacity: 1
			}
		}

		@keyframes blink {

			0%,
			100% {
				opacity: 0
			}

			50% {
				opacity: 1
			}
		}

		.obj-screen.screen-start .v-align-center>* {
			opacity: 0;
			-webkit-transform: translateY(100px);
			-ms-transform: translateY(100px);
			transform: translateY(100px);
			-webkit-transition: -webkit-transform .25s ease-out, opacity .25s ease-out;
			transition: transform .25s ease-out, opacity .25s ease-out
		}

		.obj-screen.screen-start .v-align-center h1 {
			-webkit-transition-delay: .1s;
			transition-delay: .1s
		}

		.obj-screen.screen-start .v-align-center .modal {
			-webkit-transition-delay: .2s;
			transition-delay: .2s
		}

		.obj-screen.screen-start .v-align-center>p {
			-webkit-animation: blink 1s infinite ease-in-out;
			animation: blink 1s infinite ease-in-out;
			color: #fff;
			margin-bottom: 4em;
			top: 23em;
			-webkit-transition-delay: .3s;
			transition-delay: .3s
		}

		.obj-screen.screen-start.is-visible .v-align-center>* {
			opacity: 1;
			-webkit-transform: translateY(0);
			-ms-transform: translateY(0);
			transform: translateY(0)
		}
	</style>
	<style type='text/css'>
		/**/
		#App {
			font-family: Helvetica;
		}


		/**/
		.obj-screen.screen-loading {
			background-color: #000000;
			background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR4AWNwL/BhAAADCQEEiiqnjQAAAABJRU5ErkJggg==');
			background-position: center center;
			background-repeat: no-repeat;
			background-size: auto;
		}


		/**/
		.obj-screen.screen-loading h1 {
			color: #ffffff;
			font-size: 1em;
			font-weight: 400;
			text-transform: uppercase;
		}


		/**/
		.obj-header::before {
			background-color: #000000;
			background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR4AWNwL/BhAAADCQEEiiqnjQAAAABJRU5ErkJggg==');
			background-position: center center;
			background-repeat: no-repeat;
			background-size: auto;
			opacity: 0.5;
		}


		/**/
		.obj-header p {
			color: #ffffff;
			font-size: 1;
			text-align: center;
		}


		/**/
		.obj-screen.screen-start .modal {
			color: #ffffff;
		}


		/**/
		.obj-screen.screen-start .v-align-center>p {
			color: #ffffff;
		}


		/**/
		.obj-screen.screen-start .modal::before {
			background-color: #000000;
			background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR4AWNwL/BhAAADCQEEiiqnjQAAAABJRU5ErkJggg==');
			background-position: center center;
			background-repeat: no-repeat;
			background-size: auto;
			border-radius: 0.5;
			opacity: 0.3;
		}

		/**/
		.obj-banner::before {
			background-color: #000000;
			background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR4AWNwL/BhAAADCQEEiiqnjQAAAABJRU5ErkJggg==');
			background-position: center center;
			background-repeat: no-repeat;
			background-size: auto;
			opacity: 0;
		}


		/**/
		.obj-screen.screen-end {
			color: #ffffff;
		}


		/**/
		.obj-screen.screen-end .retry {
			background-color: #ff5151;
			background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR4AWNwL/BhAAADCQEEiiqnjQAAAABJRU5ErkJggg==');
			background-position: center center;
			background-repeat: no-repeat;
			background-size: auto;
			border-radius: 0.5;
			color: #ffffff;
			font-size: 0.5em;
			font-weight: 400;
			text-transform: uppercase;
		}


		/**/
		.obj-screen.screen-end .download {
			background-color: #ff5151;
			background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR4AWNwL/BhAAADCQEEiiqnjQAAAABJRU5ErkJggg==');
			background-position: center center;
			background-repeat: no-repeat;
			background-size: auto;
			border-radius: 0.5;
			color: #ffffff;
			font-size: 0.5em;
			font-weight: 400;
			text-transform: uppercase;
		}


		/**/
		.obj-banner::before {
			background-color: #000000;
			background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR4AWNwL/BhAAADCQEEiiqnjQAAAABJRU5ErkJggg==');
			background-position: center center;
			background-repeat: no-repeat;
			background-size: auto;
			opacity: 0.5;
		}


		/**/
		.obj-banner {
			color: #ffffff;
		}


		/**/
		.obj-banner .button {
			background-color: #ff5151;
			background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR4AWNwL/BhAAADCQEEiiqnjQAAAABJRU5ErkJggg==');
			background-position: center center;
			background-repeat: no-repeat;
			background-size: auto;
			border-radius: 5px;
			color: #ffffff;
			font-size: .75em;
			font-weight: 400;
			text-transform: uppercase;
		}

		#App .button.download {
			background: #ccc;
			color: #fff;
			cursor: default;
		}
	</style>

	<script type="text/javascript"></script>
	<script type='text/javascript'>
		window._voodooProvider = 'applovin'
	</script>
</head>

<body>


	<div id="App">
		<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
			<symbol viewBox="0 0 526.5 407.6" id="ink-splash" xmlns="http://www.w3.org/2000/svg">
				<path
					d="M204 98.9c.4 4.8-2.4 8.8-3.7 13.1-1.2 3.8-4.1 7.5-.5 11.3 3.7 3.9 8.2 6.7 13.8 5.2 1.8-.5 3.1-.9 4.3 1.1-2.2 1.3-4.6 2.2-7.2 2.5-4.6.5-6.7 3.9-4.9 8.1 1.2 2.9 2.5 5.8 4.3 8.3 2.6 3.7 7 2.8 10.4 2.3 6.8-1.2 13.8-.4 20.6-1.8 9.8-2 19.7.4 29.5 0 2.8-.1 4.1-.9 5.3-3.3 1.8-3.3 4.2-6.2 6.4-9.3 5-7.2 4.8-8.6-1.9-13.6-1.8-1.4-5-2-4.1-5.4.3-.9.6-2.4 2.5-2.6 3.3-.4 4.5 1.7 6.4 3.6 2.5 2.4 2.1 6.2 5.3 8.2 1.8 1.1 3.1 1.9 4.5-.2 1-1.5 2.7-1.9 4.2-2.3 6.9-2 9.8-3.4 5.5-12.7 1.8-.6 4.6.7 5.1-2.4.2-1.2 1.6-1.2 2.5-.8 2.2.8 3.8 2.4 4.7 4.6.3.7-.3 1.8 0 2.4 1.2 2-.3 6.4 4.4 5.6 6.3-1.2 8.8-3.5 7.2-7.8-2.1-5.4-2.8-11.4-7.3-15.8-1.1-1.1-1.7-2.9-1.9-4.5-.4-2.8 1.3-4.7 3.8-5.5 2.8-.8 3.2 1.4 3.8 3.3 1.6 5.3 1 10.9 2.4 16.4 2 8.1 8 11.9 13.8 16 3.3 2.3 8.8-1.2 11.7-7.1 4-8.1 4.8-16.9 5-25.8.1-5.8-1.4-11.3-1.9-17-.1-1.3-.2-2.7.1-4 .6-2.7 2.4-4.8 5-4.7 2.9.2 4.5 2.5 4.7 5.5.5 6-1.8 11.6-2.5 17.5-1 8.6-2.3 17.2-3.4 25.8-.3 2.4-.5 5.8 3.1 5.1 2.9-.5 8.7 2.3 7.9-4.9-.3-2.8-.6-5.9 2.7-7.2.9-.4 2.3-.6 3.1.7 1.7 2.9-.7 4.8-1.4 7.2-.8 2.6-5.8 5.4-1.7 7.7 2.7 1.6 5-2.9 6.5-5.4 2.5-3.8 4.4-8 6.6-12.1 1.1-2.1 2.5-4.7 5.1-3.2 2.4 1.3 2.4 3.8 1.2 6.5-2.4 5.2-6.9 8.4-10.7 12.2-6.1 6.3-6 7.4 1.1 12.3 2.4 1.7 4.5 3.8 6.8 5.7 3.9 3.2 5 2.7 7.7-2 2.6-4.5 5-9.4 10.6-11.2 1.3-.4 2.5-1.1 3.6 0 1.6 1.5 0 3.1-.7 3.9-2.7 3-5.7 5.8-8.8 8.4-3.4 2.8-5.3 6.5-6.7 10.7 5.6 1.3 10.7-.3 16-.5 9.9-.5 19.8 1.9 29.8 1 1.8-.2 3.6-.1 5.4-.6 5.2-1.5 9.9.2 14.2 3.2-.8 1.2-2.6 2.7-2.8 4.3-.2 2-4.5 5.2 1.4 6.4 2.1.4 4 2.7 5 5s-1.7 7.5 4.5 5.4c.1.3.1.7.3.9 2.8 5.4 5.8 6.9 11.4.2 1.9-2.2 4.2-4.2 5.1-8.5 1.3 4.3-1.3 7 .2 10.2 2.2 4.9 2.6 5.3 6.5 1.9.8-.7 1.5-1.9 2.9-1.5l-.1-.1c-.7 1.5-1.7 2.9-2 4.4-.5 3.4-.4 7.2 3 8.9 3.9 1.9 8 1.3 11.3-2.7 1.4 3.4-1 4.5-2.5 6-1.7 1.8-3.6 3.2-2 6.3 1.6 2.9 3.4 2.2 5.8 1.7 2.2-.4 4.5-.3 6.7 0-4.9 2-10.4.9-15.5 3.2 3.1 4.9 2.8 9.7.3 15-2.7 5.6-1.9 6.6 3.7 9.7 1.4.8 4.2 1.3 2.5 3.7-1.1 1.6-3.3 1.1-4.9-.1-.3-.2-.7-.3-.8-.5-3.5-6.3-7.1-4.3-11.4-.5-2.3 2-3.4 3.9-1.5 6.1 2 2.4 0 2-1 3.3-3.8 4.8-4.6 1.2-5.9-1.6-.8-1.7-1.8-3.6-4-2.6-1.5.7-4.4.3-3.9 3.5.4 2.3.5 5.1 3.4 5.3 4.6.3 9.3.3 14 .1 2.1-.1 2.1-.5-.2-4.3 1.7-1.2 2.9.3 3.8 1 5.1 3.5 10.7 3.7 16.3 2.5 5.1-1.2 8.4 2.4 13 3.4-1.8 2.3-5.2 2.7-5.2 5.7 0 1.8-2.9 4.8 1.7 5.3.4.1.8 1.6.9 2.6.5 4.2-2.7 9.1 2.7 12.3-2.6 2.5-.3 5.7-1.3 8.4-1.7 4.4-2.1 9.7-1.2 13.5.9 3.8 1.1 7.9 2.5 11.7.5 1.3-1 3.7-1.9 5.2-1.6 2.8-2.2 5.1-.8 8 .2.4.4 1.1.3 1.3-3.9 4.1 1.3 5.6 2.2 8.2-4.8 3.2-10.4 1-15.5 1-6.9 0-13.9.3-20.8.3-12.8.1-25.6 0-38.5 0-3.7 0-7.5-.1-5.7 5.6.2.6-.6 2.1-.9 2.1-4.5-.1-1.9 5.7-5.9 6.8-1.8.5.8 4.4.6 6.8-5.5.2-10.4-3.1-16.4-1.1-3.3 1.1-6.4-3.5-9-6-3.8-3.7-8.1-4-12.3-3-4.3 1.1-7.3 4.5-8.5 8.9-1.2 4.2 4.4 11.8 9.6 13.3.9.3 2.6-.8 2.1 1.4-.2 1.2-.9 1.8-2.3 2.2-2.7.7-4.6-.3-6.8-1.4-3.5-1.7-6.9-.8-9.2 2.3-1.7 2.3-2.2 5.7.1 7.1 2.7 1.6 3.2 4.5 5.3 6.2 1.4 1.2 2.5 3.1 1.3 5.9-4.2-5.6-8.1-11-12.2-16.2-1.2-1.5-2.9-5-4.8-.8-3.8 8.1-10.8 9.6-18.6 9.9-1.4.1-2.8 0-4.3.7-5.4 2.7-6.1 4.1-4.2 11 .7 2.5.8 4.6-1.3 6.1-.8.6-2.2 1.9-3.5.3-1.4-1.8-3.7-3.1-1.8-5.9.4-.6.2-1.6.1-2.5-.3-3.9 5.6-8.7-.1-11.2-3.5-1.6-7.5-2.8-11.3-4.2-3.4-1.3-7.8 4.4-7.5 9.6.3 3.8.7 7.5 1.5 11.2.8 3.8-.7 6.9-2.2 10-.8 1.7-3.1 3.1-4.9 2.6-2-.6-2.9-2.8-2.3-5 1.2-4.2 2.6-8.4 4-12.6.7-2 1.6-4 2.3-6 1.3-3.5.1-5-3.6-4.4-1 .2-2 .7-2.5-.5-1-2.7-1-5.7.5-8 3.9-5.9 3.9-5.6-1.2-9.7-4-3.2-6.3.6-7.3 2.4-2.9 5-6.2 10.1-6.3 16.3 0 1.8-1.1 3.2-2.1 4.4-1.7 2.2-4.4 2-6.4 1-2.2-1.2-1.2-3.5-.1-5.2 2.9-4.6 7.1-8.2 9.9-13 4-6.7 3.8-13.6 1.9-20.5-1.4-5-10-6.4-16.2-3.3-12.9 6.5-22.9 16.1-30.8 27.9-2.2 3.2-5.2 3.4-8.1 1.6-3.1-2-2.1-4.9-.3-7.2 1.5-1.9 3.4-3.6 5.4-4.8 10.5-6.2 19.9-13.8 29.4-21.3 1.8-1.4 4-3.1 3-5-.7-1.3-4.1-2.2-5.7-1.7-9.1 3.4-18.2-.4-27.3.9-5.2.7-10.3 1.4-15.4 2.3-.9.1-1.6 1-2.4 1.3-2.6 1-4.7 3.5-4.2 5.4.6 3 3.9.7 6 1.1-.1 2.1-1.2 3.1-3.1 4-7.2 3.3-9 11.4-3 16.4l-.1.5-.5.1c-2.6.5-4.4-1.5-6.3-2.4-7.5-3.7-12.2-1-12.7 7.4 0 .5-.1 1-.2 1.6-.5-.3-1.1-.4-1.2-.7-.7-2.9-.2-6.9-4.6-7-4.9-.1-10.7 5.1-11.1 9.6-.1.9-.3 1.6-1.7 2.3 1.2-2.8 1.3-5.3-1-7-2.4-1.8-5-1.1-7.5 0-1.5-7.7-3.6-9.2-9.3-6.6.1-5.5-1-6.3-6.5-4.8-2.2.6-4.4 1-6.7 1.5-.8.1-1.6 0-3 0 .9-3.7-.6-7.3 3.2-10.5 2.2-1.8.3-3.7-4.2-1.7 2.9-3.4 4.9-5.4 2.8-8.7-2-3.2-4.6-1.9-7-2-2.5-.1-4.9.2-7.4.8-5.5 1.3-10.8-.9-16.2-1.3-8-.6-15.7-.1-23.5.9-5.2.7-10.6.9-15.9.4-3.2-.3-6.5.7-9.7-1.4-1.7-1.1-4.3.7-3 3.3 1.4 3-.6 4.3-2.3 5-2.7 1.1-3.7-1.9-3.7-3.4-.1-4-2.7-5.1-5.5-4.7-5.8.9-11.4-.5-17.4.7-5 1-11.3 1.3-16.6-1.5-.9-.5-2.7-1.4-.8-2.7 5.2-3.8 4.1-9.4 2-13.2-3.3-5.9-1.1-11.7-1.5-17.5-.1-1.9-.5-4-1.3-5.2-1.6-2.3-1-3.6-.2-6.1 1.1-3.2 2-7.2 0-10.6-1.6-2.6-4.6-3.4-7.5-2.5-4.3 1.3-8.4-.3-12.6-.4-2.4 0-4.6-.7-7.1.2-1.6.6-3.6.2-4.8-2.3 4.3-1.7 8.6.1 12.2 1 7 1.6 12.9-.7 19.1-2.7.2-.1.4-.1.4-.2.9-3.9 2.5-7.8 2.3-11.6-.1-1.8-2.3-3.5-.9-6.1.6-1.2-.5-3.1-2.3-3.2 4.5-4 11.7 2.9 13.9-1.7 2.2-4.6 9-5.3 8.5-11.5 1.7 3.8 4.9 3.9 8.1 3.6 2.6-.2 2.6-2.6 2.9-5 3.1 3.5 5.8 4.1 7.8-.7.6-1.5 1.8-2.8 2.6-4.2.9-1.5 1.2-3.8 3.7-3.3s3.7 2.4 4.7 4.6c.9 1.8-1.6 7.6 4.4 4 .5-.3.3 1 .6 1.5 1.2 2.5 3 4.2 6.1 4 2.4-.1 2.9-2.2 3.5-3.6.4-.9-.6-2.2-2.3-2.5-2.2-.4-3.2-1.1-.6-3.3 2.7-2.3 3.7-5.5 2.2-9.7-2.5-6.8-3.5-14-2.1-21.4.7-3.8-2.4-7.4-1.2-11.8.5-1.6-2.5-2.3-4.4-1.4-2.1.9-4.2 1.9-6.1 3.1-3.2 2-4.8-.5-5.7-2.6-1.1-2.4 1.2-4.2 3.1-4.4 2.7-.3 5.2-2.4 8.5-.5 1.9 1.1 4.7-.1 5.1-3.6.6-5.2-.7-10.3-1.4-15.3-.5-3.4-4.5-2.4-7-1.5-3.5 1.3-7.2 2.6-10.3 4.6-3.9 2.4-7.6 1.3-11.4.6-2-.4-3.2-2.2-2.6-4.2.8-2.7 3.1-4 5.6-3.5 5.6 1.2 11.2.7 16.9 1 5 .3 5.5-.3 3.7-4.8-1-2.6.9-3.6 2.4-4 3.1-.9 6-2.6 9.5-2 2.2.3 5.1-.2 5.4-3.1.3-2.6-1.8-4.4-4.1-5-5.6-1.7-11.3-2.9-17.1-1.8-2.2.4-3.9-.1-5.7-.5-2.6-.5-3.6-2.8-3-5.5.7-3.1 3-2.6 5.1-1.8 4.5 1.7 8.9 3.8 13.5 5.4 8.2 2.8 15.5-.2 22.5-4 3.1-1.7 2.7-9.3-.5-13.7-5.3-7.5-12.7-12.5-20.5-17-5.3-3-11.1-5.3-17-7.3-3.4-1.1-5.1-4-3.8-7.4 1.3-3.4 4.5-3 7.2-2 4.2 1.5 6.9 5.2 10.3 7.9 8.2 6.7 16.8 13 25.6 18.8 2.4 1.6 4.8 1.8 5.5-1.9.2-1.2.8-2.1 1.4-3.1 1.1-1.9 1.5-3.6-1.7-4.3-1.6-.3-3.2-1.6-4.5-2.8-1.7-1.5-1.8-4-.4-5.4 1.6-1.5 3.8-.9 5.1 1.1 1.4 2.2 2.5 4.6 4.1 6.7.9 1.1 1.8 3.2 3.9 2.1 2-1 .4-2.5.3-3.8-.5-5.3-4.4-8.7-6.8-12.9-1-1.7-2.4-3.2-3.2-4.9-.8-1.9-2-4.3.5-5.6 2.1-1.1 3.9.4 5.4 2 3.3 3.4 4 7.9 4.9 12.2 2.5 11.8 4.7 13.1 15.3 8.2 10.2-4.8 10.2-4.8 5-14.9-1.7-3.2-2.3-6.4-2.2-10 .1-1.8 1.1-3.1 2.4-3.4 1.8-.4 1.8 1.8 2.1 2.8 1.3 3.9 2.7 7.8 3.3 11.8 1 6.8 5.4 10.6 10.8 13.7.8.5 1.6.6 2.3.1 1.2-.8 1.1-2 .9-3.1-.4-2.4-2.5-4.6-1.4-7.6 3.2 1.6 5.8 3.4 7.6 6.3 5.2 8.6 18.4 12.4 24.6 1.3.9-.9 1.6-.9 2-1.1zM339.7 9.5c-.8 5.8-.6 11.6-.7 17.4 0 1 .8 3.2-1.5 2.8-1-.2-2.9.1-3.1-2.3-.2-1.9-1.1-3.8-1.1-5.9 0-4.2-2.1-7.9-3.2-11.9-.8-3-1.2-5.7 1-8 1-1 2.5-2.2 4.4-1.2 2.9 1.6 3.8 4.3 4.2 7.3.2.6 0 1.2 0 1.8z">
				</path>
				<path
					d="M303.4 110.1c-5.2-4.6-12.4-7-14.6-14.8-.7-2.6.1-4.8 1.7-5.9 1.9-1.2 4.4.3 5.4 2.1 3.1 5.8 5.7 11.9 8.5 17.8-.4.3-.7.6-1 .8zM215.1 87.3c4.4-3.8 6.6-9.3 11.3-12.7.7-.5 1.6-1.6 2.5-.8.8.8.6 1.8-.1 3.1-3.1 5.4-9.1 6.9-13.7 10.4zM498.1 175c1.3-4.9 6.3-6.6 9-10.3.8-1.1 1.9.5 2 1.2.4 2.4.9 5-2.3 6l-8.7 3c-.1 0 0 .1 0 .1zM43.8 217c3.2 2.2 3.6 5.4 4 8.6-1.3-2.8-6.2-3.7-4-8.6zM243.7 377.4c2.1 1.6 4.4 3 5.3 6.1-3.7-.2-5.4-2.2-6-5.5 0-.5.2-.7.7-.6zM130.1 340.5c1.7-.5 2.7-2.2 4.4-1 .2.1.3 1 .1 1.2-1.4 1.9-2.8.3-4.5-.2zM177.1 385.4c1.1-2.4 1.7-3.7 2.7-5.9.1 2.6.7 4.4-2.7 5.9zM493.5 156.7c-1-2.3-.1-3.5 2.4-4.3-.6 1.5-.7 3-2.4 4.3zM366.6 33.3c1.7-1.8 2.9-1.6 4-.2-1.2 1.4-2.4.8-4 .2zM193.2 384.6c.4-1.4.8-2.8 1.5-5 .4 2.5.7 4-.2 5.3-.5-.2-.9-.2-1.3-.3zM206 96c-.3 1.3.3 3.2-2.1 2.9l.1.1c-.3-1.4-.1-2.7 1.3-3.5.6-.2.8 0 .7.5z">
				</path>
				<path
					d="M205.4 95.4c.5-.8 1-1.7 2.1-1.7.1 0 .3.5.3.8-.1 1-.9 1.2-1.7 1.4-.3-.1-.5-.3-.7-.5zM208.9 93.1c-.2-.1-.6-.2-.6-.3 0-.3.2-.5.3-.7.4.2.7.4 1.1.5-.3.2-.6.3-.8.5zM243 378c-.9-.4-1.2-.9-.6-1.8.4.4.8.8 1.3 1.2-.2.2-.5.4-.7.6zM232.4 364.5c.1.4.4.9.3 1-.5.3-.7 0-.9-.5.3-.1.4-.3.6-.5z">
				</path>
			</symbol>
		</svg>

		<div class="obj-screen screen-loading is-visible">
			<div class="v-align-center">
				<h1>Roller Splat!</h1>
				<div class="obj-loader"></div>
			</div>
		</div>

		<div class="obj-header">
			<p>Text for your header</p>
		</div>


		<div class="obj-screen screen-start">
			<div class="v-align-center">

				<h1><img src="data:image/png;base64,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"
						alt="" /></h1>

				<div class="modal background-before">
					<div class="touch">
						<div class="touch-finger">
							<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGAAAABgCAMAAADVRocKAAADAFBMVEVHcEwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQEAAAAAAAAAAAAAAABOTk5aWlogICAPDw8AAAAAAAAAAAA1NTXExMT6+vri4uL///99fX0AAAAAAABdXV1sbGwAAAAbGxvc3Nzk5OQfHx8AAAAAAAB4eHidnZ0HBwcAAAAAAACampry8vJNTU0AAAAAAACPj4/Hx8cXFxcAAAAAAAAAAAAAAAA+Pj79/f16enoDAwMAAAAAAAAAAAAAAACmpqYAAAAiIiLv7++goKAAAAAAAAAAAADw8PBiYmIAAAAAAAAJCQnY2NgAAAAAAABWVlb5+fmMjIwVFRUAAAAAAAC/v79UVFQFBQUAAAAAAAA3Nzf+/v6vr68yMjIAAAAAAAAAAACcnJx5eXkNDQ0AAAAAAAAAAAAAAADp6enLy8tQUFAAAAAAAAAAAAAAAAAAAAAAAAAAAABycnIdHR0AAAAAAAAAAAAAAAAAAAAAAADS0tJzc3MAAADKyso4ODgAAAAAAAAAAAAAAAAKCgrAwMCTk5M0NDQAAAAAAAC2trb19fUAAAAAAAAAAAAvLy+Li4uEhIQICAhlZWX09PTQ0NCIiIgAAAAAAADh4eGHh4f39/fn5+epqamSkpI5OTkmJia4uLgTExOKiopERETGxsbZ2dmnp6dmZmYqKipAQEDU1NSCgoIAAADr6+vg4OCurq4tLS38/PwkJCTa2tqqqqpGRkbW1tZfX19LS0u7u7utra0WFhYAAACGhoYZGRkAAADd3d2NjY0rKyuysrIAAAAAAAA8PDyjo6Pt7e1xcXEAAACXl5cAAAAAAAAAAADMzMwAAAAAAABvb28AAACVlZUAAAAoKCi1tbUAAAC0tLT4+Phqamr7+/t7e3vl5eV2dnYwMDDq6upCQkK8vLx/f39YWFiAgIC6urqYmJgAAAAAAABISEgAAAD8YXZHAAABAHRSTlMAAgQBMTVbYFIZC0Suvd7/5/XRexQGFp2oSiq1/8pCq/r//////Mdz////////IuL//+r/////CIf////3l////x/+////hg9l7f/////mRi/4/yX////zCiz//86L//+aHf////9nYv///7o7/////5ASQP///9TCiHn///+4JE1rOLfv//+CnNjW5X7//w7//6SNPNr/////DVj//+htsv//////////aMD///////////////////////////3///////////////////9w//+U/////1XM/////6H/4F7F/yeR/3j/Sf//8f////////////////////8g1/+gZI+TugAABn5JREFUeAHt1gN4XdkaxvEV1e2/bieNphPnm9ruqW3btjuqbdu2bdu2bV/fO+c0uzpp1053Ht35Pd54sPB+r7LeX/7iolyVm4o67h7RoseIGUtFkdhx4sYjfoKEiRInUVEgaTLCJf9BWc8zBQBeeAHePspyvn4AP6ZM+ZM/BAQqi7kGAQSHhIZJyM8AidyUpVKlBq804pDWC9J5KktFB9JnEIeMmQDfzJberyxAVgmXLTvkiGbpFuQEckm43HmAhHmVhbLYIJ8Y8hcAChZS1ilcBIqKoVjxElCylIuyTOkyQFkxhAV7gW85K+8ZUL6CGCqmh0pBlZVlqvgBP4uharXsUN3HwutWA6hZSwwhwRBQu46yTOLUQF0x1KvfAEo2tDC4GwE0FkNYk6bQrLmyTiDQoqUYWrWGSm3aqq9wK+QSS3+b2gG0F0PuDh2hk7PEcFUOMbLU6Nyla+xYSlNyIP0vYvj1N/D7/Y8vRlOMRm26de+h/uhJLyBdydqp3JSWcgmA3mKoV7YPFOnrqj6WtF//ASRgYOpBncEhQdzYrkrLIMBrsBgyDgE6xbYPjFil1Z/b8UN8bADY/GwABQBsnd2VlqHxgDxiKDZsOPglT6y61RjRP0Wnkd2qjBoNwBgcfhw7Ltd4AO8JSstEgElimJyrI0yZOo1eAIxuNgBg+oy0M1vMAmaLyJy588YA85WeBcD0emJYmAZs1QHwwqHmIlksc5YsbUD2MEeqpAGKJFVaegAsE0OxkD4QALDcfwUAJRxvW8rKJivEIawB2EYqPcmAVWFiqLoagDUha9et37AR2BQeufU2r68qDluArZotIW8vYIN8sG04kFL+tH3Hzuws/WiH5L1du4FpmrEVBPCrGIpNKkHNPeKwdx/7xYmlXoBm38zcCVgjHznAQXmv5drgQ+LMJmBAIaWlG8Bh+SDsyBYJFzo2vzjza0ewHVV6egIrcssHqyvKB1XFqQ1ApZhKizvAMfnIHvmmbceBnErPCaDjSTHnFGArrbTEjA+kEZNOA3E1C+18gBAx50xT4KxmFz4HnBeTDgLx2iotsQEuiDmb/cGWSOmJA/x0Ucy5BOTQ7OSefkBxMSd3H+CyZmPuAmTfL6a0vALgrrS0vQo0EZOCgaOaqXoN4JCYc6Ep9Cuk9FwHgneJKTfKQ3/dqjcKIJeYsr0A9Pp6XiRWN2OlcnTDEcDxJaYv28BuKmIxG/YdEdgzxa1uVYYq9Ucl4LaYEXoJOKoi1DB+fBtgo1LPE90KqTuA11wx4y7QxkU5V6irDUOCeAvuqYHAQTFjbFNIEUs5NzUdQKaa92f5O8pn7UCAM2LCnuMQL6lyKukUwH/Gg8MnDw9Z449h52LRl3EFPPRQTkUvA7sHyy5pKfWGPao7hnD5RF/LNZDgnnKmsi8wr6U4PK466UnHVYBR9PQ83QBbnU8dt4RwZK4YWsrYZ3kaADBbtBXLCiRydZpu18H/uXxi8JVqHfGCYaJt/Sy47Dw+z8Gsz8Pt8ZLNKXePYblo29sUzk1QzozcSsd5FeQLc1+M73hKdO2ZBd4xlROu0YvAywtOe+HdLaJrf3mIN1Q54+kNHMmX0elvouvVcUjXw3lXmZ8QvMbsPrNEvsOu19DLUzmVNFpAADBm+ZvFuySyqq6Brd0ibHRx2QpQbaWESiRVA79GKiJ/9BsAgNfbxsUkUloWB6ZG3BldYyavVAagwLzBVSUy8gE1XFXEJtxLRhmA4YsWVhXzHmSH5N8oX0enJQgA+K3+wnpiVtkScFl9Q+ZEnaYANH13YZ2Yk28WUFB9U7mjnYoAFHg3aY/oe7QRIF1ppaFdQe8EAKfrrtymGxN5sMui2X99+lUPAHj55JHOrZjcG7sEDZWuWPdqjwbIfvpvf5dv+ccq7HK2VSbUudbvKsCq+/Pmytc0bo3dAg9l0j+jx+kFcKTFooi3YuE77FJPVJHg2XCBDaBjnlMtxZliP2O3dZCKnMyjpjYDaNq0bln50oX02I2IqSJt6M2+/QGy+ze58VkI5j+PXeAo9V3auvftBcBP75aEimHJAeymRFffy62QTxY/wIuNL17Je8eaYtclibKAq5qYogjgxf322+V/duzGLk4qZZEkQ7uNLgNQYvzKhXP3YZewlLJS3mv/IgCY9W/sHnZX1nJRHjW8bYS7NUFZzkXl/U+8BAD0rKKiRpIetZv1H3A9hopCHklLqajlpv5P/BduoGi+tj+QeQAAAABJRU5ErkJggg=="
								alt="" />
						</div>
					</div>
					<p>
						<span>Swipe right, left, top or bottom to move the ball</span><br />
					</p>
				</div>

				<p>Tap to start</p>
			</div>
		</div>

		<div class="obj-screen screen-game" id="gameScreen">
			<p><span>Level</span> <span class="level-num">0</span></p>

		</div>

		<div class="obj-screen screen-end-of-level background-before" id="endOfLevelScreen">
			<div>
				<div class="ctn-txt">
					<p><span>Level</span> <span class="level-num">1</span> <br /><span>complete</span></p>
				</div>
				<div class="ctn-svg">

					<svg width="526.5px" height="407.6px" viewBox="0 0 526.5 407.6">
						<use xlink:href="#ink-splash"></use>
					</svg>

				</div>
			</div>
		</div>

		<div class="obj-screen screen-end background-before">
			<div class="v-align-center">
				<img src="data:image/png;base64,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"
					alt="" />

				<h2>NICE GAME</h2>

				<p class="txt">
					<span>First game?</span><br />
					<span>Compete online</span><br />
					<span>Many skins available</span>
				</p>

				<span class="button retry">RETRY</span>
				<p class="or">Or</p>
				<span class="button download">DOWNLOAD</span>
			</div>
		</div>

		<div class="obj-banner">
			<div>
				<img src="data:image/png;base64,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"
					alt="" />
			</div>
			<div>
				<small>Voodoo</small>
				<h1>Roller Splat!</h1>
			</div>
			<div>
				<span class="button download">DOWNLOAD</span>
			</div>
		</div>

		<canvas id="canvas"></canvas>
	</div>


	<script type='text/javascript'>
		window._voodooIOS = "https://itunes.apple.com/fr/app/roller-splat/id1448852425?mt=8";
		window._voodooANDROID = "";


		var _gameplay = {
			difficulty: '',
			maxRetry: Infinity,
			gameMaxDuration: Infinity,
			backgroundTexture: 'data:image/png;base64,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',
			paintDrop: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAD50lEQVR4AWJ0L/BhIAbUhVaqAilrIDYBYh0gVgRicaj0SyC+D8RXgPgMEB9tWt1+mxhzQQ4gZLEDgPMyB+kjiML4c/1730chqAjpSWXfpBQs7BvBOpAyRaoUSRdILdg3FkJKIX1fB9KZzuvvfWR+sD8Yh1k1GfiYY2fe9703s7NvU7WVsJmwFq8rvxMOEvaTkJ//IwDiN6naSdhOWBoYGIihoaEYHBwMQP/x8TEoDw8PcX9/n9eaOUrYS9hNQn7VeJoO8nep+p7wMREtjY6OxuTkZExMTMTY2FgMDw8HYyMjI9Hr9QDiqBUYTdMEwrGBLWy+JEByQv01YQOD4+PjkiEiZmdnY2FhgRrEzMwMoiSWnOiIwBY2sV3y9Sqef+Kg4RHEABF4j2FCb5GAuXd3d/kYc90S2mAd24mjn7bjsIyAe/4BcjwnzBDjIZ677xk0bPhpG4EnYm9vbxW4DgdctS3YIVQsxJghp9ZYF25ubqg75xERRcABVy7AV22btkYgJgq0LXnbcF9fXyPA58K+NVvBPN+QbTjzCGz5qgkWSGKx7fOrqysEdM4pC3OJBFwtZzTtDbeZG9Cz09PTQLUghIyfnZ0BBCBEUuuy5OO54E24e+31usYg4fEVgqzf77PAC4jxPMSKZR3I+7ZFvmVsL1iDu2lPZtUA3gEjYF9IXPYpuSj7ivDMwN20HxYNlCTPjhMlUJtbcci25yDgbtqvGoZ4KKrEkoq6iHqUBMUIwN34Sa0s1HgnKZ50PatFI3eOArdXsYP5IfODwqL8JnRevq9Vj8tzkm+HBYY/dnhYepF7SRvYLsfybbIuhUGuE3A3ZDJ6VBopyWtCRG1eGQXBa02BuyGNUsBLh8x5bAdGuKpBlgtop7reCCgA7qbN4RhkUvWQUYpEoyaOZwozotXzwEVEgbtHAkkOx80EAYu89YAZD23F1HIC4cFEhE7oueQkMHDC3bTZ6wHqST6KCJRbY1tUD5+eYrM8hCY2cMJNi7JPAsn3X+Wl8ZKkixzkr11OToIzNTUVcMHpaxht6ryHMiZQa/Dy8pJI/NNNaJ+vpeRsK9kVNVxwljnhbsLbpHIDwuPjY4zExcUFtRlwuf/VmquWrx7wcM7PzxN+uj/gKlOyaPP2b5xMlJLxGglEnJycgDg/PzcLenJxMcY8cghzBZ4jenFxMbCJbTjgqv6YmJabGUNGJMgL9OS5ZKOIhmk8teSfE/nBS39GpudkyBt4p1d4WKZa9MuUzMM2PT1NBAw7nh++6s+onfg+4UsycMT+ra6uxvLyctD2R4RimCGdm5uLlZUV5jIvWIsNbNXI/24wdk7p3z0HAMehPqT0UnOsAAAAAElFTkSuQmCC',
			tail: 'data:image/png;base64,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',
			endOfLevelParticleColors: [
				'#38ff00',
				'#ff4ef2',
				'#9500ff',
				'#ffff00',
				'#ff0000'
			],
			levels: [{
				paintColor: '#ffff56',
				backgroundColor: '#2ad2ff',
				floorColor: '#bad7eb',
				width: 7,
				height: 7,
				map: [1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1,
					1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1
				]
			}, {
				paintColor: '#42e172',
				backgroundColor: '#ff93ff',
				floorColor: '#bad7eb',
				width: 7,
				height: 7,
				map: [1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 1,
					0, 1, 0, 1, 1, 0, 0, 0, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1
				]
			}, {
				paintColor: '#7813ff',
				backgroundColor: '#67ff7b',
				floorColor: '#bad7eb',
				width: 9,
				height: 10,
				map: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0,
					0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0,
					0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1
				]
			}, {
				paintColor: '#7813ff',
				backgroundColor: '#67ff7b',
				floorColor: '#bad7eb',
				width: 9,
				height: 14,
				map: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0,
					0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0, 1, 1, 1, 0, 0, 1, 0, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0,
					0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1,
					0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 2, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1,
					1, 1, 1, 1, 1
				]
			}]
		}
	</script>
	<script type='text/javascript'>
		! function (i) {
			var n = {};

			function r(t) {
				if (n[t]) return n[t].exports;
				var e = n[t] = {
					i: t,
					l: !1,
					exports: {}
				};
				return i[t].call(e.exports, e, e.exports, r), e.l = !0, e.exports
			}
			r.m = i, r.c = n, r.d = function (t, e, i) {
				r.o(t, e) || Object.defineProperty(t, e, {
					enumerable: !0,
					get: i
				})
			}, r.r = function (t) {
				"undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, {
					value: "Module"
				}), Object.defineProperty(t, "__esModule", {
					value: !0
				})
			}, r.t = function (e, t) {
				if (1 & t && (e = r(e)), 8 & t) return e;
				if (4 & t && "object" == typeof e && e && e.__esModule) return e;
				var i = Object.create(null);
				if (r.r(i), Object.defineProperty(i, "default", {
						enumerable: !0,
						value: e
					}), 2 & t && "string" != typeof e)
					for (var n in e) r.d(i, n, function (t) {
						return e[t]
					}.bind(null, n));
				return i
			}, r.n = function (t) {
				var e = t && t.__esModule ? function () {
					return t.default
				} : function () {
					return t
				};
				return r.d(e, "a", e), e
			}, r.o = function (t, e) {
				return Object.prototype.hasOwnProperty.call(t, e)
			}, r.p = "", r(r.s = 0)
		}([function (t, e, i) {
			"use strict";
			i.r(e);
			var n = i(1);
			window.onload = function () {
				new n.default(_gameplay).launch()
			}
		}, function (t, e, i) {
			"use strict";
			i.r(e);
			var n = i(2);

			function r(t) {
				this._gameOptions = t
			}
			r.prototype = {
				start: function () {
					return window.game || (window.game = new n.default(this._gameOptions)), this
				},
				launch: function () {
					window._voodooExit = function () {}
					this.start();
				},
				mute: function () {}
			}, e.default = r
		}, function (t, e, i) {
			"use strict";
			i.r(e);
			var r = i(3),
				a = i(4),
				o = i(6),
				s = i(7),
				n = i(10),
				c = i(13),
				h = i(14),
				l = i(15);

			function u(t) {
				var e, i = this,
					n = document.getElementById("canvas");
				this._settings = t, this._states = {
						levelIndex: -1,
						retry: 0,
						startTime: performance.now()
					}, this._pointer = {
						isDown: !1,
						start: new r.Vector2,
						move: new r.Vector2
					}, this._renderLoop = new o.default, this._statesManager = new l.default({
						debug: !1,
						states: ["intro", "game", "end of level", "game over", "static"]
					}), this._renderer = new r.WebGLRenderer({
						canvas: n,
						context: n.getContext("webgl"),
						antialias: !0
					}), this._renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)), this._scene = new r.Scene,
					this._interface = new a.default({
						onResize: v.bind(this),
						onClickStartScreen: function () {
							i._interface.switchScreen("start", "game"), i._statesManager.set("game")
						},
						onClickRetry: function (t) {
							t.preventDefault(), t.stopPropagation(), i._states.retry <= i._settings
								.maxRetry && (performance.now() - i._states.startTime) / 1e3 < i._settings
								.gameMaxDuration ? (i._states.retry++, i.resetGame(), i._interface
									.switchScreen("end", "start")) : _voodooExit()
						}
					}), e = this._interface.getEvents(), this._objects = {
						camera: new c.default,
						dirLight: new r.DirectionalLight(16777215, 1),
						ambLight: new r.AmbientLight(16777215, .6),
						background: new s.default({
							color: "#64ff8b",
							map: this._settings.backgroundTexture
						}),
						level: null,
						ball: new h.default({
							tail: this._settings.tail
						})
					}, this._objects.dirLight.position.set(-8, 8, 4), this._objects.dirLight.shadow.camera.left = -
					100, this._objects.dirLight.shadow.camera.right = 100, this._objects.dirLight.shadow.camera
					.bottom = -100, this._objects.dirLight.shadow.camera.top = 100, this._scene.add(this._objects
						.dirLight, this._objects.ambLight, this._objects.background.getObject(), this._objects.ball
						.getObject(), this._objects.camera.getObject()), n.addEventListener(e.pointerdown, d.bind(
						this)), n.addEventListener(e.pointermove, f.bind(this)), n.addEventListener(e.pointerup, m
						.bind(this)), document.addEventListener("keyup", g.bind(this)), this.initializeGame(), this
					._interface.switchScreen("loading", "start")
			}
			u.prototype = {
				resetGame: function () {
					return this._states.levelIndex = -1, this.initLevel(), this
				},
				initializeGame: function () {
					return this._interface.triggerResize(), this.initLevel(), this.startRender(), this
				},
				hasNextLevel: function () {
					return !!this._settings.levels[this._states.levelIndex + 1]
				},
				initLevel: function () {
					var t;
					return this._objects.level && this._scene.remove(this._objects.level.getObject()), this
						._states.levelIndex++, t = this._settings.levels[this._states.levelIndex], this
						._objects.level = new n.default(Object.assign({}, t, {
							paintDrop: this._settings.paintDrop,
							particleColors: this._settings.endOfLevelParticleColors
						})), this._objects.ball.setPosition(this._objects.level.getStartPosition()).setColor(t
							.paintColor), this._objects.background.setColor(t.backgroundColor), this
						._interface.setLevel(this._states.levelIndex + 1).setSplashColor(t.paintColor), this
						._scene.add(this._objects.level.getObject()), this._objects.camera.setDistance(this
							._objects.level.getWidth(), this._objects.level.getHeight(), this._objects.level
							.getRadius()), this
				},
				startRender: function () {
					var i = this,
						n = this._renderer,
						r = this._scene,
						a = this._statesManager,
						o = (this._interface, this._settings, this._objects.background),
						s = this._objects.camera;
					return this._renderLoop.start(function (t, e) {
						o.update(t, e), a.is("game") && i._objects.ball.update(t, e), i._objects.level
							.update(t, e), s.update(t, e), n.render(r, s.getCamera())
					}), this
				},
				stopRender: function () {
					return this._renderLoop.stop(), this
				},
				goto: function (t) {
					var e = this,
						i = this._objects.ball,
						n = this._objects.level;
					return i.moveTo(n.getNextPosition(i.getPosition(), t), t, {
						onUpdate: function (t) {
							n.controlPlayerPosition(i.getPosition())
						},
						onComplete: function () {
							n.controlLine(), n.isFinish() && (e._statesManager.set(
								"end of level"), e._interface.switchScreen("game",
									"end of level"), setTimeout(function () {
									e.hasNextLevel() ? (e.initLevel(), e._interface
										.switchScreen("end of level", "game"), e
										._statesManager.set("game")) : (e._interface
										.switchScreen("end of level", "end"), e
										._statesManager.set("game over"))
								}, 2e3))
						}
					}), this
				}
			};
			var p = function (t) {
				return (p = t.touches ? function (t, e) {
					return e && t.preventDefault(), t.touches[0]
				} : function (t, e) {
					return e && t.preventDefault(), t
				})(t)
			};

			function d(t) {
				t = p(t);
				var e = this._pointer;
				e.isDown = !0, e.start.set(t.clientX, t.clientY), e.move.set(t.clientX, t.clientY)
			}

			function f(t) {
				t = p(t, !0);
				var e = this._objects.ball,
					i = this._pointer,
					n = 50;
				i.isDown && (i.move.set(t.clientX, t.clientY), e.isMoving() ? i.start.set(t.clientX, t.clientY) : i
					.move.x - i.start.x > n ? this.goto("right") : i.move.x - i.start.x < -n ? this.goto("left") :
					i.move.y - i.start.y > n ? this.goto("bottom") : i.move.y - i.start.y < -n && this.goto("top")
					)
			}

			function m(t) {
				t = p(t), this._pointer.isDown = !1
			}

			function g(t) {
				this._objects.ball.isMoving() || (37 === t.which ? this.goto("left") : 38 === t.which ? this.goto(
					"top") : 39 === t.which ? this.goto("right") : 40 === t.which && this.goto("bottom"))
			}

			function v(t, e, i) {
				this._objects.camera.updateCamera(e, i), this._renderer.setSize(e, i)
			}
			e.default = u
		}, function (t, e, i) {
			(function (t) {
				"use strict";

				function e() {}
				void 0 === Number.EPSILON && (Number.EPSILON = Math.pow(2, -52)), void 0 === Number.isInteger && (
					Number.isInteger = function (t) {
						return "number" == typeof t && isFinite(t) && Math.floor(t) === t
					}), void 0 === Math.sign && (Math.sign = function (t) {
					return t < 0 ? -1 : 0 < t ? 1 : +t
				}), "name" in Function.prototype == !1 && Object.defineProperty(Function.prototype, "name", {
					get: function () {
						return this.toString().match(/^\s*function\s*([^\(\s]*)/)[1]
					}
				}), void 0 === Object.assign && (Object.assign = function (t) {
					if (null == t) throw new TypeError("Cannot convert undefined or null to object");
					for (var e = Object(t), i = 1; i < arguments.length; i++) {
						var n = arguments[i];
						if (null != n)
							for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r])
					}
					return e
				}), Object.assign(e.prototype, {
					addEventListener: function (t, e) {
						void 0 === this._listeners && (this._listeners = {});
						var i = this._listeners;
						void 0 === i[t] && (i[t] = []), -1 === i[t].indexOf(e) && i[t].push(e)
					},
					hasEventListener: function (t, e) {
						if (void 0 === this._listeners) return !1;
						var i = this._listeners;
						return void 0 !== i[t] && -1 !== i[t].indexOf(e)
					},
					removeEventListener: function (t, e) {
						if (void 0 !== this._listeners) {
							var i = this._listeners[t];
							if (void 0 !== i) {
								var n = i.indexOf(e); - 1 !== n && i.splice(n, 1)
							}
						}
					},
					dispatchEvent: function (t) {
						if (void 0 !== this._listeners) {
							var e = this._listeners[t.type];
							if (void 0 !== e) {
								t.target = this;
								for (var i = e.slice(0), n = 0, r = i.length; n < r; n++) i[n].call(
									this, t)
							}
						}
					}
				});
				var i, n, l, u, r, a, o, s, c, h, p, d, f, m, g, v, y, x, b, w, _, M, S, Ht = "100",
					E = {
						LEFT: 0,
						MIDDLE: 1,
						RIGHT: 2
					},
					lt = 0,
					ut = 1,
					pt = 2,
					T = 3,
					A = 0,
					L = 1,
					P = 0,
					B = 1,
					I = 2,
					N = 0,
					kt = 1,
					dt = 2,
					C = 1,
					R = 2,
					O = 0,
					D = 1,
					z = 2,
					ft = 0,
					mt = 1,
					gt = 2,
					vt = 3,
					yt = 4,
					xt = 5,
					bt = 100,
					U = 101,
					G = 102,
					F = 103,
					H = 104,
					k = 200,
					j = 201,
					V = 202,
					W = 203,
					q = 204,
					X = 205,
					Y = 206,
					J = 207,
					Z = 208,
					Q = 209,
					K = 210,
					wt = 0,
					_t = 1,
					Mt = 2,
					St = 3,
					Et = 4,
					Tt = 5,
					At = 6,
					Lt = 7,
					$ = 0,
					tt = 1,
					et = 2,
					it = 0,
					jt = 1,
					nt = 2,
					rt = 3,
					at = 4,
					ot = 5,
					st = 300,
					ct = 301,
					ht = 302,
					Pt = 303,
					Ct = 304,
					Rt = 305,
					Ot = 306,
					It = 307,
					Dt = 1e3,
					Bt = 1001,
					Nt = 1002,
					zt = 1003,
					Ut = 1004,
					Gt = 1005,
					Ft = 1006,
					Vt = 1007,
					Wt = 1008,
					qt = 1009,
					Xt = 1010,
					Yt = 1011,
					Jt = 1012,
					Zt = 1013,
					Qt = 1014,
					Kt = 1015,
					$t = 1016,
					te = 1017,
					ee = 1018,
					ie = 1019,
					ne = 1020,
					re = 1021,
					ae = 1022,
					oe = 1023,
					se = 1024,
					ce = 1025,
					he = oe,
					le = 1026,
					ue = 1027,
					pe = 1028,
					de = 33776,
					fe = 33777,
					me = 33778,
					ge = 33779,
					ve = 35840,
					ye = 35841,
					xe = 35842,
					be = 35843,
					we = 36196,
					_e = 37808,
					Me = 37809,
					Se = 37810,
					Ee = 37811,
					Te = 37812,
					Ae = 37813,
					Le = 37814,
					Pe = 37815,
					Ce = 37816,
					Re = 37817,
					Oe = 37818,
					Ie = 37819,
					De = 37820,
					Be = 37821,
					Ne = 2200,
					ze = 2201,
					Ue = 2202,
					Ge = 2300,
					Fe = 2301,
					He = 2302,
					ke = 2400,
					je = 2401,
					Ve = 2402,
					We = 0,
					qe = 1,
					Xe = 2,
					Ye = 3e3,
					Je = 3001,
					Ze = 3007,
					Qe = 3002,
					Ke = 3003,
					$e = 3004,
					ti = 3005,
					ei = 3006,
					ii = 3200,
					ni = 3201,
					ri = 0,
					ai = 1,
					oi = {
						DEG2RAD: Math.PI / 180,
						RAD2DEG: 180 / Math.PI,
						generateUUID: function () {
							for (var r = [], t = 0; t < 256; t++) r[t] = (t < 16 ? "0" : "") + t.toString(16);
							return function () {
								var t = 4294967295 * Math.random() | 0,
									e = 4294967295 * Math.random() | 0,
									i = 4294967295 * Math.random() | 0,
									n = 4294967295 * Math.random() | 0;
								return (r[255 & t] + r[t >> 8 & 255] + r[t >> 16 & 255] + r[t >> 24 &
										255] + "-" + r[255 & e] + r[e >> 8 & 255] + "-" + r[e >> 16 & 15 |
											64] + r[e >> 24 & 255] + "-" + r[63 & i | 128] + r[i >> 8 &
											255] + "-" + r[i >> 16 & 255] + r[i >> 24 & 255] + r[255 &
										n] + r[n >> 8 & 255] + r[n >> 16 & 255] + r[n >> 24 & 255])
									.toUpperCase()
							}
						}(),
						clamp: function (t, e, i) {
							return Math.max(e, Math.min(i, t))
						},
						euclideanModulo: function (t, e) {
							return (t % e + e) % e
						},
						mapLinear: function (t, e, i, n, r) {
							return n + (t - e) * (r - n) / (i - e)
						},
						lerp: function (t, e, i) {
							return (1 - i) * t + i * e
						},
						smoothstep: function (t, e, i) {
							return t <= e ? 0 : i <= t ? 1 : (t = (t - e) / (i - e)) * t * (3 - 2 * t)
						},
						smootherstep: function (t, e, i) {
							return t <= e ? 0 : i <= t ? 1 : (t = (t - e) / (i - e)) * t * t * (t * (6 * t -
								15) + 10)
						},
						randInt: function (t, e) {
							return t + Math.floor(Math.random() * (e - t + 1))
						},
						randFloat: function (t, e) {
							return t + Math.random() * (e - t)
						},
						randFloatSpread: function (t) {
							return t * (.5 - Math.random())
						},
						degToRad: function (t) {
							return t * oi.DEG2RAD
						},
						radToDeg: function (t) {
							return t * oi.RAD2DEG
						},
						isPowerOfTwo: function (t) {
							return 0 == (t & t - 1) && 0 !== t
						},
						ceilPowerOfTwo: function (t) {
							return Math.pow(2, Math.ceil(Math.log(t) / Math.LN2))
						},
						floorPowerOfTwo: function (t) {
							return Math.pow(2, Math.floor(Math.log(t) / Math.LN2))
						}
					};

				function si(t, e) {
					this.x = t || 0, this.y = e || 0
				}

				function ci() {
					this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], 0 < arguments.length &&
						console.error(
							"THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")
				}

				function hi(t, e, i, n) {
					this._x = t || 0, this._y = e || 0, this._z = i || 0, this._w = void 0 !== n ? n : 1
				}

				function li(t, e, i) {
					this.x = t || 0, this.y = e || 0, this.z = i || 0
				}

				function ui() {
					this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1], 0 < arguments.length && console.error(
						"THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")
				}
				Object.defineProperties(si.prototype, {
					width: {
						get: function () {
							return this.x
						},
						set: function (t) {
							this.x = t
						}
					},
					height: {
						get: function () {
							return this.y
						},
						set: function (t) {
							this.y = t
						}
					}
				}), Object.assign(si.prototype, {
					isVector2: !0,
					set: function (t, e) {
						return this.x = t, this.y = e, this
					},
					setScalar: function (t) {
						return this.x = t, this.y = t, this
					},
					setX: function (t) {
						return this.x = t, this
					},
					setY: function (t) {
						return this.y = t, this
					},
					setComponent: function (t, e) {
						switch (t) {
							case 0:
								this.x = e;
								break;
							case 1:
								this.y = e;
								break;
							default:
								throw new Error("index is out of range: " + t)
						}
						return this
					},
					getComponent: function (t) {
						switch (t) {
							case 0:
								return this.x;
							case 1:
								return this.y;
							default:
								throw new Error("index is out of range: " + t)
						}
					},
					clone: function () {
						return new this.constructor(this.x, this.y)
					},
					copy: function (t) {
						return this.x = t.x, this.y = t.y, this
					},
					add: function (t, e) {
						return void 0 !== e ? (console.warn(
							"THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."
							), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this)
					},
					addScalar: function (t) {
						return this.x += t, this.y += t, this
					},
					addVectors: function (t, e) {
						return this.x = t.x + e.x, this.y = t.y + e.y, this
					},
					addScaledVector: function (t, e) {
						return this.x += t.x * e, this.y += t.y * e, this
					},
					sub: function (t, e) {
						return void 0 !== e ? (console.warn(
							"THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."
							), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this)
					},
					subScalar: function (t) {
						return this.x -= t, this.y -= t, this
					},
					subVectors: function (t, e) {
						return this.x = t.x - e.x, this.y = t.y - e.y, this
					},
					multiply: function (t) {
						return this.x *= t.x, this.y *= t.y, this
					},
					multiplyScalar: function (t) {
						return this.x *= t, this.y *= t, this
					},
					divide: function (t) {
						return this.x /= t.x, this.y /= t.y, this
					},
					divideScalar: function (t) {
						return this.multiplyScalar(1 / t)
					},
					applyMatrix3: function (t) {
						var e = this.x,
							i = this.y,
							n = t.elements;
						return this.x = n[0] * e + n[3] * i + n[6], this.y = n[1] * e + n[4] * i + n[
							7], this
					},
					min: function (t) {
						return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this
					},
					max: function (t) {
						return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this
					},
					clamp: function (t, e) {
						return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y,
							Math.min(e.y, this.y)), this
					},
					clampScalar: (i = new si, n = new si, function (t, e) {
						return i.set(t, t), n.set(e, e), this.clamp(i, n)
					}),
					clampLength: function (t, e) {
						var i = this.length();
						return this.divideScalar(i || 1).multiplyScalar(Math.max(t, Math.min(e, i)))
					},
					floor: function () {
						return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this
					},
					ceil: function () {
						return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this
					},
					round: function () {
						return this.x = Math.round(this.x), this.y = Math.round(this.y), this
					},
					roundToZero: function () {
						return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y =
							this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this
					},
					negate: function () {
						return this.x = -this.x, this.y = -this.y, this
					},
					dot: function (t) {
						return this.x * t.x + this.y * t.y
					},
					cross: function (t) {
						return this.x * t.y - this.y * t.x
					},
					lengthSq: function () {
						return this.x * this.x + this.y * this.y
					},
					length: function () {
						return Math.sqrt(this.x * this.x + this.y * this.y)
					},
					manhattanLength: function () {
						return Math.abs(this.x) + Math.abs(this.y)
					},
					normalize: function () {
						return this.divideScalar(this.length() || 1)
					},
					angle: function () {
						var t = Math.atan2(this.y, this.x);
						return t < 0 && (t += 2 * Math.PI), t
					},
					distanceTo: function (t) {
						return Math.sqrt(this.distanceToSquared(t))
					},
					distanceToSquared: function (t) {
						var e = this.x - t.x,
							i = this.y - t.y;
						return e * e + i * i
					},
					manhattanDistanceTo: function (t) {
						return Math.abs(this.x - t.x) + Math.abs(this.y - t.y)
					},
					setLength: function (t) {
						return this.normalize().multiplyScalar(t)
					},
					lerp: function (t, e) {
						return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this
					},
					lerpVectors: function (t, e, i) {
						return this.subVectors(e, t).multiplyScalar(i).add(t)
					},
					equals: function (t) {
						return t.x === this.x && t.y === this.y
					},
					fromArray: function (t, e) {
						return void 0 === e && (e = 0), this.x = t[e], this.y = t[e + 1], this
					},
					toArray: function (t, e) {
						return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this.x, t[e +
							1] = this.y, t
					},
					fromBufferAttribute: function (t, e, i) {
						return void 0 !== i && console.warn(
								"THREE.Vector2: offset has been removed from .fromBufferAttribute()."
								), this.x = t.getX(e), this.y = t.getY(e), this
					},
					rotateAround: function (t, e) {
						var i = Math.cos(e),
							n = Math.sin(e),
							r = this.x - t.x,
							a = this.y - t.y;
						return this.x = r * i - a * n + t.x, this.y = r * n + a * i + t.y, this
					}
				}), Object.assign(ci.prototype, {
					isMatrix4: !0,
					set: function (t, e, i, n, r, a, o, s, c, h, l, u, p, d, f, m) {
						var g = this.elements;
						return g[0] = t, g[4] = e, g[8] = i, g[12] = n, g[1] = r, g[5] = a, g[9] = o,
							g[13] = s, g[2] = c, g[6] = h, g[10] = l, g[14] = u, g[3] = p, g[7] = d,
							g[11] = f, g[15] = m, this
					},
					identity: function () {
						return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
					},
					clone: function () {
						return (new ci).fromArray(this.elements)
					},
					copy: function (t) {
						var e = this.elements,
							i = t.elements;
						return e[0] = i[0], e[1] = i[1], e[2] = i[2], e[3] = i[3], e[4] = i[4], e[5] =
							i[5], e[6] = i[6], e[7] = i[7], e[8] = i[8], e[9] = i[9], e[10] = i[10],
							e[11] = i[11], e[12] = i[12], e[13] = i[13], e[14] = i[14], e[15] = i[15],
							this
					},
					copyPosition: function (t) {
						var e = this.elements,
							i = t.elements;
						return e[12] = i[12], e[13] = i[13], e[14] = i[14], this
					},
					extractBasis: function (t, e, i) {
						return t.setFromMatrixColumn(this, 0), e.setFromMatrixColumn(this, 1), i
							.setFromMatrixColumn(this, 2), this
					},
					makeBasis: function (t, e, i) {
						return this.set(t.x, e.x, i.x, 0, t.y, e.y, i.y, 0, t.z, e.z, i.z, 0, 0, 0, 0,
							1), this
					},
					extractRotation: (p = new li, function (t) {
						var e = this.elements,
							i = t.elements,
							n = 1 / p.setFromMatrixColumn(t, 0).length(),
							r = 1 / p.setFromMatrixColumn(t, 1).length(),
							a = 1 / p.setFromMatrixColumn(t, 2).length();
						return e[0] = i[0] * n, e[1] = i[1] * n, e[2] = i[2] * n, e[3] = 0, e[4] =
							i[4] * r, e[5] = i[5] * r, e[6] = i[6] * r, e[7] = 0, e[8] = i[8] * a,
							e[9] = i[9] * a, e[10] = i[10] * a, e[11] = 0, e[12] = 0, e[13] = 0,
							e[14] = 0, e[15] = 1, this
					}),
					makeRotationFromEuler: function (t) {
						t && t.isEuler || console.error(
							"THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order."
							);
						var e = this.elements,
							i = t.x,
							n = t.y,
							r = t.z,
							a = Math.cos(i),
							o = Math.sin(i),
							s = Math.cos(n),
							c = Math.sin(n),
							h = Math.cos(r),
							l = Math.sin(r);
						if ("XYZ" === t.order) {
							var u = a * h,
								p = a * l,
								d = o * h,
								f = o * l;
							e[0] = s * h, e[4] = -s * l, e[8] = c, e[1] = p + d * c, e[5] = u - f * c,
								e[9] = -o * s, e[2] = f - u * c, e[6] = d + p * c, e[10] = a * s
						} else if ("YXZ" === t.order) {
							var m = s * h,
								g = s * l,
								v = c * h,
								y = c * l;
							e[0] = m + y * o, e[4] = v * o - g, e[8] = a * c, e[1] = a * l, e[5] = a *
								h, e[9] = -o, e[2] = g * o - v, e[6] = y + m * o, e[10] = a * s
						} else if ("ZXY" === t.order) {
							m = s * h, g = s * l, v = c * h, y = c * l;
							e[0] = m - y * o, e[4] = -a * l, e[8] = v + g * o, e[1] = g + v * o, e[
								5] = a * h, e[9] = y - m * o, e[2] = -a * c, e[6] = o, e[10] = a * s
						} else if ("ZYX" === t.order) {
							u = a * h, p = a * l, d = o * h, f = o * l;
							e[0] = s * h, e[4] = d * c - p, e[8] = u * c + f, e[1] = s * l, e[5] = f *
								c + u, e[9] = p * c - d, e[2] = -c, e[6] = o * s, e[10] = a * s
						} else if ("YZX" === t.order) {
							var x = a * s,
								b = a * c,
								w = o * s,
								_ = o * c;
							e[0] = s * h, e[4] = _ - x * l, e[8] = w * l + b, e[1] = l, e[5] = a * h,
								e[9] = -o * h, e[2] = -c * h, e[6] = b * l + w, e[10] = x - _ * l
						} else if ("XZY" === t.order) {
							x = a * s, b = a * c, w = o * s, _ = o * c;
							e[0] = s * h, e[4] = -l, e[8] = c * h, e[1] = x * l + _, e[5] = a * h, e[
								9] = b * l - w, e[2] = w * l - b, e[6] = o * h, e[10] = _ * l + x
						}
						return e[3] = 0, e[7] = 0, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] =
							1, this
					},
					makeRotationFromQuaternion: (c = new li(0, 0, 0), h = new li(1, 1, 1), function (t) {
						return this.compose(c, t, h)
					}),
					lookAt: (a = new li, o = new li, s = new li, function (t, e, i) {
						var n = this.elements;
						return s.subVectors(t, e), 0 === s.lengthSq() && (s.z = 1), s.normalize(),
							a.crossVectors(i, s), 0 === a.lengthSq() && (1 === Math.abs(i.z) ? s
								.x += 1e-4 : s.z += 1e-4, s.normalize(), a.crossVectors(i, s)), a
							.normalize(), o.crossVectors(s, a), n[0] = a.x, n[4] = o.x, n[8] = s
							.x, n[1] = a.y, n[5] = o.y, n[9] = s.y, n[2] = a.z, n[6] = o.z, n[
							10] = s.z, this
					}),
					multiply: function (t, e) {
						return void 0 !== e ? (console.warn(
							"THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."
							), this.multiplyMatrices(t, e)) : this.multiplyMatrices(this, t)
					},
					premultiply: function (t) {
						return this.multiplyMatrices(t, this)
					},
					multiplyMatrices: function (t, e) {
						var i = t.elements,
							n = e.elements,
							r = this.elements,
							a = i[0],
							o = i[4],
							s = i[8],
							c = i[12],
							h = i[1],
							l = i[5],
							u = i[9],
							p = i[13],
							d = i[2],
							f = i[6],
							m = i[10],
							g = i[14],
							v = i[3],
							y = i[7],
							x = i[11],
							b = i[15],
							w = n[0],
							_ = n[4],
							M = n[8],
							S = n[12],
							E = n[1],
							T = n[5],
							A = n[9],
							L = n[13],
							P = n[2],
							C = n[6],
							R = n[10],
							O = n[14],
							I = n[3],
							D = n[7],
							B = n[11],
							N = n[15];
						return r[0] = a * w + o * E + s * P + c * I, r[4] = a * _ + o * T + s * C +
							c * D, r[8] = a * M + o * A + s * R + c * B, r[12] = a * S + o * L + s *
							O + c * N, r[1] = h * w + l * E + u * P + p * I, r[5] = h * _ + l * T +
							u * C + p * D, r[9] = h * M + l * A + u * R + p * B, r[13] = h * S + l *
							L + u * O + p * N, r[2] = d * w + f * E + m * P + g * I, r[6] = d * _ +
							f * T + m * C + g * D, r[10] = d * M + f * A + m * R + g * B, r[14] = d *
							S + f * L + m * O + g * N, r[3] = v * w + y * E + x * P + b * I, r[7] =
							v * _ + y * T + x * C + b * D, r[11] = v * M + y * A + x * R + b * B, r[
								15] = v * S + y * L + x * O + b * N, this
					},
					multiplyScalar: function (t) {
						var e = this.elements;
						return e[0] *= t, e[4] *= t, e[8] *= t, e[12] *= t, e[1] *= t, e[5] *= t, e[
							9] *= t, e[13] *= t, e[2] *= t, e[6] *= t, e[10] *= t, e[14] *= t, e[3] *=
							t, e[7] *= t, e[11] *= t, e[15] *= t, this
					},
					applyToBufferAttribute: (r = new li, function (t) {
						for (var e = 0, i = t.count; e < i; e++) r.x = t.getX(e), r.y = t.getY(e),
							r.z = t.getZ(e), r.applyMatrix4(this), t.setXYZ(e, r.x, r.y, r.z);
						return t
					}),
					determinant: function () {
						var t = this.elements,
							e = t[0],
							i = t[4],
							n = t[8],
							r = t[12],
							a = t[1],
							o = t[5],
							s = t[9],
							c = t[13],
							h = t[2],
							l = t[6],
							u = t[10],
							p = t[14];
						return t[3] * (+r * s * l - n * c * l - r * o * u + i * c * u + n * o * p -
							i * s * p) + t[7] * (+e * s * p - e * c * u + r * a * u - n * a * p +
							n * c * h - r * s * h) + t[11] * (+e * c * l - e * o * p - r * a * l +
							i * a * p + r * o * h - i * c * h) + t[15] * (-n * o * h - e * s * l +
							e * o * u + n * a * l - i * a * u + i * s * h)
					},
					transpose: function () {
						var t, e = this.elements;
						return t = e[1], e[1] = e[4], e[4] = t, t = e[2], e[2] = e[8], e[8] = t, t =
							e[6], e[6] = e[9], e[9] = t, t = e[3], e[3] = e[12], e[12] = t, t = e[7],
							e[7] = e[13], e[13] = t, t = e[11], e[11] = e[14], e[14] = t, this
					},
					setPosition: function (t) {
						var e = this.elements;
						return e[12] = t.x, e[13] = t.y, e[14] = t.z, this
					},
					getInverse: function (t, e) {
						var i = this.elements,
							n = t.elements,
							r = n[0],
							a = n[1],
							o = n[2],
							s = n[3],
							c = n[4],
							h = n[5],
							l = n[6],
							u = n[7],
							p = n[8],
							d = n[9],
							f = n[10],
							m = n[11],
							g = n[12],
							v = n[13],
							y = n[14],
							x = n[15],
							b = d * y * u - v * f * u + v * l * m - h * y * m - d * l * x + h * f * x,
							w = g * f * u - p * y * u - g * l * m + c * y * m + p * l * x - c * f * x,
							_ = p * v * u - g * d * u + g * h * m - c * v * m - p * h * x + c * d * x,
							M = g * d * l - p * v * l - g * h * f + c * v * f + p * h * y - c * d * y,
							S = r * b + a * w + o * _ + s * M;
						if (0 === S) {
							var E =
								"THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0";
							if (!0 === e) throw new Error(E);
							return console.warn(E), this.identity()
						}
						var T = 1 / S;
						return i[0] = b * T, i[1] = (v * f * s - d * y * s - v * o * m + a * y * m +
								d * o * x - a * f * x) * T, i[2] = (h * y * s - v * l * s + v * o *
								u - a * y * u - h * o * x + a * l * x) * T, i[3] = (d * l * s - h *
								f * s - d * o * u + a * f * u + h * o * m - a * l * m) * T, i[4] = w *
							T, i[5] = (p * y * s - g * f * s + g * o * m - r * y * m - p * o * x + r *
								f * x) * T, i[6] = (g * l * s - c * y * s - g * o * u + r * y * u +
								c * o * x - r * l * x) * T, i[7] = (c * f * s - p * l * s + p * o *
								u - r * f * u - c * o * m + r * l * m) * T, i[8] = _ * T, i[9] = (g *
								d * s - p * v * s - g * a * m + r * v * m + p * a * x - r * d * x) *
							T, i[10] = (c * v * s - g * h * s + g * a * u - r * v * u - c * a * x +
								r * h * x) * T, i[11] = (p * h * s - c * d * s - p * a * u + r * d *
								u + c * a * m - r * h * m) * T, i[12] = M * T, i[13] = (p * v * o -
								g * d * o + g * a * f - r * v * f - p * a * y + r * d * y) * T, i[
							14] = (g * h * o - c * v * o - g * a * l + r * v * l + c * a * y - r * h *
								y) * T, i[15] = (c * d * o - p * h * o + p * a * l - r * d * l - c *
								a * f + r * h * f) * T, this
					},
					scale: function (t) {
						var e = this.elements,
							i = t.x,
							n = t.y,
							r = t.z;
						return e[0] *= i, e[4] *= n, e[8] *= r, e[1] *= i, e[5] *= n, e[9] *= r, e[
							2] *= i, e[6] *= n, e[10] *= r, e[3] *= i, e[7] *= n, e[11] *= r, this
					},
					getMaxScaleOnAxis: function () {
						var t = this.elements,
							e = t[0] * t[0] + t[1] * t[1] + t[2] * t[2],
							i = t[4] * t[4] + t[5] * t[5] + t[6] * t[6],
							n = t[8] * t[8] + t[9] * t[9] + t[10] * t[10];
						return Math.sqrt(Math.max(e, i, n))
					},
					makeTranslation: function (t, e, i) {
						return this.set(1, 0, 0, t, 0, 1, 0, e, 0, 0, 1, i, 0, 0, 0, 1), this
					},
					makeRotationX: function (t) {
						var e = Math.cos(t),
							i = Math.sin(t);
						return this.set(1, 0, 0, 0, 0, e, -i, 0, 0, i, e, 0, 0, 0, 0, 1), this
					},
					makeRotationY: function (t) {
						var e = Math.cos(t),
							i = Math.sin(t);
						return this.set(e, 0, i, 0, 0, 1, 0, 0, -i, 0, e, 0, 0, 0, 0, 1), this
					},
					makeRotationZ: function (t) {
						var e = Math.cos(t),
							i = Math.sin(t);
						return this.set(e, -i, 0, 0, i, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
					},
					makeRotationAxis: function (t, e) {
						var i = Math.cos(e),
							n = Math.sin(e),
							r = 1 - i,
							a = t.x,
							o = t.y,
							s = t.z,
							c = r * a,
							h = r * o;
						return this.set(c * a + i, c * o - n * s, c * s + n * o, 0, c * o + n * s, h *
							o + i, h * s - n * a, 0, c * s - n * o, h * s + n * a, r * s * s + i,
							0, 0, 0, 0, 1), this
					},
					makeScale: function (t, e, i) {
						return this.set(t, 0, 0, 0, 0, e, 0, 0, 0, 0, i, 0, 0, 0, 0, 1), this
					},
					makeShear: function (t, e, i) {
						return this.set(1, e, i, 0, t, 1, i, 0, t, e, 1, 0, 0, 0, 0, 1), this
					},
					compose: function (t, e, i) {
						var n = this.elements,
							r = e._x,
							a = e._y,
							o = e._z,
							s = e._w,
							c = r + r,
							h = a + a,
							l = o + o,
							u = r * c,
							p = r * h,
							d = r * l,
							f = a * h,
							m = a * l,
							g = o * l,
							v = s * c,
							y = s * h,
							x = s * l,
							b = i.x,
							w = i.y,
							_ = i.z;
						return n[0] = (1 - (f + g)) * b, n[1] = (p + x) * b, n[2] = (d - y) * b, n[
							3] = 0, n[4] = (p - x) * w, n[5] = (1 - (u + g)) * w, n[6] = (m + v) * w,
							n[7] = 0, n[8] = (d + y) * _, n[9] = (m - v) * _, n[10] = (1 - (u + f)) *
							_, n[11] = 0, n[12] = t.x, n[13] = t.y, n[14] = t.z, n[15] = 1, this
					},
					decompose: (l = new li, u = new ci, function (t, e, i) {
						var n = this.elements,
							r = l.set(n[0], n[1], n[2]).length(),
							a = l.set(n[4], n[5], n[6]).length(),
							o = l.set(n[8], n[9], n[10]).length();
						this.determinant() < 0 && (r = -r), t.x = n[12], t.y = n[13], t.z = n[14],
							u.copy(this);
						var s = 1 / r,
							c = 1 / a,
							h = 1 / o;
						return u.elements[0] *= s, u.elements[1] *= s, u.elements[2] *= s, u
							.elements[4] *= c, u.elements[5] *= c, u.elements[6] *= c, u.elements[
								8] *= h, u.elements[9] *= h, u.elements[10] *= h, e
							.setFromRotationMatrix(u), i.x = r, i.y = a, i.z = o, this
					}),
					makePerspective: function (t, e, i, n, r, a) {
						void 0 === a && console.warn(
							"THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs."
							);
						var o = this.elements,
							s = 2 * r / (e - t),
							c = 2 * r / (i - n),
							h = (e + t) / (e - t),
							l = (i + n) / (i - n),
							u = -(a + r) / (a - r),
							p = -2 * a * r / (a - r);
						return o[0] = s, o[4] = 0, o[8] = h, o[12] = 0, o[1] = 0, o[5] = c, o[9] = l,
							o[13] = 0, o[2] = 0, o[6] = 0, o[10] = u, o[14] = p, o[3] = 0, o[7] = 0,
							o[11] = -1, o[15] = 0, this
					},
					makeOrthographic: function (t, e, i, n, r, a) {
						var o = this.elements,
							s = 1 / (e - t),
							c = 1 / (i - n),
							h = 1 / (a - r),
							l = (e + t) * s,
							u = (i + n) * c,
							p = (a + r) * h;
						return o[0] = 2 * s, o[4] = 0, o[8] = 0, o[12] = -l, o[1] = 0, o[5] = 2 * c,
							o[9] = 0, o[13] = -u, o[2] = 0, o[6] = 0, o[10] = -2 * h, o[14] = -p, o[
							3] = 0, o[7] = 0, o[11] = 0, o[15] = 1, this
					},
					equals: function (t) {
						for (var e = this.elements, i = t.elements, n = 0; n < 16; n++)
							if (e[n] !== i[n]) return !1;
						return !0
					},
					fromArray: function (t, e) {
						void 0 === e && (e = 0);
						for (var i = 0; i < 16; i++) this.elements[i] = t[i + e];
						return this
					},
					toArray: function (t, e) {
						void 0 === t && (t = []), void 0 === e && (e = 0);
						var i = this.elements;
						return t[e] = i[0], t[e + 1] = i[1], t[e + 2] = i[2], t[e + 3] = i[3], t[e +
								4] = i[4], t[e + 5] = i[5], t[e + 6] = i[6], t[e + 7] = i[7], t[e +
							8] = i[8], t[e + 9] = i[9], t[e + 10] = i[10], t[e + 11] = i[11], t[e +
								12] = i[12], t[e + 13] = i[13], t[e + 14] = i[14], t[e + 15] = i[15],
							t
					}
				}), Object.assign(hi, {
					slerp: function (t, e, i, n) {
						return i.copy(t).slerp(e, n)
					},
					slerpFlat: function (t, e, i, n, r, a, o) {
						var s = i[n + 0],
							c = i[n + 1],
							h = i[n + 2],
							l = i[n + 3],
							u = r[a + 0],
							p = r[a + 1],
							d = r[a + 2],
							f = r[a + 3];
						if (l !== f || s !== u || c !== p || h !== d) {
							var m = 1 - o,
								g = s * u + c * p + h * d + l * f,
								v = 0 <= g ? 1 : -1,
								y = 1 - g * g;
							if (y > Number.EPSILON) {
								var x = Math.sqrt(y),
									b = Math.atan2(x, g * v);
								m = Math.sin(m * b) / x, o = Math.sin(o * b) / x
							}
							var w = o * v;
							if (s = s * m + u * w, c = c * m + p * w, h = h * m + d * w, l = l * m +
								f * w, m === 1 - o) {
								var _ = 1 / Math.sqrt(s * s + c * c + h * h + l * l);
								s *= _, c *= _, h *= _, l *= _
							}
						}
						t[e] = s, t[e + 1] = c, t[e + 2] = h, t[e + 3] = l
					}
				}), Object.defineProperties(hi.prototype, {
					x: {
						get: function () {
							return this._x
						},
						set: function (t) {
							this._x = t, this.onChangeCallback()
						}
					},
					y: {
						get: function () {
							return this._y
						},
						set: function (t) {
							this._y = t, this.onChangeCallback()
						}
					},
					z: {
						get: function () {
							return this._z
						},
						set: function (t) {
							this._z = t, this.onChangeCallback()
						}
					},
					w: {
						get: function () {
							return this._w
						},
						set: function (t) {
							this._w = t, this.onChangeCallback()
						}
					}
				}), Object.assign(hi.prototype, {
					isQuaternion: !0,
					set: function (t, e, i, n) {
						return this._x = t, this._y = e, this._z = i, this._w = n, this
							.onChangeCallback(), this
					},
					clone: function () {
						return new this.constructor(this._x, this._y, this._z, this._w)
					},
					copy: function (t) {
						return this._x = t.x, this._y = t.y, this._z = t.z, this._w = t.w, this
							.onChangeCallback(), this
					},
					setFromEuler: function (t, e) {
						if (!t || !t.isEuler) throw new Error(
							"THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order."
							);
						var i = t._x,
							n = t._y,
							r = t._z,
							a = t.order,
							o = Math.cos,
							s = Math.sin,
							c = o(i / 2),
							h = o(n / 2),
							l = o(r / 2),
							u = s(i / 2),
							p = s(n / 2),
							d = s(r / 2);
						return "XYZ" === a ? (this._x = u * h * l + c * p * d, this._y = c * p * l -
								u * h * d, this._z = c * h * d + u * p * l, this._w = c * h * l - u *
								p * d) : "YXZ" === a ? (this._x = u * h * l + c * p * d, this._y = c *
								p * l - u * h * d, this._z = c * h * d - u * p * l, this._w = c * h *
								l + u * p * d) : "ZXY" === a ? (this._x = u * h * l - c * p * d, this
								._y = c * p * l + u * h * d, this._z = c * h * d + u * p * l, this
								._w = c * h * l - u * p * d) : "ZYX" === a ? (this._x = u * h * l -
								c * p * d, this._y = c * p * l + u * h * d, this._z = c * h * d - u *
								p * l, this._w = c * h * l + u * p * d) : "YZX" === a ? (this._x = u *
								h * l + c * p * d, this._y = c * p * l + u * h * d, this._z = c * h *
								d - u * p * l, this._w = c * h * l - u * p * d) : "XZY" === a && (this
								._x = u * h * l - c * p * d, this._y = c * p * l - u * h * d, this
								._z = c * h * d + u * p * l, this._w = c * h * l + u * p * d), !1 !==
							e && this.onChangeCallback(), this
					},
					setFromAxisAngle: function (t, e) {
						var i = e / 2,
							n = Math.sin(i);
						return this._x = t.x * n, this._y = t.y * n, this._z = t.z * n, this._w = Math
							.cos(i), this.onChangeCallback(), this
					},
					setFromRotationMatrix: function (t) {
						var e, i = t.elements,
							n = i[0],
							r = i[4],
							a = i[8],
							o = i[1],
							s = i[5],
							c = i[9],
							h = i[2],
							l = i[6],
							u = i[10],
							p = n + s + u;
						return this._z = 0 < p ? (e = .5 / Math.sqrt(p + 1), this._w = .25 / e, this
								._x = (l - c) * e, this._y = (a - h) * e, (o - r) * e) : s < n && u <
							n ? (e = 2 * Math.sqrt(1 + n - s - u), this._w = (l - c) / e, this._x =
								.25 * e, this._y = (r + o) / e, (a + h) / e) : u < s ? (e = 2 * Math
								.sqrt(1 + s - n - u), this._w = (a - h) / e, this._x = (r + o) / e,
								this._y = .25 * e, (c + l) / e) : (e = 2 * Math.sqrt(1 + u - n - s),
								this._w = (o - r) / e, this._x = (a + h) / e, this._y = (c + l) / e,
								.25 * e), this.onChangeCallback(), this
					},
					setFromUnitVectors: (f = new li, m = 1e-6, function (t, e) {
						return void 0 === f && (f = new li), (d = t.dot(e) + 1) < m ? (d = 0, Math
								.abs(t.x) > Math.abs(t.z) ? f.set(-t.y, t.x, 0) : f.set(0, -t.z, t
									.y)) : f.crossVectors(t, e), this._x = f.x, this._y = f.y,
							this._z = f.z, this._w = d, this.normalize()
					}),
					angleTo: function (t) {
						return 2 * Math.acos(Math.abs(oi.clamp(this.dot(t), -1, 1)))
					},
					rotateTowards: function (t, e) {
						var i = this.angleTo(t);
						if (0 === i) return this;
						var n = Math.min(1, e / i);
						return this.slerp(t, n), this
					},
					inverse: function () {
						return this.conjugate()
					},
					conjugate: function () {
						return this._x *= -1, this._y *= -1, this._z *= -1, this.onChangeCallback(),
							this
					},
					dot: function (t) {
						return this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w
					},
					lengthSq: function () {
						return this._x * this._x + this._y * this._y + this._z * this._z + this._w *
							this._w
					},
					length: function () {
						return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z +
							this._w * this._w)
					},
					normalize: function () {
						var t = this.length();
						return this._w = 0 === t ? (this._x = 0, this._y = 0, this._z = 0, 1) : (t =
							1 / t, this._x = this._x * t, this._y = this._y * t, this._z = this
							._z * t, this._w * t), this.onChangeCallback(), this
					},
					multiply: function (t, e) {
						return void 0 !== e ? (console.warn(
							"THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."
							), this.multiplyQuaternions(t, e)) : this.multiplyQuaternions(this, t)
					},
					premultiply: function (t) {
						return this.multiplyQuaternions(t, this)
					},
					multiplyQuaternions: function (t, e) {
						var i = t._x,
							n = t._y,
							r = t._z,
							a = t._w,
							o = e._x,
							s = e._y,
							c = e._z,
							h = e._w;
						return this._x = i * h + a * o + n * c - r * s, this._y = n * h + a * s + r *
							o - i * c, this._z = r * h + a * c + i * s - n * o, this._w = a * h - i *
							o - n * s - r * c, this.onChangeCallback(), this
					},
					slerp: function (t, e) {
						if (0 === e) return this;
						if (1 === e) return this.copy(t);
						var i = this._x,
							n = this._y,
							r = this._z,
							a = this._w,
							o = a * t._w + i * t._x + n * t._y + r * t._z;
						if (o < 0 ? (this._w = -t._w, this._x = -t._x, this._y = -t._y, this._z = -t
								._z, o = -o) : this.copy(t), 1 <= o) return this._w = a, this._x = i,
							this._y = n, this._z = r, this;
						var s = 1 - o * o;
						if (s <= Number.EPSILON) {
							var c = 1 - e;
							return this._w = c * a + e * this._w, this._x = c * i + e * this._x, this
								._y = c * n + e * this._y, this._z = c * r + e * this._z, this
								.normalize()
						}
						var h = Math.sqrt(s),
							l = Math.atan2(h, o),
							u = Math.sin((1 - e) * l) / h,
							p = Math.sin(e * l) / h;
						return this._w = a * u + this._w * p, this._x = i * u + this._x * p, this._y =
							n * u + this._y * p, this._z = r * u + this._z * p, this
							.onChangeCallback(), this
					},
					equals: function (t) {
						return t._x === this._x && t._y === this._y && t._z === this._z && t._w ===
							this._w
					},
					fromArray: function (t, e) {
						return void 0 === e && (e = 0), this._x = t[e], this._y = t[e + 1], this._z =
							t[e + 2], this._w = t[e + 3], this.onChangeCallback(), this
					},
					toArray: function (t, e) {
						return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this._x, t[
							e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._w, t
					},
					onChange: function (t) {
						return this.onChangeCallback = t, this
					},
					onChangeCallback: function () {}
				}), Object.assign(li.prototype, {
					isVector3: !0,
					set: function (t, e, i) {
						return this.x = t, this.y = e, this.z = i, this
					},
					setScalar: function (t) {
						return this.x = t, this.y = t, this.z = t, this
					},
					setX: function (t) {
						return this.x = t, this
					},
					setY: function (t) {
						return this.y = t, this
					},
					setZ: function (t) {
						return this.z = t, this
					},
					setComponent: function (t, e) {
						switch (t) {
							case 0:
								this.x = e;
								break;
							case 1:
								this.y = e;
								break;
							case 2:
								this.z = e;
								break;
							default:
								throw new Error("index is out of range: " + t)
						}
						return this
					},
					getComponent: function (t) {
						switch (t) {
							case 0:
								return this.x;
							case 1:
								return this.y;
							case 2:
								return this.z;
							default:
								throw new Error("index is out of range: " + t)
						}
					},
					clone: function () {
						return new this.constructor(this.x, this.y, this.z)
					},
					copy: function (t) {
						return this.x = t.x, this.y = t.y, this.z = t.z, this
					},
					add: function (t, e) {
						return void 0 !== e ? (console.warn(
							"THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."
							), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this.z += t
							.z, this)
					},
					addScalar: function (t) {
						return this.x += t, this.y += t, this.z += t, this
					},
					addVectors: function (t, e) {
						return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this
					},
					addScaledVector: function (t, e) {
						return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this
					},
					sub: function (t, e) {
						return void 0 !== e ? (console.warn(
							"THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."
							), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this.z -= t
							.z, this)
					},
					subScalar: function (t) {
						return this.x -= t, this.y -= t, this.z -= t, this
					},
					subVectors: function (t, e) {
						return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this
					},
					multiply: function (t, e) {
						return void 0 !== e ? (console.warn(
							"THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."
							), this.multiplyVectors(t, e)) : (this.x *= t.x, this.y *= t.y, this
							.z *= t.z, this)
					},
					multiplyScalar: function (t) {
						return this.x *= t, this.y *= t, this.z *= t, this
					},
					multiplyVectors: function (t, e) {
						return this.x = t.x * e.x, this.y = t.y * e.y, this.z = t.z * e.z, this
					},
					applyEuler: (_ = new hi, function (t) {
						return t && t.isEuler || console.error(
							"THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."
							), this.applyQuaternion(_.setFromEuler(t))
					}),
					applyAxisAngle: (w = new hi, function (t, e) {
						return this.applyQuaternion(w.setFromAxisAngle(t, e))
					}),
					applyMatrix3: function (t) {
						var e = this.x,
							i = this.y,
							n = this.z,
							r = t.elements;
						return this.x = r[0] * e + r[3] * i + r[6] * n, this.y = r[1] * e + r[4] * i +
							r[7] * n, this.z = r[2] * e + r[5] * i + r[8] * n, this
					},
					applyMatrix4: function (t) {
						var e = this.x,
							i = this.y,
							n = this.z,
							r = t.elements,
							a = 1 / (r[3] * e + r[7] * i + r[11] * n + r[15]);
						return this.x = (r[0] * e + r[4] * i + r[8] * n + r[12]) * a, this.y = (r[1] *
							e + r[5] * i + r[9] * n + r[13]) * a, this.z = (r[2] * e + r[6] * i +
							r[10] * n + r[14]) * a, this
					},
					applyQuaternion: function (t) {
						var e = this.x,
							i = this.y,
							n = this.z,
							r = t.x,
							a = t.y,
							o = t.z,
							s = t.w,
							c = s * e + a * n - o * i,
							h = s * i + o * e - r * n,
							l = s * n + r * i - a * e,
							u = -r * e - a * i - o * n;
						return this.x = c * s + u * -r + h * -o - l * -a, this.y = h * s + u * -a +
							l * -r - c * -o, this.z = l * s + u * -o + c * -a - h * -r, this
					},
					project: function (t) {
						return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t
							.projectionMatrix)
					},
					unproject: (b = new ci, function (t) {
						return this.applyMatrix4(b.getInverse(t.projectionMatrix)).applyMatrix4(t
							.matrixWorld)
					}),
					transformDirection: function (t) {
						var e = this.x,
							i = this.y,
							n = this.z,
							r = t.elements;
						return this.x = r[0] * e + r[4] * i + r[8] * n, this.y = r[1] * e + r[5] * i +
							r[9] * n, this.z = r[2] * e + r[6] * i + r[10] * n, this.normalize()
					},
					divide: function (t) {
						return this.x /= t.x, this.y /= t.y, this.z /= t.z, this
					},
					divideScalar: function (t) {
						return this.multiplyScalar(1 / t)
					},
					min: function (t) {
						return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this
							.z = Math.min(this.z, t.z), this
					},
					max: function (t) {
						return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this
							.z = Math.max(this.z, t.z), this
					},
					clamp: function (t, e) {
						return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y,
								Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)),
							this
					},
					clampScalar: (y = new li, x = new li, function (t, e) {
						return y.set(t, t, t), x.set(e, e, e), this.clamp(y, x)
					}),
					clampLength: function (t, e) {
						var i = this.length();
						return this.divideScalar(i || 1).multiplyScalar(Math.max(t, Math.min(e, i)))
					},
					floor: function () {
						return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math
							.floor(this.z), this
					},
					ceil: function () {
						return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math
							.ceil(this.z), this
					},
					round: function () {
						return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math
							.round(this.z), this
					},
					roundToZero: function () {
						return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y =
							this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ?
							Math.ceil(this.z) : Math.floor(this.z), this
					},
					negate: function () {
						return this.x = -this.x, this.y = -this.y, this.z = -this.z, this
					},
					dot: function (t) {
						return this.x * t.x + this.y * t.y + this.z * t.z
					},
					lengthSq: function () {
						return this.x * this.x + this.y * this.y + this.z * this.z
					},
					length: function () {
						return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
					},
					manhattanLength: function () {
						return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
					},
					normalize: function () {
						return this.divideScalar(this.length() || 1)
					},
					setLength: function (t) {
						return this.normalize().multiplyScalar(t)
					},
					lerp: function (t, e) {
						return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (
							t.z - this.z) * e, this
					},
					lerpVectors: function (t, e, i) {
						return this.subVectors(e, t).multiplyScalar(i).add(t)
					},
					cross: function (t, e) {
						return void 0 !== e ? (console.warn(
							"THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."
							), this.crossVectors(t, e)) : this.crossVectors(this, t)
					},
					crossVectors: function (t, e) {
						var i = t.x,
							n = t.y,
							r = t.z,
							a = e.x,
							o = e.y,
							s = e.z;
						return this.x = n * s - r * o, this.y = r * a - i * s, this.z = i * o - n * a,
							this
					},
					projectOnVector: function (t) {
						var e = t.dot(this) / t.lengthSq();
						return this.copy(t).multiplyScalar(e)
					},
					projectOnPlane: (v = new li, function (t) {
						return v.copy(this).projectOnVector(t), this.sub(v)
					}),
					reflect: (g = new li, function (t) {
						return this.sub(g.copy(t).multiplyScalar(2 * this.dot(t)))
					}),
					angleTo: function (t) {
						var e = this.dot(t) / Math.sqrt(this.lengthSq() * t.lengthSq());
						return Math.acos(oi.clamp(e, -1, 1))
					},
					distanceTo: function (t) {
						return Math.sqrt(this.distanceToSquared(t))
					},
					distanceToSquared: function (t) {
						var e = this.x - t.x,
							i = this.y - t.y,
							n = this.z - t.z;
						return e * e + i * i + n * n
					},
					manhattanDistanceTo: function (t) {
						return Math.abs(this.x - t.x) + Math.abs(this.y - t.y) + Math.abs(this.z - t
							.z)
					},
					setFromSpherical: function (t) {
						return this.setFromSphericalCoords(t.radius, t.phi, t.theta)
					},
					setFromSphericalCoords: function (t, e, i) {
						var n = Math.sin(e) * t;
						return this.x = n * Math.sin(i), this.y = Math.cos(e) * t, this.z = n * Math
							.cos(i), this
					},
					setFromCylindrical: function (t) {
						return this.setFromCylindricalCoords(t.radius, t.theta, t.y)
					},
					setFromCylindricalCoords: function (t, e, i) {
						return this.x = t * Math.sin(e), this.y = i, this.z = t * Math.cos(e), this
					},
					setFromMatrixPosition: function (t) {
						var e = t.elements;
						return this.x = e[12], this.y = e[13], this.z = e[14], this
					},
					setFromMatrixScale: function (t) {
						var e = this.setFromMatrixColumn(t, 0).length(),
							i = this.setFromMatrixColumn(t, 1).length(),
							n = this.setFromMatrixColumn(t, 2).length();
						return this.x = e, this.y = i, this.z = n, this
					},
					setFromMatrixColumn: function (t, e) {
						return this.fromArray(t.elements, 4 * e)
					},
					equals: function (t) {
						return t.x === this.x && t.y === this.y && t.z === this.z
					},
					fromArray: function (t, e) {
						return void 0 === e && (e = 0), this.x = t[e], this.y = t[e + 1], this.z = t[
							e + 2], this
					},
					toArray: function (t, e) {
						return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this.x, t[e +
							1] = this.y, t[e + 2] = this.z, t
					},
					fromBufferAttribute: function (t, e, i) {
						return void 0 !== i && console.warn(
								"THREE.Vector3: offset has been removed from .fromBufferAttribute()."
								), this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this
					}
				}), Object.assign(ui.prototype, {
					isMatrix3: !0,
					set: function (t, e, i, n, r, a, o, s, c) {
						var h = this.elements;
						return h[0] = t, h[1] = n, h[2] = o, h[3] = e, h[4] = r, h[5] = s, h[6] = i,
							h[7] = a, h[8] = c, this
					},
					identity: function () {
						return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this
					},
					clone: function () {
						return (new this.constructor).fromArray(this.elements)
					},
					copy: function (t) {
						var e = this.elements,
							i = t.elements;
						return e[0] = i[0], e[1] = i[1], e[2] = i[2], e[3] = i[3], e[4] = i[4], e[5] =
							i[5], e[6] = i[6], e[7] = i[7], e[8] = i[8], this
					},
					setFromMatrix4: function (t) {
						var e = t.elements;
						return this.set(e[0], e[4], e[8], e[1], e[5], e[9], e[2], e[6], e[10]), this
					},
					applyToBufferAttribute: (M = new li, function (t) {
						for (var e = 0, i = t.count; e < i; e++) M.x = t.getX(e), M.y = t.getY(e),
							M.z = t.getZ(e), M.applyMatrix3(this), t.setXYZ(e, M.x, M.y, M.z);
						return t
					}),
					multiply: function (t) {
						return this.multiplyMatrices(this, t)
					},
					premultiply: function (t) {
						return this.multiplyMatrices(t, this)
					},
					multiplyMatrices: function (t, e) {
						var i = t.elements,
							n = e.elements,
							r = this.elements,
							a = i[0],
							o = i[3],
							s = i[6],
							c = i[1],
							h = i[4],
							l = i[7],
							u = i[2],
							p = i[5],
							d = i[8],
							f = n[0],
							m = n[3],
							g = n[6],
							v = n[1],
							y = n[4],
							x = n[7],
							b = n[2],
							w = n[5],
							_ = n[8];
						return r[0] = a * f + o * v + s * b, r[3] = a * m + o * y + s * w, r[6] = a *
							g + o * x + s * _, r[1] = c * f + h * v + l * b, r[4] = c * m + h * y +
							l * w, r[7] = c * g + h * x + l * _, r[2] = u * f + p * v + d * b, r[5] =
							u * m + p * y + d * w, r[8] = u * g + p * x + d * _, this
					},
					multiplyScalar: function (t) {
						var e = this.elements;
						return e[0] *= t, e[3] *= t, e[6] *= t, e[1] *= t, e[4] *= t, e[7] *= t, e[
							2] *= t, e[5] *= t, e[8] *= t, this
					},
					determinant: function () {
						var t = this.elements,
							e = t[0],
							i = t[1],
							n = t[2],
							r = t[3],
							a = t[4],
							o = t[5],
							s = t[6],
							c = t[7],
							h = t[8];
						return e * a * h - e * o * c - i * r * h + i * o * s + n * r * c - n * a * s
					},
					getInverse: function (t, e) {
						t && t.isMatrix4 && console.error(
							"THREE.Matrix3: .getInverse() no longer takes a Matrix4 argument.");
						var i = t.elements,
							n = this.elements,
							r = i[0],
							a = i[1],
							o = i[2],
							s = i[3],
							c = i[4],
							h = i[5],
							l = i[6],
							u = i[7],
							p = i[8],
							d = p * c - h * u,
							f = h * l - p * s,
							m = u * s - c * l,
							g = r * d + a * f + o * m;
						if (0 === g) {
							var v =
								"THREE.Matrix3: .getInverse() can't invert matrix, determinant is 0";
							if (!0 === e) throw new Error(v);
							return console.warn(v), this.identity()
						}
						var y = 1 / g;
						return n[0] = d * y, n[1] = (o * u - p * a) * y, n[2] = (h * a - o * c) * y,
							n[3] = f * y, n[4] = (p * r - o * l) * y, n[5] = (o * s - h * r) * y, n[
							6] = m * y, n[7] = (a * l - u * r) * y, n[8] = (c * r - a * s) * y, this
					},
					transpose: function () {
						var t, e = this.elements;
						return t = e[1], e[1] = e[3], e[3] = t, t = e[2], e[2] = e[6], e[6] = t, t =
							e[5], e[5] = e[7], e[7] = t, this
					},
					getNormalMatrix: function (t) {
						return this.setFromMatrix4(t).getInverse(this).transpose()
					},
					transposeIntoArray: function (t) {
						var e = this.elements;
						return t[0] = e[0], t[1] = e[3], t[2] = e[6], t[3] = e[1], t[4] = e[4], t[5] =
							e[7], t[6] = e[2], t[7] = e[5], t[8] = e[8], this
					},
					setUvTransform: function (t, e, i, n, r, a, o) {
						var s = Math.cos(r),
							c = Math.sin(r);
						this.set(i * s, i * c, -i * (s * a + c * o) + a + t, -n * c, n * s, -n * (-c *
							a + s * o) + o + e, 0, 0, 1)
					},
					scale: function (t, e) {
						var i = this.elements;
						return i[0] *= t, i[3] *= t, i[6] *= t, i[1] *= e, i[4] *= e, i[7] *= e, this
					},
					rotate: function (t) {
						var e = Math.cos(t),
							i = Math.sin(t),
							n = this.elements,
							r = n[0],
							a = n[3],
							o = n[6],
							s = n[1],
							c = n[4],
							h = n[7];
						return n[0] = e * r + i * s, n[3] = e * a + i * c, n[6] = e * o + i * h, n[
							1] = -i * r + e * s, n[4] = -i * a + e * c, n[7] = -i * o + e * h, this
					},
					translate: function (t, e) {
						var i = this.elements;
						return i[0] += t * i[2], i[3] += t * i[5], i[6] += t * i[8], i[1] += e * i[2],
							i[4] += e * i[5], i[7] += e * i[8], this
					},
					equals: function (t) {
						for (var e = this.elements, i = t.elements, n = 0; n < 9; n++)
							if (e[n] !== i[n]) return !1;
						return !0
					},
					fromArray: function (t, e) {
						void 0 === e && (e = 0);
						for (var i = 0; i < 9; i++) this.elements[i] = t[i + e];
						return this
					},
					toArray: function (t, e) {
						void 0 === t && (t = []), void 0 === e && (e = 0);
						var i = this.elements;
						return t[e] = i[0], t[e + 1] = i[1], t[e + 2] = i[2], t[e + 3] = i[3], t[e +
								4] = i[4], t[e + 5] = i[5], t[e + 6] = i[6], t[e + 7] = i[7], t[e +
							8] = i[8], t
					}
				});
				var pi, di, fi, mi, gi, vi, yi, xi, bi, wi, _i, Mi, Si, Ei, Ti, Ai, Li = {
						getDataURL: function (t) {
							var e;
							if ("undefined" == typeof HTMLCanvasElement) return t.src;
							if (t instanceof HTMLCanvasElement) e = t;
							else {
								void 0 === S && (S = document.createElement("canvas")), S.width = t.width, S
									.height = t.height;
								var i = S.getContext("2d");
								t instanceof ImageData ? i.putImageData(t, 0, 0) : i.drawImage(t, 0, 0, t
									.width, t.height), e = S
							}
							return 2048 < e.width || 2048 < e.height ? e.toDataURL("image/jpeg", .6) : e
								.toDataURL("image/png")
						}
					},
					Pi = 0;

				function Ci(t, e, i, n, r, a, o, s, c, h) {
					Object.defineProperty(this, "id", {
							value: Pi++
						}), this.uuid = oi.generateUUID(), this.name = "", this.image = void 0 !== t ? t : Ci
						.DEFAULT_IMAGE, this.mipmaps = [], this.mapping = void 0 !== e ? e : Ci.DEFAULT_MAPPING,
						this.wrapS = void 0 !== i ? i : Bt, this.wrapT = void 0 !== n ? n : Bt, this.magFilter =
						void 0 !== r ? r : Ft, this.minFilter = void 0 !== a ? a : Wt, this.anisotropy =
						void 0 !== c ? c : 1, this.format = void 0 !== o ? o : oe, this.type = void 0 !== s ? s :
						qt, this.offset = new si(0, 0), this.repeat = new si(1, 1), this.center = new si(0, 0),
						this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new ui, this
						.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment =
						4, this.encoding = void 0 !== h ? h : Ye, this.version = 0, this.onUpdate = null
				}

				function Ri(t, e, i, n) {
					this.x = t || 0, this.y = e || 0, this.z = i || 0, this.w = void 0 !== n ? n : 1
				}

				function Oi(t, e, i) {
					this.width = t, this.height = e, this.scissor = new Ri(0, 0, t, e), this.scissorTest = !1,
						this.viewport = new Ri(0, 0, t, e), i = i || {}, this.texture = new Ci(void 0, void 0, i
							.wrapS, i.wrapT, i.magFilter, i.minFilter, i.format, i.type, i.anisotropy, i.encoding
							), this.texture.generateMipmaps = void 0 !== i.generateMipmaps && i.generateMipmaps,
						this.texture.minFilter = void 0 !== i.minFilter ? i.minFilter : Ft, this.depthBuffer =
						void 0 === i.depthBuffer || i.depthBuffer, this.stencilBuffer = void 0 === i
						.stencilBuffer || i.stencilBuffer, this.depthTexture = void 0 !== i.depthTexture ? i
						.depthTexture : null
				}

				function Ii(t, e, i) {
					Oi.call(this, t, e, i), this.activeCubeFace = 0, this.activeMipMapLevel = 0
				}

				function Di(t, e, i, n, r, a, o, s, c, h, l, u) {
					Ci.call(this, null, a, o, s, c, h, n, r, l, u), this.image = {
							data: t,
							width: e,
							height: i
						}, this.magFilter = void 0 !== c ? c : zt, this.minFilter = void 0 !== h ? h : zt, this
						.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1
				}

				function Bi(t, e) {
					this.min = void 0 !== t ? t : new li(1 / 0, 1 / 0, 1 / 0), this.max = void 0 !== e ? e :
						new li(-1 / 0, -1 / 0, -1 / 0)
				}

				function Ni(t, e) {
					this.center = void 0 !== t ? t : new li, this.radius = void 0 !== e ? e : 0
				}

				function zi(t, e) {
					this.normal = void 0 !== t ? t : new li(1, 0, 0), this.constant = void 0 !== e ? e : 0
				}

				function Ui(t, e, i, n, r, a) {
					this.planes = [void 0 !== t ? t : new zi, void 0 !== e ? e : new zi, void 0 !== i ? i :
						new zi, void 0 !== n ? n : new zi, void 0 !== r ? r : new zi, void 0 !== a ? a :
						new zi
					]
				}
				Ci.DEFAULT_IMAGE = void 0, Ci.DEFAULT_MAPPING = st, Ci.prototype = Object.assign(Object.create(e
						.prototype), {
						constructor: Ci,
						isTexture: !0,
						updateMatrix: function () {
							this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this
								.repeat.y, this.rotation, this.center.x, this.center.y)
						},
						clone: function () {
							return (new this.constructor).copy(this)
						},
						copy: function (t) {
							return this.name = t.name, this.image = t.image, this.mipmaps = t.mipmaps
								.slice(0), this.mapping = t.mapping, this.wrapS = t.wrapS, this.wrapT = t
								.wrapT, this.magFilter = t.magFilter, this.minFilter = t.minFilter, this
								.anisotropy = t.anisotropy, this.format = t.format, this.type = t.type,
								this.offset.copy(t.offset), this.repeat.copy(t.repeat), this.center.copy(t
									.center), this.rotation = t.rotation, this.matrixAutoUpdate = t
								.matrixAutoUpdate, this.matrix.copy(t.matrix), this.generateMipmaps = t
								.generateMipmaps, this.premultiplyAlpha = t.premultiplyAlpha, this.flipY =
								t.flipY, this.unpackAlignment = t.unpackAlignment, this.encoding = t
								.encoding, this
						},
						toJSON: function (t) {
							var e = void 0 === t || "string" == typeof t;
							if (!e && void 0 !== t.textures[this.uuid]) return t.textures[this.uuid];
							var i = {
								metadata: {
									version: 4.5,
									type: "Texture",
									generator: "Texture.toJSON"
								},
								uuid: this.uuid,
								name: this.name,
								mapping: this.mapping,
								repeat: [this.repeat.x, this.repeat.y],
								offset: [this.offset.x, this.offset.y],
								center: [this.center.x, this.center.y],
								rotation: this.rotation,
								wrap: [this.wrapS, this.wrapT],
								format: this.format,
								type: this.type,
								encoding: this.encoding,
								minFilter: this.minFilter,
								magFilter: this.magFilter,
								anisotropy: this.anisotropy,
								flipY: this.flipY,
								premultiplyAlpha: this.premultiplyAlpha,
								unpackAlignment: this.unpackAlignment
							};
							if (void 0 !== this.image) {
								var n = this.image;
								if (void 0 === n.uuid && (n.uuid = oi.generateUUID()), !e && void 0 === t
									.images[n.uuid]) {
									var r;
									if (Array.isArray(n)) {
										r = [];
										for (var a = 0, o = n.length; a < o; a++) r.push(Li.getDataURL(n[
											a]))
									} else r = Li.getDataURL(n);
									t.images[n.uuid] = {
										uuid: n.uuid,
										url: r
									}
								}
								i.image = n.uuid
							}
							return e || (t.textures[this.uuid] = i), i
						},
						dispose: function () {
							this.dispatchEvent({
								type: "dispose"
							})
						},
						transformUv: function (t) {
							if (this.mapping !== st) return t;
							if (t.applyMatrix3(this.matrix), t.x < 0 || 1 < t.x) switch (this.wrapS) {
								case Dt:
									t.x = t.x - Math.floor(t.x);
									break;
								case Bt:
									t.x = t.x < 0 ? 0 : 1;
									break;
								case Nt:
									1 === Math.abs(Math.floor(t.x) % 2) ? t.x = Math.ceil(t.x) - t.x :
										t.x = t.x - Math.floor(t.x)
							}
							if (t.y < 0 || 1 < t.y) switch (this.wrapT) {
								case Dt:
									t.y = t.y - Math.floor(t.y);
									break;
								case Bt:
									t.y = t.y < 0 ? 0 : 1;
									break;
								case Nt:
									1 === Math.abs(Math.floor(t.y) % 2) ? t.y = Math.ceil(t.y) - t.y :
										t.y = t.y - Math.floor(t.y)
							}
							return this.flipY && (t.y = 1 - t.y), t
						}
					}), Object.defineProperty(Ci.prototype, "needsUpdate", {
						set: function (t) {
							!0 === t && this.version++
						}
					}), Object.assign(Ri.prototype, {
						isVector4: !0,
						set: function (t, e, i, n) {
							return this.x = t, this.y = e, this.z = i, this.w = n, this
						},
						setScalar: function (t) {
							return this.x = t, this.y = t, this.z = t, this.w = t, this
						},
						setX: function (t) {
							return this.x = t, this
						},
						setY: function (t) {
							return this.y = t, this
						},
						setZ: function (t) {
							return this.z = t, this
						},
						setW: function (t) {
							return this.w = t, this
						},
						setComponent: function (t, e) {
							switch (t) {
								case 0:
									this.x = e;
									break;
								case 1:
									this.y = e;
									break;
								case 2:
									this.z = e;
									break;
								case 3:
									this.w = e;
									break;
								default:
									throw new Error("index is out of range: " + t)
							}
							return this
						},
						getComponent: function (t) {
							switch (t) {
								case 0:
									return this.x;
								case 1:
									return this.y;
								case 2:
									return this.z;
								case 3:
									return this.w;
								default:
									throw new Error("index is out of range: " + t)
							}
						},
						clone: function () {
							return new this.constructor(this.x, this.y, this.z, this.w)
						},
						copy: function (t) {
							return this.x = t.x, this.y = t.y, this.z = t.z, this.w = void 0 !== t.w ? t
								.w : 1, this
						},
						add: function (t, e) {
							return void 0 !== e ? (console.warn(
								"THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."
								), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this.z += t
								.z, this.w += t.w, this)
						},
						addScalar: function (t) {
							return this.x += t, this.y += t, this.z += t, this.w += t, this
						},
						addVectors: function (t, e) {
							return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this.w = t
								.w + e.w, this
						},
						addScaledVector: function (t, e) {
							return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this.w += t
								.w * e, this
						},
						sub: function (t, e) {
							return void 0 !== e ? (console.warn(
								"THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."
								), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this.z -= t
								.z, this.w -= t.w, this)
						},
						subScalar: function (t) {
							return this.x -= t, this.y -= t, this.z -= t, this.w -= t, this
						},
						subVectors: function (t, e) {
							return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this.w = t
								.w - e.w, this
						},
						multiplyScalar: function (t) {
							return this.x *= t, this.y *= t, this.z *= t, this.w *= t, this
						},
						applyMatrix4: function (t) {
							var e = this.x,
								i = this.y,
								n = this.z,
								r = this.w,
								a = t.elements;
							return this.x = a[0] * e + a[4] * i + a[8] * n + a[12] * r, this.y = a[1] *
								e + a[5] * i + a[9] * n + a[13] * r, this.z = a[2] * e + a[6] * i + a[
								10] * n + a[14] * r, this.w = a[3] * e + a[7] * i + a[11] * n + a[15] * r,
								this
						},
						divideScalar: function (t) {
							return this.multiplyScalar(1 / t)
						},
						setAxisAngleFromQuaternion: function (t) {
							this.w = 2 * Math.acos(t.w);
							var e = Math.sqrt(1 - t.w * t.w);
							return this.z = e < 1e-4 ? (this.x = 1, this.y = 0) : (this.x = t.x / e, this
								.y = t.y / e, t.z / e), this
						},
						setAxisAngleFromRotationMatrix: function (t) {
							var e, i, n, r, a = .01,
								o = .1,
								s = t.elements,
								c = s[0],
								h = s[4],
								l = s[8],
								u = s[1],
								p = s[5],
								d = s[9],
								f = s[2],
								m = s[6],
								g = s[10];
							if (Math.abs(h - u) < a && Math.abs(l - f) < a && Math.abs(d - m) < a) {
								if (Math.abs(h + u) < o && Math.abs(l + f) < o && Math.abs(d + m) < o &&
									Math.abs(c + p + g - 3) < o) return this.set(1, 0, 0, 0), this;
								e = Math.PI;
								var v = (c + 1) / 2,
									y = (p + 1) / 2,
									x = (g + 1) / 2,
									b = (h + u) / 4,
									w = (l + f) / 4,
									_ = (d + m) / 4;
								return y < v && x < v ? r = v < a ? (i = 0, n = .707106781) : (n = b / (
										i = Math.sqrt(v)), w / i) : x < y ? r = y < a ? (n = 0, i =
										.707106781) : (i = b / (n = Math.sqrt(y)), _ / n) : x < a ? (n =
										i = .707106781, r = 0) : (i = w / (r = Math.sqrt(x)), n = _ / r),
									this.set(i, n, r, e), this
							}
							var M = Math.sqrt((m - d) * (m - d) + (l - f) * (l - f) + (u - h) * (u - h));
							return Math.abs(M) < .001 && (M = 1), this.x = (m - d) / M, this.y = (l - f) /
								M, this.z = (u - h) / M, this.w = Math.acos((c + p + g - 1) / 2), this
						},
						min: function (t) {
							return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this
								.z = Math.min(this.z, t.z), this.w = Math.min(this.w, t.w), this
						},
						max: function (t) {
							return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this
								.z = Math.max(this.z, t.z), this.w = Math.max(this.w, t.w), this
						},
						clamp: function (t, e) {
							return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y,
									Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)),
								this.w = Math.max(t.w, Math.min(e.w, this.w)), this
						},
						clampScalar: function (t, e) {
							return void 0 === pi && (pi = new Ri, di = new Ri), pi.set(t, t, t, t), di
								.set(e, e, e, e), this.clamp(pi, di)
						},
						clampLength: function (t, e) {
							var i = this.length();
							return this.divideScalar(i || 1).multiplyScalar(Math.max(t, Math.min(e, i)))
						},
						floor: function () {
							return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math
								.floor(this.z), this.w = Math.floor(this.w), this
						},
						ceil: function () {
							return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math
								.ceil(this.z), this.w = Math.ceil(this.w), this
						},
						round: function () {
							return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math
								.round(this.z), this.w = Math.round(this.w), this
						},
						roundToZero: function () {
							return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y =
								this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ?
								Math.ceil(this.z) : Math.floor(this.z), this.w = this.w < 0 ? Math.ceil(
									this.w) : Math.floor(this.w), this
						},
						negate: function () {
							return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w,
								this
						},
						dot: function (t) {
							return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w
						},
						lengthSq: function () {
							return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
						},
						length: function () {
							return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this
								.w * this.w)
						},
						manhattanLength: function () {
							return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this
								.w)
						},
						normalize: function () {
							return this.divideScalar(this.length() || 1)
						},
						setLength: function (t) {
							return this.normalize().multiplyScalar(t)
						},
						lerp: function (t, e) {
							return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (
								t.z - this.z) * e, this.w += (t.w - this.w) * e, this
						},
						lerpVectors: function (t, e, i) {
							return this.subVectors(e, t).multiplyScalar(i).add(t)
						},
						equals: function (t) {
							return t.x === this.x && t.y === this.y && t.z === this.z && t.w === this.w
						},
						fromArray: function (t, e) {
							return void 0 === e && (e = 0), this.x = t[e], this.y = t[e + 1], this.z = t[
								e + 2], this.w = t[e + 3], this
						},
						toArray: function (t, e) {
							return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this.x, t[e +
								1] = this.y, t[e + 2] = this.z, t[e + 3] = this.w, t
						},
						fromBufferAttribute: function (t, e, i) {
							return void 0 !== i && console.warn(
									"THREE.Vector4: offset has been removed from .fromBufferAttribute()."
									), this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this
								.w = t.getW(e), this
						}
					}), Oi.prototype = Object.assign(Object.create(e.prototype), {
						constructor: Oi,
						isWebGLRenderTarget: !0,
						setSize: function (t, e) {
							this.width === t && this.height === e || (this.width = t, this.height = e,
								this.dispose()), this.viewport.set(0, 0, t, e), this.scissor.set(0, 0,
								t, e)
						},
						clone: function () {
							return (new this.constructor).copy(this)
						},
						copy: function (t) {
							return this.width = t.width, this.height = t.height, this.viewport.copy(t
									.viewport), this.texture = t.texture.clone(), this.depthBuffer = t
								.depthBuffer, this.stencilBuffer = t.stencilBuffer, this.depthTexture = t
								.depthTexture, this
						},
						dispose: function () {
							this.dispatchEvent({
								type: "dispose"
							})
						}
					}), Ii.prototype = Object.create(Oi.prototype), (Ii.prototype.constructor = Ii).prototype
					.isWebGLRenderTargetCube = !0, Di.prototype = Object.create(Ci.prototype), (Di.prototype
						.constructor = Di).prototype.isDataTexture = !0, Object.assign(Bi.prototype, {
						isBox3: !0,
						set: function (t, e) {
							return this.min.copy(t), this.max.copy(e), this
						},
						setFromArray: function (t) {
							for (var e = 1 / 0, i = 1 / 0, n = 1 / 0, r = -1 / 0, a = -1 / 0, o = -1 / 0,
									s = 0, c = t.length; s < c; s += 3) {
								var h = t[s],
									l = t[s + 1],
									u = t[s + 2];
								h < e && (e = h), l < i && (i = l), u < n && (n = u), r < h && (r = h),
									a < l && (a = l), o < u && (o = u)
							}
							return this.min.set(e, i, n), this.max.set(r, a, o), this
						},
						setFromBufferAttribute: function (t) {
							for (var e = 1 / 0, i = 1 / 0, n = 1 / 0, r = -1 / 0, a = -1 / 0, o = -1 / 0,
									s = 0, c = t.count; s < c; s++) {
								var h = t.getX(s),
									l = t.getY(s),
									u = t.getZ(s);
								h < e && (e = h), l < i && (i = l), u < n && (n = u), r < h && (r = h),
									a < l && (a = l), o < u && (o = u)
							}
							return this.min.set(e, i, n), this.max.set(r, a, o), this
						},
						setFromPoints: function (t) {
							this.makeEmpty();
							for (var e = 0, i = t.length; e < i; e++) this.expandByPoint(t[e]);
							return this
						},
						setFromCenterAndSize: (yi = new li, function (t, e) {
							var i = yi.copy(e).multiplyScalar(.5);
							return this.min.copy(t).sub(i), this.max.copy(t).add(i), this
						}),
						setFromObject: function (t) {
							return this.makeEmpty(), this.expandByObject(t)
						},
						clone: function () {
							return (new this.constructor).copy(this)
						},
						copy: function (t) {
							return this.min.copy(t.min), this.max.copy(t.max), this
						},
						makeEmpty: function () {
							return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y =
								this.max.z = -1 / 0, this
						},
						isEmpty: function () {
							return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this
								.min.z
						},
						getCenter: function (t) {
							return void 0 === t && (console.warn(
									"THREE.Box3: .getCenter() target is now required"), t = new li), this
								.isEmpty() ? t.set(0, 0, 0) : t.addVectors(this.min, this.max)
								.multiplyScalar(.5)
						},
						getSize: function (t) {
							return void 0 === t && (console.warn(
									"THREE.Box3: .getSize() target is now required"), t = new li), this
								.isEmpty() ? t.set(0, 0, 0) : t.subVectors(this.max, this.min)
						},
						expandByPoint: function (t) {
							return this.min.min(t), this.max.max(t), this
						},
						expandByVector: function (t) {
							return this.min.sub(t), this.max.add(t), this
						},
						expandByScalar: function (t) {
							return this.min.addScalar(-t), this.max.addScalar(t), this
						},
						expandByObject: function () {
							var r, a, o, s = new li;

							function e(t) {
								var e = t.geometry;
								if (void 0 !== e)
									if (e.isGeometry) {
										var i = e.vertices;
										for (a = 0, o = i.length; a < o; a++) s.copy(i[a]), s
											.applyMatrix4(t.matrixWorld), r.expandByPoint(s)
									} else if (e.isBufferGeometry) {
									var n = e.attributes.position;
									if (void 0 !== n)
										for (a = 0, o = n.count; a < o; a++) s.fromBufferAttribute(n, a)
											.applyMatrix4(t.matrixWorld), r.expandByPoint(s)
								}
							}
							return function (t) {
								return r = this, t.updateMatrixWorld(!0), t.traverse(e), this
							}
						}(),
						containsPoint: function (t) {
							return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y >
								this.max.y || t.z < this.min.z || t.z > this.max.z)
						},
						containsBox: function (t) {
							return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min
								.y && t.max.y <= this.max.y && this.min.z <= t.min.z && t.max.z <= this
								.max.z
						},
						getParameter: function (t, e) {
							return void 0 === e && (console.warn(
									"THREE.Box3: .getParameter() target is now required"), e = new li), e
								.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) /
									(this.max.y - this.min.y), (t.z - this.min.z) / (this.max.z - this.min
										.z))
						},
						intersectsBox: function (t) {
							return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min
								.y || t.min.y > this.max.y || t.max.z < this.min.z || t.min.z > this
								.max.z)
						},
						intersectsSphere: (vi = new li, function (t) {
							return this.clampPoint(t.center, vi), vi.distanceToSquared(t.center) <= t
								.radius * t.radius
						}),
						intersectsPlane: function (t) {
							var e, i;
							return i = 0 < t.normal.x ? (e = t.normal.x * this.min.x, t.normal.x * this
									.max.x) : (e = t.normal.x * this.max.x, t.normal.x * this.min.x), 0 <
								t.normal.y ? (e += t.normal.y * this.min.y, i += t.normal.y * this.max
								.y) : (e += t.normal.y * this.max.y, i += t.normal.y * this.min.y), 0 < t
								.normal.z ? (e += t.normal.z * this.min.z, i += t.normal.z * this.max.z) :
								(e += t.normal.z * this.max.z, i += t.normal.z * this.min.z), e <= -t
								.constant && i >= -t.constant
						},
						intersectsTriangle: function () {
							var s = new li,
								c = new li,
								h = new li,
								i = new li,
								n = new li,
								r = new li,
								l = new li,
								a = new li,
								u = new li,
								o = new li;

							function p(t) {
								var e, i;
								for (e = 0, i = t.length - 3; e <= i; e += 3) {
									l.fromArray(t, e);
									var n = u.x * Math.abs(l.x) + u.y * Math.abs(l.y) + u.z * Math.abs(l
											.z),
										r = s.dot(l),
										a = c.dot(l),
										o = h.dot(l);
									if (Math.max(-Math.max(r, a, o), Math.min(r, a, o)) > n) return !1
								}
								return !0
							}
							return function (t) {
								if (this.isEmpty()) return !1;
								this.getCenter(a), u.subVectors(this.max, a), s.subVectors(t.a, a), c
									.subVectors(t.b, a), h.subVectors(t.c, a), i.subVectors(c, s), n
									.subVectors(h, c), r.subVectors(s, h);
								var e = [0, -i.z, i.y, 0, -n.z, n.y, 0, -r.z, r.y, i.z, 0, -i.x, n.z,
									0, -n.x, r.z, 0, -r.x, -i.y, i.x, 0, -n.y, n.x, 0, -r.y, r.x,
									0
								];
								return !!p(e) && (!!p(e = [1, 0, 0, 0, 1, 0, 0, 0, 1]) && (o
									.crossVectors(i, n), p(e = [o.x, o.y, o.z])))
							}
						}(),
						clampPoint: function (t, e) {
							return void 0 === e && (console.warn(
									"THREE.Box3: .clampPoint() target is now required"), e = new li), e
								.copy(t).clamp(this.min, this.max)
						},
						distanceToPoint: (gi = new li, function (t) {
							return gi.copy(t).clamp(this.min, this.max).sub(t).length()
						}),
						getBoundingSphere: (mi = new li, function (t) {
							return void 0 === t && (console.warn(
										"THREE.Box3: .getBoundingSphere() target is now required"),
									t = new Ni), this.getCenter(t.center), t.radius = .5 * this
								.getSize(mi).length(), t
						}),
						intersect: function (t) {
							return this.min.max(t.min), this.max.min(t.max), this.isEmpty() && this
								.makeEmpty(), this
						},
						union: function (t) {
							return this.min.min(t.min), this.max.max(t.max), this
						},
						applyMatrix4: (fi = [new li, new li, new li, new li, new li, new li, new li, new li],
							function (t) {
								return this.isEmpty() || (fi[0].set(this.min.x, this.min.y, this.min.z)
									.applyMatrix4(t), fi[1].set(this.min.x, this.min.y, this.max.z)
									.applyMatrix4(t), fi[2].set(this.min.x, this.max.y, this.min.z)
									.applyMatrix4(t), fi[3].set(this.min.x, this.max.y, this.max.z)
									.applyMatrix4(t), fi[4].set(this.max.x, this.min.y, this.min.z)
									.applyMatrix4(t), fi[5].set(this.max.x, this.min.y, this.max.z)
									.applyMatrix4(t), fi[6].set(this.max.x, this.max.y, this.min.z)
									.applyMatrix4(t), fi[7].set(this.max.x, this.max.y, this.max.z)
									.applyMatrix4(t), this.setFromPoints(fi)), this
							}),
						translate: function (t) {
							return this.min.add(t), this.max.add(t), this
						},
						equals: function (t) {
							return t.min.equals(this.min) && t.max.equals(this.max)
						}
					}), Object.assign(Ni.prototype, {
						set: function (t, e) {
							return this.center.copy(t), this.radius = e, this
						},
						setFromPoints: (xi = new Bi, function (t, e) {
							var i = this.center;
							void 0 !== e ? i.copy(e) : xi.setFromPoints(t).getCenter(i);
							for (var n = 0, r = 0, a = t.length; r < a; r++) n = Math.max(n, i
								.distanceToSquared(t[r]));
							return this.radius = Math.sqrt(n), this
						}),
						clone: function () {
							return (new this.constructor).copy(this)
						},
						copy: function (t) {
							return this.center.copy(t.center), this.radius = t.radius, this
						},
						empty: function () {
							return this.radius <= 0
						},
						containsPoint: function (t) {
							return t.distanceToSquared(this.center) <= this.radius * this.radius
						},
						distanceToPoint: function (t) {
							return t.distanceTo(this.center) - this.radius
						},
						intersectsSphere: function (t) {
							var e = this.radius + t.radius;
							return t.center.distanceToSquared(this.center) <= e * e
						},
						intersectsBox: function (t) {
							return t.intersectsSphere(this)
						},
						intersectsPlane: function (t) {
							return Math.abs(t.distanceToPoint(this.center)) <= this.radius
						},
						clampPoint: function (t, e) {
							var i = this.center.distanceToSquared(t);
							return void 0 === e && (console.warn(
									"THREE.Sphere: .clampPoint() target is now required"), e = new li), e
								.copy(t), i > this.radius * this.radius && (e.sub(this.center)
								.normalize(), e.multiplyScalar(this.radius).add(this.center)), e
						},
						getBoundingBox: function (t) {
							return void 0 === t && (console.warn(
									"THREE.Sphere: .getBoundingBox() target is now required"), t =
								new Bi), t.set(this.center, this.center), t.expandByScalar(this
								.radius), t
						},
						applyMatrix4: function (t) {
							return this.center.applyMatrix4(t), this.radius = this.radius * t
								.getMaxScaleOnAxis(), this
						},
						translate: function (t) {
							return this.center.add(t), this
						},
						equals: function (t) {
							return t.center.equals(this.center) && t.radius === this.radius
						}
					}), Object.assign(zi.prototype, {
						set: function (t, e) {
							return this.normal.copy(t), this.constant = e, this
						},
						setComponents: function (t, e, i, n) {
							return this.normal.set(t, e, i), this.constant = n, this
						},
						setFromNormalAndCoplanarPoint: function (t, e) {
							return this.normal.copy(t), this.constant = -e.dot(this.normal), this
						},
						setFromCoplanarPoints: (Mi = new li, Si = new li, function (t, e, i) {
							var n = Mi.subVectors(i, e).cross(Si.subVectors(t, e)).normalize();
							return this.setFromNormalAndCoplanarPoint(n, t), this
						}),
						clone: function () {
							return (new this.constructor).copy(this)
						},
						copy: function (t) {
							return this.normal.copy(t.normal), this.constant = t.constant, this
						},
						normalize: function () {
							var t = 1 / this.normal.length();
							return this.normal.multiplyScalar(t), this.constant *= t, this
						},
						negate: function () {
							return this.constant *= -1, this.normal.negate(), this
						},
						distanceToPoint: function (t) {
							return this.normal.dot(t) + this.constant
						},
						distanceToSphere: function (t) {
							return this.distanceToPoint(t.center) - t.radius
						},
						projectPoint: function (t, e) {
							return void 0 === e && (console.warn(
										"THREE.Plane: .projectPoint() target is now required"), e =
									new li), e.copy(this.normal).multiplyScalar(-this.distanceToPoint(t))
								.add(t)
						},
						intersectLine: (_i = new li, function (t, e) {
							void 0 === e && (console.warn(
									"THREE.Plane: .intersectLine() target is now required"), e =
								new li);
							var i = t.delta(_i),
								n = this.normal.dot(i);
							if (0 === n) return 0 === this.distanceToPoint(t.start) ? e.copy(t
								.start) : void 0;
							var r = -(t.start.dot(this.normal) + this.constant) / n;
							return r < 0 || 1 < r ? void 0 : e.copy(i).multiplyScalar(r).add(t.start)
						}),
						intersectsLine: function (t) {
							var e = this.distanceToPoint(t.start),
								i = this.distanceToPoint(t.end);
							return e < 0 && 0 < i || i < 0 && 0 < e
						},
						intersectsBox: function (t) {
							return t.intersectsPlane(this)
						},
						intersectsSphere: function (t) {
							return t.intersectsPlane(this)
						},
						coplanarPoint: function (t) {
							return void 0 === t && (console.warn(
									"THREE.Plane: .coplanarPoint() target is now required"), t =
								new li), t.copy(this.normal).multiplyScalar(-this.constant)
						},
						applyMatrix4: (bi = new li, wi = new ui, function (t, e) {
							var i = e || wi.getNormalMatrix(t),
								n = this.coplanarPoint(bi).applyMatrix4(t),
								r = this.normal.applyMatrix3(i).normalize();
							return this.constant = -n.dot(r), this
						}),
						translate: function (t) {
							return this.constant -= t.dot(this.normal), this
						},
						equals: function (t) {
							return t.normal.equals(this.normal) && t.constant === this.constant
						}
					}), Object.assign(Ui.prototype, {
						set: function (t, e, i, n, r, a) {
							var o = this.planes;
							return o[0].copy(t), o[1].copy(e), o[2].copy(i), o[3].copy(n), o[4].copy(r),
								o[5].copy(a), this
						},
						clone: function () {
							return (new this.constructor).copy(this)
						},
						copy: function (t) {
							for (var e = this.planes, i = 0; i < 6; i++) e[i].copy(t.planes[i]);
							return this
						},
						setFromMatrix: function (t) {
							var e = this.planes,
								i = t.elements,
								n = i[0],
								r = i[1],
								a = i[2],
								o = i[3],
								s = i[4],
								c = i[5],
								h = i[6],
								l = i[7],
								u = i[8],
								p = i[9],
								d = i[10],
								f = i[11],
								m = i[12],
								g = i[13],
								v = i[14],
								y = i[15];
							return e[0].setComponents(o - n, l - s, f - u, y - m).normalize(), e[1]
								.setComponents(o + n, l + s, f + u, y + m).normalize(), e[2]
								.setComponents(o + r, l + c, f + p, y + g).normalize(), e[3]
								.setComponents(o - r, l - c, f - p, y - g).normalize(), e[4]
								.setComponents(o - a, l - h, f - d, y - v).normalize(), e[5]
								.setComponents(o + a, l + h, f + d, y + v).normalize(), this
						},
						intersectsObject: (Ai = new Ni, function (t) {
							var e = t.geometry;
							return null === e.boundingSphere && e.computeBoundingSphere(), Ai.copy(e
									.boundingSphere).applyMatrix4(t.matrixWorld), this
								.intersectsSphere(Ai)
						}),
						intersectsSprite: (Ti = new Ni, function (t) {
							return Ti.center.set(0, 0, 0), Ti.radius = .7071067811865476, Ti
								.applyMatrix4(t.matrixWorld), this.intersectsSphere(Ti)
						}),
						intersectsSphere: function (t) {
							for (var e = this.planes, i = t.center, n = -t.radius, r = 0; r < 6; r++) {
								if (e[r].distanceToPoint(i) < n) return !1
							}
							return !0
						},
						intersectsBox: (Ei = new li, function (t) {
							for (var e = this.planes, i = 0; i < 6; i++) {
								var n = e[i];
								if (Ei.x = 0 < n.normal.x ? t.max.x : t.min.x, Ei.y = 0 < n.normal.y ?
									t.max.y : t.min.y, Ei.z = 0 < n.normal.z ? t.max.z : t.min.z, n
									.distanceToPoint(Ei) < 0) return !1
							}
							return !0
						}),
						containsPoint: function (t) {
							for (var e = this.planes, i = 0; i < 6; i++)
								if (e[i].distanceToPoint(t) < 0) return !1;
							return !0
						}
					});
				var Gi = {
					alphamap_fragment: "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif",
					alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
					alphatest_fragment: "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif",
					aomap_fragment: "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif",
					aomap_pars_fragment: "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
					begin_vertex: "vec3 transformed = vec3( position );",
					beginnormal_vertex: "vec3 objectNormal = vec3( normal );",
					bsdfs: "float punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n#else\n\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t}\n\treturn 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE  = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS  = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n\treturn specularColor * AB.x + AB.y;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}",
					bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tfDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",
					clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\tif ( clipped ) discard;\n\t#endif\n#endif",
					clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n\t#if ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )\n\t\tvarying vec3 vViewPosition;\n\t#endif\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",
					clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )\n\tvarying vec3 vViewPosition;\n#endif",
					clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif",
					color_fragment: "#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif",
					color_pars_fragment: "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif",
					color_pars_vertex: "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif",
					color_vertex: "#ifdef USE_COLOR\n\tvColor.xyz = color.xyz;\n#endif",
					common: "#define PI 3.14159265359\n#define PI2 6.28318530718\n#define PI_HALF 1.5707963267949\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}",
					cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_textureSize (1024.0)\nint getFaceFromDirection(vec3 direction) {\n\tvec3 absDirection = abs(direction);\n\tint face = -1;\n\tif( absDirection.x > absDirection.z ) {\n\t\tif(absDirection.x > absDirection.y )\n\t\t\tface = direction.x > 0.0 ? 0 : 3;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\telse {\n\t\tif(absDirection.z > absDirection.y )\n\t\t\tface = direction.z > 0.0 ? 2 : 5;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\treturn face;\n}\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\n\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\n\tfloat dxRoughness = dFdx(roughness);\n\tfloat dyRoughness = dFdy(roughness);\n\tvec3 dx = dFdx( vec * scale * dxRoughness );\n\tvec3 dy = dFdy( vec * scale * dyRoughness );\n\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\n\td = clamp(d, 1.0, cubeUV_rangeClamp);\n\tfloat mipLevel = 0.5 * log2(d);\n\treturn vec2(floor(mipLevel), fract(mipLevel));\n}\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\n\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\n\tfloat a = 16.0 * cubeUV_rcpTextureSize;\n\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\n\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\n\tfloat powScale = exp2_packed.x * exp2_packed.y;\n\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\n\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\n\tbool bRes = mipLevel == 0.0;\n\tscale =  bRes && (scale < a) ? a : scale;\n\tvec3 r;\n\tvec2 offset;\n\tint face = getFaceFromDirection(direction);\n\tfloat rcpPowScale = 1.0 / powScale;\n\tif( face == 0) {\n\t\tr = vec3(direction.x, -direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 1) {\n\t\tr = vec3(direction.y, direction.x, direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 2) {\n\t\tr = vec3(direction.z, direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 3) {\n\t\tr = vec3(direction.x, direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse if( face == 4) {\n\t\tr = vec3(direction.y, direction.x, -direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse {\n\t\tr = vec3(direction.z, -direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\tr = normalize(r);\n\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\n\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\n\tvec2 base = offset + vec2( texelOffset );\n\treturn base + s * ( scale - 2.0 * texelOffset );\n}\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\nvec4 textureCubeUV( sampler2D envMap, vec3 reflectedDirection, float roughness ) {\n\tfloat roughnessVal = roughness* cubeUV_maxLods3;\n\tfloat r1 = floor(roughnessVal);\n\tfloat r2 = r1 + 1.0;\n\tfloat t = fract(roughnessVal);\n\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\n\tfloat s = mipInfo.y;\n\tfloat level0 = mipInfo.x;\n\tfloat level1 = level0 + 1.0;\n\tlevel1 = level1 > 5.0 ? 5.0 : level1;\n\tlevel0 += min( floor( s + 0.5 ), 5.0 );\n\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\n\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\n\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\n\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\n\tvec4 result = mix(color10, color20, t);\n\treturn vec4(result.rgb, 1.0);\n}\n#endif",
					defaultnormal_vertex: "vec3 transformedNormal = normalMatrix * objectNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif",
					displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",
					displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\n#endif",
					emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",
					emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",
					encodings_fragment: "gl_FragColor = linearToOutputTexel( gl_FragColor );",
					encodings_pars_fragment: "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = min( floor( D ) / 255.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n\tvec3 Xp_Y_XYZp = value.rgb * cLogLuvM;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}",
					envmap_fragment: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\tvec2 sampleUV;\n\t\treflectVec = normalize( reflectVec );\n\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\treflectVec = normalize( reflectVec );\n\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\tenvColor = envMapTexelToLinear( envColor );\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",
					envmap_pars_fragment: "#if defined( USE_ENVMAP ) || defined( PHYSICAL )\n\tuniform float reflectivity;\n\tuniform float envMapIntensity;\n#endif\n#ifdef USE_ENVMAP\n\t#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\n\t\tvarying vec3 vWorldPosition;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",
					envmap_pars_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",
					envmap_physical_pars_fragment: "#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, queryVec, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent ));\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\t\tvec2 sampleUV;\n\t\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif",
					envmap_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",
					fog_vertex: "#ifdef USE_FOG\n\tfogDepth = -mvPosition.z;\n#endif",
					fog_pars_vertex: "#ifdef USE_FOG\n\tvarying float fogDepth;\n#endif",
					fog_fragment: "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 ) );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",
					fog_pars_fragment: "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",
					gradientmap_pars_fragment: "#ifdef TOON\n\tuniform sampler2D gradientMap;\n\tvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\t\tfloat dotNL = dot( normal, lightDirection );\n\t\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t\t#ifdef USE_GRADIENTMAP\n\t\t\treturn texture2D( gradientMap, coord ).rgb;\n\t\t#else\n\t\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t\t#endif\n\t}\n#endif",
					lightmap_fragment: "#ifdef USE_LIGHTMAP\n\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n#endif",
					lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
					lights_lambert_vertex: "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvLightFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n#endif",
					lights_pars_begin: "uniform vec3 ambientLightColor;\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t\tfloat shadowCameraNear;\n\t\tfloat shadowCameraFar;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif",
					lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",
					lights_phong_pars_fragment: "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifdef TOON\n\t\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#else\n\t\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\t\tvec3 irradiance = dotNL * directLight.color;\n\t#endif\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)",
					lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\n#ifdef STANDARD\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.clearCoat = saturate( clearCoat );\tmaterial.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\n#endif",
					lights_physical_pars_fragment: "struct PhysicalMaterial {\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n\t#ifndef STANDARD\n\t\tfloat clearCoat;\n\t\tfloat clearCoatRoughness;\n\t#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearCoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifndef STANDARD\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\n\treflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\t#ifndef STANDARD\n\t\treflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifndef STANDARD\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\tfloat dotNL = dotNV;\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.indirectSpecular += ( 1.0 - clearCoatDHR ) * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\n\t#ifndef STANDARD\n\t\treflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",
					lights_fragment_begin: "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = normalize( vViewPosition );\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearCoatRadiance = vec3( 0.0 );\n#endif",
					lights_fragment_maps: "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tirradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), maxMipLevel );\n\t#ifndef STANDARD\n\t\tclearCoatRadiance += getLightProbeIndirectRadiance( geometry, Material_ClearCoat_BlinnShininessExponent( material ), maxMipLevel );\n\t#endif\n#endif",
					lights_fragment_end: "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, clearCoatRadiance, geometry, material, reflectedLight );\n#endif",
					logdepthbuf_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",
					logdepthbuf_pars_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n#endif",
					logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif",
					logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t#else\n\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\tgl_Position.z *= gl_Position.w;\n\t#endif\n#endif",
					map_fragment: "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif",
					map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",
					map_particle_fragment: "#ifdef USE_MAP\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif",
					map_particle_pars_fragment: "#ifdef USE_MAP\n\tuniform mat3 uvTransform;\n\tuniform sampler2D map;\n#endif",
					metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",
					metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
					morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n#endif",
					morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n\t#ifndef USE_MORPHNORMALS\n\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif",
					morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\t#endif\n#endif",
					normal_fragment_begin: "#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n#endif",
					normal_fragment_maps: "#ifdef USE_NORMALMAP\n\t#ifdef OBJECTSPACE_NORMALMAP\n\t\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\t#ifdef FLIP_SIDED\n\t\t\tnormal = - normal;\n\t\t#endif\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#endif\n\t\tnormal = normalize( normalMatrix * normal );\n\t#else\n\t\tnormal = perturbNormal2Arb( -vViewPosition, normal );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif",
					normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n\t#ifdef OBJECTSPACE_NORMALMAP\n\t\tuniform mat3 normalMatrix;\n\t#else\n\t\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\t\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\t\tvec2 st0 = dFdx( vUv.st );\n\t\t\tvec2 st1 = dFdy( vUv.st );\n\t\t\tfloat scale = sign( st1.t * st0.s - st0.t * st1.s );\n\t\t\tvec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\n\t\t\tvec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\n\t\t\tvec3 N = normalize( surf_norm );\n\t\t\tmat3 tsn = mat3( S, T, N );\n\t\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\t\tmapN.xy *= normalScale;\n\t\t\tmapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t\treturn normalize( tsn * mapN );\n\t\t}\n\t#endif\n#endif",
					packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}",
					premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",
					project_vertex: "vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\ngl_Position = projectionMatrix * mvPosition;",
					dithering_fragment: "#if defined( DITHERING )\n  gl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",
					dithering_pars_fragment: "#if defined( DITHERING )\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",
					roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",
					roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
					shadowmap_pars_fragment: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n\t\tconst vec2 offset = vec2( 0.0, 1.0 );\n\t\tvec2 texelSize = vec2( 1.0 ) / size;\n\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\n\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n\t\tvec2 f = fract( uv * size + 0.5 );\n\t\tfloat a = mix( lb, lt, f.y );\n\t\tfloat b = mix( rb, rt, f.y );\n\t\tfloat c = mix( a, b, f.x );\n\t\treturn c;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif",
					shadowmap_pars_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n#endif",
					shadowmap_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n#endif",
					shadowmask_pars_fragment: "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tDirectionalLight directionalLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tshadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tSpotLight spotLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tshadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tPointLight pointLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tshadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#endif\n\t#endif\n\treturn shadow;\n}",
					skinbase_vertex: "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
					skinning_pars_vertex: "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif",
					skinning_vertex: "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",
					skinnormal_vertex: "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n#endif",
					specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
					specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
					tonemapping_fragment: "#if defined( TONE_MAPPING )\n  gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",
					tonemapping_pars_fragment: "#ifndef saturate\n\t#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( ( color * ( 2.51 * color + 0.03 ) ) / ( color * ( 2.43 * color + 0.59 ) + 0.14 ) );\n}",
					uv_pars_fragment: "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n#endif",
					uv_pars_vertex: "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n\tuniform mat3 uvTransform;\n#endif",
					uv_vertex: "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif",
					uv2_pars_fragment: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif",
					uv2_pars_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n#endif",
					uv2_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = uv2;\n#endif",
					worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n#endif",
					background_frag: "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
					background_vert: "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",
					cube_frag: "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldDirection;\nvoid main() {\n\tvec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
					cube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
					depth_frag: "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - gl_FragCoord.z ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\n\t#endif\n}",
					depth_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}",
					distanceRGBA_frag: "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",
					distanceRGBA_vert: "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",
					equirect_frag: "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV;\n\tsampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
					equirect_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",
					linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
					linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\tvLineDistance = scale * lineDistance;\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
					meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\treflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
					meshbasic_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",
					meshlambert_frag: "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
					meshlambert_vert: "#define LAMBERT\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
					meshmatcap_frag: "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
					meshmatcap_vert: "#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#ifndef FLAT_SHADED\n\t\tvNormal = normalize( transformedNormal );\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",
					meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
					meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
					meshphysical_frag: "#define PHYSICAL\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifndef STANDARD\n\tuniform float clearCoat;\n\tuniform float clearCoatRoughness;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
					meshphysical_vert: "#define PHYSICAL\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
					normal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\nvoid main() {\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}",
					normal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",
					points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
					points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",
					shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <fog_fragment>\n}",
					shadow_vert: "#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
					sprite_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
					sprite_vert: "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}"
				};

				function Fi(t) {
					var e = {};
					for (var i in t)
						for (var n in e[i] = {}, t[i]) {
							var r = t[i][n];
							r && (r.isColor || r.isMatrix3 || r.isMatrix4 || r.isVector2 || r.isVector3 || r
									.isVector4 || r.isTexture) ? e[i][n] = r.clone() : Array.isArray(r) ? e[i][
								n] = r.slice() : e[i][n] = r
						}
					return e
				}

				function Hi(t) {
					for (var e = {}, i = 0; i < t.length; i++) {
						var n = Fi(t[i]);
						for (var r in n) e[r] = n[r]
					}
					return e
				}
				var ki, ji, Vi, Wi = {
						clone: Fi,
						merge: Hi
					},
					qi = {
						aliceblue: 15792383,
						antiquewhite: 16444375,
						aqua: 65535,
						aquamarine: 8388564,
						azure: 15794175,
						beige: 16119260,
						bisque: 16770244,
						black: 0,
						blanchedalmond: 16772045,
						blue: 255,
						blueviolet: 9055202,
						brown: 10824234,
						burlywood: 14596231,
						cadetblue: 6266528,
						chartreuse: 8388352,
						chocolate: 13789470,
						coral: 16744272,
						cornflowerblue: 6591981,
						cornsilk: 16775388,
						crimson: 14423100,
						cyan: 65535,
						darkblue: 139,
						darkcyan: 35723,
						darkgoldenrod: 12092939,
						darkgray: 11119017,
						darkgreen: 25600,
						darkgrey: 11119017,
						darkkhaki: 12433259,
						darkmagenta: 9109643,
						darkolivegreen: 5597999,
						darkorange: 16747520,
						darkorchid: 10040012,
						darkred: 9109504,
						darksalmon: 15308410,
						darkseagreen: 9419919,
						darkslateblue: 4734347,
						darkslategray: 3100495,
						darkslategrey: 3100495,
						darkturquoise: 52945,
						darkviolet: 9699539,
						deeppink: 16716947,
						deepskyblue: 49151,
						dimgray: 6908265,
						dimgrey: 6908265,
						dodgerblue: 2003199,
						firebrick: 11674146,
						floralwhite: 16775920,
						forestgreen: 2263842,
						fuchsia: 16711935,
						gainsboro: 14474460,
						ghostwhite: 16316671,
						gold: 16766720,
						goldenrod: 14329120,
						gray: 8421504,
						green: 32768,
						greenyellow: 11403055,
						grey: 8421504,
						honeydew: 15794160,
						hotpink: 16738740,
						indianred: 13458524,
						indigo: 4915330,
						ivory: 16777200,
						khaki: 15787660,
						lavender: 15132410,
						lavenderblush: 16773365,
						lawngreen: 8190976,
						lemonchiffon: 16775885,
						lightblue: 11393254,
						lightcoral: 15761536,
						lightcyan: 14745599,
						lightgoldenrodyellow: 16448210,
						lightgray: 13882323,
						lightgreen: 9498256,
						lightgrey: 13882323,
						lightpink: 16758465,
						lightsalmon: 16752762,
						lightseagreen: 2142890,
						lightskyblue: 8900346,
						lightslategray: 7833753,
						lightslategrey: 7833753,
						lightsteelblue: 11584734,
						lightyellow: 16777184,
						lime: 65280,
						limegreen: 3329330,
						linen: 16445670,
						magenta: 16711935,
						maroon: 8388608,
						mediumaquamarine: 6737322,
						mediumblue: 205,
						mediumorchid: 12211667,
						mediumpurple: 9662683,
						mediumseagreen: 3978097,
						mediumslateblue: 8087790,
						mediumspringgreen: 64154,
						mediumturquoise: 4772300,
						mediumvioletred: 13047173,
						midnightblue: 1644912,
						mintcream: 16121850,
						mistyrose: 16770273,
						moccasin: 16770229,
						navajowhite: 16768685,
						navy: 128,
						oldlace: 16643558,
						olive: 8421376,
						olivedrab: 7048739,
						orange: 16753920,
						orangered: 16729344,
						orchid: 14315734,
						palegoldenrod: 15657130,
						palegreen: 10025880,
						paleturquoise: 11529966,
						palevioletred: 14381203,
						papayawhip: 16773077,
						peachpuff: 16767673,
						peru: 13468991,
						pink: 16761035,
						plum: 14524637,
						powderblue: 11591910,
						purple: 8388736,
						rebeccapurple: 6697881,
						red: 16711680,
						rosybrown: 12357519,
						royalblue: 4286945,
						saddlebrown: 9127187,
						salmon: 16416882,
						sandybrown: 16032864,
						seagreen: 3050327,
						seashell: 16774638,
						sienna: 10506797,
						silver: 12632256,
						skyblue: 8900331,
						slateblue: 6970061,
						slategray: 7372944,
						slategrey: 7372944,
						snow: 16775930,
						springgreen: 65407,
						steelblue: 4620980,
						tan: 13808780,
						teal: 32896,
						thistle: 14204888,
						tomato: 16737095,
						turquoise: 4251856,
						violet: 15631086,
						wheat: 16113331,
						white: 16777215,
						whitesmoke: 16119285,
						yellow: 16776960,
						yellowgreen: 10145074
					};

				function Xi(t, e, i) {
					return void 0 === e && void 0 === i ? this.set(t) : this.setRGB(t, e, i)
				}
				Object.assign(Xi.prototype, {
					isColor: !0,
					r: 1,
					g: 1,
					b: 1,
					set: function (t) {
						return t && t.isColor ? this.copy(t) : "number" == typeof t ? this.setHex(t) :
							"string" == typeof t && this.setStyle(t), this
					},
					setScalar: function (t) {
						return this.r = t, this.g = t, this.b = t, this
					},
					setHex: function (t) {
						return t = Math.floor(t), this.r = (t >> 16 & 255) / 255, this.g = (t >> 8 &
							255) / 255, this.b = (255 & t) / 255, this
					},
					setRGB: function (t, e, i) {
						return this.r = t, this.g = e, this.b = i, this
					},
					setHSL: function () {
						function a(t, e, i) {
							return i < 0 && (i += 1), 1 < i && (i -= 1), i < 1 / 6 ? t + 6 * (e - t) *
								i : i < .5 ? e : i < 2 / 3 ? t + 6 * (e - t) * (2 / 3 - i) : t
						}
						return function (t, e, i) {
							if (t = oi.euclideanModulo(t, 1), e = oi.clamp(e, 0, 1), i = oi.clamp(
									i, 0, 1), 0 === e) this.r = this.g = this.b = i;
							else {
								var n = i <= .5 ? i * (1 + e) : i + e - i * e,
									r = 2 * i - n;
								this.r = a(r, n, t + 1 / 3), this.g = a(r, n, t), this.b = a(r, n,
									t - 1 / 3)
							}
							return this
						}
					}(),
					setStyle: function (e) {
						function t(t) {
							void 0 !== t && parseFloat(t) < 1 && console.warn(
								"THREE.Color: Alpha component of " + e + " will be ignored.")
						}
						var i;
						if (i = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(e)) {
							var n, r = i[1],
								a = i[2];
							switch (r) {
								case "rgb":
								case "rgba":
									if (n =
										/^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/
										.exec(a)) return this.r = Math.min(255, parseInt(n[1], 10)) /
										255, this.g = Math.min(255, parseInt(n[2], 10)) / 255,
										this.b = Math.min(255, parseInt(n[3], 10)) / 255, t(n[5]),
										this;
									if (n =
										/^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/
										.exec(a)) return this.r = Math.min(100, parseInt(n[1], 10)) /
										100, this.g = Math.min(100, parseInt(n[2], 10)) / 100,
										this.b = Math.min(100, parseInt(n[3], 10)) / 100, t(n[5]),
										this;
									break;
								case "hsl":
								case "hsla":
									if (n =
										/^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/
										.exec(a)) {
										var o = parseFloat(n[1]) / 360,
											s = parseInt(n[2], 10) / 100,
											c = parseInt(n[3], 10) / 100;
										return t(n[5]), this.setHSL(o, s, c)
									}
							}
						} else if (i = /^\#([A-Fa-f0-9]+)$/.exec(e)) {
							var h, l = (h = i[1]).length;
							if (3 === l) return this.r = parseInt(h.charAt(0) + h.charAt(0), 16) /
								255, this.g = parseInt(h.charAt(1) + h.charAt(1), 16) / 255, this
								.b = parseInt(h.charAt(2) + h.charAt(2), 16) / 255, this;
							if (6 === l) return this.r = parseInt(h.charAt(0) + h.charAt(1), 16) /
								255, this.g = parseInt(h.charAt(2) + h.charAt(3), 16) / 255, this
								.b = parseInt(h.charAt(4) + h.charAt(5), 16) / 255, this
						}
						e && 0 < e.length && (void 0 !== (h = qi[e]) ? this.setHex(h) : console.warn(
							"THREE.Color: Unknown color " + e));
						return this
					},
					clone: function () {
						return new this.constructor(this.r, this.g, this.b)
					},
					copy: function (t) {
						return this.r = t.r, this.g = t.g, this.b = t.b, this
					},
					copyGammaToLinear: function (t, e) {
						return void 0 === e && (e = 2), this.r = Math.pow(t.r, e), this.g = Math.pow(t
							.g, e), this.b = Math.pow(t.b, e), this
					},
					copyLinearToGamma: function (t, e) {
						void 0 === e && (e = 2);
						var i = 0 < e ? 1 / e : 1;
						return this.r = Math.pow(t.r, i), this.g = Math.pow(t.g, i), this.b = Math
							.pow(t.b, i), this
					},
					convertGammaToLinear: function (t) {
						return this.copyGammaToLinear(this, t), this
					},
					convertLinearToGamma: function (t) {
						return this.copyLinearToGamma(this, t), this
					},
					copySRGBToLinear: function () {
						function e(t) {
							return t < .04045 ? .0773993808 * t : Math.pow(.9478672986 * t +
								.0521327014, 2.4)
						}
						return function (t) {
							return this.r = e(t.r), this.g = e(t.g), this.b = e(t.b), this
						}
					}(),
					copyLinearToSRGB: function () {
						function e(t) {
							return t < .0031308 ? 12.92 * t : 1.055 * Math.pow(t, .41666) - .055
						}
						return function (t) {
							return this.r = e(t.r), this.g = e(t.g), this.b = e(t.b), this
						}
					}(),
					convertSRGBToLinear: function () {
						return this.copySRGBToLinear(this), this
					},
					convertLinearToSRGB: function () {
						return this.copyLinearToSRGB(this), this
					},
					getHex: function () {
						return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0
					},
					getHexString: function () {
						return ("000000" + this.getHex().toString(16)).slice(-6)
					},
					getHSL: function (t) {
						void 0 === t && (console.warn(
							"THREE.Color: .getHSL() target is now required"), t = {
								h: 0,
								s: 0,
								l: 0
							});
						var e, i, n = this.r,
							r = this.g,
							a = this.b,
							o = Math.max(n, r, a),
							s = Math.min(n, r, a),
							c = (s + o) / 2;
						if (s === o) i = e = 0;
						else {
							var h = o - s;
							switch (i = c <= .5 ? h / (o + s) : h / (2 - o - s), o) {
								case n:
									e = (r - a) / h + (r < a ? 6 : 0);
									break;
								case r:
									e = (a - n) / h + 2;
									break;
								case a:
									e = (n - r) / h + 4
							}
							e /= 6
						}
						return t.h = e, t.s = i, t.l = c, t
					},
					getStyle: function () {
						return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 *
							this.b | 0) + ")"
					},
					offsetHSL: (Vi = {}, function (t, e, i) {
						return this.getHSL(Vi), Vi.h += t, Vi.s += e, Vi.l += i, this.setHSL(Vi.h,
							Vi.s, Vi.l), this
					}),
					add: function (t) {
						return this.r += t.r, this.g += t.g, this.b += t.b, this
					},
					addColors: function (t, e) {
						return this.r = t.r + e.r, this.g = t.g + e.g, this.b = t.b + e.b, this
					},
					addScalar: function (t) {
						return this.r += t, this.g += t, this.b += t, this
					},
					sub: function (t) {
						return this.r = Math.max(0, this.r - t.r), this.g = Math.max(0, this.g - t.g),
							this.b = Math.max(0, this.b - t.b), this
					},
					multiply: function (t) {
						return this.r *= t.r, this.g *= t.g, this.b *= t.b, this
					},
					multiplyScalar: function (t) {
						return this.r *= t, this.g *= t, this.b *= t, this
					},
					lerp: function (t, e) {
						return this.r += (t.r - this.r) * e, this.g += (t.g - this.g) * e, this.b += (
							t.b - this.b) * e, this
					},
					lerpHSL: (ki = {
						h: 0,
						s: 0,
						l: 0
					}, ji = {
						h: 0,
						s: 0,
						l: 0
					}, function (t, e) {
						this.getHSL(ki), t.getHSL(ji);
						var i = oi.lerp(ki.h, ji.h, e),
							n = oi.lerp(ki.s, ji.s, e),
							r = oi.lerp(ki.l, ji.l, e);
						return this.setHSL(i, n, r), this
					}),
					equals: function (t) {
						return t.r === this.r && t.g === this.g && t.b === this.b
					},
					fromArray: function (t, e) {
						return void 0 === e && (e = 0), this.r = t[e], this.g = t[e + 1], this.b = t[
							e + 2], this
					},
					toArray: function (t, e) {
						return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this.r, t[e +
							1] = this.g, t[e + 2] = this.b, t
					},
					toJSON: function () {
						return this.getHex()
					}
				});
				var Yi, Ji, Zi = {
						common: {
							diffuse: {
								value: new Xi(15658734)
							},
							opacity: {
								value: 1
							},
							map: {
								value: null
							},
							uvTransform: {
								value: new ui
							},
							alphaMap: {
								value: null
							}
						},
						specularmap: {
							specularMap: {
								value: null
							}
						},
						envmap: {
							envMap: {
								value: null
							},
							flipEnvMap: {
								value: -1
							},
							reflectivity: {
								value: 1
							},
							refractionRatio: {
								value: .98
							},
							maxMipLevel: {
								value: 0
							}
						},
						aomap: {
							aoMap: {
								value: null
							},
							aoMapIntensity: {
								value: 1
							}
						},
						lightmap: {
							lightMap: {
								value: null
							},
							lightMapIntensity: {
								value: 1
							}
						},
						emissivemap: {
							emissiveMap: {
								value: null
							}
						},
						bumpmap: {
							bumpMap: {
								value: null
							},
							bumpScale: {
								value: 1
							}
						},
						normalmap: {
							normalMap: {
								value: null
							},
							normalScale: {
								value: new si(1, 1)
							}
						},
						displacementmap: {
							displacementMap: {
								value: null
							},
							displacementScale: {
								value: 1
							},
							displacementBias: {
								value: 0
							}
						},
						roughnessmap: {
							roughnessMap: {
								value: null
							}
						},
						metalnessmap: {
							metalnessMap: {
								value: null
							}
						},
						gradientmap: {
							gradientMap: {
								value: null
							}
						},
						fog: {
							fogDensity: {
								value: 25e-5
							},
							fogNear: {
								value: 1
							},
							fogFar: {
								value: 2e3
							},
							fogColor: {
								value: new Xi(16777215)
							}
						},
						lights: {
							ambientLightColor: {
								value: []
							},
							directionalLights: {
								value: [],
								properties: {
									direction: {},
									color: {},
									shadow: {},
									shadowBias: {},
									shadowRadius: {},
									shadowMapSize: {}
								}
							},
							directionalShadowMap: {
								value: []
							},
							directionalShadowMatrix: {
								value: []
							},
							spotLights: {
								value: [],
								properties: {
									color: {},
									position: {},
									direction: {},
									distance: {},
									coneCos: {},
									penumbraCos: {},
									decay: {},
									shadow: {},
									shadowBias: {},
									shadowRadius: {},
									shadowMapSize: {}
								}
							},
							spotShadowMap: {
								value: []
							},
							spotShadowMatrix: {
								value: []
							},
							pointLights: {
								value: [],
								properties: {
									color: {},
									position: {},
									decay: {},
									distance: {},
									shadow: {},
									shadowBias: {},
									shadowRadius: {},
									shadowMapSize: {},
									shadowCameraNear: {},
									shadowCameraFar: {}
								}
							},
							pointShadowMap: {
								value: []
							},
							pointShadowMatrix: {
								value: []
							},
							hemisphereLights: {
								value: [],
								properties: {
									direction: {},
									skyColor: {},
									groundColor: {}
								}
							},
							rectAreaLights: {
								value: [],
								properties: {
									color: {},
									position: {},
									width: {},
									height: {}
								}
							}
						},
						points: {
							diffuse: {
								value: new Xi(15658734)
							},
							opacity: {
								value: 1
							},
							size: {
								value: 1
							},
							scale: {
								value: 1
							},
							map: {
								value: null
							},
							uvTransform: {
								value: new ui
							}
						},
						sprite: {
							diffuse: {
								value: new Xi(15658734)
							},
							opacity: {
								value: 1
							},
							center: {
								value: new si(.5, .5)
							},
							rotation: {
								value: 0
							},
							map: {
								value: null
							},
							uvTransform: {
								value: new ui
							}
						}
					},
					Qi = {
						basic: {
							uniforms: Hi([Zi.common, Zi.specularmap, Zi.envmap, Zi.aomap, Zi.lightmap, Zi.fog]),
							vertexShader: Gi.meshbasic_vert,
							fragmentShader: Gi.meshbasic_frag
						},
						lambert: {
							uniforms: Hi([Zi.common, Zi.specularmap, Zi.envmap, Zi.aomap, Zi.lightmap, Zi
								.emissivemap, Zi.fog, Zi.lights, {
									emissive: {
										value: new Xi(0)
									}
								}
							]),
							vertexShader: Gi.meshlambert_vert,
							fragmentShader: Gi.meshlambert_frag
						},
						phong: {
							uniforms: Hi([Zi.common, Zi.specularmap, Zi.envmap, Zi.aomap, Zi.lightmap, Zi
								.emissivemap, Zi.bumpmap, Zi.normalmap, Zi.displacementmap, Zi
								.gradientmap, Zi.fog, Zi.lights, {
									emissive: {
										value: new Xi(0)
									},
									specular: {
										value: new Xi(1118481)
									},
									shininess: {
										value: 30
									}
								}
							]),
							vertexShader: Gi.meshphong_vert,
							fragmentShader: Gi.meshphong_frag
						},
						standard: {
							uniforms: Hi([Zi.common, Zi.envmap, Zi.aomap, Zi.lightmap, Zi.emissivemap, Zi.bumpmap,
								Zi.normalmap, Zi.displacementmap, Zi.roughnessmap, Zi.metalnessmap, Zi
								.fog, Zi.lights, {
									emissive: {
										value: new Xi(0)
									},
									roughness: {
										value: .5
									},
									metalness: {
										value: .5
									},
									envMapIntensity: {
										value: 1
									}
								}
							]),
							vertexShader: Gi.meshphysical_vert,
							fragmentShader: Gi.meshphysical_frag
						},
						matcap: {
							uniforms: Hi([Zi.common, Zi.bumpmap, Zi.normalmap, Zi.displacementmap, Zi.fog, {
								matcap: {
									value: null
								}
							}]),
							vertexShader: Gi.meshmatcap_vert,
							fragmentShader: Gi.meshmatcap_frag
						},
						points: {
							uniforms: Hi([Zi.points, Zi.fog]),
							vertexShader: Gi.points_vert,
							fragmentShader: Gi.points_frag
						},
						dashed: {
							uniforms: Hi([Zi.common, Zi.fog, {
								scale: {
									value: 1
								},
								dashSize: {
									value: 1
								},
								totalSize: {
									value: 2
								}
							}]),
							vertexShader: Gi.linedashed_vert,
							fragmentShader: Gi.linedashed_frag
						},
						depth: {
							uniforms: Hi([Zi.common, Zi.displacementmap]),
							vertexShader: Gi.depth_vert,
							fragmentShader: Gi.depth_frag
						},
						normal: {
							uniforms: Hi([Zi.common, Zi.bumpmap, Zi.normalmap, Zi.displacementmap, {
								opacity: {
									value: 1
								}
							}]),
							vertexShader: Gi.normal_vert,
							fragmentShader: Gi.normal_frag
						},
						sprite: {
							uniforms: Hi([Zi.sprite, Zi.fog]),
							vertexShader: Gi.sprite_vert,
							fragmentShader: Gi.sprite_frag
						},
						background: {
							uniforms: {
								uvTransform: {
									value: new ui
								},
								t2D: {
									value: null
								}
							},
							vertexShader: Gi.background_vert,
							fragmentShader: Gi.background_frag
						},
						cube: {
							uniforms: {
								tCube: {
									value: null
								},
								tFlip: {
									value: -1
								},
								opacity: {
									value: 1
								}
							},
							vertexShader: Gi.cube_vert,
							fragmentShader: Gi.cube_frag
						},
						equirect: {
							uniforms: {
								tEquirect: {
									value: null
								}
							},
							vertexShader: Gi.equirect_vert,
							fragmentShader: Gi.equirect_frag
						},
						distanceRGBA: {
							uniforms: Hi([Zi.common, Zi.displacementmap, {
								referencePosition: {
									value: new li
								},
								nearDistance: {
									value: 1
								},
								farDistance: {
									value: 1e3
								}
							}]),
							vertexShader: Gi.distanceRGBA_vert,
							fragmentShader: Gi.distanceRGBA_frag
						},
						shadow: {
							uniforms: Hi([Zi.lights, Zi.fog, {
								color: {
									value: new Xi(0)
								},
								opacity: {
									value: 1
								}
							}]),
							vertexShader: Gi.shadow_vert,
							fragmentShader: Gi.shadow_frag
						}
					};

				function Ki() {
					var i = null,
						n = !1,
						r = null;

					function a(t, e) {
						!1 !== n && (r(t, e), i.requestAnimationFrame(a))
					}
					return {
						start: function () {
							!0 !== n && null !== r && (i.requestAnimationFrame(a), n = !0)
						},
						stop: function () {
							n = !1
						},
						setAnimationLoop: function (t) {
							r = t
						},
						setContext: function (t) {
							i = t
						}
					}
				}

				function $i(o) {
					var n = new WeakMap;

					function r(t, e) {
						var i = t.array,
							n = t.dynamic ? 35048 : 35044,
							r = o.createBuffer();
						o.bindBuffer(e, r), o.bufferData(e, i, n), t.onUploadCallback();
						var a = 5126;
						return i instanceof Float32Array ? a = 5126 : i instanceof Float64Array ? console.warn(
								"THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.") :
							i instanceof Uint16Array ? a = 5123 : i instanceof Int16Array ? a = 5122 :
							i instanceof Uint32Array ? a = 5125 : i instanceof Int32Array ? a = 5124 :
							i instanceof Int8Array ? a = 5120 : i instanceof Uint8Array && (a = 5121), {
								buffer: r,
								type: a,
								bytesPerElement: i.BYTES_PER_ELEMENT,
								version: t.version
							}
					}

					function a(t, e, i) {
						var n = e.array,
							r = e.updateRange;
						o.bindBuffer(i, t), !1 === e.dynamic ? o.bufferData(i, n, 35044) : -1 === r.count ? o
							.bufferSubData(i, 0, n) : 0 === r.count ? console.error(
								"THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually."
								) : (o.bufferSubData(i, r.offset * n.BYTES_PER_ELEMENT, n.subarray(r.offset, r
								.offset + r.count)), r.count = -1)
					}

					function t(t) {
						return t.isInterleavedBufferAttribute && (t = t.data), n.get(t)
					}

					function e(t) {
						t.isInterleavedBufferAttribute && (t = t.data);
						var e = n.get(t);
						e && (o.deleteBuffer(e.buffer), n.delete(t))
					}

					function i(t, e) {
						t.isInterleavedBufferAttribute && (t = t.data);
						var i = n.get(t);
						void 0 === i ? n.set(t, r(t, e)) : i.version < t.version && (a(i.buffer, t, e), i
							.version = t.version)
					}
					return {
						get: t,
						remove: e,
						update: i
					}
				}

				function tn(t, e, i, n, r, a) {
					this.a = t, this.b = e, this.c = i, this.normal = n && n.isVector3 ? n : new li, this
						.vertexNormals = Array.isArray(n) ? n : [], this.color = r && r.isColor ? r : new Xi, this
						.vertexColors = Array.isArray(r) ? r : [], this.materialIndex = void 0 !== a ? a : 0
				}

				function en(t, e, i, n) {
					this._x = t || 0, this._y = e || 0, this._z = i || 0, this._order = n || en.DefaultOrder
				}

				function nn() {
					this.mask = 1
				}
				Qi.physical = {
						uniforms: Hi([Qi.standard.uniforms, {
							clearCoat: {
								value: 0
							},
							clearCoatRoughness: {
								value: 0
							}
						}]),
						vertexShader: Gi.meshphysical_vert,
						fragmentShader: Gi.meshphysical_frag
					}, Object.assign(tn.prototype, {
						clone: function () {
							return (new this.constructor).copy(this)
						},
						copy: function (t) {
							this.a = t.a, this.b = t.b, this.c = t.c, this.normal.copy(t.normal), this
								.color.copy(t.color), this.materialIndex = t.materialIndex;
							for (var e = 0, i = t.vertexNormals.length; e < i; e++) this.vertexNormals[
								e] = t.vertexNormals[e].clone();
							for (e = 0, i = t.vertexColors.length; e < i; e++) this.vertexColors[e] = t
								.vertexColors[e].clone();
							return this
						}
					}), en.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"], en.DefaultOrder = "XYZ",
					Object.defineProperties(en.prototype, {
						x: {
							get: function () {
								return this._x
							},
							set: function (t) {
								this._x = t, this.onChangeCallback()
							}
						},
						y: {
							get: function () {
								return this._y
							},
							set: function (t) {
								this._y = t, this.onChangeCallback()
							}
						},
						z: {
							get: function () {
								return this._z
							},
							set: function (t) {
								this._z = t, this.onChangeCallback()
							}
						},
						order: {
							get: function () {
								return this._order
							},
							set: function (t) {
								this._order = t, this.onChangeCallback()
							}
						}
					}), Object.assign(en.prototype, {
						isEuler: !0,
						set: function (t, e, i, n) {
							return this._x = t, this._y = e, this._z = i, this._order = n || this._order,
								this.onChangeCallback(), this
						},
						clone: function () {
							return new this.constructor(this._x, this._y, this._z, this._order)
						},
						copy: function (t) {
							return this._x = t._x, this._y = t._y, this._z = t._z, this._order = t._order,
								this.onChangeCallback(), this
						},
						setFromRotationMatrix: function (t, e, i) {
							var n = oi.clamp,
								r = t.elements,
								a = r[0],
								o = r[4],
								s = r[8],
								c = r[1],
								h = r[5],
								l = r[9],
								u = r[2],
								p = r[6],
								d = r[10];
							return "XYZ" === (e = e || this._order) ? (this._y = Math.asin(n(s, -1, 1)),
									Math.abs(s) < .99999 ? (this._x = Math.atan2(-l, d), this._z = Math
										.atan2(-o, a)) : (this._x = Math.atan2(p, h), this._z = 0)) :
								"YXZ" === e ? (this._x = Math.asin(-n(l, -1, 1)), Math.abs(l) < .99999 ? (
									this._y = Math.atan2(s, d), this._z = Math.atan2(c, h)) : (this
									._y = Math.atan2(-u, a), this._z = 0)) : "ZXY" === e ? (this._x = Math
									.asin(n(p, -1, 1)), Math.abs(p) < .99999 ? (this._y = Math.atan2(-u,
										d), this._z = Math.atan2(-o, h)) : (this._y = 0, this._z = Math
										.atan2(c, a))) : "ZYX" === e ? (this._y = Math.asin(-n(u, -1, 1)),
									Math.abs(u) < .99999 ? (this._x = Math.atan2(p, d), this._z = Math
										.atan2(c, a)) : (this._x = 0, this._z = Math.atan2(-o, h))) :
								"YZX" === e ? (this._z = Math.asin(n(c, -1, 1)), Math.abs(c) < .99999 ? (
									this._x = Math.atan2(-l, h), this._y = Math.atan2(-u, a)) : (this
									._x = 0, this._y = Math.atan2(s, d))) : "XZY" === e ? (this._z = Math
									.asin(-n(o, -1, 1)), Math.abs(o) < .99999 ? (this._x = Math.atan2(p,
										h), this._y = Math.atan2(s, a)) : (this._x = Math.atan2(-l, d),
										this._y = 0)) : console.warn(
									"THREE.Euler: .setFromRotationMatrix() given unsupported order: " + e
									), this._order = e, !1 !== i && this.onChangeCallback(), this
						},
						setFromQuaternion: (Ji = new ci, function (t, e, i) {
							return Ji.makeRotationFromQuaternion(t), this.setFromRotationMatrix(Ji, e,
								i)
						}),
						setFromVector3: function (t, e) {
							return this.set(t.x, t.y, t.z, e || this._order)
						},
						reorder: (Yi = new hi, function (t) {
							return Yi.setFromEuler(this), this.setFromQuaternion(Yi, t)
						}),
						equals: function (t) {
							return t._x === this._x && t._y === this._y && t._z === this._z && t
								._order === this._order
						},
						fromArray: function (t) {
							return this._x = t[0], this._y = t[1], this._z = t[2], void 0 !== t[3] && (
								this._order = t[3]), this.onChangeCallback(), this
						},
						toArray: function (t, e) {
							return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this._x, t[
								e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._order, t
						},
						toVector3: function (t) {
							return t ? t.set(this._x, this._y, this._z) : new li(this._x, this._y, this
								._z)
						},
						onChange: function (t) {
							return this.onChangeCallback = t, this
						},
						onChangeCallback: function () {}
					}), Object.assign(nn.prototype, {
						set: function (t) {
							this.mask = 1 << t | 0
						},
						enable: function (t) {
							this.mask |= 1 << t | 0
						},
						toggle: function (t) {
							this.mask ^= 1 << t | 0
						},
						disable: function (t) {
							this.mask &= ~(1 << t | 0)
						},
						test: function (t) {
							return 0 != (this.mask & t.mask)
						}
					});
				var rn, an, on, sn, cn, hn, ln, un, pn, dn, fn, mn, gn, vn, yn, xn, bn, wn, _n = 0;

				function Mn() {
					Object.defineProperty(this, "id", {
							value: _n++
						}), this.uuid = oi.generateUUID(), this.name = "", this.type = "Object3D", this.parent =
						null, this.children = [], this.up = Mn.DefaultUp.clone();
					var t = new li,
						e = new en,
						i = new hi,
						n = new li(1, 1, 1);

					function r() {
						i.setFromEuler(e, !1)
					}

					function a() {
						e.setFromQuaternion(i, void 0, !1)
					}
					e.onChange(r), i.onChange(a), Object.defineProperties(this, {
							position: {
								configurable: !0,
								enumerable: !0,
								value: t
							},
							rotation: {
								configurable: !0,
								enumerable: !0,
								value: e
							},
							quaternion: {
								configurable: !0,
								enumerable: !0,
								value: i
							},
							scale: {
								configurable: !0,
								enumerable: !0,
								value: n
							},
							modelViewMatrix: {
								value: new ci
							},
							normalMatrix: {
								value: new ui
							}
						}), this.matrix = new ci, this.matrixWorld = new ci, this.matrixAutoUpdate = Mn
						.DefaultMatrixAutoUpdate, this.matrixWorldNeedsUpdate = !1, this.layers = new nn, this
						.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0,
						this.renderOrder = 0, this.userData = {}
				}
				Mn.DefaultUp = new li(0, 1, 0), Mn.DefaultMatrixAutoUpdate = !0, Mn.prototype = Object.assign(
					Object.create(e.prototype), {
						constructor: Mn,
						isObject3D: !0,
						onBeforeRender: function () {},
						onAfterRender: function () {},
						applyMatrix: function (t) {
							this.matrix.multiplyMatrices(t, this.matrix), this.matrix.decompose(this
								.position, this.quaternion, this.scale)
						},
						applyQuaternion: function (t) {
							return this.quaternion.premultiply(t), this
						},
						setRotationFromAxisAngle: function (t, e) {
							this.quaternion.setFromAxisAngle(t, e)
						},
						setRotationFromEuler: function (t) {
							this.quaternion.setFromEuler(t, !0)
						},
						setRotationFromMatrix: function (t) {
							this.quaternion.setFromRotationMatrix(t)
						},
						setRotationFromQuaternion: function (t) {
							this.quaternion.copy(t)
						},
						rotateOnAxis: (wn = new hi, function (t, e) {
							return wn.setFromAxisAngle(t, e), this.quaternion.multiply(wn), this
						}),
						rotateOnWorldAxis: (bn = new hi, function (t, e) {
							return bn.setFromAxisAngle(t, e), this.quaternion.premultiply(bn), this
						}),
						rotateX: (xn = new li(1, 0, 0), function (t) {
							return this.rotateOnAxis(xn, t)
						}),
						rotateY: (yn = new li(0, 1, 0), function (t) {
							return this.rotateOnAxis(yn, t)
						}),
						rotateZ: (vn = new li(0, 0, 1), function (t) {
							return this.rotateOnAxis(vn, t)
						}),
						translateOnAxis: (gn = new li, function (t, e) {
							return gn.copy(t).applyQuaternion(this.quaternion), this.position.add(gn
								.multiplyScalar(e)), this
						}),
						translateX: (mn = new li(1, 0, 0), function (t) {
							return this.translateOnAxis(mn, t)
						}),
						translateY: (fn = new li(0, 1, 0), function (t) {
							return this.translateOnAxis(fn, t)
						}),
						translateZ: (dn = new li(0, 0, 1), function (t) {
							return this.translateOnAxis(dn, t)
						}),
						localToWorld: function (t) {
							return t.applyMatrix4(this.matrixWorld)
						},
						worldToLocal: (pn = new ci, function (t) {
							return t.applyMatrix4(pn.getInverse(this.matrixWorld))
						}),
						lookAt: (cn = new hi, hn = new ci, ln = new li, un = new li, function (t, e, i) {
							t.isVector3 ? ln.copy(t) : ln.set(t, e, i);
							var n = this.parent;
							this.updateWorldMatrix(!0, !1), un.setFromMatrixPosition(this
								.matrixWorld), this.isCamera || this.isLight ? hn.lookAt(un, ln, this
									.up) : hn.lookAt(ln, un, this.up), this.quaternion
								.setFromRotationMatrix(hn), n && (hn.extractRotation(n.matrixWorld),
									cn.setFromRotationMatrix(hn), this.quaternion.premultiply(cn
										.inverse()))
						}),
						add: function (t) {
							if (1 < arguments.length) {
								for (var e = 0; e < arguments.length; e++) this.add(arguments[e]);
								return this
							}
							return t === this ? console.error(
									"THREE.Object3D.add: object can't be added as a child of itself.", t
									) : t && t.isObject3D ? (null !== t.parent && t.parent.remove(t), t
									.parent = this, t.dispatchEvent({
										type: "added"
									}), this.children.push(t)) : console.error(
									"THREE.Object3D.add: object not an instance of THREE.Object3D.", t),
								this
						},
						remove: function (t) {
							if (1 < arguments.length) {
								for (var e = 0; e < arguments.length; e++) this.remove(arguments[e]);
								return this
							}
							var i = this.children.indexOf(t);
							return -1 !== i && (t.parent = null, t.dispatchEvent({
								type: "removed"
							}), this.children.splice(i, 1)), this
						},
						getObjectById: function (t) {
							return this.getObjectByProperty("id", t)
						},
						getObjectByName: function (t) {
							return this.getObjectByProperty("name", t)
						},
						getObjectByProperty: function (t, e) {
							if (this[t] === e) return this;
							for (var i = 0, n = this.children.length; i < n; i++) {
								var r = this.children[i].getObjectByProperty(t, e);
								if (void 0 !== r) return r
							}
						},
						getWorldPosition: function (t) {
							return void 0 === t && (console.warn(
									"THREE.Object3D: .getWorldPosition() target is now required"), t =
								new li), this.updateMatrixWorld(!0), t.setFromMatrixPosition(this
								.matrixWorld)
						},
						getWorldQuaternion: (on = new li, sn = new li, function (t) {
							return void 0 === t && (console.warn(
									"THREE.Object3D: .getWorldQuaternion() target is now required"
									), t = new hi), this.updateMatrixWorld(!0), this.matrixWorld
								.decompose(on, t, sn), t
						}),
						getWorldScale: (rn = new li, an = new hi, function (t) {
							return void 0 === t && (console.warn(
										"THREE.Object3D: .getWorldScale() target is now required"),
									t = new li), this.updateMatrixWorld(!0), this.matrixWorld
								.decompose(rn, an, t), t
						}),
						getWorldDirection: function (t) {
							void 0 === t && (console.warn(
									"THREE.Object3D: .getWorldDirection() target is now required"),
								t = new li), this.updateMatrixWorld(!0);
							var e = this.matrixWorld.elements;
							return t.set(e[8], e[9], e[10]).normalize()
						},
						raycast: function () {},
						traverse: function (t) {
							t(this);
							for (var e = this.children, i = 0, n = e.length; i < n; i++) e[i].traverse(t)
						},
						traverseVisible: function (t) {
							if (!1 !== this.visible) {
								t(this);
								for (var e = this.children, i = 0, n = e.length; i < n; i++) e[i]
									.traverseVisible(t)
							}
						},
						traverseAncestors: function (t) {
							var e = this.parent;
							null !== e && (t(e), e.traverseAncestors(t))
						},
						updateMatrix: function () {
							this.matrix.compose(this.position, this.quaternion, this.scale), this
								.matrixWorldNeedsUpdate = !0
						},
						updateMatrixWorld: function (t) {
							this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate ||
								t) && (null === this.parent ? this.matrixWorld.copy(this.matrix) :
								this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this
									.matrix), t = !(this.matrixWorldNeedsUpdate = !1));
							for (var e = this.children, i = 0, n = e.length; i < n; i++) e[i]
								.updateMatrixWorld(t)
						},
						updateWorldMatrix: function (t, e) {
							var i = this.parent;
							if (!0 === t && null !== i && i.updateWorldMatrix(!0, !1), this
								.matrixAutoUpdate && this.updateMatrix(), null === this.parent ? this
								.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this
									.parent.matrixWorld, this.matrix), !0 === e)
								for (var n = this.children, r = 0, a = n.length; r < a; r++) n[r]
									.updateWorldMatrix(!1, !0)
						},
						toJSON: function (i) {
							var t = void 0 === i || "string" == typeof i,
								e = {};
							t && (i = {
								geometries: {},
								materials: {},
								textures: {},
								images: {},
								shapes: {}
							}, e.metadata = {
								version: 4.5,
								type: "Object",
								generator: "Object3D.toJSON"
							});
							var n = {};

							function r(t, e) {
								return void 0 === t[e.uuid] && (t[e.uuid] = e.toJSON(i)), e.uuid
							}
							if (n.uuid = this.uuid, n.type = this.type, "" !== this.name && (n.name = this
									.name), !0 === this.castShadow && (n.castShadow = !0), !0 === this
								.receiveShadow && (n.receiveShadow = !0), !1 === this.visible && (n
									.visible = !1), !1 === this.frustumCulled && (n.frustumCulled = !1),
								0 !== this.renderOrder && (n.renderOrder = this.renderOrder), "{}" !==
								JSON.stringify(this.userData) && (n.userData = this.userData), n.layers =
								this.layers.mask, n.matrix = this.matrix.toArray(), !1 === this
								.matrixAutoUpdate && (n.matrixAutoUpdate = !1), this.isMesh || this
								.isLine || this.isPoints) {
								n.geometry = r(i.geometries, this.geometry);
								var a = this.geometry.parameters;
								if (void 0 !== a && void 0 !== a.shapes) {
									var o = a.shapes;
									if (Array.isArray(o))
										for (var s = 0, c = o.length; s < c; s++) {
											var h = o[s];
											r(i.shapes, h)
										} else r(i.shapes, o)
								}
							}
							if (void 0 !== this.material)
								if (Array.isArray(this.material)) {
									var l = [];
									for (s = 0, c = this.material.length; s < c; s++) l.push(r(i
										.materials, this.material[s]));
									n.material = l
								} else n.material = r(i.materials, this.material);
							if (0 < this.children.length) {
								n.children = [];
								for (s = 0; s < this.children.length; s++) n.children.push(this.children[
									s].toJSON(i).object)
							}
							if (t) {
								var u = m(i.geometries),
									p = m(i.materials),
									d = m(i.textures),
									f = m(i.images);
								o = m(i.shapes);
								0 < u.length && (e.geometries = u), 0 < p.length && (e.materials = p), 0 <
									d.length && (e.textures = d), 0 < f.length && (e.images = f), 0 < o
									.length && (e.shapes = o)
							}
							return e.object = n, e;

							function m(t) {
								var e = [];
								for (var i in t) {
									var n = t[i];
									delete n.metadata, e.push(n)
								}
								return e
							}
						},
						clone: function (t) {
							return (new this.constructor).copy(this, t)
						},
						copy: function (t, e) {
							if (void 0 === e && (e = !0), this.name = t.name, this.up.copy(t.up), this
								.position.copy(t.position), this.quaternion.copy(t.quaternion), this.scale
								.copy(t.scale), this.matrix.copy(t.matrix), this.matrixWorld.copy(t
									.matrixWorld), this.matrixAutoUpdate = t.matrixAutoUpdate, this
								.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate, this.layers.mask = t
								.layers.mask, this.visible = t.visible, this.castShadow = t.castShadow,
								this.receiveShadow = t.receiveShadow, this.frustumCulled = t
								.frustumCulled, this.renderOrder = t.renderOrder, this.userData = JSON
								.parse(JSON.stringify(t.userData)), !0 === e)
								for (var i = 0; i < t.children.length; i++) {
									var n = t.children[i];
									this.add(n.clone())
								}
							return this
						}
					});
				var Sn, En, Tn, An, Ln, Pn, Cn, Rn = 0;

				function On() {
					Object.defineProperty(this, "id", {
							value: Rn += 2
						}), this.uuid = oi.generateUUID(), this.name = "", this.type = "Geometry", this
						.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [
							[]
						], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this
						.skinIndices = [], this.lineDistances = [], this.boundingBox = null, this.boundingSphere =
						null, this.elementsNeedUpdate = !1, this.verticesNeedUpdate = !1, this.uvsNeedUpdate = !1,
						this.normalsNeedUpdate = !1, this.colorsNeedUpdate = !1, this.lineDistancesNeedUpdate = !
						1, this.groupsNeedUpdate = !1
				}

				function In(t, e, i) {
					if (Array.isArray(t)) throw new TypeError(
						"THREE.BufferAttribute: array should be a Typed Array.");
					this.name = "", this.array = t, this.itemSize = e, this.count = void 0 !== t ? t.length / e :
						0, this.normalized = !0 === i, this.dynamic = !1, this.updateRange = {
							offset: 0,
							count: -1
						}, this.version = 0
				}

				function Dn(t, e, i) {
					In.call(this, new Int8Array(t), e, i)
				}

				function Bn(t, e, i) {
					In.call(this, new Uint8Array(t), e, i)
				}

				function Nn(t, e, i) {
					In.call(this, new Uint8ClampedArray(t), e, i)
				}

				function zn(t, e, i) {
					In.call(this, new Int16Array(t), e, i)
				}

				function Un(t, e, i) {
					In.call(this, new Uint16Array(t), e, i)
				}

				function Gn(t, e, i) {
					In.call(this, new Int32Array(t), e, i)
				}

				function Fn(t, e, i) {
					In.call(this, new Uint32Array(t), e, i)
				}

				function Hn(t, e, i) {
					In.call(this, new Float32Array(t), e, i)
				}

				function kn(t, e, i) {
					In.call(this, new Float64Array(t), e, i)
				}

				function jn() {
					this.vertices = [], this.normals = [], this.colors = [], this.uvs = [], this.uvs2 = [], this
						.groups = [], this.morphTargets = {}, this.skinWeights = [], this.skinIndices = [], this
						.boundingBox = null, this.boundingSphere = null, this.verticesNeedUpdate = !1, this
						.normalsNeedUpdate = !1, this.colorsNeedUpdate = !1, this.uvsNeedUpdate = !1, this
						.groupsNeedUpdate = !1
				}

				function Vn(t) {
					if (0 === t.length) return -1 / 0;
					for (var e = t[0], i = 1, n = t.length; i < n; ++i) t[i] > e && (e = t[i]);
					return e
				}
				On.prototype = Object.assign(Object.create(e.prototype), {
						constructor: On,
						isGeometry: !0,
						applyMatrix: function (t) {
							for (var e = (new ui).getNormalMatrix(t), i = 0, n = this.vertices.length; i <
								n; i++) {
								this.vertices[i].applyMatrix4(t)
							}
							for (i = 0, n = this.faces.length; i < n; i++) {
								var r = this.faces[i];
								r.normal.applyMatrix3(e).normalize();
								for (var a = 0, o = r.vertexNormals.length; a < o; a++) r.vertexNormals[a]
									.applyMatrix3(e).normalize()
							}
							return null !== this.boundingBox && this.computeBoundingBox(), null !== this
								.boundingSphere && this.computeBoundingSphere(), this
								.verticesNeedUpdate = !0, this.normalsNeedUpdate = !0, this
						},
						rotateX: (Cn = new ci, function (t) {
							return Cn.makeRotationX(t), this.applyMatrix(Cn), this
						}),
						rotateY: (Pn = new ci, function (t) {
							return Pn.makeRotationY(t), this.applyMatrix(Pn), this
						}),
						rotateZ: (Ln = new ci, function (t) {
							return Ln.makeRotationZ(t), this.applyMatrix(Ln), this
						}),
						translate: (An = new ci, function (t, e, i) {
							return An.makeTranslation(t, e, i), this.applyMatrix(An), this
						}),
						scale: (Tn = new ci, function (t, e, i) {
							return Tn.makeScale(t, e, i), this.applyMatrix(Tn), this
						}),
						lookAt: (En = new Mn, function (t) {
							En.lookAt(t), En.updateMatrix(), this.applyMatrix(En.matrix)
						}),
						fromBufferGeometry: function (t) {
							var o = this,
								e = null !== t.index ? t.index.array : void 0,
								i = t.attributes,
								n = i.position.array,
								s = void 0 !== i.normal ? i.normal.array : void 0,
								c = void 0 !== i.color ? i.color.array : void 0,
								h = void 0 !== i.uv ? i.uv.array : void 0,
								l = void 0 !== i.uv2 ? i.uv2.array : void 0;
							void 0 !== l && (this.faceVertexUvs[1] = []);
							for (var r = 0, a = 0; r < n.length; r += 3, a += 2) o.vertices.push((new li)
								.fromArray(n, r)), void 0 !== c && o.colors.push((new Xi).fromArray(c,
								r));

							function u(t, e, i, n) {
								var r = void 0 === c ? [] : [o.colors[t].clone(), o.colors[e].clone(), o
										.colors[i].clone()
									],
									a = new tn(t, e, i, void 0 === s ? [] : [(new li).fromArray(s, 3 * t),
										(new li).fromArray(s, 3 * e), (new li).fromArray(s, 3 * i)
									], r, n);
								o.faces.push(a), void 0 !== h && o.faceVertexUvs[0].push([(new si)
									.fromArray(h, 2 * t), (new si).fromArray(h, 2 * e), (new si)
									.fromArray(h, 2 * i)
								]), void 0 !== l && o.faceVertexUvs[1].push([(new si).fromArray(l, 2 *
									t), (new si).fromArray(l, 2 * e), (new si).fromArray(l,
									2 * i)])
							}
							var p = t.groups;
							if (0 < p.length)
								for (r = 0; r < p.length; r++)
									for (var d = p[r], f = d.start, m = (a = f, f + d.count); a < m; a +=
										3) void 0 !== e ? u(e[a], e[a + 1], e[a + 2], d.materialIndex) :
										u(a, a + 1, a + 2, d.materialIndex);
							else if (void 0 !== e)
								for (r = 0; r < e.length; r += 3) u(e[r], e[r + 1], e[r + 2]);
							else
								for (r = 0; r < n.length / 3; r += 3) u(r, r + 1, r + 2);
							return this.computeFaceNormals(), null !== t.boundingBox && (this
								.boundingBox = t.boundingBox.clone()), null !== t.boundingSphere && (
								this.boundingSphere = t.boundingSphere.clone()), this
						},
						center: (Sn = new li, function () {
							return this.computeBoundingBox(), this.boundingBox.getCenter(Sn).negate(),
								this.translate(Sn.x, Sn.y, Sn.z), this
						}),
						normalize: function () {
							this.computeBoundingSphere();
							var t = this.boundingSphere.center,
								e = this.boundingSphere.radius,
								i = 0 === e ? 1 : 1 / e,
								n = new ci;
							return n.set(i, 0, 0, -i * t.x, 0, i, 0, -i * t.y, 0, 0, i, -i * t.z, 0, 0, 0,
								1), this.applyMatrix(n), this
						},
						computeFaceNormals: function () {
							for (var t = new li, e = new li, i = 0, n = this.faces.length; i < n; i++) {
								var r = this.faces[i],
									a = this.vertices[r.a],
									o = this.vertices[r.b],
									s = this.vertices[r.c];
								t.subVectors(s, o), e.subVectors(a, o), t.cross(e), t.normalize(), r
									.normal.copy(t)
							}
						},
						computeVertexNormals: function (t) {
							var e, i, n, r, a, o;
							for (void 0 === t && (t = !0), o = new Array(this.vertices.length), e = 0, i =
								this.vertices.length; e < i; e++) o[e] = new li;
							if (t) {
								var s, c, h, l = new li,
									u = new li;
								for (n = 0, r = this.faces.length; n < r; n++) a = this.faces[n], s = this
									.vertices[a.a], c = this.vertices[a.b], h = this.vertices[a.c], l
									.subVectors(h, c), u.subVectors(s, c), l.cross(u), o[a.a].add(l), o[a
										.b].add(l), o[a.c].add(l)
							} else
								for (this.computeFaceNormals(), n = 0, r = this.faces.length; n < r; n++)
									o[(a = this.faces[n]).a].add(a.normal), o[a.b].add(a.normal), o[a.c]
									.add(a.normal);
							for (e = 0, i = this.vertices.length; e < i; e++) o[e].normalize();
							for (n = 0, r = this.faces.length; n < r; n++) {
								var p = (a = this.faces[n]).vertexNormals;
								3 === p.length ? (p[0].copy(o[a.a]), p[1].copy(o[a.b]), p[2].copy(o[a
									.c])) : (p[0] = o[a.a].clone(), p[1] = o[a.b].clone(), p[2] = o[a.c]
										.clone())
							}
							0 < this.faces.length && (this.normalsNeedUpdate = !0)
						},
						computeFlatVertexNormals: function () {
							var t, e, i;
							for (this.computeFaceNormals(), t = 0, e = this.faces.length; t < e; t++) {
								var n = (i = this.faces[t]).vertexNormals;
								3 === n.length ? (n[0].copy(i.normal), n[1].copy(i.normal), n[2].copy(i
									.normal)) : (n[0] = i.normal.clone(), n[1] = i.normal.clone(), n[
									2] = i.normal.clone())
							}
							0 < this.faces.length && (this.normalsNeedUpdate = !0)
						},
						computeMorphNormals: function () {
							var t, e, i, n, r;
							for (i = 0, n = this.faces.length; i < n; i++)
								for ((r = this.faces[i]).__originalFaceNormal ? r.__originalFaceNormal
									.copy(r.normal) : r.__originalFaceNormal = r.normal.clone(), r
									.__originalVertexNormals || (r.__originalVertexNormals = []), t = 0,
									e = r.vertexNormals.length; t < e; t++) r.__originalVertexNormals[t] ?
									r.__originalVertexNormals[t].copy(r.vertexNormals[t]) : r
									.__originalVertexNormals[t] = r.vertexNormals[t].clone();
							var a = new On;
							for (a.faces = this.faces, t = 0, e = this.morphTargets.length; t < e; t++) {
								if (!this.morphNormals[t]) {
									this.morphNormals[t] = {}, this.morphNormals[t].faceNormals = [], this
										.morphNormals[t].vertexNormals = [];
									var o = this.morphNormals[t].faceNormals,
										s = this.morphNormals[t].vertexNormals;
									for (i = 0, n = this.faces.length; i < n; i++) c = new li, h = {
										a: new li,
										b: new li,
										c: new li
									}, o.push(c), s.push(h)
								}
								var c, h, l = this.morphNormals[t];
								for (a.vertices = this.morphTargets[t].vertices, a.computeFaceNormals(), a
									.computeVertexNormals(), i = 0, n = this.faces.length; i < n; i++) r =
									this.faces[i], c = l.faceNormals[i], h = l.vertexNormals[i], c.copy(r
										.normal), h.a.copy(r.vertexNormals[0]), h.b.copy(r.vertexNormals[
										1]), h.c.copy(r.vertexNormals[2])
							}
							for (i = 0, n = this.faces.length; i < n; i++)(r = this.faces[i]).normal = r
								.__originalFaceNormal, r.vertexNormals = r.__originalVertexNormals
						},
						computeBoundingBox: function () {
							null === this.boundingBox && (this.boundingBox = new Bi), this.boundingBox
								.setFromPoints(this.vertices)
						},
						computeBoundingSphere: function () {
							null === this.boundingSphere && (this.boundingSphere = new Ni), this
								.boundingSphere.setFromPoints(this.vertices)
						},
						merge: function (t, e, i) {
							if (t && t.isGeometry) {
								var n, r = this.vertices.length,
									a = this.vertices,
									o = t.vertices,
									s = this.faces,
									c = t.faces,
									h = this.faceVertexUvs[0],
									l = t.faceVertexUvs[0],
									u = this.colors,
									p = t.colors;
								void 0 === i && (i = 0), void 0 !== e && (n = (new ui).getNormalMatrix(
								e));
								for (var d = 0, f = o.length; d < f; d++) {
									var m = o[d].clone();
									void 0 !== e && m.applyMatrix4(e), a.push(m)
								}
								for (d = 0, f = p.length; d < f; d++) u.push(p[d].clone());
								for (d = 0, f = c.length; d < f; d++) {
									var g, v, y, x = c[d],
										b = x.vertexNormals,
										w = x.vertexColors;
									(g = new tn(x.a + r, x.b + r, x.c + r)).normal.copy(x.normal),
										void 0 !== n && g.normal.applyMatrix3(n).normalize();
									for (var _ = 0, M = b.length; _ < M; _++) v = b[_].clone(), void 0 !==
										n && v.applyMatrix3(n).normalize(), g.vertexNormals.push(v);
									g.color.copy(x.color);
									for (_ = 0, M = w.length; _ < M; _++) y = w[_], g.vertexColors.push(y
										.clone());
									g.materialIndex = x.materialIndex + i, s.push(g)
								}
								for (d = 0, f = l.length; d < f; d++) {
									var S = l[d],
										E = [];
									if (void 0 !== S) {
										for (_ = 0, M = S.length; _ < M; _++) E.push(S[_].clone());
										h.push(E)
									}
								}
							} else console.error(
								"THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.",
								t)
						},
						mergeMesh: function (t) {
							t && t.isMesh ? (t.matrixAutoUpdate && t.updateMatrix(), this.merge(t
								.geometry, t.matrix)) : console.error(
								"THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.", t)
						},
						mergeVertices: function () {
							var t, e, i, n, r, a, o, s, c = {},
								h = [],
								l = [],
								u = 4,
								p = Math.pow(10, u);
							for (i = 0, n = this.vertices.length; i < n; i++) t = this.vertices[i],
								void 0 === c[e = Math.round(t.x * p) + "_" + Math.round(t.y * p) + "_" +
									Math.round(t.z * p)] ? (c[e] = i, h.push(this.vertices[i]), l[i] = h
									.length - 1) : l[i] = l[c[e]];
							var d = [];
							for (i = 0, n = this.faces.length; i < n; i++) {
								(r = this.faces[i]).a = l[r.a], r.b = l[r.b], r.c = l[r.c], a = [r.a, r.b,
									r.c
								];
								for (var f = 0; f < 3; f++)
									if (a[f] === a[(f + 1) % 3]) {
										d.push(i);
										break
									}
							}
							for (i = d.length - 1; 0 <= i; i--) {
								var m = d[i];
								for (this.faces.splice(m, 1), o = 0, s = this.faceVertexUvs.length; o <
									s; o++) this.faceVertexUvs[o].splice(m, 1)
							}
							var g = this.vertices.length - h.length;
							return this.vertices = h, g
						},
						setFromPoints: function (t) {
							this.vertices = [];
							for (var e = 0, i = t.length; e < i; e++) {
								var n = t[e];
								this.vertices.push(new li(n.x, n.y, n.z || 0))
							}
							return this
						},
						sortFacesByMaterialIndex: function () {
							for (var t = this.faces, e = t.length, i = 0; i < e; i++) t[i]._id = i;

							function n(t, e) {
								return t.materialIndex - e.materialIndex
							}
							t.sort(n);
							var r, a, o = this.faceVertexUvs[0],
								s = this.faceVertexUvs[1];
							o && o.length === e && (r = []), s && s.length === e && (a = []);
							for (i = 0; i < e; i++) {
								var c = t[i]._id;
								r && r.push(o[c]), a && a.push(s[c])
							}
							r && (this.faceVertexUvs[0] = r), a && (this.faceVertexUvs[1] = a)
						},
						toJSON: function () {
							var t = {
								metadata: {
									version: 4.5,
									type: "Geometry",
									generator: "Geometry.toJSON"
								}
							};
							if (t.uuid = this.uuid, t.type = this.type, "" !== this.name && (t.name = this
									.name), void 0 !== this.parameters) {
								var e = this.parameters;
								for (var i in e) void 0 !== e[i] && (t[i] = e[i]);
								return t
							}
							for (var n = [], r = 0; r < this.vertices.length; r++) {
								var a = this.vertices[r];
								n.push(a.x, a.y, a.z)
							}
							var o = [],
								s = [],
								c = {},
								h = [],
								l = {},
								u = [],
								p = {};
							for (r = 0; r < this.faces.length; r++) {
								var d = this.faces[r],
									f = !0,
									m = !1,
									g = void 0 !== this.faceVertexUvs[0][r],
									v = 0 < d.normal.length(),
									y = 0 < d.vertexNormals.length,
									x = 1 !== d.color.r || 1 !== d.color.g || 1 !== d.color.b,
									b = 0 < d.vertexColors.length,
									w = 0;
								if (w = E(w = E(w = E(w = E(w = E(w = E(w = E(w = E(w, 0, 0), 1, f), 2,
										m), 3, g), 4, v), 5, y), 6, x), 7, b), o.push(w), o.push(d.a, d.b,
										d.c), o.push(d.materialIndex), g) {
									var _ = this.faceVertexUvs[0][r];
									o.push(L(_[0]), L(_[1]), L(_[2]))
								}
								if (v && o.push(T(d.normal)), y) {
									var M = d.vertexNormals;
									o.push(T(M[0]), T(M[1]), T(M[2]))
								}
								if (x && o.push(A(d.color)), b) {
									var S = d.vertexColors;
									o.push(A(S[0]), A(S[1]), A(S[2]))
								}
							}

							function E(t, e, i) {
								return i ? t | 1 << e : t & ~(1 << e)
							}

							function T(t) {
								var e = t.x.toString() + t.y.toString() + t.z.toString();
								return void 0 !== c[e] || (c[e] = s.length / 3, s.push(t.x, t.y, t.z)), c[
									e]
							}

							function A(t) {
								var e = t.r.toString() + t.g.toString() + t.b.toString();
								return void 0 !== l[e] || (l[e] = h.length, h.push(t.getHex())), l[e]
							}

							function L(t) {
								var e = t.x.toString() + t.y.toString();
								return void 0 !== p[e] || (p[e] = u.length / 2, u.push(t.x, t.y)), p[e]
							}
							return t.data = {}, t.data.vertices = n, t.data.normals = s, 0 < h.length && (
									t.data.colors = h), 0 < u.length && (t.data.uvs = [u]), t.data.faces =
								o, t
						},
						clone: function () {
							return (new On).copy(this)
						},
						copy: function (t) {
							var e, i, n, r, a, o;
							this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [
									[]
								], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [],
								this.skinIndices = [], this.lineDistances = [], this.boundingBox = null,
								this.boundingSphere = null, this.name = t.name;
							var s = t.vertices;
							for (e = 0, i = s.length; e < i; e++) this.vertices.push(s[e].clone());
							var c = t.colors;
							for (e = 0, i = c.length; e < i; e++) this.colors.push(c[e].clone());
							var h = t.faces;
							for (e = 0, i = h.length; e < i; e++) this.faces.push(h[e].clone());
							for (e = 0, i = t.faceVertexUvs.length; e < i; e++) {
								var l = t.faceVertexUvs[e];
								for (void 0 === this.faceVertexUvs[e] && (this.faceVertexUvs[e] = []), n =
									0, r = l.length; n < r; n++) {
									var u = l[n],
										p = [];
									for (a = 0, o = u.length; a < o; a++) {
										var d = u[a];
										p.push(d.clone())
									}
									this.faceVertexUvs[e].push(p)
								}
							}
							var f = t.morphTargets;
							for (e = 0, i = f.length; e < i; e++) {
								var m = {};
								if (m.name = f[e].name, void 0 !== f[e].vertices)
									for (m.vertices = [], n = 0, r = f[e].vertices.length; n < r; n++) m
										.vertices.push(f[e].vertices[n].clone());
								if (void 0 !== f[e].normals)
									for (m.normals = [], n = 0, r = f[e].normals.length; n < r; n++) m
										.normals.push(f[e].normals[n].clone());
								this.morphTargets.push(m)
							}
							var g = t.morphNormals;
							for (e = 0, i = g.length; e < i; e++) {
								var v = {};
								if (void 0 !== g[e].vertexNormals)
									for (v.vertexNormals = [], n = 0, r = g[e].vertexNormals.length; n <
										r; n++) {
										var y = g[e].vertexNormals[n],
											x = {};
										x.a = y.a.clone(), x.b = y.b.clone(), x.c = y.c.clone(), v
											.vertexNormals.push(x)
									}
								if (void 0 !== g[e].faceNormals)
									for (v.faceNormals = [], n = 0, r = g[e].faceNormals.length; n <
										r; n++) v.faceNormals.push(g[e].faceNormals[n].clone());
								this.morphNormals.push(v)
							}
							var b = t.skinWeights;
							for (e = 0, i = b.length; e < i; e++) this.skinWeights.push(b[e].clone());
							var w = t.skinIndices;
							for (e = 0, i = w.length; e < i; e++) this.skinIndices.push(w[e].clone());
							var _ = t.lineDistances;
							for (e = 0, i = _.length; e < i; e++) this.lineDistances.push(_[e]);
							var M = t.boundingBox;
							null !== M && (this.boundingBox = M.clone());
							var S = t.boundingSphere;
							return null !== S && (this.boundingSphere = S.clone()), this
								.elementsNeedUpdate = t.elementsNeedUpdate, this.verticesNeedUpdate = t
								.verticesNeedUpdate, this.uvsNeedUpdate = t.uvsNeedUpdate, this
								.normalsNeedUpdate = t.normalsNeedUpdate, this.colorsNeedUpdate = t
								.colorsNeedUpdate, this.lineDistancesNeedUpdate = t
								.lineDistancesNeedUpdate, this.groupsNeedUpdate = t.groupsNeedUpdate, this
						},
						dispose: function () {
							this.dispatchEvent({
								type: "dispose"
							})
						}
					}), Object.defineProperty(In.prototype, "needsUpdate", {
						set: function (t) {
							!0 === t && this.version++
						}
					}), Object.assign(In.prototype, {
						isBufferAttribute: !0,
						onUploadCallback: function () {},
						setArray: function (t) {
							if (Array.isArray(t)) throw new TypeError(
								"THREE.BufferAttribute: array should be a Typed Array.");
							return this.count = void 0 !== t ? t.length / this.itemSize : 0, this.array =
								t, this
						},
						setDynamic: function (t) {
							return this.dynamic = t, this
						},
						copy: function (t) {
							return this.name = t.name, this.array = new t.array.constructor(t.array), this
								.itemSize = t.itemSize, this.count = t.count, this.normalized = t
								.normalized, this.dynamic = t.dynamic, this
						},
						copyAt: function (t, e, i) {
							t *= this.itemSize, i *= e.itemSize;
							for (var n = 0, r = this.itemSize; n < r; n++) this.array[t + n] = e.array[i +
								n];
							return this
						},
						copyArray: function (t) {
							return this.array.set(t), this
						},
						copyColorsArray: function (t) {
							for (var e = this.array, i = 0, n = 0, r = t.length; n < r; n++) {
								var a = t[n];
								void 0 === a && (console.warn(
									"THREE.BufferAttribute.copyColorsArray(): color is undefined",
									n), a = new Xi), e[i++] = a.r, e[i++] = a.g, e[i++] = a.b
							}
							return this
						},
						copyVector2sArray: function (t) {
							for (var e = this.array, i = 0, n = 0, r = t.length; n < r; n++) {
								var a = t[n];
								void 0 === a && (console.warn(
									"THREE.BufferAttribute.copyVector2sArray(): vector is undefined",
									n), a = new si), e[i++] = a.x, e[i++] = a.y
							}
							return this
						},
						copyVector3sArray: function (t) {
							for (var e = this.array, i = 0, n = 0, r = t.length; n < r; n++) {
								var a = t[n];
								void 0 === a && (console.warn(
									"THREE.BufferAttribute.copyVector3sArray(): vector is undefined",
									n), a = new li), e[i++] = a.x, e[i++] = a.y, e[i++] = a.z
							}
							return this
						},
						copyVector4sArray: function (t) {
							for (var e = this.array, i = 0, n = 0, r = t.length; n < r; n++) {
								var a = t[n];
								void 0 === a && (console.warn(
										"THREE.BufferAttribute.copyVector4sArray(): vector is undefined",
										n), a = new Ri), e[i++] = a.x, e[i++] = a.y, e[i++] = a.z, e[
									i++] = a.w
							}
							return this
						},
						set: function (t, e) {
							return void 0 === e && (e = 0), this.array.set(t, e), this
						},
						getX: function (t) {
							return this.array[t * this.itemSize]
						},
						setX: function (t, e) {
							return this.array[t * this.itemSize] = e, this
						},
						getY: function (t) {
							return this.array[t * this.itemSize + 1]
						},
						setY: function (t, e) {
							return this.array[t * this.itemSize + 1] = e, this
						},
						getZ: function (t) {
							return this.array[t * this.itemSize + 2]
						},
						setZ: function (t, e) {
							return this.array[t * this.itemSize + 2] = e, this
						},
						getW: function (t) {
							return this.array[t * this.itemSize + 3]
						},
						setW: function (t, e) {
							return this.array[t * this.itemSize + 3] = e, this
						},
						setXY: function (t, e, i) {
							return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = i, this
						},
						setXYZ: function (t, e, i, n) {
							return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = i, this
								.array[t + 2] = n, this
						},
						setXYZW: function (t, e, i, n, r) {
							return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = i, this
								.array[t + 2] = n, this.array[t + 3] = r, this
						},
						onUpload: function (t) {
							return this.onUploadCallback = t, this
						},
						clone: function () {
							return new this.constructor(this.array, this.itemSize).copy(this)
						}
					}), Dn.prototype = Object.create(In.prototype), Dn.prototype.constructor = Dn, Bn.prototype =
					Object.create(In.prototype), Bn.prototype.constructor = Bn, Nn.prototype = Object.create(In
						.prototype), Nn.prototype.constructor = Nn, zn.prototype = Object.create(In.prototype), zn
					.prototype.constructor = zn, Un.prototype = Object.create(In.prototype), Un.prototype
					.constructor = Un, Gn.prototype = Object.create(In.prototype), Gn.prototype.constructor = Gn,
					Fn.prototype = Object.create(In.prototype), Fn.prototype.constructor = Fn, Hn.prototype =
					Object.create(In.prototype), Hn.prototype.constructor = Hn, kn.prototype = Object.create(In
						.prototype), kn.prototype.constructor = kn, Object.assign(jn.prototype, {
						computeGroups: function (t) {
							for (var e, i = [], n = void 0, r = t.faces, a = 0; a < r.length; a++) {
								var o = r[a];
								o.materialIndex !== n && (n = o.materialIndex, void 0 !== e && (e.count =
									3 * a - e.start, i.push(e)), e = {
									start: 3 * a,
									materialIndex: n
								})
							}
							void 0 !== e && (e.count = 3 * a - e.start, i.push(e)), this.groups = i
						},
						fromGeometry: function (t) {
							var e, i = t.faces,
								n = t.vertices,
								r = t.faceVertexUvs,
								a = r[0] && 0 < r[0].length,
								o = r[1] && 0 < r[1].length,
								s = t.morphTargets,
								c = s.length;
							if (0 < c) {
								e = [];
								for (var h = 0; h < c; h++) e[h] = {
									name: s[h].name,
									data: []
								};
								this.morphTargets.position = e
							}
							var l, u = t.morphNormals,
								p = u.length;
							if (0 < p) {
								l = [];
								for (h = 0; h < p; h++) l[h] = {
									name: u[h].name,
									data: []
								};
								this.morphTargets.normal = l
							}
							var d = t.skinIndices,
								f = t.skinWeights,
								m = d.length === n.length,
								g = f.length === n.length;
							0 < n.length && 0 === i.length && console.error(
								"THREE.DirectGeometry: Faceless geometries are not supported.");
							for (h = 0; h < i.length; h++) {
								var v = i[h];
								this.vertices.push(n[v.a], n[v.b], n[v.c]);
								var y = v.vertexNormals;
								if (3 === y.length) this.normals.push(y[0], y[1], y[2]);
								else {
									var x = v.normal;
									this.normals.push(x, x, x)
								}
								var b, w = v.vertexColors;
								if (3 === w.length) this.colors.push(w[0], w[1], w[2]);
								else {
									var _ = v.color;
									this.colors.push(_, _, _)
								}
								if (!0 === a) void 0 !== (b = r[0][h]) ? this.uvs.push(b[0], b[1], b[2]) :
									(console.warn(
											"THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ", h
											), this.uvs.push(new si, new si, new si));
								if (!0 === o) void 0 !== (b = r[1][h]) ? this.uvs2.push(b[0], b[1], b[
									2]) : (console.warn(
										"THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ", h
										), this.uvs2.push(new si, new si, new si));
								for (var M = 0; M < c; M++) {
									var S = s[M].vertices;
									e[M].data.push(S[v.a], S[v.b], S[v.c])
								}
								for (M = 0; M < p; M++) {
									var E = u[M].vertexNormals[h];
									l[M].data.push(E.a, E.b, E.c)
								}
								m && this.skinIndices.push(d[v.a], d[v.b], d[v.c]), g && this.skinWeights
									.push(f[v.a], f[v.b], f[v.c])
							}
							return this.computeGroups(t), this.verticesNeedUpdate = t.verticesNeedUpdate,
								this.normalsNeedUpdate = t.normalsNeedUpdate, this.colorsNeedUpdate = t
								.colorsNeedUpdate, this.uvsNeedUpdate = t.uvsNeedUpdate, this
								.groupsNeedUpdate = t.groupsNeedUpdate, this
						}
					});
				var Wn, qn, Xn, Yn, Jn, Zn, Qn, Kn, $n, tr, er = 1;

				function ir() {
					Object.defineProperty(this, "id", {
							value: er += 2
						}), this.uuid = oi.generateUUID(), this.name = "", this.type = "BufferGeometry", this
						.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this
						.boundingBox = null, this.boundingSphere = null, this.drawRange = {
							start: 0,
							count: 1 / 0
						}, this.userData = {}
				}

				function nr(t, e, i, n, r, a) {
					On.call(this), this.type = "BoxGeometry", this.parameters = {
						width: t,
						height: e,
						depth: i,
						widthSegments: n,
						heightSegments: r,
						depthSegments: a
					}, this.fromBufferGeometry(new rr(t, e, i, n, r, a)), this.mergeVertices()
				}

				function rr(t, e, i, n, r, a) {
					ir.call(this), this.type = "BoxBufferGeometry", this.parameters = {
						width: t,
						height: e,
						depth: i,
						widthSegments: n,
						heightSegments: r,
						depthSegments: a
					};
					var P = this;
					t = t || 1, e = e || 1, i = i || 1, n = Math.floor(n) || 1, r = Math.floor(r) || 1, a = Math
						.floor(a) || 1;
					var C = [],
						R = [],
						O = [],
						I = [],
						D = 0,
						B = 0;

					function o(t, e, i, n, r, a, o, s, c, h, l) {
						var u, p, d = a / c,
							f = o / h,
							m = a / 2,
							g = o / 2,
							v = s / 2,
							y = c + 1,
							x = h + 1,
							b = 0,
							w = 0,
							_ = new li;
						for (p = 0; p < x; p++) {
							var M = p * f - g;
							for (u = 0; u < y; u++) {
								var S = u * d - m;
								_[t] = S * n, _[e] = M * r, _[i] = v, R.push(_.x, _.y, _.z), _[t] = 0, _[e] = 0,
									_[i] = 0 < s ? 1 : -1, O.push(_.x, _.y, _.z), I.push(u / c), I.push(1 - p /
									h), b += 1
							}
						}
						for (p = 0; p < h; p++)
							for (u = 0; u < c; u++) {
								var E = D + u + y * p,
									T = D + u + y * (p + 1),
									A = D + (u + 1) + y * (p + 1),
									L = D + (u + 1) + y * p;
								C.push(E, T, L), C.push(T, A, L), w += 6
							}
						P.addGroup(B, w, l), B += w, D += b
					}
					o("z", "y", "x", -1, -1, i, e, t, a, r, 0), o("z", "y", "x", 1, -1, i, e, -t, a, r, 1), o("x",
							"z", "y", 1, 1, t, i, e, n, a, 2), o("x", "z", "y", 1, -1, t, i, -e, n, a, 3), o("x",
							"y", "z", 1, -1, t, e, i, n, r, 4), o("x", "y", "z", -1, -1, t, e, -i, n, r, 5), this
						.setIndex(C), this.addAttribute("position", new Hn(R, 3)), this.addAttribute("normal",
							new Hn(O, 3)), this.addAttribute("uv", new Hn(I, 2))
				}

				function ar(t, e, i, n) {
					On.call(this), this.type = "PlaneGeometry", this.parameters = {
						width: t,
						height: e,
						widthSegments: i,
						heightSegments: n
					}, this.fromBufferGeometry(new or(t, e, i, n)), this.mergeVertices()
				}

				function or(t, e, i, n) {
					ir.call(this), this.type = "PlaneBufferGeometry", this.parameters = {
						width: t,
						height: e,
						widthSegments: i,
						heightSegments: n
					};
					var r, a, o = (t = t || 1) / 2,
						s = (e = e || 1) / 2,
						c = Math.floor(i) || 1,
						h = Math.floor(n) || 1,
						l = c + 1,
						u = h + 1,
						p = t / c,
						d = e / h,
						f = [],
						m = [],
						g = [],
						v = [];
					for (a = 0; a < u; a++) {
						var y = a * d - s;
						for (r = 0; r < l; r++) {
							var x = r * p - o;
							m.push(x, -y, 0), g.push(0, 0, 1), v.push(r / c), v.push(1 - a / h)
						}
					}
					for (a = 0; a < h; a++)
						for (r = 0; r < c; r++) {
							var b = r + l * a,
								w = r + l * (a + 1),
								_ = r + 1 + l * (a + 1),
								M = r + 1 + l * a;
							f.push(b, w, M), f.push(w, _, M)
						}
					this.setIndex(f), this.addAttribute("position", new Hn(m, 3)), this.addAttribute("normal",
						new Hn(g, 3)), this.addAttribute("uv", new Hn(v, 2))
				}
				ir.prototype = Object.assign(Object.create(e.prototype), {
						constructor: ir,
						isBufferGeometry: !0,
						getIndex: function () {
							return this.index
						},
						setIndex: function (t) {
							Array.isArray(t) ? this.index = new(65535 < Vn(t) ? Fn : Un)(t, 1) : this
								.index = t
						},
						addAttribute: function (t, e) {
							return e && e.isBufferAttribute || e && e.isInterleavedBufferAttribute ? (
								"index" === t ? (console.warn(
									"THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."
									), this.setIndex(e)) : this.attributes[t] = e, this) : (console
								.warn(
									"THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."
									), this.addAttribute(t, new In(arguments[1], arguments[2])))
						},
						getAttribute: function (t) {
							return this.attributes[t]
						},
						removeAttribute: function (t) {
							return delete this.attributes[t], this
						},
						addGroup: function (t, e, i) {
							this.groups.push({
								start: t,
								count: e,
								materialIndex: void 0 !== i ? i : 0
							})
						},
						clearGroups: function () {
							this.groups = []
						},
						setDrawRange: function (t, e) {
							this.drawRange.start = t, this.drawRange.count = e
						},
						applyMatrix: function (t) {
							var e = this.attributes.position;
							void 0 !== e && (t.applyToBufferAttribute(e), e.needsUpdate = !0);
							var i = this.attributes.normal;
							void 0 !== i && ((new ui).getNormalMatrix(t).applyToBufferAttribute(i), i
								.needsUpdate = !0);
							return null !== this.boundingBox && this.computeBoundingBox(), null !== this
								.boundingSphere && this.computeBoundingSphere(), this
						},
						rotateX: (tr = new ci, function (t) {
							return tr.makeRotationX(t), this.applyMatrix(tr), this
						}),
						rotateY: ($n = new ci, function (t) {
							return $n.makeRotationY(t), this.applyMatrix($n), this
						}),
						rotateZ: (Kn = new ci, function (t) {
							return Kn.makeRotationZ(t), this.applyMatrix(Kn), this
						}),
						translate: (Qn = new ci, function (t, e, i) {
							return Qn.makeTranslation(t, e, i), this.applyMatrix(Qn), this
						}),
						scale: (Zn = new ci, function (t, e, i) {
							return Zn.makeScale(t, e, i), this.applyMatrix(Zn), this
						}),
						lookAt: (Jn = new Mn, function (t) {
							Jn.lookAt(t), Jn.updateMatrix(), this.applyMatrix(Jn.matrix)
						}),
						center: (Yn = new li, function () {
							return this.computeBoundingBox(), this.boundingBox.getCenter(Yn).negate(),
								this.translate(Yn.x, Yn.y, Yn.z), this
						}),
						setFromObject: function (t) {
							var e = t.geometry;
							if (t.isPoints || t.isLine) {
								var i = new Hn(3 * e.vertices.length, 3),
									n = new Hn(3 * e.colors.length, 3);
								if (this.addAttribute("position", i.copyVector3sArray(e.vertices)), this
									.addAttribute("color", n.copyColorsArray(e.colors)), e
									.lineDistances && e.lineDistances.length === e.vertices.length) {
									var r = new Hn(e.lineDistances.length, 1);
									this.addAttribute("lineDistance", r.copyArray(e.lineDistances))
								}
								null !== e.boundingSphere && (this.boundingSphere = e.boundingSphere
									.clone()), null !== e.boundingBox && (this.boundingBox = e
									.boundingBox.clone())
							} else t.isMesh && e && e.isGeometry && this.fromGeometry(e);
							return this
						},
						setFromPoints: function (t) {
							for (var e = [], i = 0, n = t.length; i < n; i++) {
								var r = t[i];
								e.push(r.x, r.y, r.z || 0)
							}
							return this.addAttribute("position", new Hn(e, 3)), this
						},
						updateFromObject: function (t) {
							var e, i = t.geometry;
							if (t.isMesh) {
								var n = i.__directGeometry;
								if (!0 === i.elementsNeedUpdate && (n = void 0, i.elementsNeedUpdate = !
									1), void 0 === n) return this.fromGeometry(i);
								n.verticesNeedUpdate = i.verticesNeedUpdate, n.normalsNeedUpdate = i
									.normalsNeedUpdate, n.colorsNeedUpdate = i.colorsNeedUpdate, n
									.uvsNeedUpdate = i.uvsNeedUpdate, n.groupsNeedUpdate = i
									.groupsNeedUpdate, i.verticesNeedUpdate = !1, i.normalsNeedUpdate = !
									1, i.colorsNeedUpdate = !1, i.uvsNeedUpdate = !1, i
									.groupsNeedUpdate = !1, i = n
							}
							return !0 === i.verticesNeedUpdate && (void 0 !== (e = this.attributes
									.position) && (e.copyVector3sArray(i.vertices), e.needsUpdate = !
									0), i.verticesNeedUpdate = !1), !0 === i.normalsNeedUpdate && (
									void 0 !== (e = this.attributes.normal) && (e.copyVector3sArray(i
										.normals), e.needsUpdate = !0), i.normalsNeedUpdate = !1), !0 ===
								i.colorsNeedUpdate && (void 0 !== (e = this.attributes.color) && (e
										.copyColorsArray(i.colors), e.needsUpdate = !0), i
									.colorsNeedUpdate = !1), i.uvsNeedUpdate && (void 0 !== (e = this
									.attributes.uv) && (e.copyVector2sArray(i.uvs), e.needsUpdate = !
									0), i.uvsNeedUpdate = !1), i.lineDistancesNeedUpdate && (void 0 !== (
										e = this.attributes.lineDistance) && (e.copyArray(i
										.lineDistances), e.needsUpdate = !0), i
									.lineDistancesNeedUpdate = !1), i.groupsNeedUpdate && (i
									.computeGroups(t.geometry), this.groups = i.groups, i
									.groupsNeedUpdate = !1), this
						},
						fromGeometry: function (t) {
							return t.__directGeometry = (new jn).fromGeometry(t), this.fromDirectGeometry(
								t.__directGeometry)
						},
						fromDirectGeometry: function (t) {
							var e = new Float32Array(3 * t.vertices.length);
							if (this.addAttribute("position", new In(e, 3).copyVector3sArray(t.vertices)),
								0 < t.normals.length) {
								var i = new Float32Array(3 * t.normals.length);
								this.addAttribute("normal", new In(i, 3).copyVector3sArray(t.normals))
							}
							if (0 < t.colors.length) {
								var n = new Float32Array(3 * t.colors.length);
								this.addAttribute("color", new In(n, 3).copyColorsArray(t.colors))
							}
							if (0 < t.uvs.length) {
								var r = new Float32Array(2 * t.uvs.length);
								this.addAttribute("uv", new In(r, 2).copyVector2sArray(t.uvs))
							}
							if (0 < t.uvs2.length) {
								var a = new Float32Array(2 * t.uvs2.length);
								this.addAttribute("uv2", new In(a, 2).copyVector2sArray(t.uvs2))
							}
							for (var o in this.groups = t.groups, t.morphTargets) {
								for (var s = [], c = t.morphTargets[o], h = 0, l = c.length; h < l; h++) {
									var u = c[h],
										p = new Hn(3 * u.data.length, 3);
									p.name = u.name, s.push(p.copyVector3sArray(u.data))
								}
								this.morphAttributes[o] = s
							}
							if (0 < t.skinIndices.length) {
								var d = new Hn(4 * t.skinIndices.length, 4);
								this.addAttribute("skinIndex", d.copyVector4sArray(t.skinIndices))
							}
							if (0 < t.skinWeights.length) {
								var f = new Hn(4 * t.skinWeights.length, 4);
								this.addAttribute("skinWeight", f.copyVector4sArray(t.skinWeights))
							}
							return null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere
								.clone()), null !== t.boundingBox && (this.boundingBox = t.boundingBox
								.clone()), this
						},
						computeBoundingBox: function () {
							null === this.boundingBox && (this.boundingBox = new Bi);
							var t = this.attributes.position;
							void 0 !== t ? this.boundingBox.setFromBufferAttribute(t) : this.boundingBox
								.makeEmpty(), (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min
									.y) || isNaN(this.boundingBox.min.z)) && console.error(
									'THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',
									this)
						},
						computeBoundingSphere: (qn = new Bi, Xn = new li, function () {
							null === this.boundingSphere && (this.boundingSphere = new Ni);
							var t = this.attributes.position;
							if (t) {
								var e = this.boundingSphere.center;
								qn.setFromBufferAttribute(t), qn.getCenter(e);
								for (var i = 0, n = 0, r = t.count; n < r; n++) Xn.x = t.getX(n), Xn
									.y = t.getY(n), Xn.z = t.getZ(n), i = Math.max(i, e
										.distanceToSquared(Xn));
								this.boundingSphere.radius = Math.sqrt(i), isNaN(this.boundingSphere
									.radius) && console.error(
									'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',
									this)
							}
						}),
						computeFaceNormals: function () {},
						computeVertexNormals: function () {
							var t = this.index,
								e = this.attributes;
							if (e.position) {
								var i = e.position.array;
								if (void 0 === e.normal) this.addAttribute("normal", new In(
									new Float32Array(i.length), 3));
								else
									for (var n = e.normal.array, r = 0, a = n.length; r < a; r++) n[r] =
									0;
								var o, s, c, h = e.normal.array,
									l = new li,
									u = new li,
									p = new li,
									d = new li,
									f = new li;
								if (t) {
									var m = t.array;
									for (r = 0, a = t.count; r < a; r += 3) o = 3 * m[r + 0], s = 3 * m[
											r + 1], c = 3 * m[r + 2], l.fromArray(i, o), u.fromArray(i,
										s), p.fromArray(i, c), d.subVectors(p, u), f.subVectors(l, u), d
										.cross(f), h[o] += d.x, h[o + 1] += d.y, h[o + 2] += d.z, h[s] +=
										d.x, h[s + 1] += d.y, h[s + 2] += d.z, h[c] += d.x, h[c + 1] += d
										.y, h[c + 2] += d.z
								} else
									for (r = 0, a = i.length; r < a; r += 9) l.fromArray(i, r), u
										.fromArray(i, r + 3), p.fromArray(i, r + 6), d.subVectors(p, u), f
										.subVectors(l, u), d.cross(f), h[r] = d.x, h[r + 1] = d.y, h[r +
											2] = d.z, h[r + 3] = d.x, h[r + 4] = d.y, h[r + 5] = d.z, h[
											r + 6] = d.x, h[r + 7] = d.y, h[r + 8] = d.z;
								this.normalizeNormals(), e.normal.needsUpdate = !0
							}
						},
						merge: function (t, e) {
							if (t && t.isBufferGeometry) {
								void 0 === e && (e = 0, console.warn(
									"THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."
									));
								var i = this.attributes;
								for (var n in i)
									if (void 0 !== t.attributes[n])
										for (var r = i[n].array, a = t.attributes[n], o = a.array, s = 0,
												c = a.itemSize * e; s < o.length; s++, c++) r[c] = o[s];
								return this
							}
							console.error(
								"THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.",
								t)
						},
						normalizeNormals: (Wn = new li, function () {
							for (var t = this.attributes.normal, e = 0, i = t.count; e < i; e++) Wn
								.x = t.getX(e), Wn.y = t.getY(e), Wn.z = t.getZ(e), Wn.normalize(), t
								.setXYZ(e, Wn.x, Wn.y, Wn.z)
						}),
						toNonIndexed: function () {
							if (null === this.index) return console.warn(
								"THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed."
								), this;
							var t = new ir,
								e = this.index.array,
								i = this.attributes;
							for (var n in i) {
								for (var r = i[n], a = r.array, o = r.itemSize, s = new a.constructor(e
										.length * o), c = 0, h = 0, l = 0, u = e.length; l < u; l++) {
									c = e[l] * o;
									for (var p = 0; p < o; p++) s[h++] = a[c++]
								}
								t.addAttribute(n, new In(s, o))
							}
							var d = this.groups;
							for (l = 0, u = d.length; l < u; l++) {
								var f = d[l];
								t.addGroup(f.start, f.count, f.materialIndex)
							}
							return t
						},
						toJSON: function () {
							var t = {
								metadata: {
									version: 4.5,
									type: "BufferGeometry",
									generator: "BufferGeometry.toJSON"
								}
							};
							if (t.uuid = this.uuid, t.type = this.type, "" !== this.name && (t.name = this
									.name), 0 < Object.keys(this.userData).length && (t.userData = this
									.userData), void 0 !== this.parameters) {
								var e = this.parameters;
								for (var i in e) void 0 !== e[i] && (t[i] = e[i]);
								return t
							}
							t.data = {
								attributes: {}
							};
							var n = this.index;
							if (null !== n) {
								var r = Array.prototype.slice.call(n.array);
								t.data.index = {
									type: n.array.constructor.name,
									array: r
								}
							}
							var a = this.attributes;
							for (var i in a) {
								var o = a[i];
								r = Array.prototype.slice.call(o.array);
								t.data.attributes[i] = {
									itemSize: o.itemSize,
									type: o.array.constructor.name,
									array: r,
									normalized: o.normalized
								}
							}
							var s = this.groups;
							0 < s.length && (t.data.groups = JSON.parse(JSON.stringify(s)));
							var c = this.boundingSphere;
							return null !== c && (t.data.boundingSphere = {
								center: c.center.toArray(),
								radius: c.radius
							}), t
						},
						clone: function () {
							return (new ir).copy(this)
						},
						copy: function (t) {
							var e, i, n;
							this.index = null, this.attributes = {}, this.morphAttributes = {}, this
								.groups = [], this.boundingBox = null, this.boundingSphere = null, this
								.name = t.name;
							var r = t.index;
							null !== r && this.setIndex(r.clone());
							var a = t.attributes;
							for (e in a) {
								var o = a[e];
								this.addAttribute(e, o.clone())
							}
							var s = t.morphAttributes;
							for (e in s) {
								var c = [],
									h = s[e];
								for (i = 0, n = h.length; i < n; i++) c.push(h[i].clone());
								this.morphAttributes[e] = c
							}
							var l = t.groups;
							for (i = 0, n = l.length; i < n; i++) {
								var u = l[i];
								this.addGroup(u.start, u.count, u.materialIndex)
							}
							var p = t.boundingBox;
							null !== p && (this.boundingBox = p.clone());
							var d = t.boundingSphere;
							return null !== d && (this.boundingSphere = d.clone()), this.drawRange.start =
								t.drawRange.start, this.drawRange.count = t.drawRange.count, this
								.userData = t.userData, this
						},
						dispose: function () {
							this.dispatchEvent({
								type: "dispose"
							})
						}
					}), nr.prototype = Object.create(On.prototype), nr.prototype.constructor = nr, rr.prototype =
					Object.create(ir.prototype), rr.prototype.constructor = rr, ar.prototype = Object.create(On
						.prototype), ar.prototype.constructor = ar, or.prototype = Object.create(ir.prototype), or
					.prototype.constructor = or;
				var sr, cr, hr, lr, ur, pr, dr, fr, mr, gr, vr, yr, xr, br, wr, _r, Mr, Sr, Er, Tr, Ar, Lr, Pr,
					Cr, Rr, Or = 0;

				function Ir() {
					Object.defineProperty(this, "id", {
							value: Or++
						}), this.uuid = oi.generateUUID(), this.name = "", this.type = "Material", this.fog = !0,
						this.lights = !0, this.blending = mt, this.side = N, this.flatShading = !1, this
						.vertexColors = O, this.opacity = 1, this.transparent = !1, this.blendSrc = q, this
						.blendDst = X, this.blendEquation = bt, this.blendSrcAlpha = null, this.blendDstAlpha =
						null, this.blendEquationAlpha = null, this.depthFunc = St, this.depthTest = !0, this
						.depthWrite = !0, this.clippingPlanes = null, this.clipIntersection = !1, this
						.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null,
						this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this
						.dithering = !1, this.alphaTest = 0, this.premultipliedAlpha = !1, this.visible = !0, this
						.userData = {}, this.needsUpdate = !0
				}

				function Dr(t) {
					Ir.call(this), this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this
						.vertexShader =
						"void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",
						this.fragmentShader = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}",
						this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this
						.lights = !1, this.clipping = !1, this.skinning = !1, this.morphTargets = !1, this
						.morphNormals = !1, this.extensions = {
							derivatives: !1,
							fragDepth: !1,
							drawBuffers: !1,
							shaderTextureLOD: !1
						}, this.defaultAttributeValues = {
							color: [1, 1, 1],
							uv: [0, 0],
							uv2: [0, 0]
						}, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, void 0 !== t && (
							void 0 !== t.attributes && console.error(
								"THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."
								), this.setValues(t))
				}

				function Br(t, e) {
					this.origin = void 0 !== t ? t : new li, this.direction = void 0 !== e ? e : new li
				}

				function Nr(t, e, i) {
					this.a = void 0 !== t ? t : new li, this.b = void 0 !== e ? e : new li, this.c = void 0 !==
						i ? i : new li
				}

				function zr(t) {
					Ir.call(this), this.type = "MeshBasicMaterial", this.color = new Xi(16777215), this.map =
						null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this
						.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null,
						this.combine = $, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1,
						this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin =
						"round", this.skinning = !1, this.morphTargets = !1, this.lights = !1, this.setValues(t)
				}

				function Ur(t, e) {
					Mn.call(this), this.type = "Mesh", this.geometry = void 0 !== t ? t : new ir, this.material =
						void 0 !== e ? e : new zr({
							color: 16777215 * Math.random()
						}), this.drawMode = We, this.updateMorphTargets()
				}

				function Gr(o, i, s, n) {
					var c, h, l = new Xi(0),
						u = 0,
						p = null,
						d = 0;

					function t(t, e, i, n) {
						var r = e.background;
						if (null === r ? (f(l, u), p = null, d = 0) : r && r.isColor && (f(r, 1), n = !0, p =
								null, d = 0), (o.autoClear || n) && o.clear(o.autoClearColor, o.autoClearDepth, o
								.autoClearStencil), r && (r.isCubeTexture || r.isWebGLRenderTargetCube)) {
							void 0 === h && ((h = new Ur(new rr(1, 1, 1), new Dr({
									type: "BackgroundCubeMaterial",
									uniforms: Fi(Qi.cube.uniforms),
									vertexShader: Qi.cube.vertexShader,
									fragmentShader: Qi.cube.fragmentShader,
									side: kt,
									depthTest: !0,
									depthWrite: !1,
									fog: !1
								}))).geometry.removeAttribute("normal"), h.geometry.removeAttribute("uv"), h
								.onBeforeRender = function (t, e, i) {
									this.matrixWorld.copyPosition(i.matrixWorld)
								}, Object.defineProperty(h.material, "map", {
									get: function () {
										return this.uniforms.tCube.value
									}
								}), s.update(h));
							var a = r.isWebGLRenderTargetCube ? r.texture : r;
							h.material.uniforms.tCube.value = a, h.material.uniforms.tFlip.value = r
								.isWebGLRenderTargetCube ? 1 : -1, p === r && d === a.version || (h.material
									.needsUpdate = !0, p = r, d = a.version), t.unshift(h, h.geometry, h.material,
									0, null)
						} else r && r.isTexture && (void 0 === c && ((c = new Ur(new or(2, 2), new Dr({
								type: "BackgroundMaterial",
								uniforms: Fi(Qi.background.uniforms),
								vertexShader: Qi.background.vertexShader,
								fragmentShader: Qi.background.fragmentShader,
								side: N,
								depthTest: !1,
								depthWrite: !1,
								fog: !1
							}))).geometry.removeAttribute("normal"), Object.defineProperty(c.material,
								"map", {
									get: function () {
										return this.uniforms.t2D.value
									}
								}), s.update(c)), !0 === (c.material.uniforms.t2D.value = r)
							.matrixAutoUpdate && r.updateMatrix(), c.material.uniforms.uvTransform.value.copy(
								r.matrix), p === r && d === r.version || (c.material.needsUpdate = !0, d = (
								p = r).version), t.unshift(c, c.geometry, c.material, 0, null))
					}

					function f(t, e) {
						i.buffers.color.setClear(t.r, t.g, t.b, e, n)
					}
					return {
						getClearColor: function () {
							return l
						},
						setClearColor: function (t, e) {
							l.set(t), f(l, u = void 0 !== e ? e : 1)
						},
						getClearAlpha: function () {
							return u
						},
						setClearAlpha: function (t) {
							f(l, u = t)
						},
						render: t
					}
				}

				function Fr(r, a, o, s) {
					var c;

					function t(t) {
						c = t
					}

					function e(t, e) {
						r.drawArrays(c, t, e), o.update(e, c)
					}

					function i(t, e, i) {
						var n;
						if (s.isWebGL2) n = r;
						else if (null === (n = a.get("ANGLE_instanced_arrays"))) return void console.error(
							"THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
							);
						n[s.isWebGL2 ? "drawArraysInstanced" : "drawArraysInstancedANGLE"](c, e, i, t
							.maxInstancedCount), o.update(i, c, t.maxInstancedCount)
					}
					this.setMode = t, this.render = e, this.renderInstances = i
				}

				function Hr(e, i, t) {
					var n;

					function r() {
						if (void 0 !== n) return n;
						var t = i.get("EXT_texture_filter_anisotropic");
						return n = null !== t ? e.getParameter(t.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0
					}

					function a(t) {
						if ("highp" === t) {
							if (0 < e.getShaderPrecisionFormat(35633, 36338).precision && 0 < e
								.getShaderPrecisionFormat(35632, 36338).precision) return "highp";
							t = "mediump"
						}
						return "mediump" === t && 0 < e.getShaderPrecisionFormat(35633, 36337).precision && 0 < e
							.getShaderPrecisionFormat(35632, 36337).precision ? "mediump" : "lowp"
					}
					var o = "undefined" != typeof WebGL2RenderingContext && e instanceof WebGL2RenderingContext,
						s = void 0 !== t.precision ? t.precision : "highp",
						c = a(s);
					c !== s && (console.warn("THREE.WebGLRenderer:", s, "not supported, using", c, "instead."),
						s = c);
					var h = !0 === t.logarithmicDepthBuffer,
						l = e.getParameter(34930),
						u = e.getParameter(35660),
						p = e.getParameter(3379),
						d = e.getParameter(34076),
						f = e.getParameter(34921),
						m = e.getParameter(36347),
						g = e.getParameter(36348),
						v = e.getParameter(36349),
						y = 0 < u,
						x = o || !!i.get("OES_texture_float");
					return {
						isWebGL2: o,
						getMaxAnisotropy: r,
						getMaxPrecision: a,
						precision: s,
						logarithmicDepthBuffer: h,
						maxTextures: l,
						maxVertexTextures: u,
						maxTextureSize: p,
						maxCubemapSize: d,
						maxAttributes: f,
						maxVertexUniforms: m,
						maxVaryings: g,
						maxFragmentUniforms: v,
						vertexTextures: y,
						floatFragmentTextures: x,
						floatVertexTextures: y && x
					}
				}

				function kr() {
					var l = this,
						u = null,
						p = 0,
						d = !1,
						f = !1,
						m = new zi,
						g = new ui,
						v = {
							value: null,
							needsUpdate: !1
						};

					function y() {
						v.value !== u && (v.value = u, v.needsUpdate = 0 < p), l.numPlanes = p, l
							.numIntersection = 0
					}

					function x(t, e, i, n) {
						var r = null !== t ? t.length : 0,
							a = null;
						if (0 !== r) {
							if (a = v.value, !0 !== n || null === a) {
								var o = i + 4 * r,
									s = e.matrixWorldInverse;
								g.getNormalMatrix(s), (null === a || a.length < o) && (a = new Float32Array(o));
								for (var c = 0, h = i; c !== r; ++c, h += 4) m.copy(t[c]).applyMatrix4(s, g), m
									.normal.toArray(a, h), a[h + 3] = m.constant
							}
							v.value = a, v.needsUpdate = !0
						}
						return l.numPlanes = r, a
					}
					this.uniform = v, this.numPlanes = 0, this.numIntersection = 0, this.init = function (t, e,
					i) {
						var n = 0 !== t.length || e || 0 !== p || d;
						return d = e, u = x(t, i, 0), p = t.length, n
					}, this.beginShadows = function () {
						f = !0, x(null)
					}, this.endShadows = function () {
						f = !1, y()
					}, this.setState = function (t, e, i, n, r, a) {
						if (!d || null === t || 0 === t.length || f && !i) f ? x(null) : y();
						else {
							var o = f ? 0 : p,
								s = 4 * o,
								c = r.clippingState || null;
							v.value = c, c = x(t, n, s, a);
							for (var h = 0; h !== s; ++h) c[h] = u[h];
							r.clippingState = c, this.numIntersection = e ? this.numPlanes : 0, this
								.numPlanes += o
						}
					}
				}

				function jr(i) {
					var n = {};
					return {
						get: function (t) {
							if (void 0 !== n[t]) return n[t];
							var e;
							switch (t) {
								case "WEBGL_depth_texture":
									e = i.getExtension("WEBGL_depth_texture") || i.getExtension(
										"MOZ_WEBGL_depth_texture") || i.getExtension(
										"WEBKIT_WEBGL_depth_texture");
									break;
								case "EXT_texture_filter_anisotropic":
									e = i.getExtension("EXT_texture_filter_anisotropic") || i.getExtension(
										"MOZ_EXT_texture_filter_anisotropic") || i.getExtension(
										"WEBKIT_EXT_texture_filter_anisotropic");
									break;
								case "WEBGL_compressed_texture_s3tc":
									e = i.getExtension("WEBGL_compressed_texture_s3tc") || i.getExtension(
										"MOZ_WEBGL_compressed_texture_s3tc") || i.getExtension(
										"WEBKIT_WEBGL_compressed_texture_s3tc");
									break;
								case "WEBGL_compressed_texture_pvrtc":
									e = i.getExtension("WEBGL_compressed_texture_pvrtc") || i.getExtension(
										"WEBKIT_WEBGL_compressed_texture_pvrtc");
									break;
								default:
									e = i.getExtension(t)
							}
							return null === e && console.warn("THREE.WebGLRenderer: " + t +
								" extension not supported."), n[t] = e
						}
					}
				}

				function Vr(t, u, a) {
					var o = {},
						p = {};

					function s(t) {
						var e = t.target,
							i = o[e.id];
						for (var n in null !== i.index && u.remove(i.index), i.attributes) u.remove(i.attributes[
							n]);
						e.removeEventListener("dispose", s), delete o[e.id];
						var r = p[i.id];
						r && (u.remove(r), delete p[i.id]), a.memory.geometries--
					}

					function e(t, e) {
						var i = o[e.id];
						return i || (e.addEventListener("dispose", s), e.isBufferGeometry ? i = e : e
							.isGeometry && (void 0 === e._bufferGeometry && (e._bufferGeometry = (new ir)
								.setFromObject(t)), i = e._bufferGeometry), o[e.id] = i, a.memory
							.geometries++, i)
					}

					function i(t) {
						var e = t.index,
							i = t.attributes;
						for (var n in null !== e && u.update(e, 34963), i) u.update(i[n], 34962);
						var r = t.morphAttributes;
						for (var n in r)
							for (var a = r[n], o = 0, s = a.length; o < s; o++) u.update(a[o], 34962)
					}

					function n(t) {
						var e = p[t.id];
						if (e) return e;
						var i = [],
							n = t.index,
							r = t.attributes;
						if (null !== n)
							for (var a = 0, o = (l = n.array).length; a < o; a += 3) {
								var s = l[a + 0],
									c = l[a + 1],
									h = l[a + 2];
								i.push(s, c, c, h, h, s)
							} else {
								var l;
								for (a = 0, o = (l = r.position.array).length / 3 - 1; a < o; a += 3) {
									s = a + 0, c = a + 1, h = a + 2;
									i.push(s, c, c, h, h, s)
								}
							}
						return e = new(65535 < Vn(i) ? Fn : Un)(i, 1), u.update(e, 34963), p[t.id] = e
					}
					return {
						get: e,
						update: i,
						getWireframeAttribute: n
					}
				}

				function Wr(r, a, o, s) {
					var c, h, l;

					function t(t) {
						c = t
					}

					function e(t) {
						h = t.type, l = t.bytesPerElement
					}

					function i(t, e) {
						r.drawElements(c, e, h, t * l), o.update(e, c)
					}

					function n(t, e, i) {
						var n;
						if (s.isWebGL2) n = r;
						else if (null === (n = a.get("ANGLE_instanced_arrays"))) return void console.error(
							"THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
							);
						n[s.isWebGL2 ? "drawElementsInstanced" : "drawElementsInstancedANGLE"](c, i, h, e * l, t
							.maxInstancedCount), o.update(i, c, t.maxInstancedCount)
					}
					this.setMode = t, this.setIndex = e, this.render = i, this.renderInstances = n
				}

				function qr(t) {
					var n = {
						frame: 0,
						calls: 0,
						triangles: 0,
						points: 0,
						lines: 0
					};

					function e(t, e, i) {
						switch (i = i || 1, n.calls++, e) {
							case 4:
								n.triangles += i * (t / 3);
								break;
							case 5:
							case 6:
								n.triangles += i * (t - 2);
								break;
							case 1:
								n.lines += i * (t / 2);
								break;
							case 3:
								n.lines += i * (t - 1);
								break;
							case 2:
								n.lines += i * t;
								break;
							case 0:
								n.points += i * t;
								break;
							default:
								console.error("THREE.WebGLInfo: Unknown draw mode:", e)
						}
					}

					function i() {
						n.frame++, n.calls = 0, n.triangles = 0, n.points = 0, n.lines = 0
					}
					return {
						memory: {
							geometries: 0,
							textures: 0
						},
						render: n,
						programs: null,
						autoReset: !0,
						reset: i,
						update: e
					}
				}

				function Xr(t, e) {
					return Math.abs(e[1]) - Math.abs(t[1])
				}

				function Yr(d) {
					var f = {},
						m = new Float32Array(8);

					function t(t, e, i, n) {
						var r = t.morphTargetInfluences,
							a = r.length,
							o = f[e.id];
						if (void 0 === o) {
							o = [];
							for (var s = 0; s < a; s++) o[s] = [s, 0];
							f[e.id] = o
						}
						var c = i.morphTargets && e.morphAttributes.position,
							h = i.morphNormals && e.morphAttributes.normal;
						for (s = 0; s < a; s++) {
							0 !== (l = o[s])[1] && (c && e.removeAttribute("morphTarget" + s), h && e
								.removeAttribute("morphNormal" + s))
						}
						for (s = 0; s < a; s++) {
							(l = o[s])[0] = s, l[1] = r[s]
						}
						o.sort(Xr);
						for (s = 0; s < 8; s++) {
							var l;
							if (l = o[s]) {
								var u = l[0],
									p = l[1];
								if (p) {
									c && e.addAttribute("morphTarget" + s, c[u]), h && e.addAttribute(
										"morphNormal" + s, h[u]), m[s] = p;
									continue
								}
							}
							m[s] = 0
						}
						n.getUniforms().setValue(d, "morphTargetInfluences", m)
					}
					return {
						update: t
					}
				}

				function Jr(r, a) {
					var o = {};

					function t(t) {
						var e = a.render.frame,
							i = t.geometry,
							n = r.get(t, i);
						return o[n.id] !== e && (i.isGeometry && n.updateFromObject(t), r.update(n), o[n.id] = e),
							n
					}

					function e() {
						o = {}
					}
					return {
						update: t,
						dispose: e
					}
				}

				function Zr(t, e, i, n, r, a, o, s, c, h) {
					t = void 0 !== t ? t : [], e = void 0 !== e ? e : ct, Ci.call(this, t, e, i, n, r, a, o, s, c,
						h), this.flipY = !1
				}

				function Qr(t, e, i, n) {
					Ci.call(this, null), this.image = {
						data: t,
						width: e,
						height: i,
						depth: n
					}, this.magFilter = zt, this.minFilter = zt, this.generateMipmaps = !1, this.flipY = !1
				}
				Ir.prototype = Object.assign(Object.create(e.prototype), {
						constructor: Ir,
						isMaterial: !0,
						onBeforeCompile: function () {},
						setValues: function (t) {
							if (void 0 !== t)
								for (var e in t) {
									var i = t[e];
									if (void 0 !== i)
										if ("shading" !== e) {
											var n = this[e];
											void 0 !== n ? n && n.isColor ? n.set(i) : n && n.isVector3 &&
												i && i.isVector3 ? n.copy(i) : this[e] = i : console.warn(
													"THREE." + this.type + ": '" + e +
													"' is not a property of this material.")
										} else console.warn("THREE." + this.type +
											": .shading has been removed. Use the boolean .flatShading instead."
											), this.flatShading = i === C;
									else console.warn("THREE.Material: '" + e +
										"' parameter is undefined.")
								}
						},
						toJSON: function (t) {
							var e = void 0 === t || "string" == typeof t;
							e && (t = {
								textures: {},
								images: {}
							});
							var i = {
								metadata: {
									version: 4.5,
									type: "Material",
									generator: "Material.toJSON"
								}
							};

							function n(t) {
								var e = [];
								for (var i in t) {
									var n = t[i];
									delete n.metadata, e.push(n)
								}
								return e
							}
							if (i.uuid = this.uuid, i.type = this.type, "" !== this.name && (i.name = this
									.name), this.color && this.color.isColor && (i.color = this.color
									.getHex()), void 0 !== this.roughness && (i.roughness = this
									.roughness), void 0 !== this.metalness && (i.metalness = this
									.metalness), this.emissive && this.emissive.isColor && (i.emissive =
									this.emissive.getHex()), 1 !== this.emissiveIntensity && (i
									.emissiveIntensity = this.emissiveIntensity), this.specular && this
								.specular.isColor && (i.specular = this.specular.getHex()), void 0 !==
								this.shininess && (i.shininess = this.shininess), void 0 !== this
								.clearCoat && (i.clearCoat = this.clearCoat), void 0 !== this
								.clearCoatRoughness && (i.clearCoatRoughness = this.clearCoatRoughness),
								this.map && this.map.isTexture && (i.map = this.map.toJSON(t).uuid), this
								.alphaMap && this.alphaMap.isTexture && (i.alphaMap = this.alphaMap
									.toJSON(t).uuid), this.lightMap && this.lightMap.isTexture && (i
									.lightMap = this.lightMap.toJSON(t).uuid), this.aoMap && this.aoMap
								.isTexture && (i.aoMap = this.aoMap.toJSON(t).uuid, i.aoMapIntensity =
									this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (i
									.bumpMap = this.bumpMap.toJSON(t).uuid, i.bumpScale = this.bumpScale),
								this.normalMap && this.normalMap.isTexture && (i.normalMap = this
									.normalMap.toJSON(t).uuid, i.normalMapType = this.normalMapType, i
									.normalScale = this.normalScale.toArray()), this.displacementMap &&
								this.displacementMap.isTexture && (i.displacementMap = this
									.displacementMap.toJSON(t).uuid, i.displacementScale = this
									.displacementScale, i.displacementBias = this.displacementBias), this
								.roughnessMap && this.roughnessMap.isTexture && (i.roughnessMap = this
									.roughnessMap.toJSON(t).uuid), this.metalnessMap && this.metalnessMap
								.isTexture && (i.metalnessMap = this.metalnessMap.toJSON(t).uuid), this
								.emissiveMap && this.emissiveMap.isTexture && (i.emissiveMap = this
									.emissiveMap.toJSON(t).uuid), this.specularMap && this.specularMap
								.isTexture && (i.specularMap = this.specularMap.toJSON(t).uuid), this
								.envMap && this.envMap.isTexture && (i.envMap = this.envMap.toJSON(t)
									.uuid, i.reflectivity = this.reflectivity, void 0 !== this.combine &&
									(i.combine = this.combine), void 0 !== this.envMapIntensity && (i
										.envMapIntensity = this.envMapIntensity)), this.gradientMap &&
								this.gradientMap.isTexture && (i.gradientMap = this.gradientMap.toJSON(t)
									.uuid), void 0 !== this.size && (i.size = this.size), void 0 !== this
								.sizeAttenuation && (i.sizeAttenuation = this.sizeAttenuation), this
								.blending !== mt && (i.blending = this.blending), !0 === this
								.flatShading && (i.flatShading = this.flatShading), this.side !== N && (i
									.side = this.side), this.vertexColors !== O && (i.vertexColors = this
									.vertexColors), this.opacity < 1 && (i.opacity = this.opacity), !0 ===
								this.transparent && (i.transparent = this.transparent), i.depthFunc = this
								.depthFunc, i.depthTest = this.depthTest, i.depthWrite = this.depthWrite,
								0 !== this.rotation && (i.rotation = this.rotation), !0 === this
								.polygonOffset && (i.polygonOffset = !0), 0 !== this
								.polygonOffsetFactor && (i.polygonOffsetFactor = this
								.polygonOffsetFactor), 0 !== this.polygonOffsetUnits && (i
									.polygonOffsetUnits = this.polygonOffsetUnits), 1 !== this
								.linewidth && (i.linewidth = this.linewidth), void 0 !== this.dashSize &&
								(i.dashSize = this.dashSize), void 0 !== this.gapSize && (i.gapSize = this
									.gapSize), void 0 !== this.scale && (i.scale = this.scale), !0 ===
								this.dithering && (i.dithering = !0), 0 < this.alphaTest && (i.alphaTest =
									this.alphaTest), !0 === this.premultipliedAlpha && (i
									.premultipliedAlpha = this.premultipliedAlpha), !0 === this
								.wireframe && (i.wireframe = this.wireframe), 1 < this
								.wireframeLinewidth && (i.wireframeLinewidth = this.wireframeLinewidth),
								"round" !== this.wireframeLinecap && (i.wireframeLinecap = this
									.wireframeLinecap), "round" !== this.wireframeLinejoin && (i
									.wireframeLinejoin = this.wireframeLinejoin), !0 === this
								.morphTargets && (i.morphTargets = !0), !0 === this.skinning && (i
									.skinning = !0), !1 === this.visible && (i.visible = !1), "{}" !==
								JSON.stringify(this.userData) && (i.userData = this.userData), e) {
								var r = n(t.textures),
									a = n(t.images);
								0 < r.length && (i.textures = r), 0 < a.length && (i.images = a)
							}
							return i
						},
						clone: function () {
							return (new this.constructor).copy(this)
						},
						copy: function (t) {
							this.name = t.name, this.fog = t.fog, this.lights = t.lights, this.blending =
								t.blending, this.side = t.side, this.flatShading = t.flatShading, this
								.vertexColors = t.vertexColors, this.opacity = t.opacity, this
								.transparent = t.transparent, this.blendSrc = t.blendSrc, this.blendDst =
								t.blendDst, this.blendEquation = t.blendEquation, this.blendSrcAlpha = t
								.blendSrcAlpha, this.blendDstAlpha = t.blendDstAlpha, this
								.blendEquationAlpha = t.blendEquationAlpha, this.depthFunc = t.depthFunc,
								this.depthTest = t.depthTest, this.depthWrite = t.depthWrite, this
								.colorWrite = t.colorWrite, this.precision = t.precision, this
								.polygonOffset = t.polygonOffset, this.polygonOffsetFactor = t
								.polygonOffsetFactor, this.polygonOffsetUnits = t.polygonOffsetUnits, this
								.dithering = t.dithering, this.alphaTest = t.alphaTest, this
								.premultipliedAlpha = t.premultipliedAlpha, this.visible = t.visible, this
								.userData = JSON.parse(JSON.stringify(t.userData)), this.clipShadows = t
								.clipShadows, this.clipIntersection = t.clipIntersection;
							var e = t.clippingPlanes,
								i = null;
							if (null !== e) {
								var n = e.length;
								i = new Array(n);
								for (var r = 0; r !== n; ++r) i[r] = e[r].clone()
							}
							return this.clippingPlanes = i, this.shadowSide = t.shadowSide, this
						},
						dispose: function () {
							this.dispatchEvent({
								type: "dispose"
							})
						}
					}), Dr.prototype = Object.create(Ir.prototype), (Dr.prototype.constructor = Dr).prototype
					.isShaderMaterial = !0, Dr.prototype.copy = function (t) {
						return Ir.prototype.copy.call(this, t), this.fragmentShader = t.fragmentShader, this
							.vertexShader = t.vertexShader, this.uniforms = Fi(t.uniforms), this.defines = Object
							.assign({}, t.defines), this.wireframe = t.wireframe, this.wireframeLinewidth = t
							.wireframeLinewidth, this.lights = t.lights, this.clipping = t.clipping, this
							.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t
							.morphNormals, this.extensions = t.extensions, this
					}, Dr.prototype.toJSON = function (t) {
						var e = Ir.prototype.toJSON.call(this, t);
						for (var i in e.uniforms = {}, this.uniforms) {
							var n = this.uniforms[i].value;
							n && n.isTexture ? e.uniforms[i] = {
								type: "t",
								value: n.toJSON(t).uuid
							} : n && n.isColor ? e.uniforms[i] = {
								type: "c",
								value: n.getHex()
							} : n && n.isVector2 ? e.uniforms[i] = {
								type: "v2",
								value: n.toArray()
							} : n && n.isVector3 ? e.uniforms[i] = {
								type: "v3",
								value: n.toArray()
							} : n && n.isVector4 ? e.uniforms[i] = {
								type: "v4",
								value: n.toArray()
							} : n && n.isMatrix4 ? e.uniforms[i] = {
								type: "m4",
								value: n.toArray()
							} : e.uniforms[i] = {
								value: n
							}
						}
						0 < Object.keys(this.defines).length && (e.defines = this.defines), e.vertexShader = this
							.vertexShader, e.fragmentShader = this.fragmentShader;
						var r = {};
						for (var a in this.extensions) !0 === this.extensions[a] && (r[a] = !0);
						return 0 < Object.keys(r).length && (e.extensions = r), e
					}, Object.assign(Br.prototype, {
						set: function (t, e) {
							return this.origin.copy(t), this.direction.copy(e), this
						},
						clone: function () {
							return (new this.constructor).copy(this)
						},
						copy: function (t) {
							return this.origin.copy(t.origin), this.direction.copy(t.direction), this
						},
						at: function (t, e) {
							return void 0 === e && (console.warn(
								"THREE.Ray: .at() target is now required"), e = new li), e.copy(this
								.direction).multiplyScalar(t).add(this.origin)
						},
						lookAt: function (t) {
							return this.direction.copy(t).sub(this.origin).normalize(), this
						},
						recast: (vr = new li, function (t) {
							return this.origin.copy(this.at(t, vr)), this
						}),
						closestPointToPoint: function (t, e) {
							void 0 === e && (console.warn(
									"THREE.Ray: .closestPointToPoint() target is now required"), e =
								new li), e.subVectors(t, this.origin);
							var i = e.dot(this.direction);
							return i < 0 ? e.copy(this.origin) : e.copy(this.direction).multiplyScalar(i)
								.add(this.origin)
						},
						distanceToPoint: function (t) {
							return Math.sqrt(this.distanceSqToPoint(t))
						},
						distanceSqToPoint: (gr = new li, function (t) {
							var e = gr.subVectors(t, this.origin).dot(this.direction);
							return e < 0 ? this.origin.distanceToSquared(t) : (gr.copy(this.direction)
								.multiplyScalar(e).add(this.origin), gr.distanceToSquared(t))
						}),
						distanceSqToSegment: (dr = new li, fr = new li, mr = new li, function (t, e, i, n) {
							dr.copy(t).add(e).multiplyScalar(.5), fr.copy(e).sub(t).normalize(), mr
								.copy(this.origin).sub(dr);
							var r, a, o, s, c = .5 * t.distanceTo(e),
								h = -this.direction.dot(fr),
								l = mr.dot(this.direction),
								u = -mr.dot(fr),
								p = mr.lengthSq(),
								d = Math.abs(1 - h * h);
							if (0 < d)
								if (a = h * l - u, s = c * d, 0 <= (r = h * u - l))
									if (-s <= a)
										if (a <= s) {
											var f = 1 / d;
											o = (r *= f) * (r + h * (a *= f) + 2 * l) + a * (h * r +
												a + 2 * u) + p
										} else a = c, o = -(r = Math.max(0, -(h * a + l))) * r + a * (
											a + 2 * u) + p;
							else a = -c, o = -(r = Math.max(0, -(h * a + l))) * r + a * (a + 2 * u) +
								p;
							else o = a <= -s ? -(r = Math.max(0, -(-h * c + l))) * r + (a = 0 < r ? -
								c : Math.min(Math.max(-c, -u), c)) * (a + 2 * u) + p : a <= s ? (
								r = 0, (a = Math.min(Math.max(-c, -u), c)) * (a + 2 * u) + p) : -(
								r = Math.max(0, -(h * c + l))) * r + (a = 0 < r ? c : Math.min(
								Math.max(-c, -u), c)) * (a + 2 * u) + p;
							else a = 0 < h ? -c : c, o = -(r = Math.max(0, -(h * a + l))) * r + a * (
								a + 2 * u) + p;
							return i && i.copy(this.direction).multiplyScalar(r).add(this.origin),
								n && n.copy(fr).multiplyScalar(a).add(dr), o
						}),
						intersectSphere: (pr = new li, function (t, e) {
							pr.subVectors(t.center, this.origin);
							var i = pr.dot(this.direction),
								n = pr.dot(pr) - i * i,
								r = t.radius * t.radius;
							if (r < n) return null;
							var a = Math.sqrt(r - n),
								o = i - a,
								s = i + a;
							return o < 0 && s < 0 ? null : o < 0 ? this.at(s, e) : this.at(o, e)
						}),
						intersectsSphere: function (t) {
							return this.distanceSqToPoint(t.center) <= t.radius * t.radius
						},
						distanceToPlane: function (t) {
							var e = t.normal.dot(this.direction);
							if (0 === e) return 0 === t.distanceToPoint(this.origin) ? 0 : null;
							var i = -(this.origin.dot(t.normal) + t.constant) / e;
							return 0 <= i ? i : null
						},
						intersectPlane: function (t, e) {
							var i = this.distanceToPlane(t);
							return null === i ? null : this.at(i, e)
						},
						intersectsPlane: function (t) {
							var e = t.distanceToPoint(this.origin);
							return 0 === e || t.normal.dot(this.direction) * e < 0
						},
						intersectBox: function (t, e) {
							var i, n, r, a, o, s, c = 1 / this.direction.x,
								h = 1 / this.direction.y,
								l = 1 / this.direction.z,
								u = this.origin;
							return n = 0 <= c ? (i = (t.min.x - u.x) * c, (t.max.x - u.x) * c) : (i = (t
								.max.x - u.x) * c, (t.min.x - u.x) * c), (a = 0 <= h ? (r = (t.min.y -
								u.y) * h, (t.max.y - u.y) * h) : (r = (t.max.y - u.y) * h, (t.min
								.y - u.y) * h)) < i || n < r ? null : ((i < r || i != i) && (i = r), (
								a < n || n != n) && (n = a), (s = 0 <= l ? (o = (t.min.z - u.z) *
								l, (t.max.z - u.z) * l) : (o = (t.max.z - u.z) * l, (t.min.z -
								u.z) * l)) < i || n < o ? null : ((i < o || i != i) && (i = o), (
								s < n || n != n) && (n = s), n < 0 ? null : this.at(0 <= i ?
								i : n, e)))
						},
						intersectsBox: (ur = new li, function (t) {
							return null !== this.intersectBox(t, ur)
						}),
						intersectTriangle: (sr = new li, cr = new li, hr = new li, lr = new li, function (t,
							e, i, n, r) {
							cr.subVectors(e, t), hr.subVectors(i, t), lr.crossVectors(cr, hr);
							var a, o = this.direction.dot(lr);
							if (0 < o) {
								if (n) return null;
								a = 1
							} else {
								if (!(o < 0)) return null;
								a = -1, o = -o
							}
							sr.subVectors(this.origin, t);
							var s = a * this.direction.dot(hr.crossVectors(sr, hr));
							if (s < 0) return null;
							var c = a * this.direction.dot(cr.cross(sr));
							if (c < 0) return null;
							if (o < s + c) return null;
							var h = -a * sr.dot(lr);
							return h < 0 ? null : this.at(h / o, r)
						}),
						applyMatrix4: function (t) {
							return this.origin.applyMatrix4(t), this.direction.transformDirection(t), this
						},
						equals: function (t) {
							return t.origin.equals(this.origin) && t.direction.equals(this.direction)
						}
					}), Object.assign(Nr, {
						getNormal: (Mr = new li, function (t, e, i, n) {
							void 0 === n && (console.warn(
									"THREE.Triangle: .getNormal() target is now required"), n =
								new li), n.subVectors(i, e), Mr.subVectors(t, e), n.cross(Mr);
							var r = n.lengthSq();
							return 0 < r ? n.multiplyScalar(1 / Math.sqrt(r)) : n.set(0, 0, 0)
						}),
						getBarycoord: (br = new li, wr = new li, _r = new li, function (t, e, i, n, r) {
							br.subVectors(n, e), wr.subVectors(i, e), _r.subVectors(t, e);
							var a = br.dot(br),
								o = br.dot(wr),
								s = br.dot(_r),
								c = wr.dot(wr),
								h = wr.dot(_r),
								l = a * c - o * o;
							if (void 0 === r && (console.warn(
										"THREE.Triangle: .getBarycoord() target is now required"), r =
									new li), 0 === l) return r.set(-2, -1, -1);
							var u = 1 / l,
								p = (c * s - o * h) * u,
								d = (a * h - o * s) * u;
							return r.set(1 - p - d, d, p)
						}),
						containsPoint: (xr = new li, function (t, e, i, n) {
							return Nr.getBarycoord(t, e, i, n, xr), 0 <= xr.x && 0 <= xr.y && xr.x +
								xr.y <= 1
						}),
						getUV: (yr = new li, function (t, e, i, n, r, a, o, s) {
							return this.getBarycoord(t, e, i, n, yr), s.set(0, 0), s.addScaledVector(
									r, yr.x), s.addScaledVector(a, yr.y), s.addScaledVector(o, yr.z),
								s
						})
					}), Object.assign(Nr.prototype, {
						set: function (t, e, i) {
							return this.a.copy(t), this.b.copy(e), this.c.copy(i), this
						},
						setFromPointsAndIndices: function (t, e, i, n) {
							return this.a.copy(t[e]), this.b.copy(t[i]), this.c.copy(t[n]), this
						},
						clone: function () {
							return (new this.constructor).copy(this)
						},
						copy: function (t) {
							return this.a.copy(t.a), this.b.copy(t.b), this.c.copy(t.c), this
						},
						getArea: (Cr = new li, Rr = new li, function () {
							return Cr.subVectors(this.c, this.b), Rr.subVectors(this.a, this.b), .5 *
								Cr.cross(Rr).length()
						}),
						getMidpoint: function (t) {
							return void 0 === t && (console.warn(
									"THREE.Triangle: .getMidpoint() target is now required"), t =
								new li), t.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 /
								3)
						},
						getNormal: function (t) {
							return Nr.getNormal(this.a, this.b, this.c, t)
						},
						getPlane: function (t) {
							return void 0 === t && (console.warn(
									"THREE.Triangle: .getPlane() target is now required"), t = new li), t
								.setFromCoplanarPoints(this.a, this.b, this.c)
						},
						getBarycoord: function (t, e) {
							return Nr.getBarycoord(t, this.a, this.b, this.c, e)
						},
						containsPoint: function (t) {
							return Nr.containsPoint(t, this.a, this.b, this.c)
						},
						getUV: function (t, e, i, n, r) {
							return Nr.getUV(t, this.a, this.b, this.c, e, i, n, r)
						},
						intersectsBox: function (t) {
							return t.intersectsTriangle(this)
						},
						closestPointToPoint: (Sr = new li, Er = new li, Tr = new li, Ar = new li, Lr = new li,
							Pr = new li,
							function (t, e) {
								void 0 === e && (console.warn(
									"THREE.Triangle: .closestPointToPoint() target is now required"
									), e = new li);
								var i, n, r = this.a,
									a = this.b,
									o = this.c;
								Sr.subVectors(a, r), Er.subVectors(o, r), Ar.subVectors(t, r);
								var s = Sr.dot(Ar),
									c = Er.dot(Ar);
								if (s <= 0 && c <= 0) return e.copy(r);
								Lr.subVectors(t, a);
								var h = Sr.dot(Lr),
									l = Er.dot(Lr);
								if (0 <= h && l <= h) return e.copy(a);
								var u = s * l - h * c;
								if (u <= 0 && 0 <= s && h <= 0) return i = s / (s - h), e.copy(r)
									.addScaledVector(Sr, i);
								Pr.subVectors(t, o);
								var p = Sr.dot(Pr),
									d = Er.dot(Pr);
								if (0 <= d && p <= d) return e.copy(o);
								var f = p * c - s * d;
								if (f <= 0 && 0 <= c && d <= 0) return n = c / (c - d), e.copy(r)
									.addScaledVector(Er, n);
								var m = h * d - p * l;
								if (m <= 0 && 0 <= l - h && 0 <= p - d) return Tr.subVectors(o, a), n = (
									l - h) / (l - h + (p - d)), e.copy(a).addScaledVector(Tr, n);
								var g = 1 / (m + f + u);
								return i = f * g, n = u * g, e.copy(r).addScaledVector(Sr, i)
									.addScaledVector(Er, n)
							}),
						equals: function (t) {
							return t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c)
						}
					}), zr.prototype = Object.create(Ir.prototype), (zr.prototype.constructor = zr).prototype
					.isMeshBasicMaterial = !0, zr.prototype.copy = function (t) {
						return Ir.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this
							.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t
							.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.specularMap = t.specularMap, this
							.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this
							.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this
							.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this
							.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin,
							this.skinning = t.skinning, this.morphTargets = t.morphTargets, this
					}, Ur.prototype = Object.assign(Object.create(Mn.prototype), {
						constructor: Ur,
						isMesh: !0,
						setDrawMode: function (t) {
							this.drawMode = t
						},
						copy: function (t) {
							return Mn.prototype.copy.call(this, t), this.drawMode = t.drawMode, void 0 !==
								t.morphTargetInfluences && (this.morphTargetInfluences = t
									.morphTargetInfluences.slice()), void 0 !== t.morphTargetDictionary &&
								(this.morphTargetDictionary = Object.assign({}, t.morphTargetDictionary)),
								this
						},
						updateMorphTargets: function () {
							var t, e, i, n = this.geometry;
							if (n.isBufferGeometry) {
								var r = n.morphAttributes,
									a = Object.keys(r);
								if (0 < a.length) {
									var o = r[a[0]];
									if (void 0 !== o)
										for (this.morphTargetInfluences = [], this
											.morphTargetDictionary = {}, t = 0, e = o.length; t < e; t++)
											i = o[t].name || String(t), this.morphTargetInfluences.push(
											0), this.morphTargetDictionary[i] = t
								}
							} else {
								var s = n.morphTargets;
								void 0 !== s && 0 < s.length && console.error(
									"THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
									)
							}
						},
						raycast: function () {
							var G = new ci,
								F = new Br,
								H = new Ni,
								k = new li,
								j = new li,
								V = new li,
								W = new li,
								q = new li,
								X = new li,
								Y = new si,
								J = new si,
								Z = new si,
								Q = new li,
								h = new li;

							function K(t, e, i, n, r, a, o, s) {
								if (null === (e.side === kt ? n.intersectTriangle(o, a, r, !0, s) : n
										.intersectTriangle(r, a, o, e.side !== dt, s))) return null;
								h.copy(s), h.applyMatrix4(t.matrixWorld);
								var c = i.ray.origin.distanceTo(h);
								return c < i.near || c > i.far ? null : {
									distance: c,
									point: h.clone(),
									object: t
								}
							}

							function $(t, e, i, n, r, a, o, s, c) {
								k.fromBufferAttribute(r, o), j.fromBufferAttribute(r, s), V
									.fromBufferAttribute(r, c);
								var h = K(t, e, i, n, k, j, V, Q);
								if (h) {
									a && (Y.fromBufferAttribute(a, o), J.fromBufferAttribute(a, s), Z
										.fromBufferAttribute(a, c), h.uv = Nr.getUV(Q, k, j, V, Y, J,
											Z, new si));
									var l = new tn(o, s, c);
									Nr.getNormal(k, j, V, l.normal), h.face = l
								}
								return h
							}
							return function (t, e) {
								var i, n = this.geometry,
									r = this.material,
									a = this.matrixWorld;
								if (void 0 !== r && (null === n.boundingSphere && n
										.computeBoundingSphere(), H.copy(n.boundingSphere), H
										.applyMatrix4(a), !1 !== t.ray.intersectsSphere(H) && (G
											.getInverse(a), F.copy(t.ray).applyMatrix4(G), null === n
											.boundingBox || !1 !== F.intersectsBox(n.boundingBox))))
									if (n.isBufferGeometry) {
										var o, s, c, h, l, u, p, d, f, m = n.index,
											g = n.attributes.position,
											v = n.attributes.uv,
											y = n.groups,
											x = n.drawRange;
										if (null !== m)
											if (Array.isArray(r))
												for (h = 0, u = y.length; h < u; h++)
													for (f = r[(d = y[h]).materialIndex], l = Math
														.max(d.start, x.start), p = Math.min(d.start +
															d.count, x.start + x.count); l < p; l += 3
														) o = m.getX(l), s = m.getX(l + 1), c = m
														.getX(l + 2), (i = $(this, f, t, F, g, v, o,
															s, c)) && (i.faceIndex = Math.floor(l /
															3), e.push(i));
											else
												for (h = Math.max(0, x.start), u = Math.min(m.count, x
														.start + x.count); h < u; h += 3) o = m.getX(
													h), s = m.getX(h + 1), c = m.getX(h + 2), (i =
													$(this, r, t, F, g, v, o, s, c)) && (i
													.faceIndex = Math.floor(h / 3), e.push(i));
										else if (void 0 !== g)
											if (Array.isArray(r))
												for (h = 0, u = y.length; h < u; h++)
													for (f = r[(d = y[h]).materialIndex], l = Math
														.max(d.start, x.start), p = Math.min(d.start +
															d.count, x.start + x.count); l < p; l += 3
														)(i = $(this, f, t, F, g, v, o = l, s = l + 1,
														c = l + 2)) && (i.faceIndex = Math.floor(
														l / 3), e.push(i));
											else
												for (h = Math.max(0, x.start), u = Math.min(g.count, x
														.start + x.count); h < u; h += 3)(i = $(this,
													r, t, F, g, v, o = h, s = h + 1, c = h + 2
													)) && (i.faceIndex = Math.floor(h / 3), e
													.push(i))
									} else if (n.isGeometry) {
									var b, w, _, M, S = Array.isArray(r),
										E = n.vertices,
										T = n.faces,
										A = n.faceVertexUvs[0];
									0 < A.length && (M = A);
									for (var L = 0, P = T.length; L < P; L++) {
										var C = T[L],
											R = S ? r[C.materialIndex] : r;
										if (void 0 !== R) {
											if (b = E[C.a], w = E[C.b], _ = E[C.c], !0 === R
												.morphTargets) {
												var O = n.morphTargets,
													I = this.morphTargetInfluences;
												k.set(0, 0, 0), j.set(0, 0, 0), V.set(0, 0, 0);
												for (var D = 0, B = O.length; D < B; D++) {
													var N = I[D];
													if (0 !== N) {
														var z = O[D].vertices;
														k.addScaledVector(W.subVectors(z[C.a], b), N),
															j.addScaledVector(q.subVectors(z[C.b], w),
																N), V.addScaledVector(X.subVectors(z[C
																.c], _), N)
													}
												}
												k.add(b), j.add(w), V.add(_), b = k, w = j, _ = V
											}
											if (i = K(this, R, t, F, b, w, _, Q)) {
												if (M && M[L]) {
													var U = M[L];
													Y.copy(U[0]), J.copy(U[1]), Z.copy(U[2]), i.uv =
														Nr.getUV(Q, b, w, _, Y, J, Z, new si)
												}
												i.face = C, i.faceIndex = L, e.push(i)
											}
										}
									}
								}
							}
						}(),
						clone: function () {
							return new this.constructor(this.geometry, this.material).copy(this)
						}
					}), Zr.prototype = Object.create(Ci.prototype), (Zr.prototype.constructor = Zr).prototype
					.isCubeTexture = !0, Object.defineProperty(Zr.prototype, "images", {
						get: function () {
							return this.image
						},
						set: function (t) {
							this.image = t
						}
					}), Qr.prototype = Object.create(Ci.prototype), (Qr.prototype.constructor = Qr).prototype
					.isDataTexture3D = !0;
				var Kr = new Ci,
					$r = new Qr,
					ta = new Zr;

				function ea() {
					this.seq = [], this.map = {}
				}
				var ia = [],
					na = [],
					ra = new Float32Array(16),
					aa = new Float32Array(9),
					oa = new Float32Array(4);

				function sa(t, e, i) {
					var n = t[0];
					if (n <= 0 || 0 < n) return t;
					var r = e * i,
						a = ia[r];
					if (void 0 === a && (a = new Float32Array(r), ia[r] = a), 0 !== e) {
						n.toArray(a, 0);
						for (var o = 1, s = 0; o !== e; ++o) s += i, t[o].toArray(a, s)
					}
					return a
				}

				function ca(t, e) {
					if (t.length !== e.length) return !1;
					for (var i = 0, n = t.length; i < n; i++)
						if (t[i] !== e[i]) return !1;
					return !0
				}

				function ha(t, e) {
					for (var i = 0, n = e.length; i < n; i++) t[i] = e[i]
				}

				function la(t, e) {
					var i = na[e];
					void 0 === i && (i = new Int32Array(e), na[e] = i);
					for (var n = 0; n !== e; ++n) i[n] = t.allocTextureUnit();
					return i
				}

				function ua(t, e) {
					var i = this.cache;
					i[0] !== e && (t.uniform1f(this.addr, e), i[0] = e)
				}

				function pa(t, e) {
					var i = this.cache;
					i[0] !== e && (t.uniform1i(this.addr, e), i[0] = e)
				}

				function da(t, e) {
					var i = this.cache;
					if (void 0 !== e.x) i[0] === e.x && i[1] === e.y || (t.uniform2f(this.addr, e.x, e.y), i[0] =
						e.x, i[1] = e.y);
					else {
						if (ca(i, e)) return;
						t.uniform2fv(this.addr, e), ha(i, e)
					}
				}

				function fa(t, e) {
					var i = this.cache;
					if (void 0 !== e.x) i[0] === e.x && i[1] === e.y && i[2] === e.z || (t.uniform3f(this.addr, e
						.x, e.y, e.z), i[0] = e.x, i[1] = e.y, i[2] = e.z);
					else if (void 0 !== e.r) i[0] === e.r && i[1] === e.g && i[2] === e.b || (t.uniform3f(this
						.addr, e.r, e.g, e.b), i[0] = e.r, i[1] = e.g, i[2] = e.b);
					else {
						if (ca(i, e)) return;
						t.uniform3fv(this.addr, e), ha(i, e)
					}
				}

				function ma(t, e) {
					var i = this.cache;
					if (void 0 !== e.x) i[0] === e.x && i[1] === e.y && i[2] === e.z && i[3] === e.w || (t
						.uniform4f(this.addr, e.x, e.y, e.z, e.w), i[0] = e.x, i[1] = e.y, i[2] = e.z, i[3] =
						e.w);
					else {
						if (ca(i, e)) return;
						t.uniform4fv(this.addr, e), ha(i, e)
					}
				}

				function ga(t, e) {
					var i = this.cache,
						n = e.elements;
					if (void 0 === n) {
						if (ca(i, e)) return;
						t.uniformMatrix2fv(this.addr, !1, e), ha(i, e)
					} else {
						if (ca(i, n)) return;
						oa.set(n), t.uniformMatrix2fv(this.addr, !1, oa), ha(i, n)
					}
				}

				function va(t, e) {
					var i = this.cache,
						n = e.elements;
					if (void 0 === n) {
						if (ca(i, e)) return;
						t.uniformMatrix3fv(this.addr, !1, e), ha(i, e)
					} else {
						if (ca(i, n)) return;
						aa.set(n), t.uniformMatrix3fv(this.addr, !1, aa), ha(i, n)
					}
				}

				function ya(t, e) {
					var i = this.cache,
						n = e.elements;
					if (void 0 === n) {
						if (ca(i, e)) return;
						t.uniformMatrix4fv(this.addr, !1, e), ha(i, e)
					} else {
						if (ca(i, n)) return;
						ra.set(n), t.uniformMatrix4fv(this.addr, !1, ra), ha(i, n)
					}
				}

				function xa(t, e, i) {
					var n = this.cache,
						r = i.allocTextureUnit();
					n[0] !== r && (t.uniform1i(this.addr, r), n[0] = r), i.setTexture2D(e || Kr, r)
				}

				function ba(t, e, i) {
					var n = this.cache,
						r = i.allocTextureUnit();
					n[0] !== r && (t.uniform1i(this.addr, r), n[0] = r), i.setTexture3D(e || $r, r)
				}

				function wa(t, e, i) {
					var n = this.cache,
						r = i.allocTextureUnit();
					n[0] !== r && (t.uniform1i(this.addr, r), n[0] = r), i.setTextureCube(e || ta, r)
				}

				function _a(t, e) {
					var i = this.cache;
					ca(i, e) || (t.uniform2iv(this.addr, e), ha(i, e))
				}

				function Ma(t, e) {
					var i = this.cache;
					ca(i, e) || (t.uniform3iv(this.addr, e), ha(i, e))
				}

				function Sa(t, e) {
					var i = this.cache;
					ca(i, e) || (t.uniform4iv(this.addr, e), ha(i, e))
				}

				function Ea(t) {
					switch (t) {
						case 5126:
							return ua;
						case 35664:
							return da;
						case 35665:
							return fa;
						case 35666:
							return ma;
						case 35674:
							return ga;
						case 35675:
							return va;
						case 35676:
							return ya;
						case 35678:
						case 36198:
							return xa;
						case 35679:
							return ba;
						case 35680:
							return wa;
						case 5124:
						case 35670:
							return pa;
						case 35667:
						case 35671:
							return _a;
						case 35668:
						case 35672:
							return Ma;
						case 35669:
						case 35673:
							return Sa
					}
				}

				function Ta(t, e) {
					var i = this.cache;
					ca(i, e) || (t.uniform1fv(this.addr, e), ha(i, e))
				}

				function Aa(t, e) {
					var i = this.cache;
					ca(i, e) || (t.uniform1iv(this.addr, e), ha(i, e))
				}

				function La(t, e) {
					var i = this.cache,
						n = sa(e, this.size, 2);
					ca(i, n) || (t.uniform2fv(this.addr, n), this.updateCache(n))
				}

				function Pa(t, e) {
					var i = this.cache,
						n = sa(e, this.size, 3);
					ca(i, n) || (t.uniform3fv(this.addr, n), this.updateCache(n))
				}

				function Ca(t, e) {
					var i = this.cache,
						n = sa(e, this.size, 4);
					ca(i, n) || (t.uniform4fv(this.addr, n), this.updateCache(n))
				}

				function Ra(t, e) {
					var i = this.cache,
						n = sa(e, this.size, 4);
					ca(i, n) || (t.uniformMatrix2fv(this.addr, !1, n), this.updateCache(n))
				}

				function Oa(t, e) {
					var i = this.cache,
						n = sa(e, this.size, 9);
					ca(i, n) || (t.uniformMatrix3fv(this.addr, !1, n), this.updateCache(n))
				}

				function Ia(t, e) {
					var i = this.cache,
						n = sa(e, this.size, 16);
					ca(i, n) || (t.uniformMatrix4fv(this.addr, !1, n), this.updateCache(n))
				}

				function Da(t, e, i) {
					var n = this.cache,
						r = e.length,
						a = la(i, r);
					!1 === ca(n, a) && (t.uniform1iv(this.addr, a), ha(n, a));
					for (var o = 0; o !== r; ++o) i.setTexture2D(e[o] || Kr, a[o])
				}

				function Ba(t, e, i) {
					var n = this.cache,
						r = e.length,
						a = la(i, r);
					!1 === ca(n, a) && (t.uniform1iv(this.addr, a), ha(n, a));
					for (var o = 0; o !== r; ++o) i.setTextureCube(e[o] || ta, a[o])
				}

				function Na(t) {
					switch (t) {
						case 5126:
							return Ta;
						case 35664:
							return La;
						case 35665:
							return Pa;
						case 35666:
							return Ca;
						case 35674:
							return Ra;
						case 35675:
							return Oa;
						case 35676:
							return Ia;
						case 35678:
							return Da;
						case 35680:
							return Ba;
						case 5124:
						case 35670:
							return Aa;
						case 35667:
						case 35671:
							return _a;
						case 35668:
						case 35672:
							return Ma;
						case 35669:
						case 35673:
							return Sa
					}
				}

				function za(t, e, i) {
					this.id = t, this.addr = i, this.cache = [], this.setValue = Ea(e.type)
				}

				function Ua(t, e, i) {
					this.id = t, this.addr = i, this.cache = [], this.size = e.size, this.setValue = Na(e.type)
				}

				function Ga(t) {
					this.id = t, ea.call(this)
				}
				Ua.prototype.updateCache = function (t) {
					var e = this.cache;
					t instanceof Float32Array && e.length !== t.length && (this.cache = new Float32Array(t
						.length)), ha(e, t)
				}, Ga.prototype.setValue = function (t, e, i) {
					for (var n = this.seq, r = 0, a = n.length; r !== a; ++r) {
						var o = n[r];
						o.setValue(t, e[o.id], i)
					}
				};
				var Fa = /([\w\d_]+)(\])?(\[|\.)?/g;

				function Ha(t, e) {
					t.seq.push(e), t.map[e.id] = e
				}

				function ka(t, e, i) {
					var n = t.name,
						r = n.length;
					for (Fa.lastIndex = 0;;) {
						var a = Fa.exec(n),
							o = Fa.lastIndex,
							s = a[1],
							c = "]" === a[2],
							h = a[3];
						if (c && (s |= 0), void 0 === h || "[" === h && o + 2 === r) {
							Ha(i, void 0 === h ? new za(s, t, e) : new Ua(s, t, e));
							break
						}
						var l = i.map[s];
						void 0 === l && Ha(i, l = new Ga(s)), i = l
					}
				}

				function ja(t, e, i) {
					ea.call(this), this.renderer = i;
					for (var n = t.getProgramParameter(e, 35718), r = 0; r < n; ++r) {
						var a = t.getActiveUniform(e, r);
						ka(a, t.getUniformLocation(e, a.name), this)
					}
				}

				function Va(t) {
					for (var e = t.split("\n"), i = 0; i < e.length; i++) e[i] = i + 1 + ": " + e[i];
					return e.join("\n")
				}

				function Wa(t, e, i) {
					var n = t.createShader(e);
					return t.shaderSource(n, i), t.compileShader(n), !1 === t.getShaderParameter(n, 35713) &&
						console.error("THREE.WebGLShader: Shader couldn't compile."), "" !== t.getShaderInfoLog(
						n) && console.warn("THREE.WebGLShader: gl.getShaderInfoLog()", 35633 === e ? "vertex" :
							"fragment", t.getShaderInfoLog(n), Va(i)), n
				}
				ja.prototype.setValue = function (t, e, i) {
					var n = this.map[e];
					void 0 !== n && n.setValue(t, i, this.renderer)
				}, ja.prototype.setOptional = function (t, e, i) {
					var n = e[i];
					void 0 !== n && this.setValue(t, i, n)
				}, ja.upload = function (t, e, i, n) {
					for (var r = 0, a = e.length; r !== a; ++r) {
						var o = e[r],
							s = i[o.id];
						!1 !== s.needsUpdate && o.setValue(t, s.value, n)
					}
				}, ja.seqWithValue = function (t, e) {
					for (var i = [], n = 0, r = t.length; n !== r; ++n) {
						var a = t[n];
						a.id in e && i.push(a)
					}
					return i
				};
				var qa = 0;

				function Xa(t) {
					switch (t) {
						case Ye:
							return ["Linear", "( value )"];
						case Je:
							return ["sRGB", "( value )"];
						case Qe:
							return ["RGBE", "( value )"];
						case $e:
							return ["RGBM", "( value, 7.0 )"];
						case ti:
							return ["RGBM", "( value, 16.0 )"];
						case ei:
							return ["RGBD", "( value, 256.0 )"];
						case Ze:
							return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
						default:
							throw new Error("unsupported encoding: " + t)
					}
				}

				function Ya(t, e) {
					var i = Xa(e);
					return "vec4 " + t + "( vec4 value ) { return " + i[0] + "ToLinear" + i[1] + "; }"
				}

				function Ja(t, e) {
					var i = Xa(e);
					return "vec4 " + t + "( vec4 value ) { return LinearTo" + i[0] + i[1] + "; }"
				}

				function Za(t, e) {
					var i;
					switch (e) {
						case jt:
							i = "Linear";
							break;
						case nt:
							i = "Reinhard";
							break;
						case rt:
							i = "Uncharted2";
							break;
						case at:
							i = "OptimizedCineon";
							break;
						case ot:
							i = "ACESFilmic";
							break;
						default:
							throw new Error("unsupported toneMapping: " + e)
					}
					return "vec3 " + t + "( vec3 color ) { return " + i + "ToneMapping( color ); }"
				}

				function Qa(t, e, i) {
					return [(t = t || {}).derivatives || e.envMapCubeUV || e.bumpMap || e.normalMap && !e
						.objectSpaceNormalMap || e.flatShading ?
						"#extension GL_OES_standard_derivatives : enable" : "", (t.fragDepth || e
							.logarithmicDepthBuffer) && i.get("EXT_frag_depth") ?
						"#extension GL_EXT_frag_depth : enable" : "", t.drawBuffers && i.get(
							"WEBGL_draw_buffers") ? "#extension GL_EXT_draw_buffers : require" : "", (t
							.shaderTextureLOD || e.envMap) && i.get("EXT_shader_texture_lod") ?
						"#extension GL_EXT_shader_texture_lod : enable" : ""
					].filter(to).join("\n")
				}

				function Ka(t) {
					var e = [];
					for (var i in t) {
						var n = t[i];
						!1 !== n && e.push("#define " + i + " " + n)
					}
					return e.join("\n")
				}

				function $a(t, e) {
					for (var i = {}, n = t.getProgramParameter(e, 35721), r = 0; r < n; r++) {
						var a = t.getActiveAttrib(e, r).name;
						i[a] = t.getAttribLocation(e, a)
					}
					return i
				}

				function to(t) {
					return "" !== t
				}

				function eo(t, e) {
					return t.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e
						.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(
						/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights)
				}

				function io(t, e) {
					return t.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(
						/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection)
				}

				function no(t) {
					var e = /^[ \t]*#include +<([\w\d./]+)>/gm;

					function i(t, e) {
						var i = Gi[e];
						if (void 0 === i) throw new Error("Can not resolve #include <" + e + ">");
						return no(i)
					}
					return t.replace(e, i)
				}

				function ro(t) {
					var e =
						/#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;

					function i(t, e, i, n) {
						for (var r = "", a = parseInt(e); a < parseInt(i); a++) r += n.replace(/\[ i \]/g, "[ " +
							a + " ]");
						return r
					}
					return t.replace(e, i)
				}

				function ao(t, e, i, n, r, a, o) {
					var s = t.context,
						c = n.defines,
						h = r.vertexShader,
						l = r.fragmentShader,
						u = "SHADOWMAP_TYPE_BASIC";
					a.shadowMapType === B ? u = "SHADOWMAP_TYPE_PCF" : a.shadowMapType === I && (u =
						"SHADOWMAP_TYPE_PCF_SOFT");
					var p = "ENVMAP_TYPE_CUBE",
						d = "ENVMAP_MODE_REFLECTION",
						f = "ENVMAP_BLENDING_MULTIPLY";
					if (a.envMap) {
						switch (n.envMap.mapping) {
							case ct:
							case ht:
								p = "ENVMAP_TYPE_CUBE";
								break;
							case Ot:
							case It:
								p = "ENVMAP_TYPE_CUBE_UV";
								break;
							case Pt:
							case Ct:
								p = "ENVMAP_TYPE_EQUIREC";
								break;
							case Rt:
								p = "ENVMAP_TYPE_SPHERE"
						}
						switch (n.envMap.mapping) {
							case ht:
							case Ct:
								d = "ENVMAP_MODE_REFRACTION"
						}
						switch (n.combine) {
							case $:
								f = "ENVMAP_BLENDING_MULTIPLY";
								break;
							case tt:
								f = "ENVMAP_BLENDING_MIX";
								break;
							case et:
								f = "ENVMAP_BLENDING_ADD"
						}
					}
					var m, g, v = 0 < t.gammaFactor ? t.gammaFactor : 1,
						y = o.isWebGL2 ? "" : Qa(n.extensions, a, e),
						x = Ka(c),
						b = s.createProgram();
					if (n.isRawShaderMaterial ? (0 < (m = [x].filter(to).join("\n")).length && (m += "\n"), 0 < (
							g = [y, x].filter(to).join("\n")).length && (g += "\n")) : (m = ["precision " + a
							.precision + " float;", "precision " + a.precision + " int;",
							"#define SHADER_NAME " + r.name, x, a.supportsVertexTextures ?
							"#define VERTEX_TEXTURES" : "", "#define GAMMA_FACTOR " + v,
							"#define MAX_BONES " + a.maxBones, a.useFog && a.fog ? "#define USE_FOG" : "", a
							.useFog && a.fogExp ? "#define FOG_EXP2" : "", a.map ? "#define USE_MAP" : "", a
							.envMap ? "#define USE_ENVMAP" : "", a.envMap ? "#define " + d : "", a.lightMap ?
							"#define USE_LIGHTMAP" : "", a.aoMap ? "#define USE_AOMAP" : "", a.emissiveMap ?
							"#define USE_EMISSIVEMAP" : "", a.bumpMap ? "#define USE_BUMPMAP" : "", a
							.normalMap ? "#define USE_NORMALMAP" : "", a.normalMap && a.objectSpaceNormalMap ?
							"#define OBJECTSPACE_NORMALMAP" : "", a.displacementMap && a
							.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", a.specularMap ?
							"#define USE_SPECULARMAP" : "", a.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
							a.metalnessMap ? "#define USE_METALNESSMAP" : "", a.alphaMap ?
							"#define USE_ALPHAMAP" : "", a.vertexColors ? "#define USE_COLOR" : "", a
							.flatShading ? "#define FLAT_SHADED" : "", a.skinning ? "#define USE_SKINNING" :
							"", a.useVertexTexture ? "#define BONE_TEXTURE" : "", a.morphTargets ?
							"#define USE_MORPHTARGETS" : "", a.morphNormals && !1 === a.flatShading ?
							"#define USE_MORPHNORMALS" : "", a.doubleSided ? "#define DOUBLE_SIDED" : "", a
							.flipSided ? "#define FLIP_SIDED" : "", a.shadowMapEnabled ?
							"#define USE_SHADOWMAP" : "", a.shadowMapEnabled ? "#define " + u : "", a
							.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", a.logarithmicDepthBuffer ?
							"#define USE_LOGDEPTHBUF" : "", a.logarithmicDepthBuffer && (o.isWebGL2 || e.get(
								"EXT_frag_depth")) ? "#define USE_LOGDEPTHBUF_EXT" : "",
							"uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;",
							"uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;",
							"uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;",
							"attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;",
							"#ifdef USE_COLOR", "\tattribute vec3 color;", "#endif",
							"#ifdef USE_MORPHTARGETS", "\tattribute vec3 morphTarget0;",
							"\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;",
							"\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS",
							"\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;",
							"\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else",
							"\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;",
							"\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;",
							"\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;",
							"\tattribute vec4 skinWeight;", "#endif", "\n"
						].filter(to).join("\n"), g = [y, "precision " + a.precision + " float;",
							"precision " + a.precision + " int;", "#define SHADER_NAME " + r.name, x, a
							.alphaTest ? "#define ALPHATEST " + a.alphaTest + (a.alphaTest % 1 ? "" : ".0") :
							"", "#define GAMMA_FACTOR " + v, a.useFog && a.fog ? "#define USE_FOG" : "", a
							.useFog && a.fogExp ? "#define FOG_EXP2" : "", a.map ? "#define USE_MAP" : "", a
							.matcap ? "#define USE_MATCAP" : "", a.envMap ? "#define USE_ENVMAP" : "", a
							.envMap ? "#define " + p : "", a.envMap ? "#define " + d : "", a.envMap ?
							"#define " + f : "", a.lightMap ? "#define USE_LIGHTMAP" : "", a.aoMap ?
							"#define USE_AOMAP" : "", a.emissiveMap ? "#define USE_EMISSIVEMAP" : "", a
							.bumpMap ? "#define USE_BUMPMAP" : "", a.normalMap ? "#define USE_NORMALMAP" : "",
							a.normalMap && a.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", a
							.specularMap ? "#define USE_SPECULARMAP" : "", a.roughnessMap ?
							"#define USE_ROUGHNESSMAP" : "", a.metalnessMap ? "#define USE_METALNESSMAP" : "",
							a.alphaMap ? "#define USE_ALPHAMAP" : "", a.vertexColors ? "#define USE_COLOR" :
							"", a.gradientMap ? "#define USE_GRADIENTMAP" : "", a.flatShading ?
							"#define FLAT_SHADED" : "", a.doubleSided ? "#define DOUBLE_SIDED" : "", a
							.flipSided ? "#define FLIP_SIDED" : "", a.shadowMapEnabled ?
							"#define USE_SHADOWMAP" : "", a.shadowMapEnabled ? "#define " + u : "", a
							.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", a
							.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", a
							.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", a
							.logarithmicDepthBuffer && (o.isWebGL2 || e.get("EXT_frag_depth")) ?
							"#define USE_LOGDEPTHBUF_EXT" : "", a.envMap && (o.isWebGL2 || e.get(
								"EXT_shader_texture_lod")) ? "#define TEXTURE_LOD_EXT" : "",
							"uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", a.toneMapping !== it ?
							"#define TONE_MAPPING" : "", a.toneMapping !== it ? Gi.tonemapping_pars_fragment :
							"", a.toneMapping !== it ? Za("toneMapping", a.toneMapping) : "", a.dithering ?
							"#define DITHERING" : "", a.outputEncoding || a.mapEncoding || a.matcapEncoding ||
							a.envMapEncoding || a.emissiveMapEncoding ? Gi.encodings_pars_fragment : "", a
							.mapEncoding ? Ya("mapTexelToLinear", a.mapEncoding) : "", a.matcapEncoding ? Ya(
								"matcapTexelToLinear", a.matcapEncoding) : "", a.envMapEncoding ? Ya(
								"envMapTexelToLinear", a.envMapEncoding) : "", a.emissiveMapEncoding ? Ya(
								"emissiveMapTexelToLinear", a.emissiveMapEncoding) : "", a.outputEncoding ?
							Ja("linearToOutputTexel", a.outputEncoding) : "", a.depthPacking ?
							"#define DEPTH_PACKING " + n.depthPacking : "", "\n"
						].filter(to).join("\n")), h = io(h = eo(h = no(h), a), a), l = io(l = eo(l = no(l), a),
						a), h = ro(h), l = ro(l), o.isWebGL2 && !n.isRawShaderMaterial) {
						var w = !1,
							_ = /^\s*#version\s+300\s+es\s*\n/;
						n.isShaderMaterial && null !== h.match(_) && null !== l.match(_) && (w = !0, h = h
							.replace(_, ""), l = l.replace(_, "")), m = ["#version 300 es\n",
							"#define attribute in", "#define varying out", "#define texture2D texture"
						].join("\n") + "\n" + m, g = ["#version 300 es\n", "#define varying in", w ? "" :
							"out highp vec4 pc_fragColor;", w ? "" : "#define gl_FragColor pc_fragColor",
							"#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture",
							"#define textureCube texture", "#define texture2DProj textureProj",
							"#define texture2DLodEXT textureLod",
							"#define texture2DProjLodEXT textureProjLod",
							"#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad",
							"#define texture2DProjGradEXT textureProjGrad",
							"#define textureCubeGradEXT textureGrad"
						].join("\n") + "\n" + g
					}
					var M = g + l,
						S = Wa(s, 35633, m + h),
						E = Wa(s, 35632, M);
					s.attachShader(b, S), s.attachShader(b, E), void 0 !== n.index0AttributeName ? s
						.bindAttribLocation(b, 0, n.index0AttributeName) : !0 === a.morphTargets && s
						.bindAttribLocation(b, 0, "position"), s.linkProgram(b);
					var T, A, L = s.getProgramInfoLog(b).trim(),
						P = s.getShaderInfoLog(S).trim(),
						C = s.getShaderInfoLog(E).trim(),
						R = !0,
						O = !0;
					return !1 === s.getProgramParameter(b, 35714) ? (R = !1, console.error(
							"THREE.WebGLProgram: shader error: ", s.getError(), "35715", s
							.getProgramParameter(b, 35715), "gl.getProgramInfoLog", L, P, C)) : "" !== L ? console
						.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", L) : "" !== P && "" !== C || (O = !1),
						O && (this.diagnostics = {
							runnable: R,
							material: n,
							programLog: L,
							vertexShader: {
								log: P,
								prefix: m
							},
							fragmentShader: {
								log: C,
								prefix: g
							}
						}), s.deleteShader(S), s.deleteShader(E), this.getUniforms = function () {
							return void 0 === T && (T = new ja(s, b, t)), T
						}, this.getAttributes = function () {
							return void 0 === A && (A = $a(s, b)), A
						}, this.destroy = function () {
							s.deleteProgram(b), this.program = void 0
						}, Object.defineProperties(this, {
							uniforms: {
								get: function () {
									return console.warn(
											"THREE.WebGLProgram: .uniforms is now .getUniforms()."), this
										.getUniforms()
								}
							},
							attributes: {
								get: function () {
									return console.warn(
											"THREE.WebGLProgram: .attributes is now .getAttributes()."),
										this.getAttributes()
								}
							}
						}), this.name = r.name, this.id = qa++, this.code = i, this.usedTimes = 1, this.program =
						b, this.vertexShader = S, this.fragmentShader = E, this
				}

				function oo(u, c, p) {
					var h = [],
						d = {
							MeshDepthMaterial: "depth",
							MeshDistanceMaterial: "distanceRGBA",
							MeshNormalMaterial: "normal",
							MeshBasicMaterial: "basic",
							MeshLambertMaterial: "lambert",
							MeshPhongMaterial: "phong",
							MeshToonMaterial: "phong",
							MeshStandardMaterial: "physical",
							MeshPhysicalMaterial: "physical",
							MeshMatcapMaterial: "matcap",
							LineBasicMaterial: "basic",
							LineDashedMaterial: "dashed",
							PointsMaterial: "points",
							ShadowMaterial: "shadow",
							SpriteMaterial: "sprite"
						},
						a = ["precision", "supportsVertexTextures", "map", "mapEncoding", "matcap",
							"matcapEncoding", "envMap", "envMapMode", "envMapEncoding", "lightMap", "aoMap",
							"emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "objectSpaceNormalMap",
							"displacementMap", "specularMap", "roughnessMap", "metalnessMap", "gradientMap",
							"alphaMap", "combine", "vertexColors", "fog", "useFog", "fogExp", "flatShading",
							"sizeAttenuation", "logarithmicDepthBuffer", "skinning", "maxBones",
							"useVertexTexture", "morphTargets", "morphNormals", "maxMorphTargets",
							"maxMorphNormals", "premultipliedAlpha", "numDirLights", "numPointLights",
							"numSpotLights", "numHemiLights", "numRectAreaLights", "shadowMapEnabled",
							"shadowMapType", "toneMapping", "physicallyCorrectLights", "alphaTest", "doubleSided",
							"flipSided", "numClippingPlanes", "numClipIntersection", "depthPacking", "dithering"
						];

					function f(t) {
						var e = t.skeleton.bones;
						if (p.floatVertexTextures) return 1024;
						var i = p.maxVertexUniforms,
							n = Math.floor((i - 20) / 4),
							r = Math.min(n, e.length);
						return r < e.length ? (console.warn("THREE.WebGLRenderer: Skeleton has " + e.length +
							" bones. This GPU supports " + r + "."), 0) : r
					}

					function m(t, e) {
						var i;
						return t ? t.isTexture ? i = t.encoding : t.isWebGLRenderTarget && (console.warn(
							"THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."
							), i = t.texture.encoding) : i = Ye, i === Ye && e && (i = Ze), i
					}
					this.getParameters = function (t, e, i, n, r, a, o) {
						var s = d[t.type],
							c = o.isSkinnedMesh ? f(o) : 0,
							h = p.precision;
						null !== t.precision && (h = p.getMaxPrecision(t.precision)) !== t.precision &&
							console.warn("THREE.WebGLProgram.getParameters:", t.precision,
								"not supported, using", h, "instead.");
						var l = u.getRenderTarget();
						return {
							shaderID: s,
							precision: h,
							supportsVertexTextures: p.vertexTextures,
							outputEncoding: m(l ? l.texture : null, u.gammaOutput),
							map: !!t.map,
							mapEncoding: m(t.map, u.gammaInput),
							matcap: !!t.matcap,
							matcapEncoding: m(t.matcap, u.gammaInput),
							envMap: !!t.envMap,
							envMapMode: t.envMap && t.envMap.mapping,
							envMapEncoding: m(t.envMap, u.gammaInput),
							envMapCubeUV: !!t.envMap && (t.envMap.mapping === Ot || t.envMap.mapping === It),
							lightMap: !!t.lightMap,
							aoMap: !!t.aoMap,
							emissiveMap: !!t.emissiveMap,
							emissiveMapEncoding: m(t.emissiveMap, u.gammaInput),
							bumpMap: !!t.bumpMap,
							normalMap: !!t.normalMap,
							objectSpaceNormalMap: t.normalMapType === ai,
							displacementMap: !!t.displacementMap,
							roughnessMap: !!t.roughnessMap,
							metalnessMap: !!t.metalnessMap,
							specularMap: !!t.specularMap,
							alphaMap: !!t.alphaMap,
							gradientMap: !!t.gradientMap,
							combine: t.combine,
							vertexColors: t.vertexColors,
							fog: !!n,
							useFog: t.fog,
							fogExp: n && n.isFogExp2,
							flatShading: t.flatShading,
							sizeAttenuation: t.sizeAttenuation,
							logarithmicDepthBuffer: p.logarithmicDepthBuffer,
							skinning: t.skinning && 0 < c,
							maxBones: c,
							useVertexTexture: p.floatVertexTextures,
							morphTargets: t.morphTargets,
							morphNormals: t.morphNormals,
							maxMorphTargets: u.maxMorphTargets,
							maxMorphNormals: u.maxMorphNormals,
							numDirLights: e.directional.length,
							numPointLights: e.point.length,
							numSpotLights: e.spot.length,
							numRectAreaLights: e.rectArea.length,
							numHemiLights: e.hemi.length,
							numClippingPlanes: r,
							numClipIntersection: a,
							dithering: t.dithering,
							shadowMapEnabled: u.shadowMap.enabled && o.receiveShadow && 0 < i.length,
							shadowMapType: u.shadowMap.type,
							toneMapping: u.toneMapping,
							physicallyCorrectLights: u.physicallyCorrectLights,
							premultipliedAlpha: t.premultipliedAlpha,
							alphaTest: t.alphaTest,
							doubleSided: t.side === dt,
							flipSided: t.side === kt,
							depthPacking: void 0 !== t.depthPacking && t.depthPacking
						}
					}, this.getProgramCode = function (t, e) {
						var i = [];
						if (e.shaderID ? i.push(e.shaderID) : (i.push(t.fragmentShader), i.push(t
								.vertexShader)), void 0 !== t.defines)
							for (var n in t.defines) i.push(n), i.push(t.defines[n]);
						for (var r = 0; r < a.length; r++) i.push(e[a[r]]);
						return i.push(t.onBeforeCompile.toString()), i.push(u.gammaOutput), i.push(u
							.gammaFactor), i.join()
					}, this.acquireProgram = function (t, e, i, n) {
						for (var r, a = 0, o = h.length; a < o; a++) {
							var s = h[a];
							if (s.code === n) {
								++(r = s).usedTimes;
								break
							}
						}
						return void 0 === r && (r = new ao(u, c, n, t, e, i, p), h.push(r)), r
					}, this.releaseProgram = function (t) {
						if (0 == --t.usedTimes) {
							var e = h.indexOf(t);
							h[e] = h[h.length - 1], h.pop(), t.destroy()
						}
					}, this.programs = h
				}

				function so() {
					var n = new WeakMap;

					function t(t) {
						var e = n.get(t);
						return void 0 === e && (e = {}, n.set(t, e)), e
					}

					function e(t) {
						n.delete(t)
					}

					function i(t, e, i) {
						n.get(t)[e] = i
					}

					function r() {
						n = new WeakMap
					}
					return {
						get: t,
						remove: e,
						update: i,
						dispose: r
					}
				}

				function co(t, e) {
					return t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.program && e
						.program && t.program !== e.program ? t.program.id - e.program.id : t.material.id !== e
						.material.id ? t.material.id - e.material.id : t.z !== e.z ? t.z - e.z : t.id - e.id
				}

				function ho(t, e) {
					return t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.z !== e.z ? e.z - t
						.z : t.id - e.id
				}

				function lo() {
					var o = [],
						s = 0,
						c = [],
						h = [];

					function t() {
						s = 0, c.length = 0, h.length = 0
					}

					function l(t, e, i, n, r) {
						var a = o[s];
						return void 0 === a ? (a = {
							id: t.id,
							object: t,
							geometry: e,
							material: i,
							program: i.program,
							renderOrder: t.renderOrder,
							z: n,
							group: r
						}, o[s] = a) : (a.id = t.id, a.object = t, a.geometry = e, a.material = i, a.program =
							i.program, a.renderOrder = t.renderOrder, a.z = n, a.group = r), s++, a
					}

					function e(t, e, i, n, r) {
						var a = l(t, e, i, n, r);
						(!0 === i.transparent ? h : c).push(a)
					}

					function i(t, e, i, n, r) {
						var a = l(t, e, i, n, r);
						(!0 === i.transparent ? h : c).unshift(a)
					}

					function n() {
						1 < c.length && c.sort(co), 1 < h.length && h.sort(ho)
					}
					return {
						opaque: c,
						transparent: h,
						init: t,
						push: e,
						unshift: i,
						sort: n
					}
				}

				function uo() {
					var r = {};

					function t(t, e) {
						var i, n = r[t.id];
						return void 0 === n ? (i = new lo, r[t.id] = {}, r[t.id][e.id] = i) : void 0 === (i = n[e
							.id]) && (i = new lo, n[e.id] = i), i
					}

					function e() {
						r = {}
					}
					return {
						get: t,
						dispose: e
					}
				}

				function po() {
					var i = {};
					return {
						get: function (t) {
							if (void 0 !== i[t.id]) return i[t.id];
							var e;
							switch (t.type) {
								case "DirectionalLight":
									e = {
										direction: new li,
										color: new Xi,
										shadow: !1,
										shadowBias: 0,
										shadowRadius: 1,
										shadowMapSize: new si
									};
									break;
								case "SpotLight":
									e = {
										position: new li,
										direction: new li,
										color: new Xi,
										distance: 0,
										coneCos: 0,
										penumbraCos: 0,
										decay: 0,
										shadow: !1,
										shadowBias: 0,
										shadowRadius: 1,
										shadowMapSize: new si
									};
									break;
								case "PointLight":
									e = {
										position: new li,
										color: new Xi,
										distance: 0,
										decay: 0,
										shadow: !1,
										shadowBias: 0,
										shadowRadius: 1,
										shadowMapSize: new si,
										shadowCameraNear: 1,
										shadowCameraFar: 1e3
									};
									break;
								case "HemisphereLight":
									e = {
										direction: new li,
										skyColor: new Xi,
										groundColor: new Xi
									};
									break;
								case "RectAreaLight":
									e = {
										color: new Xi,
										position: new li,
										halfWidth: new li,
										halfHeight: new li
									}
							}
							return i[t.id] = e
						}
					}
				}
				var fo = 0;

				function mo() {
					var w = new po,
						_ = {
							id: fo++,
							hash: {
								stateID: -1,
								directionalLength: -1,
								pointLength: -1,
								spotLength: -1,
								rectAreaLength: -1,
								hemiLength: -1,
								shadowsLength: -1
							},
							ambient: [0, 0, 0],
							directional: [],
							directionalShadowMap: [],
							directionalShadowMatrix: [],
							spot: [],
							spotShadowMap: [],
							spotShadowMatrix: [],
							rectArea: [],
							point: [],
							pointShadowMap: [],
							pointShadowMatrix: [],
							hemi: []
						},
						M = new li,
						S = new ci,
						E = new ci;

					function t(t, e, i) {
						for (var n = 0, r = 0, a = 0, o = 0, s = 0, c = 0, h = 0, l = 0, u = i.matrixWorldInverse,
								p = 0, d = t.length; p < d; p++) {
							var f = t[p],
								m = f.color,
								g = f.intensity,
								v = f.distance,
								y = f.shadow && f.shadow.map ? f.shadow.map.texture : null;
							if (f.isAmbientLight) n += m.r * g, r += m.g * g, a += m.b * g;
							else if (f.isDirectionalLight) {
								if ((b = w.get(f)).color.copy(f.color).multiplyScalar(f.intensity), b.direction
									.setFromMatrixPosition(f.matrixWorld), M.setFromMatrixPosition(f.target
										.matrixWorld), b.direction.sub(M), b.direction.transformDirection(u), b
									.shadow = f.castShadow, f.castShadow) {
									var x = f.shadow;
									b.shadowBias = x.bias, b.shadowRadius = x.radius, b.shadowMapSize = x.mapSize
								}
								_.directionalShadowMap[o] = y, _.directionalShadowMatrix[o] = f.shadow.matrix, _
									.directional[o] = b, o++
							} else if (f.isSpotLight) {
								if ((b = w.get(f)).position.setFromMatrixPosition(f.matrixWorld), b.position
									.applyMatrix4(u), b.color.copy(m).multiplyScalar(g), b.distance = v, b
									.direction.setFromMatrixPosition(f.matrixWorld), M.setFromMatrixPosition(f
										.target.matrixWorld), b.direction.sub(M), b.direction.transformDirection(
										u), b.coneCos = Math.cos(f.angle), b.penumbraCos = Math.cos(f.angle * (1 -
										f.penumbra)), b.decay = f.decay, b.shadow = f.castShadow, f.castShadow) {
									x = f.shadow;
									b.shadowBias = x.bias, b.shadowRadius = x.radius, b.shadowMapSize = x.mapSize
								}
								_.spotShadowMap[c] = y, _.spotShadowMatrix[c] = f.shadow.matrix, _.spot[c] = b,
									c++
							} else if (f.isRectAreaLight) {
								(b = w.get(f)).color.copy(m).multiplyScalar(g), b.position.setFromMatrixPosition(f
										.matrixWorld), b.position.applyMatrix4(u), E.identity(), S.copy(f
										.matrixWorld), S.premultiply(u), E.extractRotation(S), b.halfWidth.set(
										.5 * f.width, 0, 0), b.halfHeight.set(0, .5 * f.height, 0), b.halfWidth
									.applyMatrix4(E), b.halfHeight.applyMatrix4(E), _.rectArea[h] = b, h++
							} else if (f.isPointLight) {
								if ((b = w.get(f)).position.setFromMatrixPosition(f.matrixWorld), b.position
									.applyMatrix4(u), b.color.copy(f.color).multiplyScalar(f.intensity), b
									.distance = f.distance, b.decay = f.decay, b.shadow = f.castShadow, f
									.castShadow) {
									x = f.shadow;
									b.shadowBias = x.bias, b.shadowRadius = x.radius, b.shadowMapSize = x.mapSize,
										b.shadowCameraNear = x.camera.near, b.shadowCameraFar = x.camera.far
								}
								_.pointShadowMap[s] = y, _.pointShadowMatrix[s] = f.shadow.matrix, _.point[s] = b,
									s++
							} else if (f.isHemisphereLight) {
								var b;
								(b = w.get(f)).direction.setFromMatrixPosition(f.matrixWorld), b.direction
									.transformDirection(u), b.direction.normalize(), b.skyColor.copy(f.color)
									.multiplyScalar(g), b.groundColor.copy(f.groundColor).multiplyScalar(g), _
									.hemi[l] = b, l++
							}
						}
						_.ambient[0] = n, _.ambient[1] = r, _.ambient[2] = a, _.directional.length = o, _.spot
							.length = c, _.rectArea.length = h, _.point.length = s, _.hemi.length = l, _.hash
							.stateID = _.id, _.hash.directionalLength = o, _.hash.pointLength = s, _.hash
							.spotLength = c, _.hash.rectAreaLength = h, _.hash.hemiLength = l, _.hash
							.shadowsLength = e.length
					}
					return {
						setup: t,
						state: _
					}
				}

				function go() {
					var e = new mo,
						i = [],
						n = [];

					function t() {
						i.length = 0, n.length = 0
					}

					function r(t) {
						i.push(t)
					}

					function a(t) {
						n.push(t)
					}

					function o(t) {
						e.setup(i, n, t)
					}
					return {
						init: t,
						state: {
							lightsArray: i,
							shadowsArray: n,
							lights: e
						},
						setupLights: o,
						pushLight: r,
						pushShadow: a
					}
				}

				function vo() {
					var n = {};

					function t(t, e) {
						var i;
						return void 0 === n[t.id] ? (i = new go, n[t.id] = {}, n[t.id][e.id] = i) : void 0 === n[t
							.id][e.id] ? (i = new go, n[t.id][e.id] = i) : i = n[t.id][e.id], i
					}

					function e() {
						n = {}
					}
					return {
						get: t,
						dispose: e
					}
				}

				function yo(t) {
					Ir.call(this), this.type = "MeshDepthMaterial", this.depthPacking = ii, this.skinning = !1,
						this.morphTargets = !1, this.map = null, this.alphaMap = null, this.displacementMap =
						null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this
						.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.setValues(t)
				}

				function xo(t) {
					Ir.call(this), this.type = "MeshDistanceMaterial", this.referencePosition = new li, this
						.nearDistance = 1, this.farDistance = 1e3, this.skinning = !1, this.morphTargets = !1,
						this.map = null, this.alphaMap = null, this.displacementMap = null, this
						.displacementScale = 1, this.displacementBias = 0, this.fog = !1, this.lights = !1, this
						.setValues(t)
				}

				function bo(y, m, t) {
					for (var x = new Ui, b = new ci, w = new si, _ = new si(t, t), M = new li, S = new li, v = 1,
							E = 2, e = 1 + (v | E), T = new Array(e), A = new Array(e), L = {}, P = {
								0: kt,
								1: N,
								2: dt
							}, C = [new li(1, 0, 0), new li(-1, 0, 0), new li(0, 0, 1), new li(0, 0, -1), new li(
								0, 1, 0), new li(0, -1, 0)], R = [new li(0, 1, 0), new li(0, 1, 0), new li(0, 1,
								0), new li(0, 1, 0), new li(0, 0, 1), new li(0, 0, -1)], O = [new Ri, new Ri,
								new Ri, new Ri, new Ri, new Ri
							], i = 0; i !== e; ++i) {
						var n = 0 != (i & v),
							r = 0 != (i & E),
							a = new yo({
								depthPacking: ni,
								morphTargets: n,
								skinning: r
							});
						T[i] = a;
						var o = new xo({
							morphTargets: n,
							skinning: r
						});
						A[i] = o
					}
					var I = this;

					function g(t, e, i, n, r, a) {
						var o = t.geometry,
							s = null,
							c = T,
							h = t.customDepthMaterial;
						if (i && (c = A, h = t.customDistanceMaterial), h) s = h;
						else {
							var l = !1;
							e.morphTargets && (o && o.isBufferGeometry ? l = o.morphAttributes && o
									.morphAttributes.position && 0 < o.morphAttributes.position.length : o && o
									.isGeometry && (l = o.morphTargets && 0 < o.morphTargets.length)), t
								.isSkinnedMesh && !1 === e.skinning && console.warn(
									"THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:",
									t);
							var u = t.isSkinnedMesh && e.skinning,
								p = 0;
							l && (p |= v), u && (p |= E), s = c[p]
						}
						if (y.localClippingEnabled && !0 === e.clipShadows && 0 !== e.clippingPlanes.length) {
							var d = s.uuid,
								f = e.uuid,
								m = L[d];
							void 0 === m && (m = {}, L[d] = m);
							var g = m[f];
							void 0 === g && (g = s.clone(), m[f] = g), s = g
						}
						return s.visible = e.visible, s.wireframe = e.wireframe, s.side = null != e.shadowSide ? e
							.shadowSide : P[e.side], s.clipShadows = e.clipShadows, s.clippingPlanes = e
							.clippingPlanes, s.clipIntersection = e.clipIntersection, s.wireframeLinewidth = e
							.wireframeLinewidth, s.linewidth = e.linewidth, i && s.isMeshDistanceMaterial && (s
								.referencePosition.copy(n), s.nearDistance = r, s.farDistance = a), s
					}

					function D(t, e, i, n) {
						if (!1 !== t.visible) {
							if (t.layers.test(e.layers) && (t.isMesh || t.isLine || t.isPoints) && t.castShadow &&
								(!t.frustumCulled || x.intersectsObject(t))) {
								t.modelViewMatrix.multiplyMatrices(i.matrixWorldInverse, t.matrixWorld);
								var r = m.update(t),
									a = t.material;
								if (Array.isArray(a))
									for (var o = r.groups, s = 0, c = o.length; s < c; s++) {
										var h = o[s],
											l = a[h.materialIndex];
										if (l && l.visible) {
											var u = g(t, l, n, S, i.near, i.far);
											y.renderBufferDirect(i, null, r, u, t, h)
										}
									} else if (a.visible) {
										u = g(t, a, n, S, i.near, i.far);
										y.renderBufferDirect(i, null, r, u, t, null)
									}
							}
							for (var p = t.children, d = 0, f = p.length; d < f; d++) D(p[d], e, i, n)
						}
					}
					this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = B, this.render =
						function (t, e, i) {
							if (!1 !== I.enabled && (!1 !== I.autoUpdate || !1 !== I.needsUpdate) && 0 !== t
								.length) {
								y.context;
								var n, r = y.state;
								r.disable(3042), r.buffers.color.setClear(1, 1, 1, 1), r.buffers.depth.setTest(!
									0), r.setScissorTest(!1);
								for (var a = 0, o = t.length; a < o; a++) {
									var s = t[a],
										c = s.shadow,
										h = s && s.isPointLight;
									if (void 0 !== c) {
										var l = c.camera;
										if (w.copy(c.mapSize), w.min(_), h) {
											var u = w.x,
												p = w.y;
											O[0].set(2 * u, p, u, p), O[1].set(0, p, u, p), O[2].set(3 * u, p, u,
												p), O[3].set(u, p, u, p), O[4].set(3 * u, 0, u, p), O[5].set(
												u, 0, u, p), w.x *= 4, w.y *= 2
										}
										if (null === c.map) {
											var d = {
												minFilter: zt,
												magFilter: zt,
												format: oe
											};
											c.map = new Oi(w.x, w.y, d), c.map.texture.name = s.name +
												".shadowMap", l.updateProjectionMatrix()
										}
										c.isSpotLightShadow && c.update(s);
										var f = c.map,
											m = c.matrix;
										S.setFromMatrixPosition(s.matrixWorld), l.position.copy(S), h ? (n = 6, m
											.makeTranslation(-S.x, -S.y, -S.z)) : (n = 1, M
											.setFromMatrixPosition(s.target.matrixWorld), l.lookAt(M), l
											.updateMatrixWorld(), m.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5,
												.5, 0, 0, 0, 1), m.multiply(l.projectionMatrix), m.multiply(l
												.matrixWorldInverse)), y.setRenderTarget(f), y.clear();
										for (var g = 0; g < n; g++) {
											if (h) {
												M.copy(l.position), M.add(C[g]), l.up.copy(R[g]), l.lookAt(M), l
													.updateMatrixWorld();
												var v = O[g];
												r.viewport(v)
											}
											b.multiplyMatrices(l.projectionMatrix, l.matrixWorldInverse), x
												.setFromMatrix(b), D(e, i, l, h)
										}
									} else console.warn("THREE.WebGLShadowMap:", s, "has no shadow.")
								}
								I.needsUpdate = !1
							}
						}
				}

				function wo(l, i, c, n) {
					function t() {
						var e = !1,
							a = new Ri,
							i = null,
							o = new Ri(0, 0, 0, 0);
						return {
							setMask: function (t) {
								i === t || e || (l.colorMask(t, t, t, t), i = t)
							},
							setLocked: function (t) {
								e = t
							},
							setClear: function (t, e, i, n, r) {
								!0 === r && (t *= n, e *= n, i *= n), a.set(t, e, i, n), !1 === o.equals(a) &&
									(l.clearColor(t, e, i, n), o.copy(a))
							},
							reset: function () {
								e = !1, i = null, o.set(-1, 0, 0, 0)
							}
						}
					}

					function e() {
						var e = !1,
							i = null,
							n = null,
							r = null;
						return {
							setTest: function (t) {
								t ? W(2929) : q(2929)
							},
							setMask: function (t) {
								i === t || e || (l.depthMask(t), i = t)
							},
							setFunc: function (t) {
								if (n !== t) {
									if (t) switch (t) {
										case wt:
											l.depthFunc(512);
											break;
										case _t:
											l.depthFunc(519);
											break;
										case Mt:
											l.depthFunc(513);
											break;
										case St:
											l.depthFunc(515);
											break;
										case Et:
											l.depthFunc(514);
											break;
										case Tt:
											l.depthFunc(518);
											break;
										case At:
											l.depthFunc(516);
											break;
										case Lt:
											l.depthFunc(517);
											break;
										default:
											l.depthFunc(515)
									} else l.depthFunc(515);
									n = t
								}
							},
							setLocked: function (t) {
								e = t
							},
							setClear: function (t) {
								r !== t && (l.clearDepth(t), r = t)
							},
							reset: function () {
								e = !1, r = n = i = null
							}
						}
					}

					function r() {
						var e = !1,
							i = null,
							n = null,
							r = null,
							a = null,
							o = null,
							s = null,
							c = null,
							h = null;
						return {
							setTest: function (t) {
								t ? W(2960) : q(2960)
							},
							setMask: function (t) {
								i === t || e || (l.stencilMask(t), i = t)
							},
							setFunc: function (t, e, i) {
								n === t && r === e && a === i || (l.stencilFunc(t, e, i), n = t, r = e, a = i)
							},
							setOp: function (t, e, i) {
								o === t && s === e && c === i || (l.stencilOp(t, e, i), o = t, s = e, c = i)
							},
							setLocked: function (t) {
								e = t
							},
							setClear: function (t) {
								h !== t && (l.clearStencil(t), h = t)
							},
							reset: function () {
								e = !1, h = c = s = o = a = r = n = i = null
							}
						}
					}
					var a = new t,
						o = new e,
						s = new r,
						h = l.getParameter(34921),
						u = new Uint8Array(h),
						p = new Uint8Array(h),
						d = new Uint8Array(h),
						f = {},
						m = null,
						g = null,
						v = null,
						y = null,
						x = null,
						b = null,
						w = null,
						_ = null,
						M = null,
						S = null,
						E = !1,
						T = null,
						A = null,
						L = null,
						P = null,
						C = null,
						R = l.getParameter(35661),
						O = !1,
						I = 0,
						D = l.getParameter(7938); - 1 !== D.indexOf("WebGL") ? (I = parseFloat(/^WebGL\ ([0-9])/
						.exec(D)[1]), O = 1 <= I) : -1 !== D.indexOf("OpenGL ES") && (I = parseFloat(
						/^OpenGL\ ES\ ([0-9])/.exec(D)[1]), O = 2 <= I);
					var B = null,
						N = {},
						z = new Ri,
						U = new Ri;

					function G(t, e, i) {
						var n = new Uint8Array(4),
							r = l.createTexture();
						l.bindTexture(t, r), l.texParameteri(t, 10241, 9728), l.texParameteri(t, 10240, 9728);
						for (var a = 0; a < i; a++) l.texImage2D(e + a, 0, 6408, 1, 1, 0, 6408, 5121, n);
						return r
					}
					var F = {};

					function H() {
						for (var t = 0, e = u.length; t < e; t++) u[t] = 0
					}

					function k(t) {
						j(t, 0)
					}

					function j(t, e) {
						(u[t] = 1, 0 === p[t] && (l.enableVertexAttribArray(t), p[t] = 1), d[t] !== e) && ((n
							.isWebGL2 ? l : i.get("ANGLE_instanced_arrays"))[n.isWebGL2 ?
							"vertexAttribDivisor" : "vertexAttribDivisorANGLE"](t, e), d[t] = e)
					}

					function V() {
						for (var t = 0, e = p.length; t !== e; ++t) p[t] !== u[t] && (l.disableVertexAttribArray(
							t), p[t] = 0)
					}

					function W(t) {
						!0 !== f[t] && (l.enable(t), f[t] = !0)
					}

					function q(t) {
						!1 !== f[t] && (l.disable(t), f[t] = !1)
					}

					function X() {
						if (null === m && (m = [], i.get("WEBGL_compressed_texture_pvrtc") || i.get(
									"WEBGL_compressed_texture_s3tc") || i.get("WEBGL_compressed_texture_etc1") ||
								i.get("WEBGL_compressed_texture_astc")))
							for (var t = l.getParameter(34467), e = 0; e < t.length; e++) m.push(t[e]);
						return m
					}

					function Y(t) {
						return g !== t && (l.useProgram(t), g = t, !0)
					}

					function J(t, e, i, n, r, a, o, s) {
						if (t !== ft) {
							if (v || (W(3042), v = !0), t === xt) r = r || e, a = a || i, o = o || n, e === x &&
								r === _ || (l.blendEquationSeparate(c.convert(e), c.convert(r)), x = e, _ = r),
								i === b && n === w && a === M && o === S || (l.blendFuncSeparate(c.convert(i), c
									.convert(n), c.convert(a), c.convert(o)), b = i, w = n, M = a, S = o), y = t,
								E = null;
							else if (t !== y || s !== E) {
								if (x === bt && _ === bt || (l.blendEquation(32774), _ = x = bt), s) switch (t) {
									case mt:
										l.blendFuncSeparate(1, 771, 1, 771);
										break;
									case gt:
										l.blendFunc(1, 1);
										break;
									case vt:
										l.blendFuncSeparate(0, 0, 769, 771);
										break;
									case yt:
										l.blendFuncSeparate(0, 768, 0, 770);
										break;
									default:
										console.error("THREE.WebGLState: Invalid blending: ", t)
								} else switch (t) {
									case mt:
										l.blendFuncSeparate(770, 771, 1, 771);
										break;
									case gt:
										l.blendFunc(770, 1);
										break;
									case vt:
										l.blendFunc(0, 769);
										break;
									case yt:
										l.blendFunc(0, 768);
										break;
									default:
										console.error("THREE.WebGLState: Invalid blending: ", t)
								}
								S = M = w = b = null, y = t, E = s
							}
						} else v && (q(3042), v = !1)
					}

					function Z(t, e) {
						t.side === dt ? q(2884) : W(2884);
						var i = t.side === kt;
						e && (i = !i), Q(i), t.blending === mt && !1 === t.transparent ? J(ft) : J(t.blending, t
							.blendEquation, t.blendSrc, t.blendDst, t.blendEquationAlpha, t.blendSrcAlpha, t
							.blendDstAlpha, t.premultipliedAlpha), o.setFunc(t.depthFunc), o.setTest(t
							.depthTest), o.setMask(t.depthWrite), a.setMask(t.colorWrite), tt(t.polygonOffset,
							t.polygonOffsetFactor, t.polygonOffsetUnits)
					}

					function Q(t) {
						T !== t && (t ? l.frontFace(2304) : l.frontFace(2305), T = t)
					}

					function K(t) {
						t !== lt ? (W(2884), t !== A && (t === ut ? l.cullFace(1029) : t === pt ? l.cullFace(
							1028) : l.cullFace(1032))) : q(2884), A = t
					}

					function $(t) {
						t !== L && (O && l.lineWidth(t), L = t)
					}

					function tt(t, e, i) {
						t ? (W(32823), P === e && C === i || (l.polygonOffset(e, i), P = e, C = i)) : q(32823)
					}

					function et(t) {
						t ? W(3089) : q(3089)
					}

					function it(t) {
						void 0 === t && (t = 33984 + R - 1), B !== t && (l.activeTexture(t), B = t)
					}

					function nt(t, e) {
						null === B && it();
						var i = N[B];
						void 0 === i && (i = {
							type: void 0,
							texture: void 0
						}, N[B] = i), i.type === t && i.texture === e || (l.bindTexture(t, e || F[t]), i
							.type = t, i.texture = e)
					}

					function rt() {
						try {
							l.compressedTexImage2D.apply(l, arguments)
						} catch (t) {
							console.error("THREE.WebGLState:", t)
						}
					}

					function at() {
						try {
							l.texImage2D.apply(l, arguments)
						} catch (t) {
							console.error("THREE.WebGLState:", t)
						}
					}

					function ot() {
						try {
							l.texImage3D.apply(l, arguments)
						} catch (t) {
							console.error("THREE.WebGLState:", t)
						}
					}

					function st(t) {
						!1 === z.equals(t) && (l.scissor(t.x, t.y, t.z, t.w), z.copy(t))
					}

					function ct(t) {
						!1 === U.equals(t) && (l.viewport(t.x, t.y, t.z, t.w), U.copy(t))
					}

					function ht() {
						for (var t = 0; t < p.length; t++) 1 === p[t] && (l.disableVertexAttribArray(t), p[t] =
						0);
						f = {}, N = {}, A = T = y = g = B = m = null, a.reset(), o.reset(), s.reset()
					}
					return F[3553] = G(3553, 3553, 1), F[34067] = G(34067, 34069, 6), a.setClear(0, 0, 0, 1), o
						.setClear(1), s.setClear(0), W(2929), o.setFunc(St), Q(!1), K(ut), W(2884), J(ft), {
							buffers: {
								color: a,
								depth: o,
								stencil: s
							},
							initAttributes: H,
							enableAttribute: k,
							enableAttributeAndDivisor: j,
							disableUnusedAttributes: V,
							enable: W,
							disable: q,
							getCompressedTextureFormats: X,
							useProgram: Y,
							setBlending: J,
							setMaterial: Z,
							setFlipSided: Q,
							setCullFace: K,
							setLineWidth: $,
							setPolygonOffset: tt,
							setScissorTest: et,
							activeTexture: it,
							bindTexture: nt,
							compressedTexImage2D: rt,
							texImage2D: at,
							texImage3D: ot,
							scissor: st,
							viewport: ct,
							reset: ht
						}
				}

				function _o(g, r, v, y, x, b, w) {
					var e, n = {};

					function _(t, e) {
						if (t.width > e || t.height > e) {
							if ("data" in t) return void console.warn(
								"THREE.WebGLRenderer: image in DataTexture is too big (" + t.width + "x" +
								t.height + ").");
							var i = e / Math.max(t.width, t.height),
								n = document.createElement("canvas");
							return n.width = Math.floor(t.width * i), n.height = Math.floor(t.height * i), n
								.getContext("2d").drawImage(t, 0, 0, t.width, t.height, 0, 0, n.width, n.height),
								console.warn("THREE.WebGLRenderer: image is too big (" + t.width + "x" + t
									.height + "). Resized to " + n.width + "x" + n.height), n
						}
						return t
					}

					function M(t) {
						return oi.isPowerOfTwo(t.width) && oi.isPowerOfTwo(t.height)
					}

					function d(t) {
						return t instanceof HTMLImageElement || t instanceof HTMLCanvasElement ||
							t instanceof ImageBitmap ? (void 0 === e && (e = document.createElement("canvas")), e
								.width = oi.floorPowerOfTwo(t.width), e.height = oi.floorPowerOfTwo(t.height), e
								.getContext("2d").drawImage(t, 0, 0, e.width, e.height), console.warn(
									"THREE.WebGLRenderer: image is not power of two (" + t.width + "x" + t
									.height + "). Resized to " + e.width + "x" + e.height), e) : t
					}

					function f(t) {
						return !x.isWebGL2 && (t.wrapS !== Bt || t.wrapT !== Bt || t.minFilter !== zt && t
							.minFilter !== Ft)
					}

					function S(t, e) {
						return t.generateMipmaps && e && t.minFilter !== zt && t.minFilter !== Ft
					}

					function E(t, e, i, n) {
						g.generateMipmap(t), y.get(e).__maxMipLevel = Math.log(Math.max(i, n)) * Math.LOG2E
					}

					function T(t, e) {
						if (!x.isWebGL2) return t;
						if (6403 === t) {
							if (5126 === e) return 33326;
							if (5131 === e) return 33325;
							if (5121 === e) return 33321
						}
						if (6407 === t) {
							if (5126 === e) return 34837;
							if (5131 === e) return 34843;
							if (5121 === e) return 32849
						}
						if (6408 === t) {
							if (5126 === e) return 34836;
							if (5131 === e) return 34842;
							if (5121 === e) return 32856
						}
						return t
					}

					function a(t) {
						return t === zt || t === Ut || t === Gt ? 9728 : 9729
					}

					function A(t) {
						var e = t.target;
						e.removeEventListener("dispose", A), i(e), e.isVideoTexture && delete n[e.id], w.memory
							.textures--
					}

					function o(t) {
						var e = t.target;
						e.removeEventListener("dispose", o), s(e), w.memory.textures--
					}

					function i(t) {
						var e = y.get(t);
						if (t.image && e.__image__webglTextureCube) g.deleteTexture(e.__image__webglTextureCube);
						else {
							if (void 0 === e.__webglInit) return;
							g.deleteTexture(e.__webglTexture)
						}
						y.remove(t)
					}

					function s(t) {
						var e = y.get(t),
							i = y.get(t.texture);
						if (t) {
							if (void 0 !== i.__webglTexture && g.deleteTexture(i.__webglTexture), t
								.depthTexture && t.depthTexture.dispose(), t.isWebGLRenderTargetCube)
								for (var n = 0; n < 6; n++) g.deleteFramebuffer(e.__webglFramebuffer[n]), e
									.__webglDepthbuffer && g.deleteRenderbuffer(e.__webglDepthbuffer[n]);
							else g.deleteFramebuffer(e.__webglFramebuffer), e.__webglDepthbuffer && g
								.deleteRenderbuffer(e.__webglDepthbuffer);
							y.remove(t.texture), y.remove(t)
						}
					}

					function c(t, e) {
						var i = y.get(t);
						if (t.isVideoTexture && I(t), 0 < t.version && i.__version !== t.version) {
							var n = t.image;
							if (void 0 === n) console.warn(
								"THREE.WebGLRenderer: Texture marked for update but image is undefined");
							else {
								if (!1 !== n.complete) return void u(i, t, e);
								console.warn(
									"THREE.WebGLRenderer: Texture marked for update but image is incomplete")
							}
						}
						v.activeTexture(33984 + e), v.bindTexture(3553, i.__webglTexture)
					}

					function t(t, e) {
						var i = y.get(t);
						0 < t.version && i.__version !== t.version ? u(i, t, e) : (v.activeTexture(33984 + e), v
							.bindTexture(32879, i.__webglTexture))
					}

					function h(t, e) {
						var i = y.get(t);
						if (6 === t.image.length)
							if (0 < t.version && i.__version !== t.version) {
								i.__image__webglTextureCube || (t.addEventListener("dispose", A), i
										.__image__webglTextureCube = g.createTexture(), w.memory.textures++), v
									.activeTexture(33984 + e), v.bindTexture(34067, i.__image__webglTextureCube),
									g.pixelStorei(37440, t.flipY);
								for (var n = t && t.isCompressedTexture, r = t.image[0] && t.image[0]
										.isDataTexture, a = [], o = 0; o < 6; o++) a[o] = n || r ? r ? t.image[o]
									.image : t.image[o] : _(t.image[o], x.maxCubemapSize);
								var s = a[0],
									c = M(s),
									h = b.convert(t.format),
									l = b.convert(t.type),
									u = T(h, l);
								L(34067, t, c);
								for (o = 0; o < 6; o++)
									if (n)
										for (var p, d = a[o].mipmaps, f = 0, m = d.length; f < m; f++) p = d[f], t
											.format !== oe && t.format !== ae ? -1 < v
											.getCompressedTextureFormats().indexOf(h) ? v.compressedTexImage2D(
												34069 + o, f, u, p.width, p.height, 0, p.data) : console.warn(
												"THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"
												) : v.texImage2D(34069 + o, f, u, p.width, p.height, 0, h, l, p
												.data);
									else r ? v.texImage2D(34069 + o, 0, u, a[o].width, a[o].height, 0, h, l, a[o]
										.data) : v.texImage2D(34069 + o, 0, u, h, l, a[o]);
								i.__maxMipLevel = n ? d.length - 1 : 0, S(t, c) && E(34067, t, s.width, s.height),
									i.__version = t.version, t.onUpdate && t.onUpdate(t)
							} else v.activeTexture(33984 + e), v.bindTexture(34067, i.__image__webglTextureCube)
					}

					function l(t, e) {
						v.activeTexture(33984 + e), v.bindTexture(34067, y.get(t).__webglTexture)
					}

					function L(t, e, i) {
						var n;
						if (i ? (g.texParameteri(t, 10242, b.convert(e.wrapS)), g.texParameteri(t, 10243, b
									.convert(e.wrapT)), g.texParameteri(t, 10240, b.convert(e.magFilter)), g
								.texParameteri(t, 10241, b.convert(e.minFilter))) : (g.texParameteri(t, 10242,
									33071), g.texParameteri(t, 10243, 33071), e.wrapS === Bt && e.wrapT === Bt ||
								console.warn(
									"THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."
									), g.texParameteri(t, 10240, a(e.magFilter)), g.texParameteri(t, 10241, a(e
									.minFilter)), e.minFilter !== zt && e.minFilter !== Ft && console.warn(
									"THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter."
									)), n = r.get("EXT_texture_filter_anisotropic")) {
							if (e.type === Kt && null === r.get("OES_texture_float_linear")) return;
							if (e.type === $t && null === (x.isWebGL2 || r.get("OES_texture_half_float_linear")))
								return;
							(1 < e.anisotropy || y.get(e).__currentAnisotropy) && (g.texParameterf(t, n
									.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(e.anisotropy, x.getMaxAnisotropy())), y
								.get(e).__currentAnisotropy = e.anisotropy)
						}
					}

					function u(t, e, i) {
						var n;
						n = e.isDataTexture3D ? 32879 : 3553, void 0 === t.__webglInit && (t.__webglInit = !0, e
								.addEventListener("dispose", A), t.__webglTexture = g.createTexture(), w.memory
								.textures++), v.activeTexture(33984 + i), v.bindTexture(n, t.__webglTexture), g
							.pixelStorei(37440, e.flipY), g.pixelStorei(37441, e.premultiplyAlpha), g.pixelStorei(
								3317, e.unpackAlignment);
						var r = _(e.image, x.maxTextureSize);
						f(e) && !1 === M(r) && (r = d(r));
						var a = M(r),
							o = b.convert(e.format),
							s = b.convert(e.type),
							c = T(o, s);
						L(n, e, a);
						var h, l = e.mipmaps;
						if (e.isDepthTexture) {
							if (c = 6402, e.type === Kt) {
								if (!x.isWebGL2) throw new Error(
								"Float Depth Texture only supported in WebGL2.0");
								c = 36012
							} else x.isWebGL2 && (c = 33189);
							e.format === le && 6402 === c && e.type !== Jt && e.type !== Qt && (console.warn(
								"THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."
								), e.type = Jt, s = b.convert(e.type)), e.format === ue && (c = 34041, e
								.type !== ne && (console.warn(
									"THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."
									), e.type = ne, s = b.convert(e.type))), v.texImage2D(3553, 0, c, r.width,
								r.height, 0, o, s, null)
						} else if (e.isDataTexture)
							if (0 < l.length && a) {
								for (var u = 0, p = l.length; u < p; u++) h = l[u], v.texImage2D(3553, u, c, h
									.width, h.height, 0, o, s, h.data);
								e.generateMipmaps = !1, t.__maxMipLevel = l.length - 1
							} else v.texImage2D(3553, 0, c, r.width, r.height, 0, o, s, r.data), t.__maxMipLevel =
								0;
						else if (e.isCompressedTexture) {
							for (u = 0, p = l.length; u < p; u++) h = l[u], e.format !== oe && e.format !== ae ? -
								1 < v.getCompressedTextureFormats().indexOf(o) ? v.compressedTexImage2D(3553, u,
									c, h.width, h.height, 0, h.data) : console.warn(
									"THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"
									) : v.texImage2D(3553, u, c, h.width, h.height, 0, o, s, h.data);
							t.__maxMipLevel = l.length - 1
						} else if (e.isDataTexture3D) v.texImage3D(32879, 0, c, r.width, r.height, r.depth, 0, o,
							s, r.data), t.__maxMipLevel = 0;
						else if (0 < l.length && a) {
							for (u = 0, p = l.length; u < p; u++) h = l[u], v.texImage2D(3553, u, c, o, s, h);
							e.generateMipmaps = !1, t.__maxMipLevel = l.length - 1
						} else v.texImage2D(3553, 0, c, o, s, r), t.__maxMipLevel = 0;
						S(e, a) && E(3553, e, r.width, r.height), t.__version = e.version, e.onUpdate && e
							.onUpdate(e)
					}

					function p(t, e, i, n) {
						var r = b.convert(e.texture.format),
							a = b.convert(e.texture.type),
							o = T(r, a);
						v.texImage2D(n, 0, o, e.width, e.height, 0, r, a, null), g.bindFramebuffer(36160, t), g
							.framebufferTexture2D(36160, i, n, y.get(e.texture).__webglTexture, 0), g
							.bindFramebuffer(36160, null)
					}

					function m(t, e) {
						g.bindRenderbuffer(36161, t), e.depthBuffer && !e.stencilBuffer ? (g.renderbufferStorage(
								36161, 33189, e.width, e.height), g.framebufferRenderbuffer(36160, 36096,
								36161, t)) : e.depthBuffer && e.stencilBuffer ? (g.renderbufferStorage(36161,
								34041, e.width, e.height), g.framebufferRenderbuffer(36160, 33306, 36161, t)) : g
							.renderbufferStorage(36161, 32854, e.width, e.height), g.bindRenderbuffer(36161, null)
					}

					function P(t, e) {
						if (e && e.isWebGLRenderTargetCube) throw new Error(
							"Depth Texture with cube render targets is not supported");
						if (g.bindFramebuffer(36160, t), !e.depthTexture || !e.depthTexture.isDepthTexture)
						throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
						y.get(e.depthTexture).__webglTexture && e.depthTexture.image.width === e.width && e
							.depthTexture.image.height === e.height || (e.depthTexture.image.width = e.width, e
								.depthTexture.image.height = e.height, e.depthTexture.needsUpdate = !0), c(e
								.depthTexture, 0);
						var i = y.get(e.depthTexture).__webglTexture;
						if (e.depthTexture.format === le) g.framebufferTexture2D(36160, 36096, 3553, i, 0);
						else {
							if (e.depthTexture.format !== ue) throw new Error("Unknown depthTexture format");
							g.framebufferTexture2D(36160, 33306, 3553, i, 0)
						}
					}

					function C(t) {
						var e = y.get(t),
							i = !0 === t.isWebGLRenderTargetCube;
						if (t.depthTexture) {
							if (i) throw new Error("target.depthTexture not supported in Cube render targets");
							P(e.__webglFramebuffer, t)
						} else if (i) {
							e.__webglDepthbuffer = [];
							for (var n = 0; n < 6; n++) g.bindFramebuffer(36160, e.__webglFramebuffer[n]), e
								.__webglDepthbuffer[n] = g.createRenderbuffer(), m(e.__webglDepthbuffer[n], t)
						} else g.bindFramebuffer(36160, e.__webglFramebuffer), e.__webglDepthbuffer = g
							.createRenderbuffer(), m(e.__webglDepthbuffer, t);
						g.bindFramebuffer(36160, null)
					}

					function R(t) {
						var e = y.get(t),
							i = y.get(t.texture);
						t.addEventListener("dispose", o), i.__webglTexture = g.createTexture(), w.memory
							.textures++;
						var n = !0 === t.isWebGLRenderTargetCube,
							r = M(t);
						if (n) {
							e.__webglFramebuffer = [];
							for (var a = 0; a < 6; a++) e.__webglFramebuffer[a] = g.createFramebuffer()
						} else e.__webglFramebuffer = g.createFramebuffer();
						if (n) {
							v.bindTexture(34067, i.__webglTexture), L(34067, t.texture, r);
							for (a = 0; a < 6; a++) p(e.__webglFramebuffer[a], t, 36064, 34069 + a);
							S(t.texture, r) && E(34067, t.texture, t.width, t.height), v.bindTexture(34067, null)
						} else v.bindTexture(3553, i.__webglTexture), L(3553, t.texture, r), p(e
							.__webglFramebuffer, t, 36064, 3553), S(t.texture, r) && E(3553, t.texture, t
							.width, t.height), v.bindTexture(3553, null);
						t.depthBuffer && C(t)
					}

					function O(t) {
						var e = t.texture;
						if (S(e, M(t))) {
							var i = t.isWebGLRenderTargetCube ? 34067 : 3553,
								n = y.get(e).__webglTexture;
							v.bindTexture(i, n), E(i, e, t.width, t.height), v.bindTexture(i, null)
						}
					}

					function I(t) {
						var e = t.id,
							i = w.render.frame;
						n[e] !== i && (n[e] = i, t.update())
					}
					this.setTexture2D = c, this.setTexture3D = t, this.setTextureCube = h, this
						.setTextureCubeDynamic = l, this.setupRenderTarget = R, this.updateRenderTargetMipmap = O
				}

				function Mo(t, i, n) {
					function e(t) {
						var e;
						if (t === Dt) return 10497;
						if (t === Bt) return 33071;
						if (t === Nt) return 33648;
						if (t === zt) return 9728;
						if (t === Ut) return 9984;
						if (t === Gt) return 9986;
						if (t === Ft) return 9729;
						if (t === Vt) return 9985;
						if (t === Wt) return 9987;
						if (t === qt) return 5121;
						if (t === te) return 32819;
						if (t === ee) return 32820;
						if (t === ie) return 33635;
						if (t === Xt) return 5120;
						if (t === Yt) return 5122;
						if (t === Jt) return 5123;
						if (t === Zt) return 5124;
						if (t === Qt) return 5125;
						if (t === Kt) return 5126;
						if (t === $t) {
							if (n.isWebGL2) return 5131;
							if (null !== (e = i.get("OES_texture_half_float"))) return e.HALF_FLOAT_OES
						}
						if (t === re) return 6406;
						if (t === ae) return 6407;
						if (t === oe) return 6408;
						if (t === se) return 6409;
						if (t === ce) return 6410;
						if (t === le) return 6402;
						if (t === ue) return 34041;
						if (t === pe) return 6403;
						if (t === bt) return 32774;
						if (t === U) return 32778;
						if (t === G) return 32779;
						if (t === k) return 0;
						if (t === j) return 1;
						if (t === V) return 768;
						if (t === W) return 769;
						if (t === q) return 770;
						if (t === X) return 771;
						if (t === Y) return 772;
						if (t === J) return 773;
						if (t === Z) return 774;
						if (t === Q) return 775;
						if (t === K) return 776;
						if ((t === de || t === fe || t === me || t === ge) && null !== (e = i.get(
								"WEBGL_compressed_texture_s3tc"))) {
							if (t === de) return e.COMPRESSED_RGB_S3TC_DXT1_EXT;
							if (t === fe) return e.COMPRESSED_RGBA_S3TC_DXT1_EXT;
							if (t === me) return e.COMPRESSED_RGBA_S3TC_DXT3_EXT;
							if (t === ge) return e.COMPRESSED_RGBA_S3TC_DXT5_EXT
						}
						if ((t === ve || t === ye || t === xe || t === be) && null !== (e = i.get(
								"WEBGL_compressed_texture_pvrtc"))) {
							if (t === ve) return e.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
							if (t === ye) return e.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
							if (t === xe) return e.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
							if (t === be) return e.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
						}
						if (t === we && null !== (e = i.get("WEBGL_compressed_texture_etc1"))) return e
							.COMPRESSED_RGB_ETC1_WEBGL;
						if ((t === _e || t === Me || t === Se || t === Ee || t === Te || t === Ae || t === Le ||
								t === Pe || t === Ce || t === Re || t === Oe || t === Ie || t === De || t === Be
								) && null !== (e = i.get("WEBGL_compressed_texture_astc"))) return t;
						if (t === F || t === H) {
							if (n.isWebGL2) {
								if (t === F) return 32775;
								if (t === H) return 32776
							}
							if (null !== (e = i.get("EXT_blend_minmax"))) {
								if (t === F) return e.MIN_EXT;
								if (t === H) return e.MAX_EXT
							}
						}
						if (t === ne) {
							if (n.isWebGL2) return 34042;
							if (null !== (e = i.get("WEBGL_depth_texture"))) return e.UNSIGNED_INT_24_8_WEBGL
						}
						return 0
					}
					return {
						convert: e
					}
				}

				function So() {
					Mn.call(this), this.type = "Group"
				}

				function Eo() {
					Mn.call(this), this.type = "Camera", this.matrixWorldInverse = new ci, this.projectionMatrix =
						new ci, this.projectionMatrixInverse = new ci
				}

				function To(t, e, i, n) {
					Eo.call(this), this.type = "PerspectiveCamera", this.fov = void 0 !== t ? t : 50, this.zoom =
						1, this.near = void 0 !== i ? i : .1, this.far = void 0 !== n ? n : 2e3, this.focus = 10,
						this.aspect = void 0 !== e ? e : 1, this.view = null, this.filmGauge = 35, this
						.filmOffset = 0, this.updateProjectionMatrix()
				}

				function Ao(t) {
					To.call(this), this.cameras = t || []
				}
				yo.prototype = Object.create(Ir.prototype), (yo.prototype.constructor = yo).prototype
					.isMeshDepthMaterial = !0, yo.prototype.copy = function (t) {
						return Ir.prototype.copy.call(this, t), this.depthPacking = t.depthPacking, this
							.skinning = t.skinning, this.morphTargets = t.morphTargets, this.map = t.map, this
							.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this
							.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias,
							this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this
					}, xo.prototype = Object.create(Ir.prototype), (xo.prototype.constructor = xo).prototype
					.isMeshDistanceMaterial = !0, xo.prototype.copy = function (t) {
						return Ir.prototype.copy.call(this, t), this.referencePosition.copy(t.referencePosition),
							this.nearDistance = t.nearDistance, this.farDistance = t.farDistance, this.skinning =
							t.skinning, this.morphTargets = t.morphTargets, this.map = t.map, this.alphaMap = t
							.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t
							.displacementScale, this.displacementBias = t.displacementBias, this
					}, So.prototype = Object.assign(Object.create(Mn.prototype), {
						constructor: So,
						isGroup: !0
					}), Eo.prototype = Object.assign(Object.create(Mn.prototype), {
						constructor: Eo,
						isCamera: !0,
						copy: function (t, e) {
							return Mn.prototype.copy.call(this, t, e), this.matrixWorldInverse.copy(t
									.matrixWorldInverse), this.projectionMatrix.copy(t.projectionMatrix),
								this.projectionMatrixInverse.copy(t.projectionMatrixInverse), this
						},
						getWorldDirection: function (t) {
							void 0 === t && (console.warn(
									"THREE.Camera: .getWorldDirection() target is now required"), t =
								new li), this.updateMatrixWorld(!0);
							var e = this.matrixWorld.elements;
							return t.set(-e[8], -e[9], -e[10]).normalize()
						},
						updateMatrixWorld: function (t) {
							Mn.prototype.updateMatrixWorld.call(this, t), this.matrixWorldInverse
								.getInverse(this.matrixWorld)
						},
						clone: function () {
							return (new this.constructor).copy(this)
						}
					}), To.prototype = Object.assign(Object.create(Eo.prototype), {
						constructor: To,
						isPerspectiveCamera: !0,
						copy: function (t, e) {
							return Eo.prototype.copy.call(this, t, e), this.fov = t.fov, this.zoom = t
								.zoom, this.near = t.near, this.far = t.far, this.focus = t.focus, this
								.aspect = t.aspect, this.view = null === t.view ? null : Object.assign({},
									t.view), this.filmGauge = t.filmGauge, this.filmOffset = t.filmOffset,
								this
						},
						setFocalLength: function (t) {
							var e = .5 * this.getFilmHeight() / t;
							this.fov = 2 * oi.RAD2DEG * Math.atan(e), this.updateProjectionMatrix()
						},
						getFocalLength: function () {
							var t = Math.tan(.5 * oi.DEG2RAD * this.fov);
							return .5 * this.getFilmHeight() / t
						},
						getEffectiveFOV: function () {
							return 2 * oi.RAD2DEG * Math.atan(Math.tan(.5 * oi.DEG2RAD * this.fov) / this
								.zoom)
						},
						getFilmWidth: function () {
							return this.filmGauge * Math.min(this.aspect, 1)
						},
						getFilmHeight: function () {
							return this.filmGauge / Math.max(this.aspect, 1)
						},
						setViewOffset: function (t, e, i, n, r, a) {
							this.aspect = t / e, null === this.view && (this.view = {
									enabled: !0,
									fullWidth: 1,
									fullHeight: 1,
									offsetX: 0,
									offsetY: 0,
									width: 1,
									height: 1
								}), this.view.enabled = !0, this.view.fullWidth = t, this.view
								.fullHeight = e, this.view.offsetX = i, this.view.offsetY = n, this.view
								.width = r, this.view.height = a, this.updateProjectionMatrix()
						},
						clearViewOffset: function () {
							null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
						},
						updateProjectionMatrix: function () {
							var t = this.near,
								e = t * Math.tan(.5 * oi.DEG2RAD * this.fov) / this.zoom,
								i = 2 * e,
								n = this.aspect * i,
								r = -.5 * n,
								a = this.view;
							if (null !== this.view && this.view.enabled) {
								var o = a.fullWidth,
									s = a.fullHeight;
								r += a.offsetX * n / o, e -= a.offsetY * i / s, n *= a.width / o, i *= a
									.height / s
							}
							var c = this.filmOffset;
							0 !== c && (r += t * c / this.getFilmWidth()), this.projectionMatrix
								.makePerspective(r, r + n, e, e - i, t, this.far), this
								.projectionMatrixInverse.getInverse(this.projectionMatrix)
						},
						toJSON: function (t) {
							var e = Mn.prototype.toJSON.call(this, t);
							return e.object.fov = this.fov, e.object.zoom = this.zoom, e.object.near =
								this.near, e.object.far = this.far, e.object.focus = this.focus, e.object
								.aspect = this.aspect, null !== this.view && (e.object.view = Object
									.assign({}, this.view)), e.object.filmGauge = this.filmGauge, e.object
								.filmOffset = this.filmOffset, e
						}
					}), Ao.prototype = Object.assign(Object.create(To.prototype), {
						constructor: Ao,
						isArrayCamera: !0
					});
				var Lo, Po, Co, Ro, Oo, Io, Do, Bo, No, zo, Uo, Go, Fo, Ho, ko, jo, Vo = new li,
					Wo = new li;

				function qo(t, e, i) {
					Vo.setFromMatrixPosition(e.matrixWorld), Wo.setFromMatrixPosition(i.matrixWorld);
					var n = Vo.distanceTo(Wo),
						r = e.projectionMatrix.elements,
						a = i.projectionMatrix.elements,
						o = r[14] / (r[10] - 1),
						s = r[14] / (r[10] + 1),
						c = (r[9] + 1) / r[5],
						h = (r[9] - 1) / r[5],
						l = (r[8] - 1) / r[0],
						u = (a[8] + 1) / a[0],
						p = o * l,
						d = o * u,
						f = n / (-l + u),
						m = f * -l;
					e.matrixWorld.decompose(t.position, t.quaternion, t.scale), t.translateX(m), t.translateZ(f),
						t.matrixWorld.compose(t.position, t.quaternion, t.scale), t.matrixWorldInverse.getInverse(
							t.matrixWorld);
					var g = o + f,
						v = s + f,
						y = p - m,
						x = d + (n - m),
						b = c * s / v * g,
						w = h * s / v * g;
					t.projectionMatrix.makePerspective(y, x, b, w, g, v)
				}

				function Xo(n) {
					var r = this,
						c = null,
						h = null,
						l = null,
						a = [],
						u = new ci,
						p = new ci,
						o = 1,
						d = "stage";
					"undefined" != typeof window && "VRFrameData" in window && (h = new window.VRFrameData, window
						.addEventListener("vrdisplaypresentchange", t, !1));
					var f = new ci,
						m = new hi,
						g = new li,
						v = new To;
					v.bounds = new Ri(0, 0, .5, 1), v.layers.enable(1);
					var y = new To;
					y.bounds = new Ri(.5, 0, .5, 1), y.layers.enable(2);
					var s, x, b = new Ao([v, y]);

					function w() {
						return null !== c && !0 === c.isPresenting
					}

					function t() {
						if (w()) {
							var t = c.getEyeParameters("left"),
								e = t.renderWidth * o,
								i = t.renderHeight * o;
							x = n.getPixelRatio(), s = n.getSize(), n.setDrawingBufferSize(2 * e, i, 1), E.start()
						} else r.enabled && n.setDrawingBufferSize(s.width, s.height, x), E.stop()
					}
					b.layers.enable(1), b.layers.enable(2);
					var _ = [];

					function M(t) {
						for (var e = navigator.getGamepads && navigator.getGamepads(), i = 0, n = 0, r = e
							.length; i < r; i++) {
							var a = e[i];
							if (a && ("Daydream Controller" === a.id || "Gear VR Controller" === a.id ||
									"Oculus Go Controller" === a.id || "OpenVR Gamepad" === a.id || a.id
									.startsWith("Oculus Touch") || a.id.startsWith("Spatial Controller"))) {
								if (n === t) return a;
								n++
							}
						}
					}

					function S() {
						for (var t = 0; t < a.length; t++) {
							var e = a[t],
								i = M(t);
							if (void 0 !== i && void 0 !== i.pose) {
								if (null === i.pose) return;
								var n = i.pose;
								!1 === n.hasPosition && e.position.set(.2, -.6, -.05), null !== n.position && e
									.position.fromArray(n.position), null !== n.orientation && e.quaternion
									.fromArray(n.orientation), e.matrix.compose(e.position, e.quaternion, e
									.scale), e.matrix.premultiply(u), e.matrix.decompose(e.position, e.quaternion,
										e.scale), e.matrixWorldNeedsUpdate = !0, e.visible = !0;
								var r = "Daydream Controller" === i.id ? 0 : 1;
								_[t] !== i.buttons[r].pressed && (_[t] = i.buttons[r].pressed, !0 === _[t] ? e
									.dispatchEvent({
										type: "selectstart"
									}) : (e.dispatchEvent({
										type: "selectend"
									}), e.dispatchEvent({
										type: "select"
									})))
							} else e.visible = !1
						}
					}
					this.enabled = !1, this.getController = function (t) {
						var e = a[t];
						return void 0 === e && ((e = new So).matrixAutoUpdate = !1, e.visible = !1, a[t] = e),
							e
					}, this.getDevice = function () {
						return c
					}, this.setDevice = function (t) {
						void 0 !== t && (c = t), E.setContext(t)
					}, this.setFramebufferScaleFactor = function (t) {
						o = t
					}, this.setFrameOfReferenceType = function (t) {
						d = t
					}, this.setPoseTarget = function (t) {
						void 0 !== t && (l = t)
					}, this.getCamera = function (t) {
						var e = "stage" === d ? 1.6 : 0;
						if (null === c) return t.position.set(0, e, 0), t;
						if (c.depthNear = t.near, c.depthFar = t.far, c.getFrameData(h), "stage" === d) {
							var i = c.stageParameters;
							i ? u.fromArray(i.sittingToStandingTransform) : u.makeTranslation(0, e, 0)
						}
						var n = h.pose,
							r = null !== l ? l : t;
						if (r.matrix.copy(u), r.matrix.decompose(r.position, r.quaternion, r.scale), null !==
							n.orientation && (m.fromArray(n.orientation), r.quaternion.multiply(m)), null !==
							n.position && (m.setFromRotationMatrix(u), g.fromArray(n.position), g
								.applyQuaternion(m), r.position.add(g)), r.updateMatrixWorld(), !1 === c
							.isPresenting) return t;
						v.near = t.near, y.near = t.near, v.far = t.far, y.far = t.far, v.matrixWorldInverse
							.fromArray(h.leftViewMatrix), y.matrixWorldInverse.fromArray(h.rightViewMatrix), p
							.getInverse(u), "stage" === d && (v.matrixWorldInverse.multiply(p), y
								.matrixWorldInverse.multiply(p));
						var a = r.parent;
						null !== a && (f.getInverse(a.matrixWorld), v.matrixWorldInverse.multiply(f), y
								.matrixWorldInverse.multiply(f)), v.matrixWorld.getInverse(v
								.matrixWorldInverse), y.matrixWorld.getInverse(y.matrixWorldInverse), v
							.projectionMatrix.fromArray(h.leftProjectionMatrix), y.projectionMatrix.fromArray(
								h.rightProjectionMatrix), qo(b, v, y);
						var o = c.getLayers();
						if (o.length) {
							var s = o[0];
							null !== s.leftBounds && 4 === s.leftBounds.length && v.bounds.fromArray(s
									.leftBounds), null !== s.rightBounds && 4 === s.rightBounds.length && y
								.bounds.fromArray(s.rightBounds)
						}
						return S(), b
					}, this.getStandingMatrix = function () {
						return u
					}, this.isPresenting = w;
					var E = new Ki;
					this.setAnimationLoop = function (t) {
						E.setAnimationLoop(t)
					}, this.submitFrame = function () {
						w() && c.submitFrame()
					}, this.dispose = function () {
						"undefined" != typeof window && window.removeEventListener("vrdisplaypresentchange",
							t)
					}
				}

				function Yo(e) {
					var i = e.context,
						n = null,
						p = null,
						r = 1,
						d = null,
						a = "stage",
						f = null,
						m = [],
						g = [];

					function o() {
						return null !== p && null !== d
					}
					var s = new To;
					s.layers.enable(1), s.viewport = new Ri;
					var c = new To;
					c.layers.enable(2), c.viewport = new Ri;
					var v = new Ao([s, c]);

					function h(t) {
						var e = m[g.indexOf(t.inputSource)];
						e && e.dispatchEvent({
							type: t.type
						})
					}

					function l() {
						e.setFramebuffer(null), x.stop()
					}

					function u(t, e) {
						null === e ? t.matrixWorld.copy(t.matrix) : t.matrixWorld.multiplyMatrices(e.matrixWorld,
							t.matrix), t.matrixWorldInverse.getInverse(t.matrixWorld)
					}
					v.layers.enable(1), v.layers.enable(2), this.enabled = !1, this.getController = function (t) {
						var e = m[t];
						return void 0 === e && ((e = new So).matrixAutoUpdate = !1, e.visible = !1, m[t] = e),
							e
					}, this.getDevice = function () {
						return n
					}, this.setDevice = function (t) {
						void 0 !== t && (n = t), t instanceof XRDevice && i.setCompatibleXRDevice(t)
					}, this.setFramebufferScaleFactor = function (t) {
						r = t
					}, this.setFrameOfReferenceType = function (t) {
						a = t
					}, this.setSession = function (t) {
						null !== (p = t) && (p.addEventListener("select", h), p.addEventListener(
							"selectstart", h), p.addEventListener("selectend", h), p.addEventListener(
							"end", l), p.baseLayer = new XRWebGLLayer(p, i, {
							framebufferScaleFactor: r
						}), p.requestFrameOfReference(a).then(function (t) {
							d = t, e.setFramebuffer(p.baseLayer.framebuffer), x.setContext(p), x
								.start()
						}), g = p.getInputSources(), p.addEventListener("inputsourceschange",
							function () {
								g = p.getInputSources(), console.log(g);
								for (var t = 0; t < m.length; t++) {
									m[t].userData.inputSource = g[t]
								}
							}))
					}, this.getCamera = function (t) {
						if (o()) {
							var e = t.parent,
								i = v.cameras;
							u(v, e);
							for (var n = 0; n < i.length; n++) u(i[n], e);
							t.matrixWorld.copy(v.matrixWorld);
							for (var r = t.children, a = (n = 0, r.length); n < a; n++) r[n]
								.updateMatrixWorld(!0);
							return qo(v, s, c), v
						}
						return t
					}, this.isPresenting = o;
					var y = null;

					function t(t, e) {
						if (null !== (f = e.getDevicePose(d)))
							for (var i = p.baseLayer, n = e.views, r = 0; r < n.length; r++) {
								var a = n[r],
									o = i.getViewport(a),
									s = f.getViewMatrix(a),
									c = v.cameras[r];
								c.matrix.fromArray(s).getInverse(c.matrix), c.projectionMatrix.fromArray(a
										.projectionMatrix), c.viewport.set(o.x, o.y, o.width, o.height), 0 ===
									r && v.matrix.copy(c.matrix)
							}
						for (r = 0; r < m.length; r++) {
							var h = m[r],
								l = g[r];
							if (l) {
								var u = e.getInputPose(l, d);
								if (null !== u) {
									"targetRay" in u ? h.matrix.elements = u.targetRay.transformMatrix :
										"pointerMatrix" in u && (h.matrix.elements = u.pointerMatrix), h.matrix
										.decompose(h.position, h.rotation, h.scale), h.visible = !0;
									continue
								}
							}
							h.visible = !1
						}
						y && y(t)
					}
					var x = new Ki;
					x.setAnimationLoop(t), this.setAnimationLoop = function (t) {
						y = t
					}, this.dispose = function () {}, this.getStandingMatrix = function () {
						return console.warn("THREE.WebXRManager: getStandingMatrix() is no longer needed."),
							new THREE.Matrix4
					}, this.submitFrame = function () {}
				}

				function Jo(t) {
					console.log("THREE.WebGLRenderer", Ht);
					var n = void 0 !== (t = t || {}).canvas ? t.canvas : document.createElement("canvas"),
						e = void 0 !== t.context ? t.context : null,
						i = void 0 !== t.alpha && t.alpha,
						r = void 0 === t.depth || t.depth,
						a = void 0 === t.stencil || t.stencil,
						o = void 0 !== t.antialias && t.antialias,
						s = void 0 === t.premultipliedAlpha || t.premultipliedAlpha,
						c = void 0 !== t.preserveDrawingBuffer && t.preserveDrawingBuffer,
						h = void 0 !== t.powerPreference ? t.powerPreference : "default",
						u = null,
						w = null;
					this.domElement = n, this.context = null, this.autoClear = !0, this.autoClearColor = !0, this
						.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this
						.clippingPlanes = [], this.localClippingEnabled = !1, this.gammaFactor = 2, this
						.gammaInput = !1, this.gammaOutput = !1, this.physicallyCorrectLights = !1, this
						.toneMapping = jt, this.toneMappingExposure = 1, this.toneMappingWhitePoint = 1, this
						.maxMorphTargets = 8, this.maxMorphNormals = 4;
					var M, x, _, S, l, E, p, T, A, d, y, f, m, g, L, P, C, v, R = this,
						b = !1,
						O = null,
						I = null,
						D = null,
						B = -1,
						N = {
							geometry: null,
							program: null,
							wireframe: !1
						},
						z = null,
						U = null,
						G = new Ri,
						F = new Ri,
						H = null,
						k = 0,
						j = n.width,
						V = n.height,
						W = 1,
						q = new Ri(0, 0, j, V),
						X = new Ri(0, 0, j, V),
						Y = !1,
						J = new Ui,
						Z = new kr,
						Q = !1,
						K = !1,
						$ = new ci,
						tt = new li;

					function et() {
						return null === I ? W : 1
					}
					try {
						var it = {
							alpha: i,
							depth: r,
							stencil: a,
							antialias: o,
							premultipliedAlpha: s,
							preserveDrawingBuffer: c,
							powerPreference: h
						};
						if (n.addEventListener("webglcontextlost", ot, !1), n.addEventListener(
								"webglcontextrestored", st, !1), null === (M = e || n.getContext("webgl", it) || n
								.getContext("experimental-webgl", it))) throw null !== n.getContext("webgl") ?
							new Error("Error creating WebGL context with your selected attributes.") :
							new Error("Error creating WebGL context.");
						void 0 === M.getShaderPrecisionFormat && (M.getShaderPrecisionFormat = function () {
							return {
								rangeMin: 1,
								rangeMax: 1,
								precision: 1
							}
						})
					} catch (t) {
						console.error("THREE.WebGLRenderer: " + t.message)
					}

					function nt() {
						x = new jr(M), (_ = new Hr(M, x, t)).isWebGL2 || (x.get("WEBGL_depth_texture"), x.get(
								"OES_texture_float"), x.get("OES_texture_half_float"), x.get(
								"OES_texture_half_float_linear"), x.get("OES_standard_derivatives"), x.get(
								"OES_element_index_uint"), x.get("ANGLE_instanced_arrays")), x.get(
								"OES_texture_float_linear"), v = new Mo(M, x, _), (S = new wo(M, x, v, _))
							.scissor(F.copy(X).multiplyScalar(W)), S.viewport(G.copy(q).multiplyScalar(W)), l =
							new qr(M), E = new so, p = new _o(M, x, S, E, _, v, l), T = new $i(M), A = new Vr(M,
								T, l), d = new Jr(A, l), L = new Yr(M), y = new oo(R, x, _), f = new uo, m =
							new vo, g = new Gr(R, S, d, s), P = new Fr(M, x, l, _), C = new Wr(M, x, l, _), l
							.programs = y.programs, R.context = M, R.capabilities = _, R.extensions = x, R
							.properties = E, R.renderLists = f, R.state = S, R.info = l
					}
					nt();
					var rt = null;
					"undefined" != typeof navigator && (rt = "xr" in navigator ? new Yo(R) : new Xo(R)), this.vr =
						rt;
					var at = new bo(R, d, _.maxTextureSize);

					function ot(t) {
						t.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), b = !0
					}

					function st() {
						console.log("THREE.WebGLRenderer: Context Restored."), b = !1, nt()
					}

					function ct(t) {
						var e = t.target;
						e.removeEventListener("dispose", ct), ht(e)
					}

					function ht(t) {
						lt(t), E.remove(t)
					}

					function lt(t) {
						var e = E.get(t).program;
						(t.program = void 0) !== e && y.releaseProgram(e)
					}

					function ut(t, e) {
						t.render(function (t) {
							R.renderBufferImmediate(t, e)
						})
					}

					function pt(t, e, i) {
						if (i && i.isInstancedBufferGeometry & !_.isWebGL2 && null === x.get(
								"ANGLE_instanced_arrays")) console.error(
							"THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
							);
						else {
							S.initAttributes();
							var n = i.attributes,
								r = e.getAttributes(),
								a = t.defaultAttributeValues;
							for (var o in r) {
								var s = r[o];
								if (0 <= s) {
									var c = n[o];
									if (void 0 !== c) {
										var h = c.normalized,
											l = c.itemSize,
											u = T.get(c);
										if (void 0 === u) continue;
										var p = u.buffer,
											d = u.type,
											f = u.bytesPerElement;
										if (c.isInterleavedBufferAttribute) {
											var m = c.data,
												g = m.stride,
												v = c.offset;
											m && m.isInstancedInterleavedBuffer ? (S.enableAttributeAndDivisor(s,
													m.meshPerAttribute), void 0 === i.maxInstancedCount && (i
													.maxInstancedCount = m.meshPerAttribute * m.count)) : S
												.enableAttribute(s), M.bindBuffer(34962, p), M
												.vertexAttribPointer(s, l, d, h, g * f, v * f)
										} else c.isInstancedBufferAttribute ? (S.enableAttributeAndDivisor(s, c
												.meshPerAttribute), void 0 === i.maxInstancedCount && (i
												.maxInstancedCount = c.meshPerAttribute * c.count)) : S
											.enableAttribute(s), M.bindBuffer(34962, p), M.vertexAttribPointer(s,
												l, d, h, 0, 0)
									} else if (void 0 !== a) {
										var y = a[o];
										if (void 0 !== y) switch (y.length) {
											case 2:
												M.vertexAttrib2fv(s, y);
												break;
											case 3:
												M.vertexAttrib3fv(s, y);
												break;
											case 4:
												M.vertexAttrib4fv(s, y);
												break;
											default:
												M.vertexAttrib1fv(s, y)
										}
									}
								}
							}
							S.disableUnusedAttributes()
						}
					}
					this.shadowMap = at, this.getContext = function () {
						return M
					}, this.getContextAttributes = function () {
						return M.getContextAttributes()
					}, this.forceContextLoss = function () {
						var t = x.get("WEBGL_lose_context");
						t && t.loseContext()
					}, this.forceContextRestore = function () {
						var t = x.get("WEBGL_lose_context");
						t && t.restoreContext()
					}, this.getPixelRatio = function () {
						return W
					}, this.setPixelRatio = function (t) {
						void 0 !== t && (W = t, this.setSize(j, V, !1))
					}, this.getSize = function () {
						return {
							width: j,
							height: V
						}
					}, this.setSize = function (t, e, i) {
						rt.isPresenting() ? console.warn(
							"THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (
							j = t, V = e, n.width = t * W, n.height = e * W, !1 !== i && (n.style.width =
								t + "px", n.style.height = e + "px"), this.setViewport(0, 0, t, e))
					}, this.getDrawingBufferSize = function () {
						return {
							width: j * W,
							height: V * W
						}
					}, this.setDrawingBufferSize = function (t, e, i) {
						j = t, V = e, W = i, n.width = t * i, n.height = e * i, this.setViewport(0, 0, t, e)
					}, this.getCurrentViewport = function () {
						return G
					}, this.setViewport = function (t, e, i, n) {
						q.set(t, V - e - n, i, n), S.viewport(G.copy(q).multiplyScalar(W))
					}, this.setScissor = function (t, e, i, n) {
						X.set(t, V - e - n, i, n), S.scissor(F.copy(X).multiplyScalar(W))
					}, this.setScissorTest = function (t) {
						S.setScissorTest(Y = t)
					}, this.getClearColor = function () {
						return g.getClearColor()
					}, this.setClearColor = function () {
						g.setClearColor.apply(g, arguments)
					}, this.getClearAlpha = function () {
						return g.getClearAlpha()
					}, this.setClearAlpha = function () {
						g.setClearAlpha.apply(g, arguments)
					}, this.clear = function (t, e, i) {
						var n = 0;
						(void 0 === t || t) && (n |= 16384), (void 0 === e || e) && (n |= 256), (void 0 ===
							i || i) && (n |= 1024), M.clear(n)
					}, this.clearColor = function () {
						this.clear(!0, !1, !1)
					}, this.clearDepth = function () {
						this.clear(!1, !0, !1)
					}, this.clearStencil = function () {
						this.clear(!1, !1, !0)
					}, this.dispose = function () {
						n.removeEventListener("webglcontextlost", ot, !1), n.removeEventListener(
								"webglcontextrestored", st, !1), f.dispose(), m.dispose(), E.dispose(), d
							.dispose(), rt.dispose(), yt.stop()
					}, this.renderBufferImmediate = function (t, e) {
						S.initAttributes();
						var i = E.get(t);
						t.hasPositions && !i.position && (i.position = M.createBuffer()), t.hasNormals && !i
							.normal && (i.normal = M.createBuffer()), t.hasUvs && !i.uv && (i.uv = M
								.createBuffer()), t.hasColors && !i.color && (i.color = M.createBuffer());
						var n = e.getAttributes();
						t.hasPositions && (M.bindBuffer(34962, i.position), M.bufferData(34962, t
								.positionArray, 35048), S.enableAttribute(n.position), M
							.vertexAttribPointer(n.position, 3, 5126, !1, 0, 0)), t.hasNormals && (M
							.bindBuffer(34962, i.normal), M.bufferData(34962, t.normalArray, 35048), S
							.enableAttribute(n.normal), M.vertexAttribPointer(n.normal, 3, 5126, !1, 0, 0)
							), t.hasUvs && (M.bindBuffer(34962, i.uv), M.bufferData(34962, t.uvArray,
							35048), S.enableAttribute(n.uv), M.vertexAttribPointer(n.uv, 2, 5126, !1,
							0, 0)), t.hasColors && (M.bindBuffer(34962, i.color), M.bufferData(34962, t
							.colorArray, 35048), S.enableAttribute(n.color), M.vertexAttribPointer(n
							.color, 3, 5126, !1, 0, 0)), S.disableUnusedAttributes(), M.drawArrays(4, 0, t
							.count), t.count = 0
					}, this.renderBufferDirect = function (t, e, i, n, r, a) {
						var o = r.isMesh && r.normalMatrix.determinant() < 0;
						S.setMaterial(n, o);
						var s = Mt(t, e, n, r),
							c = !1;
						N.geometry === i.id && N.program === s.id && N.wireframe === (!0 === n.wireframe) || (
								N.geometry = i.id, N.program = s.id, N.wireframe = !0 === n.wireframe, c = !0
								), r.morphTargetInfluences && (L.update(r, i, n, s), c = !0);
						var h, l = i.index,
							u = i.attributes.position,
							p = 1;
						!0 === n.wireframe && (l = A.getWireframeAttribute(i), p = 2);
						var d = P;
						null !== l && (h = T.get(l), (d = C).setIndex(h)), c && (pt(n, s, i), null !== l && M
							.bindBuffer(34963, h.buffer));
						var f = 1 / 0;
						null !== l ? f = l.count : void 0 !== u && (f = u.count);
						var m = i.drawRange.start * p,
							g = i.drawRange.count * p,
							v = null !== a ? a.start * p : 0,
							y = null !== a ? a.count * p : 1 / 0,
							x = Math.max(m, v),
							b = Math.min(f, m + g, v + y) - 1,
							w = Math.max(0, b - x + 1);
						if (0 !== w) {
							if (r.isMesh)
								if (!0 === n.wireframe) S.setLineWidth(n.wireframeLinewidth * et()), d
									.setMode(1);
								else switch (r.drawMode) {
									case We:
										d.setMode(4);
										break;
									case qe:
										d.setMode(5);
										break;
									case Xe:
										d.setMode(6)
								} else if (r.isLine) {
									var _ = n.linewidth;
									void 0 === _ && (_ = 1), S.setLineWidth(_ * et()), r.isLineSegments ?
										d.setMode(1) : r.isLineLoop ? d.setMode(2) : d.setMode(3)
								} else r.isPoints ? d.setMode(0) : r.isSprite && d.setMode(4);
							i && i.isInstancedBufferGeometry ? 0 < i.maxInstancedCount && d.renderInstances(i,
								x, w) : d.render(x, w)
						}
					}, this.compile = function (i, t) {
						(w = m.get(i, t)).init(), i.traverse(function (t) {
							t.isLight && (w.pushLight(t), t.castShadow && w.pushShadow(t))
						}), w.setupLights(t), i.traverse(function (t) {
							if (t.material)
								if (Array.isArray(t.material))
									for (var e = 0; e < t.material.length; e++) _t(t.material[e], i
										.fog, t);
								else _t(t.material, i.fog, t)
						})
					};
					var dt = null;

					function ft(t) {
						rt.isPresenting() || dt && dt(t)
					}
					var mt, gt, vt, yt = new Ki;

					function xt(t, e, i) {
						if (!1 !== t.visible) {
							if (t.layers.test(e.layers))
								if (t.isLight) w.pushLight(t), t.castShadow && w.pushShadow(t);
								else if (t.isSprite) {
								if (!t.frustumCulled || J.intersectsSprite(t)) {
									i && tt.setFromMatrixPosition(t.matrixWorld).applyMatrix4($);
									var n = d.update(t),
										r = t.material;
									u.push(t, n, r, tt.z, null)
								}
							} else if (t.isImmediateRenderObject) i && tt.setFromMatrixPosition(t.matrixWorld)
								.applyMatrix4($), u.push(t, null, t.material, tt.z, null);
							else if ((t.isMesh || t.isLine || t.isPoints) && (t.isSkinnedMesh && t.skeleton
									.update(), !t.frustumCulled || J.intersectsObject(t))) {
								i && tt.setFromMatrixPosition(t.matrixWorld).applyMatrix4($);
								n = d.update(t), r = t.material;
								if (Array.isArray(r))
									for (var a = n.groups, o = 0, s = a.length; o < s; o++) {
										var c = a[o],
											h = r[c.materialIndex];
										h && h.visible && u.push(t, n, h, tt.z, c)
									} else r.visible && u.push(t, n, r, tt.z, null)
							}
							var l = t.children;
							for (o = 0, s = l.length; o < s; o++) xt(l[o], e, i)
						}
					}

					function bt(t, e, i, n) {
						for (var r = 0, a = t.length; r < a; r++) {
							var o = t[r],
								s = o.object,
								c = o.geometry,
								h = void 0 === n ? o.material : n,
								l = o.group;
							if (i.isArrayCamera)
								for (var u = (U = i).cameras, p = 0, d = u.length; p < d; p++) {
									var f = u[p];
									if (s.layers.test(f.layers)) {
										if ("viewport" in f) S.viewport(G.copy(f.viewport));
										else {
											var m = f.bounds,
												g = m.x * j,
												v = m.y * V,
												y = m.z * j,
												x = m.w * V;
											S.viewport(G.set(g, v, y, x).multiplyScalar(W))
										}
										w.setupLights(f), wt(s, e, f, c, h, l)
									}
								} else U = null, wt(s, e, i, c, h, l)
						}
					}

					function wt(t, e, i, n, r, a) {
						if (t.onBeforeRender(R, e, i, n, r, a), w = m.get(e, U || i), t.modelViewMatrix
							.multiplyMatrices(i.matrixWorldInverse, t.matrixWorld), t.normalMatrix
							.getNormalMatrix(t.modelViewMatrix), t.isImmediateRenderObject) {
							S.setMaterial(r);
							var o = Mt(i, e.fog, r, t);
							N.geometry = null, N.program = null, N.wireframe = !1, ut(t, o)
						} else R.renderBufferDirect(i, e.fog, n, r, t, a);
						t.onAfterRender(R, e, i, n, r, a), w = m.get(e, U || i)
					}

					function _t(t, e, i) {
						var n = E.get(t),
							r = w.state.lights,
							a = w.state.shadowsArray,
							o = n.lightsHash,
							s = r.state.hash,
							c = y.getParameters(t, r.state, a, e, Z.numPlanes, Z.numIntersection, i),
							h = y.getProgramCode(t, c),
							l = n.program,
							u = !0;
						if (void 0 === l) t.addEventListener("dispose", ct);
						else if (l.code !== h) lt(t);
						else if (o.stateID !== s.stateID || o.directionalLength !== s.directionalLength || o
							.pointLength !== s.pointLength || o.spotLength !== s.spotLength || o
							.rectAreaLength !== s.rectAreaLength || o.hemiLength !== s.hemiLength || o
							.shadowsLength !== s.shadowsLength) o.stateID = s.stateID, o.directionalLength = s
							.directionalLength, o.pointLength = s.pointLength, o.spotLength = s.spotLength, o
							.rectAreaLength = s.rectAreaLength, o.hemiLength = s.hemiLength, o.shadowsLength = s
							.shadowsLength, u = !1;
						else {
							if (void 0 !== c.shaderID) return;
							u = !1
						}
						if (u) {
							if (c.shaderID) {
								var p = Qi[c.shaderID];
								n.shader = {
									name: t.type,
									uniforms: Fi(p.uniforms),
									vertexShader: p.vertexShader,
									fragmentShader: p.fragmentShader
								}
							} else n.shader = {
								name: t.type,
								uniforms: t.uniforms,
								vertexShader: t.vertexShader,
								fragmentShader: t.fragmentShader
							};
							t.onBeforeCompile(n.shader, R), h = y.getProgramCode(t, c), l = y.acquireProgram(t, n
								.shader, c, h), n.program = l, t.program = l
						}
						var d = l.getAttributes();
						if (t.morphTargets)
							for (var f = t.numSupportedMorphTargets = 0; f < R.maxMorphTargets; f++) 0 <= d[
								"morphTarget" + f] && t.numSupportedMorphTargets++;
						if (t.morphNormals)
							for (f = t.numSupportedMorphNormals = 0; f < R.maxMorphNormals; f++) 0 <= d[
								"morphNormal" + f] && t.numSupportedMorphNormals++;
						var m = n.shader.uniforms;
						(t.isShaderMaterial || t.isRawShaderMaterial) && !0 !== t.clipping || (n
								.numClippingPlanes = Z.numPlanes, n.numIntersection = Z.numIntersection, m
								.clippingPlanes = Z.uniform), n.fog = e, void 0 === o && (n.lightsHash = o = {}),
							o.stateID = s.stateID, o.directionalLength = s.directionalLength, o.pointLength = s
							.pointLength, o.spotLength = s.spotLength, o.rectAreaLength = s.rectAreaLength, o
							.hemiLength = s.hemiLength, o.shadowsLength = s.shadowsLength, t.lights && (m
								.ambientLightColor.value = r.state.ambient, m.directionalLights.value = r.state
								.directional, m.spotLights.value = r.state.spot, m.rectAreaLights.value = r.state
								.rectArea, m.pointLights.value = r.state.point, m.hemisphereLights.value = r.state
								.hemi, m.directionalShadowMap.value = r.state.directionalShadowMap, m
								.directionalShadowMatrix.value = r.state.directionalShadowMatrix, m.spotShadowMap
								.value = r.state.spotShadowMap, m.spotShadowMatrix.value = r.state
								.spotShadowMatrix, m.pointShadowMap.value = r.state.pointShadowMap, m
								.pointShadowMatrix.value = r.state.pointShadowMatrix);
						var g = n.program.getUniforms(),
							v = ja.seqWithValue(g.seq, m);
						n.uniformsList = v
					}

					function Mt(t, e, i, n) {
						k = 0;
						var r = E.get(i),
							a = w.state.lights,
							o = r.lightsHash,
							s = a.state.hash;
						if (Q && (K || t !== z)) {
							var c = t === z && i.id === B;
							Z.setState(i.clippingPlanes, i.clipIntersection, i.clipShadows, t, r, c)
						}!1 === i.needsUpdate && (void 0 === r.program ? i.needsUpdate = !0 : i.fog && r.fog !==
							e ? i.needsUpdate = !0 : (!i.lights || o.stateID === s.stateID && o
								.directionalLength === s.directionalLength && o.pointLength === s
								.pointLength && o.spotLength === s.spotLength && o.rectAreaLength === s
								.rectAreaLength && o.hemiLength === s.hemiLength && o.shadowsLength === s
								.shadowsLength) && (void 0 === r.numClippingPlanes || r.numClippingPlanes ===
								Z.numPlanes && r.numIntersection === Z.numIntersection) || (i.needsUpdate = !
								0)), i.needsUpdate && (_t(i, e, n), i.needsUpdate = !1);
						var h = !1,
							l = !1,
							u = !1,
							p = r.program,
							d = p.getUniforms(),
							f = r.shader.uniforms;
						if (S.useProgram(p.program) && (u = l = h = !0), i.id !== B && (B = i.id, l = !0), h ||
							z !== t) {
							if (d.setValue(M, "projectionMatrix", t.projectionMatrix), _.logarithmicDepthBuffer &&
								d.setValue(M, "logDepthBufFC", 2 / (Math.log(t.far + 1) / Math.LN2)), z !== t && (
									z = t, u = l = !0), i.isShaderMaterial || i.isMeshPhongMaterial || i
								.isMeshStandardMaterial || i.envMap) {
								var m = d.map.cameraPosition;
								void 0 !== m && m.setValue(M, tt.setFromMatrixPosition(t.matrixWorld))
							}(i.isMeshPhongMaterial || i.isMeshLambertMaterial || i.isMeshBasicMaterial || i
								.isMeshStandardMaterial || i.isShaderMaterial || i.skinning) && d.setValue(M,
								"viewMatrix", t.matrixWorldInverse)
						}
						if (i.skinning) {
							d.setOptional(M, n, "bindMatrix"), d.setOptional(M, n, "bindMatrixInverse");
							var g = n.skeleton;
							if (g) {
								var v = g.bones;
								if (_.floatVertexTextures) {
									if (void 0 === g.boneTexture) {
										var y = Math.sqrt(4 * v.length);
										y = oi.ceilPowerOfTwo(y), y = Math.max(y, 4);
										var x = new Float32Array(y * y * 4);
										x.set(g.boneMatrices);
										var b = new Di(x, y, y, oe, Kt);
										b.needsUpdate = !0, g.boneMatrices = x, g.boneTexture = b, g
											.boneTextureSize = y
									}
									d.setValue(M, "boneTexture", g.boneTexture), d.setValue(M, "boneTextureSize",
										g.boneTextureSize)
								} else d.setOptional(M, g, "boneMatrices")
							}
						}
						return l && (d.setValue(M, "toneMappingExposure", R.toneMappingExposure), d.setValue(M,
									"toneMappingWhitePoint", R.toneMappingWhitePoint), i.lights && Gt(f, u), e &&
								i.fog && Pt(f, e), i.isMeshBasicMaterial ? St(f, i) : i.isMeshLambertMaterial ? (
									St(f, i), Ct(f, i)) : i.isMeshPhongMaterial ? (St(f, i), i
									.isMeshToonMaterial ? Ot(f, i) : Rt(f, i)) : i.isMeshStandardMaterial ? (St(f,
									i), i.isMeshPhysicalMaterial ? Dt(f, i) : It(f, i)) : i.isMeshMatcapMaterial ?
								(St(f, i), Bt(f, i)) : i.isMeshDepthMaterial ? (St(f, i), Nt(f, i)) : i
								.isMeshDistanceMaterial ? (St(f, i), zt(f, i)) : i.isMeshNormalMaterial ? (St(f,
									i), Ut(f, i)) : i.isLineBasicMaterial ? (Et(f, i), i.isLineDashedMaterial &&
									Tt(f, i)) : i.isPointsMaterial ? At(f, i) : i.isSpriteMaterial ? Lt(f, i) : i
								.isShadowMaterial && (f.color.value = i.color, f.opacity.value = i.opacity),
								void 0 !== f.ltc_1 && (f.ltc_1.value = Zi.LTC_1), void 0 !== f.ltc_2 && (f.ltc_2
									.value = Zi.LTC_2), ja.upload(M, r.uniformsList, f, R)), i.isShaderMaterial &&
							!0 === i.uniformsNeedUpdate && (ja.upload(M, r.uniformsList, f, R), i
								.uniformsNeedUpdate = !1), i.isSpriteMaterial && d.setValue(M, "center", n
							.center), d.setValue(M, "modelViewMatrix", n.modelViewMatrix), d.setValue(M,
								"normalMatrix", n.normalMatrix), d.setValue(M, "modelMatrix", n.matrixWorld), p
					}

					function St(t, e) {
						var i;
						t.opacity.value = e.opacity, e.color && (t.diffuse.value = e.color), e.emissive && t
							.emissive.value.copy(e.emissive).multiplyScalar(e.emissiveIntensity), e.map && (t.map
								.value = e.map), e.alphaMap && (t.alphaMap.value = e.alphaMap), e.specularMap && (
								t.specularMap.value = e.specularMap), e.envMap && (t.envMap.value = e.envMap, t
								.flipEnvMap.value = e.envMap.isCubeTexture ? -1 : 1, t.reflectivity.value = e
								.reflectivity, t.refractionRatio.value = e.refractionRatio, t.maxMipLevel.value =
								E.get(e.envMap).__maxMipLevel), e.lightMap && (t.lightMap.value = e.lightMap, t
								.lightMapIntensity.value = e.lightMapIntensity), e.aoMap && (t.aoMap.value = e
								.aoMap, t.aoMapIntensity.value = e.aoMapIntensity), e.map ? i = e.map : e
							.specularMap ? i = e.specularMap : e.displacementMap ? i = e.displacementMap : e
							.normalMap ? i = e.normalMap : e.bumpMap ? i = e.bumpMap : e.roughnessMap ? i = e
							.roughnessMap : e.metalnessMap ? i = e.metalnessMap : e.alphaMap ? i = e.alphaMap : e
							.emissiveMap && (i = e.emissiveMap), void 0 !== i && (i.isWebGLRenderTarget && (i = i
									.texture), !0 === i.matrixAutoUpdate && i.updateMatrix(), t.uvTransform.value
								.copy(i.matrix))
					}

					function Et(t, e) {
						t.diffuse.value = e.color, t.opacity.value = e.opacity
					}

					function Tt(t, e) {
						t.dashSize.value = e.dashSize, t.totalSize.value = e.dashSize + e.gapSize, t.scale.value =
							e.scale
					}

					function At(t, e) {
						t.diffuse.value = e.color, t.opacity.value = e.opacity, t.size.value = e.size * W, t.scale
							.value = .5 * V, t.map.value = e.map, null !== e.map && (!0 === e.map
								.matrixAutoUpdate && e.map.updateMatrix(), t.uvTransform.value.copy(e.map.matrix))
					}

					function Lt(t, e) {
						t.diffuse.value = e.color, t.opacity.value = e.opacity, t.rotation.value = e.rotation, t
							.map.value = e.map, null !== e.map && (!0 === e.map.matrixAutoUpdate && e.map
								.updateMatrix(), t.uvTransform.value.copy(e.map.matrix))
					}

					function Pt(t, e) {
						t.fogColor.value = e.color, e.isFog ? (t.fogNear.value = e.near, t.fogFar.value = e.far) :
							e.isFogExp2 && (t.fogDensity.value = e.density)
					}

					function Ct(t, e) {
						e.emissiveMap && (t.emissiveMap.value = e.emissiveMap)
					}

					function Rt(t, e) {
						t.specular.value = e.specular, t.shininess.value = Math.max(e.shininess, 1e-4), e
							.emissiveMap && (t.emissiveMap.value = e.emissiveMap), e.bumpMap && (t.bumpMap.value =
								e.bumpMap, t.bumpScale.value = e.bumpScale, e.side === kt && (t.bumpScale.value *=
									-1)), e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value
								.copy(e.normalScale), e.side === kt && t.normalScale.value.negate()), e
							.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale
								.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
					}

					function Ot(t, e) {
						Rt(t, e), e.gradientMap && (t.gradientMap.value = e.gradientMap)
					}

					function It(t, e) {
						t.roughness.value = e.roughness, t.metalness.value = e.metalness, e.roughnessMap && (t
								.roughnessMap.value = e.roughnessMap), e.metalnessMap && (t.metalnessMap.value = e
								.metalnessMap), e.emissiveMap && (t.emissiveMap.value = e.emissiveMap), e
							.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, e.side ===
								kt && (t.bumpScale.value *= -1)), e.normalMap && (t.normalMap.value = e.normalMap,
								t.normalScale.value.copy(e.normalScale), e.side === kt && t.normalScale.value
								.negate()), e.displacementMap && (t.displacementMap.value = e.displacementMap, t
								.displacementScale.value = e.displacementScale, t.displacementBias.value = e
								.displacementBias), e.envMap && (t.envMapIntensity.value = e.envMapIntensity)
					}

					function Dt(t, e) {
						It(t, e), t.reflectivity.value = e.reflectivity, t.clearCoat.value = e.clearCoat, t
							.clearCoatRoughness.value = e.clearCoatRoughness
					}

					function Bt(t, e) {
						e.matcap && (t.matcap.value = e.matcap), e.bumpMap && (t.bumpMap.value = e.bumpMap, t
								.bumpScale.value = e.bumpScale, e.side === kt && (t.bumpScale.value *= -1)), e
							.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e
								.normalScale), e.side === kt && t.normalScale.value.negate()), e
							.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale
								.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
					}

					function Nt(t, e) {
						e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale
							.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
					}

					function zt(t, e) {
						e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale
								.value = e.displacementScale, t.displacementBias.value = e.displacementBias), t
							.referencePosition.value.copy(e.referencePosition), t.nearDistance.value = e
							.nearDistance, t.farDistance.value = e.farDistance
					}

					function Ut(t, e) {
						e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, e.side ===
							kt && (t.bumpScale.value *= -1)), e.normalMap && (t.normalMap.value = e.normalMap,
							t.normalScale.value.copy(e.normalScale), e.side === kt && t.normalScale.value
							.negate()), e.displacementMap && (t.displacementMap.value = e.displacementMap, t
							.displacementScale.value = e.displacementScale, t.displacementBias.value = e
							.displacementBias)
					}

					function Gt(t, e) {
						t.ambientLightColor.needsUpdate = e, t.directionalLights.needsUpdate = e, t.pointLights
							.needsUpdate = e, t.spotLights.needsUpdate = e, t.rectAreaLights.needsUpdate = e, t
							.hemisphereLights.needsUpdate = e
					}

					function Ft() {
						var t = k;
						return t >= _.maxTextures && console.warn("THREE.WebGLRenderer: Trying to use " + t +
							" texture units while this GPU supports only " + _.maxTextures), k += 1, t
					}
					yt.setAnimationLoop(ft), "undefined" != typeof window && yt.setContext(window), this
						.setAnimationLoop = function (t) {
							dt = t, rt.setAnimationLoop(t), yt.start()
						}, this.render = function (t, e, i, n) {
							if (e && e.isCamera) {
								if (!b) {
									N.geometry = null, N.program = null, N.wireframe = !1, B = -1, !(z = null) ===
										t.autoUpdate && t.updateMatrixWorld(), null === e.parent && e
										.updateMatrixWorld(), rt.enabled && (e = rt.getCamera(e)), (w = m.get(t,
											e)).init(), t.onBeforeRender(R, t, e, i), $.multiplyMatrices(e
											.projectionMatrix, e.matrixWorldInverse), J.setFromMatrix($), K = this
										.localClippingEnabled, Q = Z.init(this.clippingPlanes, K, e), (u = f.get(
											t, e)).init(), xt(t, e, R.sortObjects), !0 === R.sortObjects && u
										.sort(), Q && Z.beginShadows();
									var r = w.state.shadowsArray;
									at.render(r, t, e), w.setupLights(e), Q && Z.endShadows(), this.info
										.autoReset && this.info.reset(), void 0 === i && (i = null), this
										.setRenderTarget(i), g.render(u, t, e, n);
									var a = u.opaque,
										o = u.transparent;
									if (t.overrideMaterial) {
										var s = t.overrideMaterial;
										a.length && bt(a, t, e, s), o.length && bt(o, t, e, s)
									} else a.length && bt(a, t, e), o.length && bt(o, t, e);
									i && p.updateRenderTargetMipmap(i), S.buffers.depth.setTest(!0), S.buffers
										.depth.setMask(!0), S.buffers.color.setMask(!0), S.setPolygonOffset(!1), t
										.onAfterRender(R, t, e), rt.enabled && rt.submitFrame(), w = u = null
								}
							} else console.error(
								"THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.")
						}, this.allocTextureUnit = Ft, this.setTexture2D = (mt = !1, function (t, e) {
							t && t.isWebGLRenderTarget && (mt || (console.warn(
								"THREE.WebGLRenderer.setTexture2D: don't use render targets as textures. Use their .texture property instead."
								), mt = !0), t = t.texture), p.setTexture2D(t, e)
						}), this.setTexture3D = function (t, e) {
							p.setTexture3D(t, e)
						}, this.setTexture = (gt = !1, function (t, e) {
							gt || (console.warn(
								"THREE.WebGLRenderer: .setTexture is deprecated, use setTexture2D instead."
								), gt = !0), p.setTexture2D(t, e)
						}), this.setTextureCube = (vt = !1, function (t, e) {
							t && t.isWebGLRenderTargetCube && (vt || (console.warn(
									"THREE.WebGLRenderer.setTextureCube: don't use cube render targets as textures. Use their .texture property instead."
									), vt = !0), t = t.texture), t && t.isCubeTexture || Array.isArray(t
									.image) && 6 === t.image.length ? p.setTextureCube(t, e) : p
								.setTextureCubeDynamic(t, e)
						}), this.setFramebuffer = function (t) {
							O = t
						}, this.getRenderTarget = function () {
							return I
						}, this.setRenderTarget = function (t) {
							(I = t) && void 0 === E.get(t).__webglFramebuffer && p.setupRenderTarget(t);
							var e = O,
								i = !1;
							if (t) {
								var n = E.get(t).__webglFramebuffer;
								t.isWebGLRenderTargetCube ? (e = n[t.activeCubeFace], i = !0) : e = n, G.copy(t
									.viewport), F.copy(t.scissor), H = t.scissorTest
							} else G.copy(q).multiplyScalar(W), F.copy(X).multiplyScalar(W), H = Y;
							if (D !== e && (M.bindFramebuffer(36160, e), D = e), S.viewport(G), S.scissor(F), S
								.setScissorTest(H), i) {
								var r = E.get(t.texture);
								M.framebufferTexture2D(36160, 36064, 34069 + t.activeCubeFace, r.__webglTexture, t
									.activeMipMapLevel)
							}
						}, this.readRenderTargetPixels = function (t, e, i, n, r, a) {
							if (t && t.isWebGLRenderTarget) {
								var o = E.get(t).__webglFramebuffer;
								if (o) {
									var s = !1;
									o !== D && (M.bindFramebuffer(36160, o), s = !0);
									try {
										var c = t.texture,
											h = c.format,
											l = c.type;
										if (h !== oe && v.convert(h) !== M.getParameter(35739))
										return void console.error(
												"THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format."
												);
										if (!(l === qt || v.convert(l) === M.getParameter(35738) || l === Kt && (_
												.isWebGL2 || x.get("OES_texture_float") || x.get(
													"WEBGL_color_buffer_float")) || l === $t && (_.isWebGL2 ?
												x.get("EXT_color_buffer_float") : x.get(
													"EXT_color_buffer_half_float")))) return void console.error(
											"THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type."
											);
										36053 === M.checkFramebufferStatus(36160) ? 0 <= e && e <= t.width - n &&
											0 <= i && i <= t.height - r && M.readPixels(e, i, n, r, v.convert(h),
												v.convert(l), a) : console.error(
												"THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete."
												)
									} finally {
										s && M.bindFramebuffer(36160, D)
									}
								}
							} else console.error(
								"THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget."
								)
						}, this.copyFramebufferToTexture = function (t, e, i) {
							var n = e.image.width,
								r = e.image.height,
								a = v.convert(e.format);
							this.setTexture2D(e, 0), M.copyTexImage2D(3553, i || 0, a, t.x, t.y, n, r, 0)
						}, this.copyTextureToTexture = function (t, e, i, n) {
							var r = e.image.width,
								a = e.image.height,
								o = v.convert(i.format),
								s = v.convert(i.type);
							this.setTexture2D(i, 0), e.isDataTexture ? M.texSubImage2D(3553, n || 0, t.x, t.y, r,
								a, o, s, e.image.data) : M.texSubImage2D(3553, n || 0, t.x, t.y, o, s, e
								.image)
						}
				}

				function Zo(t, e) {
					this.name = "", this.color = new Xi(t), this.density = void 0 !== e ? e : 25e-5
				}

				function Qo(t, e, i) {
					this.name = "", this.color = new Xi(t), this.near = void 0 !== e ? e : 1, this.far =
						void 0 !== i ? i : 1e3
				}

				function Ko() {
					Mn.call(this), this.type = "Scene", this.background = null, this.fog = null, this
						.overrideMaterial = null, this.autoUpdate = !0
				}

				function $o(t, e) {
					this.array = t, this.stride = e, this.count = void 0 !== t ? t.length / e : 0, this
						.dynamic = !1, this.updateRange = {
							offset: 0,
							count: -1
						}, this.version = 0
				}

				function ts(t, e, i, n) {
					this.data = t, this.itemSize = e, this.offset = i, this.normalized = !0 === n
				}

				function es(t) {
					Ir.call(this), this.type = "SpriteMaterial", this.color = new Xi(16777215), this.map = null,
						this.rotation = 0, this.sizeAttenuation = !0, this.lights = !1, this.transparent = !0,
						this.setValues(t)
				}

				function is(t) {
					if (Mn.call(this), this.type = "Sprite", void 0 === Lo) {
						Lo = new ir;
						var e = new $o(new Float32Array([-.5, -.5, 0, 0, 0, .5, -.5, 0, 1, 0, .5, .5, 0, 1, 1, -
							.5, .5, 0, 0, 1
						]), 5);
						Lo.setIndex([0, 1, 2, 0, 2, 3]), Lo.addAttribute("position", new ts(e, 3, 0, !1)), Lo
							.addAttribute("uv", new ts(e, 2, 3, !1))
					}
					this.geometry = Lo, this.material = void 0 !== t ? t : new es, this.center = new si(.5, .5)
				}

				function ns() {
					Mn.call(this), this.type = "LOD", Object.defineProperties(this, {
						levels: {
							enumerable: !0,
							value: []
						}
					})
				}

				function rs(t, e) {
					t && t.isGeometry && console.error(
							"THREE.SkinnedMesh no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
							), Ur.call(this, t, e), this.type = "SkinnedMesh", this.bindMode = "attached", this
						.bindMatrix = new ci, this.bindMatrixInverse = new ci
				}

				function as(t, e) {
					if (t = t || [], this.bones = t.slice(0), this.boneMatrices = new Float32Array(16 * this.bones
							.length), void 0 === e) this.calculateInverses();
					else if (this.bones.length === e.length) this.boneInverses = e.slice(0);
					else {
						console.warn("THREE.Skeleton boneInverses is the wrong length."), this.boneInverses = [];
						for (var i = 0, n = this.bones.length; i < n; i++) this.boneInverses.push(new ci)
					}
				}

				function os() {
					Mn.call(this), this.type = "Bone"
				}

				function ss(t) {
					Ir.call(this), this.type = "LineBasicMaterial", this.color = new Xi(16777215), this
						.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.lights = !1, this
						.setValues(t)
				}

				function cs(t, e, i) {
					1 === i && console.error(
							"THREE.Line: parameter THREE.LinePieces no longer supported. Use THREE.LineSegments instead."
							), Mn.call(this), this.type = "Line", this.geometry = void 0 !== t ? t : new ir, this
						.material = void 0 !== e ? e : new ss({
							color: 16777215 * Math.random()
						})
				}

				function hs(t, e) {
					cs.call(this, t, e), this.type = "LineSegments"
				}

				function ls(t, e) {
					cs.call(this, t, e), this.type = "LineLoop"
				}

				function us(t) {
					Ir.call(this), this.type = "PointsMaterial", this.color = new Xi(16777215), this.map = null,
						this.size = 1, this.sizeAttenuation = !0, this.morphTargets = !1, this.lights = !1, this
						.setValues(t)
				}

				function ps(t, e) {
					Mn.call(this), this.type = "Points", this.geometry = void 0 !== t ? t : new ir, this
						.material = void 0 !== e ? e : new us({
							color: 16777215 * Math.random()
						})
				}

				function ds(t, e, i, n, r, a, o, s, c) {
					Ci.call(this, t, e, i, n, r, a, o, s, c), this.format = void 0 !== o ? o : ae, this
						.minFilter = void 0 !== a ? a : Ft, this.magFilter = void 0 !== r ? r : Ft, this
						.generateMipmaps = !1
				}

				function fs(t, e, i, n, r, a, o, s, c, h, l, u) {
					Ci.call(this, null, a, o, s, c, h, n, r, l, u), this.image = {
						width: e,
						height: i
					}, this.mipmaps = t, this.flipY = !1, this.generateMipmaps = !1
				}

				function ms(t, e, i, n, r, a, o, s, c) {
					Ci.call(this, t, e, i, n, r, a, o, s, c), this.needsUpdate = !0
				}

				function gs(t, e, i, n, r, a, o, s, c, h) {
					if ((h = void 0 !== h ? h : le) !== le && h !== ue) throw new Error(
						"DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat"
						);
					void 0 === i && h === le && (i = Jt), void 0 === i && h === ue && (i = ne), Ci.call(this,
							null, n, r, a, o, s, h, i, c), this.image = {
							width: t,
							height: e
						}, this.magFilter = void 0 !== o ? o : zt, this.minFilter = void 0 !== s ? s : zt, this
						.flipY = !1, this.generateMipmaps = !1
				}

				function vs(t) {
					ir.call(this), this.type = "WireframeGeometry";
					var e, i, n, r, a, o, s, c, h, l, u = [],
						p = [0, 0],
						d = {},
						f = ["a", "b", "c"];
					if (t && t.isGeometry) {
						var m = t.faces;
						for (e = 0, n = m.length; e < n; e++) {
							var g = m[e];
							for (i = 0; i < 3; i++) s = g[f[i]], c = g[f[(i + 1) % 3]], p[0] = Math.min(s, c), p[
								1] = Math.max(s, c), void 0 === d[h = p[0] + "," + p[1]] && (d[h] = {
								index1: p[0],
								index2: p[1]
							})
						}
						for (h in d) o = d[h], l = t.vertices[o.index1], u.push(l.x, l.y, l.z), l = t.vertices[o
							.index2], u.push(l.x, l.y, l.z)
					} else if (t && t.isBufferGeometry) {
						var v, y, x, b, w, _;
						if (l = new li, null !== t.index) {
							for (v = t.attributes.position, y = t.index, 0 === (x = t.groups).length && (x = [{
									start: 0,
									count: y.count,
									materialIndex: 0
								}]), r = 0, a = x.length; r < a; ++r)
								for (n = (e = (b = x[r]).start) + b.count; e < n; e += 3)
									for (i = 0; i < 3; i++) s = y.getX(e + i), c = y.getX(e + (i + 1) % 3), p[0] =
										Math.min(s, c), p[1] = Math.max(s, c), void 0 === d[h = p[0] + "," + p[
										1]] && (d[h] = {
											index1: p[0],
											index2: p[1]
										});
							for (h in d) o = d[h], l.fromBufferAttribute(v, o.index1), u.push(l.x, l.y, l.z), l
								.fromBufferAttribute(v, o.index2), u.push(l.x, l.y, l.z)
						} else
							for (e = 0, n = (v = t.attributes.position).count / 3; e < n; e++)
								for (i = 0; i < 3; i++) w = 3 * e + i, l.fromBufferAttribute(v, w), u.push(l.x, l
									.y, l.z), _ = 3 * e + (i + 1) % 3, l.fromBufferAttribute(v, _), u.push(l
									.x, l.y, l.z)
					}
					this.addAttribute("position", new Hn(u, 3))
				}

				function ys(t, e, i) {
					On.call(this), this.type = "ParametricGeometry", this.parameters = {
						func: t,
						slices: e,
						stacks: i
					}, this.fromBufferGeometry(new xs(t, e, i)), this.mergeVertices()
				}

				function xs(t, e, i) {
					ir.call(this), this.type = "ParametricBufferGeometry", this.parameters = {
						func: t,
						slices: e,
						stacks: i
					};
					var n, r, a = [],
						o = [],
						s = [],
						c = [],
						h = 1e-5,
						l = new li,
						u = new li,
						p = new li,
						d = new li,
						f = new li;
					t.length < 3 && console.error(
						"THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.");
					var m = e + 1;
					for (n = 0; n <= i; n++) {
						var g = n / i;
						for (r = 0; r <= e; r++) {
							var v = r / e;
							t(v, g, u), o.push(u.x, u.y, u.z), 0 <= v - h ? (t(v - h, g, p), d.subVectors(u, p)) :
								(t(v + h, g, p), d.subVectors(p, u)), 0 <= g - h ? (t(v, g - h, p), f.subVectors(
									u, p)) : (t(v, g + h, p), f.subVectors(p, u)), l.crossVectors(d, f)
								.normalize(), s.push(l.x, l.y, l.z), c.push(v, g)
						}
					}
					for (n = 0; n < i; n++)
						for (r = 0; r < e; r++) {
							var y = n * m + r,
								x = n * m + r + 1,
								b = (n + 1) * m + r + 1,
								w = (n + 1) * m + r;
							a.push(y, x, w), a.push(x, b, w)
						}
					this.setIndex(a), this.addAttribute("position", new Hn(o, 3)), this.addAttribute("normal",
						new Hn(s, 3)), this.addAttribute("uv", new Hn(c, 2))
				}

				function bs(t, e, i, n) {
					On.call(this), this.type = "PolyhedronGeometry", this.parameters = {
						vertices: t,
						indices: e,
						radius: i,
						detail: n
					}, this.fromBufferGeometry(new ws(t, e, i, n)), this.mergeVertices()
				}

				function ws(n, a, t, e) {
					ir.call(this), this.type = "PolyhedronBufferGeometry", this.parameters = {
						vertices: n,
						indices: a,
						radius: t,
						detail: e
					}, t = t || 1;
					var l = [],
						u = [];

					function i(t) {
						for (var e = new li, i = new li, n = new li, r = 0; r < a.length; r += 3) h(a[r + 0], e),
							h(a[r + 1], i), h(a[r + 2], n), o(e, i, n, t)
					}

					function o(t, e, i, n) {
						var r, a, o = Math.pow(2, n),
							s = [];
						for (r = 0; r <= o; r++) {
							s[r] = [];
							var c = t.clone().lerp(i, r / o),
								h = e.clone().lerp(i, r / o),
								l = o - r;
							for (a = 0; a <= l; a++) s[r][a] = 0 === a && r === o ? c : c.clone().lerp(h, a / l)
						}
						for (r = 0; r < o; r++)
							for (a = 0; a < 2 * (o - r) - 1; a++) {
								var u = Math.floor(a / 2);
								a % 2 == 0 ? (p(s[r][u + 1]), p(s[r + 1][u]), p(s[r][u])) : (p(s[r][u + 1]), p(s[
									r + 1][u + 1]), p(s[r + 1][u]))
							}
					}

					function r(t) {
						for (var e = new li, i = 0; i < l.length; i += 3) e.x = l[i + 0], e.y = l[i + 1], e.z = l[
								i + 2], e.normalize().multiplyScalar(t), l[i + 0] = e.x, l[i + 1] = e.y, l[i +
							2] = e.z
					}

					function s() {
						for (var t = new li, e = 0; e < l.length; e += 3) {
							t.x = l[e + 0], t.y = l[e + 1], t.z = l[e + 2];
							var i = m(t) / 2 / Math.PI + .5,
								n = g(t) / Math.PI + .5;
							u.push(i, 1 - n)
						}
						d(), c()
					}

					function c() {
						for (var t = 0; t < u.length; t += 6) {
							var e = u[t + 0],
								i = u[t + 2],
								n = u[t + 4],
								r = Math.max(e, i, n),
								a = Math.min(e, i, n);
							.9 < r && a < .1 && (e < .2 && (u[t + 0] += 1), i < .2 && (u[t + 2] += 1), n < .2 && (
								u[t + 4] += 1))
						}
					}

					function p(t) {
						l.push(t.x, t.y, t.z)
					}

					function h(t, e) {
						var i = 3 * t;
						e.x = n[i + 0], e.y = n[i + 1], e.z = n[i + 2]
					}

					function d() {
						for (var t = new li, e = new li, i = new li, n = new li, r = new si, a = new si, o =
								new si, s = 0, c = 0; s < l.length; s += 9, c += 6) {
							t.set(l[s + 0], l[s + 1], l[s + 2]), e.set(l[s + 3], l[s + 4], l[s + 5]), i.set(l[s +
									6], l[s + 7], l[s + 8]), r.set(u[c + 0], u[c + 1]), a.set(u[c + 2], u[c + 3]),
								o.set(u[c + 4], u[c + 5]), n.copy(t).add(e).add(i).divideScalar(3);
							var h = m(n);
							f(r, c + 0, t, h), f(a, c + 2, e, h), f(o, c + 4, i, h)
						}
					}

					function f(t, e, i, n) {
						n < 0 && 1 === t.x && (u[e] = t.x - 1), 0 === i.x && 0 === i.z && (u[e] = n / 2 / Math
							.PI + .5)
					}

					function m(t) {
						return Math.atan2(t.z, -t.x)
					}

					function g(t) {
						return Math.atan2(-t.y, Math.sqrt(t.x * t.x + t.z * t.z))
					}
					i(e = e || 0), r(t), s(), this.addAttribute("position", new Hn(l, 3)), this.addAttribute(
							"normal", new Hn(l.slice(), 3)), this.addAttribute("uv", new Hn(u, 2)), 0 === e ? this
						.computeVertexNormals() : this.normalizeNormals()
				}

				function _s(t, e) {
					On.call(this), this.type = "TetrahedronGeometry", this.parameters = {
						radius: t,
						detail: e
					}, this.fromBufferGeometry(new Ms(t, e)), this.mergeVertices()
				}

				function Ms(t, e) {
					var i = [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1],
						n = [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1];
					ws.call(this, i, n, t, e), this.type = "TetrahedronBufferGeometry", this.parameters = {
						radius: t,
						detail: e
					}
				}

				function Ss(t, e) {
					On.call(this), this.type = "OctahedronGeometry", this.parameters = {
						radius: t,
						detail: e
					}, this.fromBufferGeometry(new Es(t, e)), this.mergeVertices()
				}

				function Es(t, e) {
					var i = [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1],
						n = [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2];
					ws.call(this, i, n, t, e), this.type = "OctahedronBufferGeometry", this.parameters = {
						radius: t,
						detail: e
					}
				}

				function Ts(t, e) {
					On.call(this), this.type = "IcosahedronGeometry", this.parameters = {
						radius: t,
						detail: e
					}, this.fromBufferGeometry(new As(t, e)), this.mergeVertices()
				}

				function As(t, e) {
					var i = (1 + Math.sqrt(5)) / 2,
						n = [-1, i, 0, 1, i, 0, -1, -i, 0, 1, -i, 0, 0, -1, i, 0, 1, i, 0, -1, -i, 0, 1, -i, i, 0,
							-1, i, 0, 1, -i, 0, -1, -i, 0, 1
						],
						r = [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7,
							6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10,
							8, 6, 7, 9, 8, 1
						];
					ws.call(this, n, r, t, e), this.type = "IcosahedronBufferGeometry", this.parameters = {
						radius: t,
						detail: e
					}
				}

				function Ls(t, e) {
					On.call(this), this.type = "DodecahedronGeometry", this.parameters = {
						radius: t,
						detail: e
					}, this.fromBufferGeometry(new Ps(t, e)), this.mergeVertices()
				}

				function Ps(t, e) {
					var i = (1 + Math.sqrt(5)) / 2,
						n = 1 / i,
						r = [-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1,
							0, -n, -i, 0, -n, i, 0, n, -i, 0, n, i, -n, -i, 0, -n, i, 0, n, -i, 0, n, i, 0, -i, 0,
							-n, i, 0, -n, -i, 0, n, i, 0, n
						],
						a = [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10,
							17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6,
							2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4,
							14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19,
							4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9
						];
					ws.call(this, r, a, t, e), this.type = "DodecahedronBufferGeometry", this.parameters = {
						radius: t,
						detail: e
					}
				}

				function Cs(t, e, i, n, r, a) {
					On.call(this), this.type = "TubeGeometry", this.parameters = {
						path: t,
						tubularSegments: e,
						radius: i,
						radialSegments: n,
						closed: r
					}, void 0 !== a && console.warn("THREE.TubeGeometry: taper has been removed.");
					var o = new Rs(t, e, i, n, r);
					this.tangents = o.tangents, this.normals = o.normals, this.binormals = o.binormals, this
						.fromBufferGeometry(o), this.mergeVertices()
				}

				function Rs(o, s, c, h, t) {
					ir.call(this), this.type = "TubeBufferGeometry", this.parameters = {
						path: o,
						tubularSegments: s,
						radius: c,
						radialSegments: h,
						closed: t
					}, s = s || 64, c = c || 1, h = h || 8, t = t || !1;
					var l = o.computeFrenetFrames(s, t);
					this.tangents = l.tangents, this.normals = l.normals, this.binormals = l.binormals;
					var r, u, p = new li,
						d = new li,
						e = new si,
						f = new li,
						m = [],
						g = [],
						i = [],
						a = [];

					function n() {
						for (r = 0; r < s; r++) v(r);
						v(!1 === t ? s : 0), x(), y()
					}

					function v(t) {
						f = o.getPointAt(t / s, f);
						var e = l.normals[t],
							i = l.binormals[t];
						for (u = 0; u <= h; u++) {
							var n = u / h * Math.PI * 2,
								r = Math.sin(n),
								a = -Math.cos(n);
							d.x = a * e.x + r * i.x, d.y = a * e.y + r * i.y, d.z = a * e.z + r * i.z, d
								.normalize(), g.push(d.x, d.y, d.z), p.x = f.x + c * d.x, p.y = f.y + c * d.y, p
								.z = f.z + c * d.z, m.push(p.x, p.y, p.z)
						}
					}

					function y() {
						for (u = 1; u <= s; u++)
							for (r = 1; r <= h; r++) {
								var t = (h + 1) * (u - 1) + (r - 1),
									e = (h + 1) * u + (r - 1),
									i = (h + 1) * u + r,
									n = (h + 1) * (u - 1) + r;
								a.push(t, e, n), a.push(e, i, n)
							}
					}

					function x() {
						for (r = 0; r <= s; r++)
							for (u = 0; u <= h; u++) e.x = r / s, e.y = u / h, i.push(e.x, e.y)
					}
					n(), this.setIndex(a), this.addAttribute("position", new Hn(m, 3)), this.addAttribute(
						"normal", new Hn(g, 3)), this.addAttribute("uv", new Hn(i, 2))
				}

				function Os(t, e, i, n, r, a, o) {
					On.call(this), this.type = "TorusKnotGeometry", this.parameters = {
						radius: t,
						tube: e,
						tubularSegments: i,
						radialSegments: n,
						p: r,
						q: a
					}, void 0 !== o && console.warn(
						"THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead."
						), this.fromBufferGeometry(new Is(t, e, i, n, r, a)), this.mergeVertices()
				}

				function Is(t, e, i, n, r, a) {
					ir.call(this), this.type = "TorusKnotBufferGeometry", this.parameters = {
							radius: t,
							tube: e,
							tubularSegments: i,
							radialSegments: n,
							p: r,
							q: a
						}, t = t || 1, e = e || .4, i = Math.floor(i) || 64, n = Math.floor(n) || 8, r = r || 2,
						a = a || 3;
					var o, s, c = [],
						h = [],
						l = [],
						u = [],
						p = new li,
						d = new li,
						f = new li,
						m = new li,
						g = new li,
						v = new li,
						y = new li;
					for (o = 0; o <= i; ++o) {
						var x = o / i * r * Math.PI * 2;
						for (A(x, r, a, t, f), A(x + .01, r, a, t, m), v.subVectors(m, f), y.addVectors(m, f), g
							.crossVectors(v, y), y.crossVectors(g, v), g.normalize(), y.normalize(), s = 0; s <=
							n; ++s) {
							var b = s / n * Math.PI * 2,
								w = -e * Math.cos(b),
								_ = e * Math.sin(b);
							p.x = f.x + (w * y.x + _ * g.x), p.y = f.y + (w * y.y + _ * g.y), p.z = f.z + (w * y
								.z + _ * g.z), h.push(p.x, p.y, p.z), d.subVectors(p, f).normalize(), l.push(d
								.x, d.y, d.z), u.push(o / i), u.push(s / n)
						}
					}
					for (s = 1; s <= i; s++)
						for (o = 1; o <= n; o++) {
							var M = (n + 1) * (s - 1) + (o - 1),
								S = (n + 1) * s + (o - 1),
								E = (n + 1) * s + o,
								T = (n + 1) * (s - 1) + o;
							c.push(M, S, T), c.push(S, E, T)
						}

					function A(t, e, i, n, r) {
						var a = Math.cos(t),
							o = Math.sin(t),
							s = i / e * t,
							c = Math.cos(s);
						r.x = n * (2 + c) * .5 * a, r.y = n * (2 + c) * o * .5, r.z = n * Math.sin(s) * .5
					}
					this.setIndex(c), this.addAttribute("position", new Hn(h, 3)), this.addAttribute("normal",
						new Hn(l, 3)), this.addAttribute("uv", new Hn(u, 2))
				}

				function Ds(t, e, i, n, r) {
					On.call(this), this.type = "TorusGeometry", this.parameters = {
						radius: t,
						tube: e,
						radialSegments: i,
						tubularSegments: n,
						arc: r
					}, this.fromBufferGeometry(new Bs(t, e, i, n, r)), this.mergeVertices()
				}

				function Bs(t, e, i, n, r) {
					ir.call(this), this.type = "TorusBufferGeometry", this.parameters = {
							radius: t,
							tube: e,
							radialSegments: i,
							tubularSegments: n,
							arc: r
						}, t = t || 1, e = e || .4, i = Math.floor(i) || 8, n = Math.floor(n) || 6, r = r || 2 *
						Math.PI;
					var a, o, s = [],
						c = [],
						h = [],
						l = [],
						u = new li,
						p = new li,
						d = new li;
					for (a = 0; a <= i; a++)
						for (o = 0; o <= n; o++) {
							var f = o / n * r,
								m = a / i * Math.PI * 2;
							p.x = (t + e * Math.cos(m)) * Math.cos(f), p.y = (t + e * Math.cos(m)) * Math.sin(f),
								p.z = e * Math.sin(m), c.push(p.x, p.y, p.z), u.x = t * Math.cos(f), u.y = t *
								Math.sin(f), d.subVectors(p, u).normalize(), h.push(d.x, d.y, d.z), l.push(o / n),
								l.push(a / i)
						}
					for (a = 1; a <= i; a++)
						for (o = 1; o <= n; o++) {
							var g = (n + 1) * a + o - 1,
								v = (n + 1) * (a - 1) + o - 1,
								y = (n + 1) * (a - 1) + o,
								x = (n + 1) * a + o;
							s.push(g, v, x), s.push(v, y, x)
						}
					this.setIndex(s), this.addAttribute("position", new Hn(c, 3)), this.addAttribute("normal",
						new Hn(h, 3)), this.addAttribute("uv", new Hn(l, 2))
				}
				Zo.prototype.isFogExp2 = !0, Zo.prototype.clone = function () {
						return new Zo(this.color, this.density)
					}, Zo.prototype.toJSON = function () {
						return {
							type: "FogExp2",
							color: this.color.getHex(),
							density: this.density
						}
					}, Qo.prototype.isFog = !0, Qo.prototype.clone = function () {
						return new Qo(this.color, this.near, this.far)
					}, Qo.prototype.toJSON = function () {
						return {
							type: "Fog",
							color: this.color.getHex(),
							near: this.near,
							far: this.far
						}
					}, Ko.prototype = Object.assign(Object.create(Mn.prototype), {
						constructor: Ko,
						copy: function (t, e) {
							return Mn.prototype.copy.call(this, t, e), null !== t.background && (this
									.background = t.background.clone()), null !== t.fog && (this.fog = t
									.fog.clone()), null !== t.overrideMaterial && (this.overrideMaterial =
									t.overrideMaterial.clone()), this.autoUpdate = t.autoUpdate, this
								.matrixAutoUpdate = t.matrixAutoUpdate, this
						},
						toJSON: function (t) {
							var e = Mn.prototype.toJSON.call(this, t);
							return null !== this.background && (e.object.background = this.background
									.toJSON(t)), null !== this.fog && (e.object.fog = this.fog.toJSON()),
								e
						}
					}), Object.defineProperty($o.prototype, "needsUpdate", {
						set: function (t) {
							!0 === t && this.version++
						}
					}), Object.assign($o.prototype, {
						isInterleavedBuffer: !0,
						onUploadCallback: function () {},
						setArray: function (t) {
							if (Array.isArray(t)) throw new TypeError(
								"THREE.BufferAttribute: array should be a Typed Array.");
							return this.count = void 0 !== t ? t.length / this.stride : 0, this.array = t,
								this
						},
						setDynamic: function (t) {
							return this.dynamic = t, this
						},
						copy: function (t) {
							return this.array = new t.array.constructor(t.array), this.count = t.count,
								this.stride = t.stride, this.dynamic = t.dynamic, this
						},
						copyAt: function (t, e, i) {
							t *= this.stride, i *= e.stride;
							for (var n = 0, r = this.stride; n < r; n++) this.array[t + n] = e.array[i +
								n];
							return this
						},
						set: function (t, e) {
							return void 0 === e && (e = 0), this.array.set(t, e), this
						},
						clone: function () {
							return (new this.constructor).copy(this)
						},
						onUpload: function (t) {
							return this.onUploadCallback = t, this
						}
					}), Object.defineProperties(ts.prototype, {
						count: {
							get: function () {
								return this.data.count
							}
						},
						array: {
							get: function () {
								return this.data.array
							}
						}
					}), Object.assign(ts.prototype, {
						isInterleavedBufferAttribute: !0,
						setX: function (t, e) {
							return this.data.array[t * this.data.stride + this.offset] = e, this
						},
						setY: function (t, e) {
							return this.data.array[t * this.data.stride + this.offset + 1] = e, this
						},
						setZ: function (t, e) {
							return this.data.array[t * this.data.stride + this.offset + 2] = e, this
						},
						setW: function (t, e) {
							return this.data.array[t * this.data.stride + this.offset + 3] = e, this
						},
						getX: function (t) {
							return this.data.array[t * this.data.stride + this.offset]
						},
						getY: function (t) {
							return this.data.array[t * this.data.stride + this.offset + 1]
						},
						getZ: function (t) {
							return this.data.array[t * this.data.stride + this.offset + 2]
						},
						getW: function (t) {
							return this.data.array[t * this.data.stride + this.offset + 3]
						},
						setXY: function (t, e, i) {
							return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e,
								this.data.array[t + 1] = i, this
						},
						setXYZ: function (t, e, i, n) {
							return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e,
								this.data.array[t + 1] = i, this.data.array[t + 2] = n, this
						},
						setXYZW: function (t, e, i, n, r) {
							return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e,
								this.data.array[t + 1] = i, this.data.array[t + 2] = n, this.data.array[
									t + 3] = r, this
						}
					}), es.prototype = Object.create(Ir.prototype), (es.prototype.constructor = es).prototype
					.isSpriteMaterial = !0, es.prototype.copy = function (t) {
						return Ir.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this
							.rotation = t.rotation, this.sizeAttenuation = t.sizeAttenuation, this
					}, is.prototype = Object.assign(Object.create(Mn.prototype), {
						constructor: is,
						isSprite: !0,
						raycast: function () {
							var c = new li,
								h = new li,
								l = new li,
								o = new si,
								s = new si,
								u = new ci,
								p = new li,
								d = new li,
								f = new li,
								m = new si,
								g = new si,
								v = new si;

							function y(t, e, i, n, r, a) {
								o.subVectors(t, i).addScalar(.5).multiply(n), void 0 !== r ? (s.x = a * o
										.x - r * o.y, s.y = r * o.x + a * o.y) : s.copy(o), t.copy(e), t
									.x += s.x, t.y += s.y, t.applyMatrix4(u)
							}
							return function (t, e) {
								h.setFromMatrixScale(this.matrixWorld), u.getInverse(this
										.modelViewMatrix).premultiply(this.matrixWorld), l
									.setFromMatrixPosition(this.modelViewMatrix);
								var i, n, r = this.material.rotation;
								0 !== r && (n = Math.cos(r), i = Math.sin(r));
								var a = this.center;
								y(p.set(-.5, -.5, 0), l, a, h, i, n), y(d.set(.5, -.5, 0), l, a, h, i,
									n), y(f.set(.5, .5, 0), l, a, h, i, n), m.set(0, 0), g.set(1,
									0), v.set(1, 1);
								var o = t.ray.intersectTriangle(p, d, f, !1, c);
								if (null !== o || (y(d.set(-.5, .5, 0), l, a, h, i, n), g.set(0, 1),
										null !== (o = t.ray.intersectTriangle(p, f, d, !1, c)))) {
									var s = t.ray.origin.distanceTo(c);
									s < t.near || s > t.far || e.push({
										distance: s,
										point: c.clone(),
										uv: Nr.getUV(c, p, d, f, m, g, v, new si),
										face: null,
										object: this
									})
								}
							}
						}(),
						clone: function () {
							return new this.constructor(this.material).copy(this)
						},
						copy: function (t) {
							return Mn.prototype.copy.call(this, t), void 0 !== t.center && this.center
								.copy(t.center), this
						}
					}), ns.prototype = Object.assign(Object.create(Mn.prototype), {
						constructor: ns,
						copy: function (t) {
							Mn.prototype.copy.call(this, t, !1);
							for (var e = t.levels, i = 0, n = e.length; i < n; i++) {
								var r = e[i];
								this.addLevel(r.object.clone(), r.distance)
							}
							return this
						},
						addLevel: function (t, e) {
							void 0 === e && (e = 0), e = Math.abs(e);
							for (var i = this.levels, n = 0; n < i.length && !(e < i[n].distance); n++);
							i.splice(n, 0, {
								distance: e,
								object: t
							}), this.add(t)
						},
						getObjectForDistance: function (t) {
							for (var e = this.levels, i = 1, n = e.length; i < n && !(t < e[i]
								.distance); i++);
							return e[i - 1].object
						},
						raycast: (Ro = new li, function (t, e) {
							Ro.setFromMatrixPosition(this.matrixWorld);
							var i = t.ray.origin.distanceTo(Ro);
							this.getObjectForDistance(i).raycast(t, e)
						}),
						update: (Po = new li, Co = new li, function (t) {
							var e = this.levels;
							if (1 < e.length) {
								Po.setFromMatrixPosition(t.matrixWorld), Co.setFromMatrixPosition(this
									.matrixWorld);
								var i = Po.distanceTo(Co);
								e[0].object.visible = !0;
								for (var n = 1, r = e.length; n < r && i >= e[n].distance; n++) e[n -
									1].object.visible = !1, e[n].object.visible = !0;
								for (; n < r; n++) e[n].object.visible = !1
							}
						}),
						toJSON: function (t) {
							var e = Mn.prototype.toJSON.call(this, t);
							e.object.levels = [];
							for (var i = this.levels, n = 0, r = i.length; n < r; n++) {
								var a = i[n];
								e.object.levels.push({
									object: a.object.uuid,
									distance: a.distance
								})
							}
							return e
						}
					}), rs.prototype = Object.assign(Object.create(Ur.prototype), {
						constructor: rs,
						isSkinnedMesh: !0,
						bind: function (t, e) {
							this.skeleton = t, void 0 === e && (this.updateMatrixWorld(!0), this.skeleton
									.calculateInverses(), e = this.matrixWorld), this.bindMatrix.copy(e),
								this.bindMatrixInverse.getInverse(e)
						},
						pose: function () {
							this.skeleton.pose()
						},
						normalizeSkinWeights: function () {
							for (var t = new Ri, e = this.geometry.attributes.skinWeight, i = 0, n = e
									.count; i < n; i++) {
								t.x = e.getX(i), t.y = e.getY(i), t.z = e.getZ(i), t.w = e.getW(i);
								var r = 1 / t.manhattanLength();
								r !== 1 / 0 ? t.multiplyScalar(r) : t.set(1, 0, 0, 0), e.setXYZW(i, t.x, t
									.y, t.z, t.w)
							}
						},
						updateMatrixWorld: function (t) {
							Ur.prototype.updateMatrixWorld.call(this, t), "attached" === this.bindMode ?
								this.bindMatrixInverse.getInverse(this.matrixWorld) : "detached" === this
								.bindMode ? this.bindMatrixInverse.getInverse(this.bindMatrix) : console
								.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode)
						},
						clone: function () {
							return new this.constructor(this.geometry, this.material).copy(this)
						}
					}), Object.assign(as.prototype, {
						calculateInverses: function () {
							this.boneInverses = [];
							for (var t = 0, e = this.bones.length; t < e; t++) {
								var i = new ci;
								this.bones[t] && i.getInverse(this.bones[t].matrixWorld), this
									.boneInverses.push(i)
							}
						},
						pose: function () {
							var t, e, i;
							for (e = 0, i = this.bones.length; e < i; e++)(t = this.bones[e]) && t
								.matrixWorld.getInverse(this.boneInverses[e]);
							for (e = 0, i = this.bones.length; e < i; e++)(t = this.bones[e]) && (t
								.parent && t.parent.isBone ? (t.matrix.getInverse(t.parent
									.matrixWorld), t.matrix.multiply(t.matrixWorld)) : t.matrix.copy(t
									.matrixWorld), t.matrix.decompose(t.position, t.quaternion, t
									.scale))
						},
						update: (Oo = new ci, Io = new ci, function () {
							for (var t = this.bones, e = this.boneInverses, i = this.boneMatrices, n =
									this.boneTexture, r = 0, a = t.length; r < a; r++) {
								var o = t[r] ? t[r].matrixWorld : Io;
								Oo.multiplyMatrices(o, e[r]), Oo.toArray(i, 16 * r)
							}
							void 0 !== n && (n.needsUpdate = !0)
						}),
						clone: function () {
							return new as(this.bones, this.boneInverses)
						},
						getBoneByName: function (t) {
							for (var e = 0, i = this.bones.length; e < i; e++) {
								var n = this.bones[e];
								if (n.name === t) return n
							}
						}
					}), os.prototype = Object.assign(Object.create(Mn.prototype), {
						constructor: os,
						isBone: !0
					}), ss.prototype = Object.create(Ir.prototype), (ss.prototype.constructor = ss).prototype
					.isLineBasicMaterial = !0, ss.prototype.copy = function (t) {
						return Ir.prototype.copy.call(this, t), this.color.copy(t.color), this.linewidth = t
							.linewidth, this.linecap = t.linecap, this.linejoin = t.linejoin, this
					}, cs.prototype = Object.assign(Object.create(Mn.prototype), {
						constructor: cs,
						isLine: !0,
						computeLineDistances: (zo = new li, Uo = new li, function () {
							var t = this.geometry;
							if (t.isBufferGeometry)
								if (null === t.index) {
									for (var e = t.attributes.position, i = [0], n = 1, r = e
										.count; n < r; n++) zo.fromBufferAttribute(e, n - 1), Uo
										.fromBufferAttribute(e, n), i[n] = i[n - 1], i[n] += zo
										.distanceTo(Uo);
									t.addAttribute("lineDistance", new Hn(i, 1))
								} else console.warn(
									"THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
									);
							else if (t.isGeometry) {
								var a = t.vertices;
								for ((i = t.lineDistances)[0] = 0, n = 1, r = a.length; n < r; n++) i[
									n] = i[n - 1], i[n] += a[n - 1].distanceTo(a[n])
							}
							return this
						}),
						raycast: (Do = new ci, Bo = new Br, No = new Ni, function (t, e) {
							var i = t.linePrecision,
								n = this.geometry,
								r = this.matrixWorld;
							if (null === n.boundingSphere && n.computeBoundingSphere(), No.copy(n
									.boundingSphere), No.applyMatrix4(r), No.radius += i, !1 !== t.ray
								.intersectsSphere(No)) {
								Do.getInverse(r), Bo.copy(t.ray).applyMatrix4(Do);
								var a = i / ((this.scale.x + this.scale.y + this.scale.z) / 3),
									o = a * a,
									s = new li,
									c = new li,
									h = new li,
									l = new li,
									u = this && this.isLineSegments ? 2 : 1;
								if (n.isBufferGeometry) {
									var p = n.index,
										d = n.attributes.position.array;
									if (null !== p)
										for (var f = p.array, m = 0, g = f.length - 1; m < g; m +=
											u) {
											var v = f[m],
												y = f[m + 1];
											s.fromArray(d, 3 * v), c.fromArray(d, 3 * y), o < Bo
												.distanceSqToSegment(s, c, l, h) || (l.applyMatrix4(
														this.matrixWorld), (w = t.ray.origin
														.distanceTo(l)) < t.near || w > t.far || e
													.push({
														distance: w,
														point: h.clone().applyMatrix4(this
															.matrixWorld),
														index: m,
														face: null,
														faceIndex: null,
														object: this
													}))
										} else
											for (m = 0, g = d.length / 3 - 1; m < g; m += u) s
												.fromArray(d, 3 * m), c.fromArray(d, 3 * m + 3), o <
												Bo.distanceSqToSegment(s, c, l, h) || (l.applyMatrix4(
														this.matrixWorld), (w = t.ray.origin
														.distanceTo(l)) < t.near || w > t.far || e
													.push({
														distance: w,
														point: h.clone().applyMatrix4(this
															.matrixWorld),
														index: m,
														face: null,
														faceIndex: null,
														object: this
													}))
								} else if (n.isGeometry) {
									var x = n.vertices,
										b = x.length;
									for (m = 0; m < b - 1; m += u) {
										var w;
										o < Bo.distanceSqToSegment(x[m], x[m + 1], l, h) || (l
											.applyMatrix4(this.matrixWorld), (w = t.ray.origin
												.distanceTo(l)) < t.near || w > t.far || e.push({
												distance: w,
												point: h.clone().applyMatrix4(this
													.matrixWorld),
												index: m,
												face: null,
												faceIndex: null,
												object: this
											}))
									}
								}
							}
						}),
						copy: function (t) {
							return Mn.prototype.copy.call(this, t), this.geometry.copy(t.geometry), this
								.material.copy(t.material), this
						},
						clone: function () {
							return (new this.constructor).copy(this)
						}
					}), hs.prototype = Object.assign(Object.create(cs.prototype), {
						constructor: hs,
						isLineSegments: !0,
						computeLineDistances: (Go = new li, Fo = new li, function () {
							var t = this.geometry;
							if (t.isBufferGeometry)
								if (null === t.index) {
									for (var e = t.attributes.position, i = [], n = 0, r = e
										.count; n < r; n += 2) Go.fromBufferAttribute(e, n), Fo
										.fromBufferAttribute(e, n + 1), i[n] = 0 === n ? 0 : i[n - 1],
										i[n + 1] = i[n] + Go.distanceTo(Fo);
									t.addAttribute("lineDistance", new Hn(i, 1))
								} else console.warn(
									"THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
									);
							else if (t.isGeometry) {
								var a = t.vertices;
								for (i = t.lineDistances, n = 0, r = a.length; n < r; n += 2) Go.copy(
									a[n]), Fo.copy(a[n + 1]), i[n] = 0 === n ? 0 : i[n - 1], i[n +
									1] = i[n] + Go.distanceTo(Fo)
							}
							return this
						})
					}), ls.prototype = Object.assign(Object.create(cs.prototype), {
						constructor: ls,
						isLineLoop: !0
					}), us.prototype = Object.create(Ir.prototype), (us.prototype.constructor = us).prototype
					.isPointsMaterial = !0, us.prototype.copy = function (t) {
						return Ir.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this
							.size = t.size, this.sizeAttenuation = t.sizeAttenuation, this.morphTargets = t
							.morphTargets, this
					}, ps.prototype = Object.assign(Object.create(Mn.prototype), {
						constructor: ps,
						isPoints: !0,
						raycast: (Ho = new ci, ko = new Br, jo = new Ni, function (r, a) {
							var o = this,
								t = this.geometry,
								s = this.matrixWorld,
								e = r.params.Points.threshold;
							if (null === t.boundingSphere && t.computeBoundingSphere(), jo.copy(t
									.boundingSphere), jo.applyMatrix4(s), jo.radius += e, !1 !== r.ray
								.intersectsSphere(jo)) {
								Ho.getInverse(s), ko.copy(r.ray).applyMatrix4(Ho);
								var i = e / ((this.scale.x + this.scale.y + this.scale.z) / 3),
									c = i * i,
									n = new li,
									h = new li;
								if (t.isBufferGeometry) {
									var l = t.index,
										u = t.attributes.position.array;
									if (null !== l)
										for (var p = l.array, d = 0, f = p.length; d < f; d++) {
											var m = p[d];
											n.fromArray(u, 3 * m), y(n, m)
										} else {
											d = 0;
											for (var g = u.length / 3; d < g; d++) n.fromArray(u, 3 *
												d), y(n, d)
										}
								} else {
									var v = t.vertices;
									for (d = 0, g = v.length; d < g; d++) y(v[d], d)
								}
							}

							function y(t, e) {
								var i = ko.distanceSqToPoint(t);
								if (i < c) {
									ko.closestPointToPoint(t, h), h.applyMatrix4(s);
									var n = r.ray.origin.distanceTo(h);
									if (n < r.near || n > r.far) return;
									a.push({
										distance: n,
										distanceToRay: Math.sqrt(i),
										point: h.clone(),
										index: e,
										face: null,
										object: o
									})
								}
							}
						}),
						clone: function () {
							return new this.constructor(this.geometry, this.material).copy(this)
						}
					}), ds.prototype = Object.assign(Object.create(Ci.prototype), {
						constructor: ds,
						isVideoTexture: !0,
						update: function () {
							var t = this.image;
							t.readyState >= t.HAVE_CURRENT_DATA && (this.needsUpdate = !0)
						}
					}), fs.prototype = Object.create(Ci.prototype), (fs.prototype.constructor = fs).prototype
					.isCompressedTexture = !0, ms.prototype = Object.create(Ci.prototype), (ms.prototype
						.constructor = ms).prototype.isCanvasTexture = !0, gs.prototype = Object.create(Ci
						.prototype), (gs.prototype.constructor = gs).prototype.isDepthTexture = !0, vs.prototype =
					Object.create(ir.prototype), vs.prototype.constructor = vs, ys.prototype = Object.create(On
						.prototype), ys.prototype.constructor = ys, xs.prototype = Object.create(ir.prototype), xs
					.prototype.constructor = xs, bs.prototype = Object.create(On.prototype), bs.prototype
					.constructor = bs, ws.prototype = Object.create(ir.prototype), ws.prototype.constructor = ws,
					_s.prototype = Object.create(On.prototype), _s.prototype.constructor = _s, Ms.prototype =
					Object.create(ws.prototype), Ms.prototype.constructor = Ms, Ss.prototype = Object.create(On
						.prototype), Ss.prototype.constructor = Ss, Es.prototype = Object.create(ws.prototype), Es
					.prototype.constructor = Es, Ts.prototype = Object.create(On.prototype), Ts.prototype
					.constructor = Ts, As.prototype = Object.create(ws.prototype), As.prototype.constructor = As,
					Ls.prototype = Object.create(On.prototype), Ls.prototype.constructor = Ls, Ps.prototype =
					Object.create(ws.prototype), Ps.prototype.constructor = Ps, Cs.prototype = Object.create(On
						.prototype), Cs.prototype.constructor = Cs, Rs.prototype = Object.create(ir.prototype), Rs
					.prototype.constructor = Rs, Os.prototype = Object.create(On.prototype), Os.prototype
					.constructor = Os, Is.prototype = Object.create(ir.prototype), Is.prototype.constructor = Is,
					Ds.prototype = Object.create(On.prototype), Ds.prototype.constructor = Ds, Bs.prototype =
					Object.create(ir.prototype), Bs.prototype.constructor = Bs;
				var Ns = {
					triangulate: function (t, e, i) {
						i = i || 2;
						var n, r, a, o, s, c, h, l = e && e.length,
							u = l ? e[0] * i : t.length,
							p = zs(t, 0, u, i, !0),
							d = [];
						if (!p) return d;
						if (l && (p = Vs(t, e, p, i)), t.length > 80 * i) {
							n = a = t[0], r = o = t[1];
							for (var f = i; f < u; f += i)(s = t[f]) < n && (n = s), (c = t[f + 1]) < r &&
								(r = c), a < s && (a = s), o < c && (o = c);
							h = 0 !== (h = Math.max(a - n, o - r)) ? 1 / h : 0
						}
						return Gs(p, d, i, n, r, h), d
					}
				};

				function zs(t, e, i, n, r) {
					var a, o;
					if (r === 0 < lc(t, e, i, n))
						for (a = e; a < i; a += n) o = sc(a, t[a], t[a + 1], o);
					else
						for (a = i - n; e <= a; a -= n) o = sc(a, t[a], t[a + 1], o);
					return o && ec(o, o.next) && (cc(o), o = o.next), o
				}

				function Us(t, e) {
					if (!t) return t;
					e || (e = t);
					var i, n = t;
					do {
						if (i = !1, n.steiner || !ec(n, n.next) && 0 !== tc(n.prev, n, n.next)) n = n.next;
						else {
							if (cc(n), (n = e = n.prev) === n.next) break;
							i = !0
						}
					} while (i || n !== e);
					return e
				}

				function Gs(t, e, i, n, r, a, o) {
					if (t) {
						!o && a && Ys(t, n, r, a);
						for (var s, c, h = t; t.prev !== t.next;)
							if (s = t.prev, c = t.next, a ? Hs(t, n, r, a) : Fs(t)) e.push(s.i / i), e.push(t.i /
								i), e.push(c.i / i), cc(t), t = c.next, h = c.next;
							else if ((t = c) === h) {
							o ? 1 === o ? Gs(t = ks(t, e, i), e, i, n, r, a, 2) : 2 === o && js(t, e, i, n, r,
								a) : Gs(Us(t), e, i, n, r, a, 1);
							break
						}
					}
				}

				function Fs(t) {
					var e = t.prev,
						i = t,
						n = t.next;
					if (0 <= tc(e, i, n)) return !1;
					for (var r = t.next.next; r !== t.prev;) {
						if (Ks(e.x, e.y, i.x, i.y, n.x, n.y, r.x, r.y) && 0 <= tc(r.prev, r, r.next)) return !1;
						r = r.next
					}
					return !0
				}

				function Hs(t, e, i, n) {
					var r = t.prev,
						a = t,
						o = t.next;
					if (0 <= tc(r, a, o)) return !1;
					for (var s = r.x < a.x ? r.x < o.x ? r.x : o.x : a.x < o.x ? a.x : o.x, c = r.y < a.y ? r.y <
							o.y ? r.y : o.y : a.y < o.y ? a.y : o.y, h = r.x > a.x ? r.x > o.x ? r.x : o.x : a.x >
							o.x ? a.x : o.x, l = r.y > a.y ? r.y > o.y ? r.y : o.y : a.y > o.y ? a.y : o.y, u =
							Zs(s, c, e, i, n), p = Zs(h, l, e, i, n), d = t.nextZ; d && d.z <= p;) {
						if (d !== t.prev && d !== t.next && Ks(r.x, r.y, a.x, a.y, o.x, o.y, d.x, d.y) && 0 <= tc(
								d.prev, d, d.next)) return !1;
						d = d.nextZ
					}
					for (d = t.prevZ; d && d.z >= u;) {
						if (d !== t.prev && d !== t.next && Ks(r.x, r.y, a.x, a.y, o.x, o.y, d.x, d.y) && 0 <= tc(
								d.prev, d, d.next)) return !1;
						d = d.prevZ
					}
					return !0
				}

				function ks(t, e, i) {
					var n = t;
					do {
						var r = n.prev,
							a = n.next.next;
						!ec(r, a) && ic(r, n, n.next, a) && rc(r, a) && rc(a, r) && (e.push(r.i / i), e.push(n.i /
							i), e.push(a.i / i), cc(n), cc(n.next), n = t = a), n = n.next
					} while (n !== t);
					return n
				}

				function js(t, e, i, n, r, a) {
					var o = t;
					do {
						for (var s = o.next.next; s !== o.prev;) {
							if (o.i !== s.i && $s(o, s)) {
								var c = oc(o, s);
								return o = Us(o, o.next), c = Us(c, c.next), Gs(o, e, i, n, r, a), void Gs(c, e,
									i, n, r, a)
							}
							s = s.next
						}
						o = o.next
					} while (o !== t)
				}

				function Vs(t, e, i, n) {
					var r, a, o, s = [];
					for (r = 0, a = e.length; r < a; r++)(o = zs(t, e[r] * n, r < a - 1 ? e[r + 1] * n : t.length,
						n, !1)) === o.next && (o.steiner = !0), s.push(Qs(o));
					for (s.sort(Ws), r = 0; r < s.length; r++) qs(s[r], i), i = Us(i, i.next);
					return i
				}

				function Ws(t, e) {
					return t.x - e.x
				}

				function qs(t, e) {
					if (e = Xs(t, e)) {
						var i = oc(e, t);
						Us(i, i.next)
					}
				}

				function Xs(t, e) {
					var i, n = e,
						r = t.x,
						a = t.y,
						o = -1 / 0;
					do {
						if (a <= n.y && a >= n.next.y && n.next.y !== n.y) {
							var s = n.x + (a - n.y) * (n.next.x - n.x) / (n.next.y - n.y);
							if (s <= r && o < s) {
								if ((o = s) === r) {
									if (a === n.y) return n;
									if (a === n.next.y) return n.next
								}
								i = n.x < n.next.x ? n : n.next
							}
						}
						n = n.next
					} while (n !== e);
					if (!i) return null;
					if (r === o) return i.prev;
					var c, h = i,
						l = i.x,
						u = i.y,
						p = 1 / 0;
					for (n = i.next; n !== h;) r >= n.x && n.x >= l && r !== n.x && Ks(a < u ? r : o, a, l, u, a <
						u ? o : r, a, n.x, n.y) && ((c = Math.abs(a - n.y) / (r - n.x)) < p || c === p && n
						.x > i.x) && rc(n, t) && (i = n, p = c), n = n.next;
					return i
				}

				function Ys(t, e, i, n) {
					for (var r = t; null === r.z && (r.z = Zs(r.x, r.y, e, i, n)), r.prevZ = r.prev, r.nextZ = r
						.next, (r = r.next) !== t;);
					r.prevZ.nextZ = null, r.prevZ = null, Js(r)
				}

				function Js(t) {
					var e, i, n, r, a, o, s, c, h = 1;
					do {
						for (i = t, a = t = null, o = 0; i;) {
							for (o++, n = i, e = s = 0; e < h && (s++, n = n.nextZ); e++);
							for (c = h; 0 < s || 0 < c && n;) 0 !== s && (0 === c || !n || i.z <= n.z) ? (i = (r =
									i).nextZ, s--) : (n = (r = n).nextZ, c--), a ? a.nextZ = r : t = r, r.prevZ =
								a, a = r;
							i = n
						}
						a.nextZ = null, h *= 2
					} while (1 < o);
					return t
				}

				function Zs(t, e, i, n, r) {
					return (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = 32767 * (
						t - i) * r) | t << 8)) | t << 4)) | t << 2)) | t << 1)) | (e = 1431655765 & ((e =
						858993459 & ((e = 252645135 & ((e = 16711935 & ((e = 32767 * (e - n) * r) |
							e << 8)) | e << 4)) | e << 2)) | e << 1)) << 1
				}

				function Qs(t) {
					for (var e = t, i = t; e.x < i.x && (i = e), (e = e.next) !== t;);
					return i
				}

				function Ks(t, e, i, n, r, a, o, s) {
					return 0 <= (r - o) * (e - s) - (t - o) * (a - s) && 0 <= (t - o) * (n - s) - (i - o) * (e -
						s) && 0 <= (i - o) * (a - s) - (r - o) * (n - s)
				}

				function $s(t, e) {
					return t.next.i !== e.i && t.prev.i !== e.i && !nc(t, e) && rc(t, e) && rc(e, t) && ac(t, e)
				}

				function tc(t, e, i) {
					return (e.y - t.y) * (i.x - e.x) - (e.x - t.x) * (i.y - e.y)
				}

				function ec(t, e) {
					return t.x === e.x && t.y === e.y
				}

				function ic(t, e, i, n) {
					return !!(ec(t, e) && ec(i, n) || ec(t, n) && ec(i, e)) || 0 < tc(t, e, i) != 0 < tc(t, e,
						n) && 0 < tc(i, n, t) != 0 < tc(i, n, e)
				}

				function nc(t, e) {
					var i = t;
					do {
						if (i.i !== t.i && i.next.i !== t.i && i.i !== e.i && i.next.i !== e.i && ic(i, i.next, t,
								e)) return !0;
						i = i.next
					} while (i !== t);
					return !1
				}

				function rc(t, e) {
					return tc(t.prev, t, t.next) < 0 ? 0 <= tc(t, e, t.next) && 0 <= tc(t, t.prev, e) : tc(t, e, t
						.prev) < 0 || tc(t, t.next, e) < 0
				}

				function ac(t, e) {
					for (var i = t, n = !1, r = (t.x + e.x) / 2, a = (t.y + e.y) / 2; i.y > a != i.next.y > a && i
						.next.y !== i.y && r < (i.next.x - i.x) * (a - i.y) / (i.next.y - i.y) + i.x && (n = !n),
						(i = i.next) !== t;);
					return n
				}

				function oc(t, e) {
					var i = new hc(t.i, t.x, t.y),
						n = new hc(e.i, e.x, e.y),
						r = t.next,
						a = e.prev;
					return (t.next = e).prev = t, (i.next = r).prev = i, (n.next = i).prev = n, (a.next = n)
						.prev = a, n
				}

				function sc(t, e, i, n) {
					var r = new hc(t, e, i);
					return n ? (r.next = n.next, (r.prev = n).next.prev = r, n.next = r) : (r.prev = r).next = r,
						r
				}

				function cc(t) {
					t.next.prev = t.prev, t.prev.next = t.next, t.prevZ && (t.prevZ.nextZ = t.nextZ), t.nextZ && (
						t.nextZ.prevZ = t.prevZ)
				}

				function hc(t, e, i) {
					this.i = t, this.x = e, this.y = i, this.prev = null, this.next = null, this.z = null, this
						.prevZ = null, this.nextZ = null, this.steiner = !1
				}

				function lc(t, e, i, n) {
					for (var r = 0, a = e, o = i - n; a < i; a += n) r += (t[o] - t[a]) * (t[a + 1] + t[o + 1]),
						o = a;
					return r
				}
				var uc = {
					area: function (t) {
						for (var e = t.length, i = 0, n = e - 1, r = 0; r < e; n = r++) i += t[n].x * t[r]
							.y - t[r].x * t[n].y;
						return .5 * i
					},
					isClockWise: function (t) {
						return uc.area(t) < 0
					},
					triangulateShape: function (t, e) {
						var i = [],
							n = [],
							r = [];
						pc(t), dc(i, t);
						var a = t.length;
						e.forEach(pc);
						for (var o = 0; o < e.length; o++) n.push(a), a += e[o].length, dc(i, e[o]);
						var s = Ns.triangulate(i, n);
						for (o = 0; o < s.length; o += 3) r.push(s.slice(o, o + 3));
						return r
					}
				};

				function pc(t) {
					var e = t.length;
					2 < e && t[e - 1].equals(t[0]) && t.pop()
				}

				function dc(t, e) {
					for (var i = 0; i < e.length; i++) t.push(e[i].x), t.push(e[i].y)
				}

				function fc(t, e) {
					On.call(this), this.type = "ExtrudeGeometry", this.parameters = {
						shapes: t,
						options: e
					}, this.fromBufferGeometry(new mc(t, e)), this.mergeVertices()
				}

				function mc(t, K) {
					ir.call(this), this.type = "ExtrudeBufferGeometry", this.parameters = {
						shapes: t,
						options: K
					}, t = Array.isArray(t) ? t : [t];
					for (var $ = this, tt = [], et = [], e = 0, i = t.length; e < i; e++) {
						n(t[e])
					}

					function n(t) {
						var n = [],
							e = void 0 !== K.curveSegments ? K.curveSegments : 12,
							c = void 0 !== K.steps ? K.steps : 1,
							i = void 0 !== K.depth ? K.depth : 100,
							r = void 0 === K.bevelEnabled || K.bevelEnabled,
							a = void 0 !== K.bevelThickness ? K.bevelThickness : 6,
							o = void 0 !== K.bevelSize ? K.bevelSize : a - 2,
							h = void 0 !== K.bevelSegments ? K.bevelSegments : 3,
							s = K.extrudePath,
							l = void 0 !== K.UVGenerator ? K.UVGenerator : gc;
						void 0 !== K.amount && (console.warn(
								"THREE.ExtrudeBufferGeometry: amount has been renamed to depth."), i = K
							.amount);
						var u, p, d, f, m, g, v, y, x = !1;
						s && (u = s.getSpacedPoints(c), r = !(x = !0), p = s.computeFrenetFrames(c, !1), d =
							new li, f = new li, m = new li), r || (o = a = h = 0);
						var b = t.extractPoints(e),
							w = b.shape,
							_ = b.holes;
						if (!uc.isClockWise(w))
							for (w = w.reverse(), v = 0, y = _.length; v < y; v++) g = _[v], uc.isClockWise(g) &&
								(_[v] = g.reverse());
						var M = uc.triangulateShape(w, _),
							S = w;
						for (v = 0, y = _.length; v < y; v++) g = _[v], w = w.concat(g);

						function E(t, e, i) {
							return e || console.error("THREE.ExtrudeGeometry: vec does not exist"), e.clone()
								.multiplyScalar(i).add(t)
						}
						var T, A, L, P, C, R, O = w.length,
							I = M.length;

						function D(t, e, i) {
							var n, r, a, o = t.x - e.x,
								s = t.y - e.y,
								c = i.x - t.x,
								h = i.y - t.y,
								l = o * o + s * s,
								u = o * h - s * c;
							if (Math.abs(u) > Number.EPSILON) {
								var p = Math.sqrt(l),
									d = Math.sqrt(c * c + h * h),
									f = e.x - s / p,
									m = e.y + o / p,
									g = ((i.x - h / d - f) * h - (i.y + c / d - m) * c) / (o * h - s * c),
									v = (n = f + o * g - t.x) * n + (r = m + s * g - t.y) * r;
								if (v <= 2) return new si(n, r);
								a = Math.sqrt(v / 2)
							} else {
								var y = !1;
								o > Number.EPSILON ? c > Number.EPSILON && (y = !0) : o < -Number.EPSILON ? c < -
									Number.EPSILON && (y = !0) : Math.sign(s) === Math.sign(h) && (y = !0), a =
									y ? (n = -s, r = o, Math.sqrt(l)) : (n = o, r = s, Math.sqrt(l / 2))
							}
							return new si(n / a, r / a)
						}
						for (var B = [], N = 0, z = S.length, U = z - 1, G = N + 1; N < z; N++, U++, G++) U ===
							z && (U = 0), G === z && (G = 0), B[N] = D(S[N], S[U], S[G]);
						var F, H, k = [],
							j = B.concat();
						for (v = 0, y = _.length; v < y; v++) {
							for (g = _[v], F = [], N = 0, U = (z = g.length) - 1, G = N + 1; N < z; N++, U++, G++)
								U === z && (U = 0), G === z && (G = 0), F[N] = D(g[N], g[U], g[G]);
							k.push(F), j = j.concat(F)
						}
						for (T = 0; T < h; T++) {
							for (L = T / h, P = a * Math.cos(L * Math.PI / 2), A = o * Math.sin(L * Math.PI / 2),
								N = 0, z = S.length; N < z; N++) X((C = E(S[N], B[N], A)).x, C.y, -P);
							for (v = 0, y = _.length; v < y; v++)
								for (g = _[v], F = k[v], N = 0, z = g.length; N < z; N++) X((C = E(g[N], F[N], A))
									.x, C.y, -P)
						}
						for (A = o, N = 0; N < O; N++) C = r ? E(w[N], j[N], A) : w[N], x ? (f.copy(p.normals[0])
							.multiplyScalar(C.x), d.copy(p.binormals[0]).multiplyScalar(C.y), m.copy(u[0])
							.add(f).add(d), X(m.x, m.y, m.z)) : X(C.x, C.y, 0);
						for (H = 1; H <= c; H++)
							for (N = 0; N < O; N++) C = r ? E(w[N], j[N], A) : w[N], x ? (f.copy(p.normals[H])
								.multiplyScalar(C.x), d.copy(p.binormals[H]).multiplyScalar(C.y), m.copy(u[H])
								.add(f).add(d), X(m.x, m.y, m.z)) : X(C.x, C.y, i / c * H);
						for (T = h - 1; 0 <= T; T--) {
							for (L = T / h, P = a * Math.cos(L * Math.PI / 2), A = o * Math.sin(L * Math.PI / 2),
								N = 0, z = S.length; N < z; N++) X((C = E(S[N], B[N], A)).x, C.y, i + P);
							for (v = 0, y = _.length; v < y; v++)
								for (g = _[v], F = k[v], N = 0, z = g.length; N < z; N++) C = E(g[N], F[N], A),
									x ? X(C.x, C.y + u[c - 1].y, u[c - 1].x + P) : X(C.x, C.y, i + P)
						}

						function V() {
							var t = tt.length / 3;
							if (r) {
								var e = 0,
									i = O * e;
								for (N = 0; N < I; N++) Y((R = M[N])[2] + i, R[1] + i, R[0] + i);
								for (i = O * (e = c + 2 * h), N = 0; N < I; N++) Y((R = M[N])[0] + i, R[1] + i, R[
									2] + i)
							} else {
								for (N = 0; N < I; N++) Y((R = M[N])[2], R[1], R[0]);
								for (N = 0; N < I; N++) Y((R = M[N])[0] + O * c, R[1] + O * c, R[2] + O * c)
							}
							$.addGroup(t, tt.length / 3 - t, 0)
						}

						function W() {
							var t = tt.length / 3,
								e = 0;
							for (q(S, e), e += S.length, v = 0, y = _.length; v < y; v++) q(g = _[v], e), e += g
								.length;
							$.addGroup(t, tt.length / 3 - t, 1)
						}

						function q(t, e) {
							var i, n;
							for (N = t.length; 0 <= --N;) {
								(n = (i = N) - 1) < 0 && (n = t.length - 1);
								var r = 0,
									a = c + 2 * h;
								for (r = 0; r < a; r++) {
									var o = O * r,
										s = O * (r + 1);
									J(e + i + o, e + n + o, e + n + s, e + i + s)
								}
							}
						}

						function X(t, e, i) {
							n.push(t), n.push(e), n.push(i)
						}

						function Y(t, e, i) {
							Z(t), Z(e), Z(i);
							var n = tt.length / 3,
								r = l.generateTopUV($, tt, n - 3, n - 2, n - 1);
							Q(r[0]), Q(r[1]), Q(r[2])
						}

						function J(t, e, i, n) {
							Z(t), Z(e), Z(n), Z(e), Z(i), Z(n);
							var r = tt.length / 3,
								a = l.generateSideWallUV($, tt, r - 6, r - 3, r - 2, r - 1);
							Q(a[0]), Q(a[1]), Q(a[3]), Q(a[1]), Q(a[2]), Q(a[3])
						}

						function Z(t) {
							tt.push(n[3 * t + 0]), tt.push(n[3 * t + 1]), tt.push(n[3 * t + 2])
						}

						function Q(t) {
							et.push(t.x), et.push(t.y)
						}
						V(), W()
					}
					this.addAttribute("position", new Hn(tt, 3)), this.addAttribute("uv", new Hn(et, 2)), this
						.computeVertexNormals()
				}
				fc.prototype = Object.create(On.prototype), (fc.prototype.constructor = fc).prototype.toJSON =
					function () {
						var t = On.prototype.toJSON.call(this);
						return vc(this.parameters.shapes, this.parameters.options, t)
					}, mc.prototype = Object.create(ir.prototype), (mc.prototype.constructor = mc).prototype
					.toJSON = function () {
						var t = ir.prototype.toJSON.call(this);
						return vc(this.parameters.shapes, this.parameters.options, t)
					};
				var gc = {
					generateTopUV: function (t, e, i, n, r) {
						var a = e[3 * i],
							o = e[3 * i + 1],
							s = e[3 * n],
							c = e[3 * n + 1],
							h = e[3 * r],
							l = e[3 * r + 1];
						return [new si(a, o), new si(s, c), new si(h, l)]
					},
					generateSideWallUV: function (t, e, i, n, r, a) {
						var o = e[3 * i],
							s = e[3 * i + 1],
							c = e[3 * i + 2],
							h = e[3 * n],
							l = e[3 * n + 1],
							u = e[3 * n + 2],
							p = e[3 * r],
							d = e[3 * r + 1],
							f = e[3 * r + 2],
							m = e[3 * a],
							g = e[3 * a + 1],
							v = e[3 * a + 2];
						return Math.abs(s - l) < .01 ? [new si(o, 1 - c), new si(h, 1 - u), new si(p, 1 -
							f), new si(m, 1 - v)] : [new si(s, 1 - c), new si(l, 1 - u), new si(d, 1 -
							f), new si(g, 1 - v)]
					}
				};

				function vc(t, e, i) {
					if (i.shapes = [], Array.isArray(t))
						for (var n = 0, r = t.length; n < r; n++) {
							var a = t[n];
							i.shapes.push(a.uuid)
						} else i.shapes.push(t.uuid);
					return void 0 !== e.extrudePath && (i.options.extrudePath = e.extrudePath.toJSON()), i
				}

				function yc(t, e) {
					On.call(this), this.type = "TextGeometry", this.parameters = {
						text: t,
						parameters: e
					}, this.fromBufferGeometry(new xc(t, e)), this.mergeVertices()
				}

				function xc(t, e) {
					var i = (e = e || {}).font;
					if (!i || !i.isFont) return console.error(
						"THREE.TextGeometry: font parameter is not an instance of THREE.Font."), new On;
					var n = i.generateShapes(t, e.size);
					e.depth = void 0 !== e.height ? e.height : 50, void 0 === e.bevelThickness && (e
							.bevelThickness = 10), void 0 === e.bevelSize && (e.bevelSize = 8), void 0 === e
						.bevelEnabled && (e.bevelEnabled = !1), mc.call(this, n, e), this.type =
						"TextBufferGeometry"
				}

				function bc(t, e, i, n, r, a, o) {
					On.call(this), this.type = "SphereGeometry", this.parameters = {
						radius: t,
						widthSegments: e,
						heightSegments: i,
						phiStart: n,
						phiLength: r,
						thetaStart: a,
						thetaLength: o
					}, this.fromBufferGeometry(new wc(t, e, i, n, r, a, o)), this.mergeVertices()
				}

				function wc(t, e, i, n, r, a, o) {
					ir.call(this), this.type = "SphereBufferGeometry", this.parameters = {
							radius: t,
							widthSegments: e,
							heightSegments: i,
							phiStart: n,
							phiLength: r,
							thetaStart: a,
							thetaLength: o
						}, t = t || 1, e = Math.max(3, Math.floor(e) || 8), i = Math.max(2, Math.floor(i) || 6),
						n = void 0 !== n ? n : 0, r = void 0 !== r ? r : 2 * Math.PI;
					var s, c, h = (a = void 0 !== a ? a : 0) + (o = void 0 !== o ? o : Math.PI),
						l = 0,
						u = [],
						p = new li,
						d = new li,
						f = [],
						m = [],
						g = [],
						v = [];
					for (c = 0; c <= i; c++) {
						var y = [],
							x = c / i;
						for (s = 0; s <= e; s++) {
							var b = s / e;
							p.x = -t * Math.cos(n + b * r) * Math.sin(a + x * o), p.y = t * Math.cos(a + x * o), p
								.z = t * Math.sin(n + b * r) * Math.sin(a + x * o), m.push(p.x, p.y, p.z), d.set(p
									.x, p.y, p.z).normalize(), g.push(d.x, d.y, d.z), v.push(b, 1 - x), y.push(
									l++)
						}
						u.push(y)
					}
					for (c = 0; c < i; c++)
						for (s = 0; s < e; s++) {
							var w = u[c][s + 1],
								_ = u[c][s],
								M = u[c + 1][s],
								S = u[c + 1][s + 1];
							(0 !== c || 0 < a) && f.push(w, _, S), (c !== i - 1 || h < Math.PI) && f.push(_, M, S)
						}
					this.setIndex(f), this.addAttribute("position", new Hn(m, 3)), this.addAttribute("normal",
						new Hn(g, 3)), this.addAttribute("uv", new Hn(v, 2))
				}

				function _c(t, e, i, n, r, a) {
					On.call(this), this.type = "RingGeometry", this.parameters = {
						innerRadius: t,
						outerRadius: e,
						thetaSegments: i,
						phiSegments: n,
						thetaStart: r,
						thetaLength: a
					}, this.fromBufferGeometry(new Mc(t, e, i, n, r, a)), this.mergeVertices()
				}

				function Mc(t, e, i, n, r, a) {
					ir.call(this), this.type = "RingBufferGeometry", this.parameters = {
							innerRadius: t,
							outerRadius: e,
							thetaSegments: i,
							phiSegments: n,
							thetaStart: r,
							thetaLength: a
						}, t = t || .5, e = e || 1, r = void 0 !== r ? r : 0, a = void 0 !== a ? a : 2 * Math.PI,
						i = void 0 !== i ? Math.max(3, i) : 8;
					var o, s, c, h = [],
						l = [],
						u = [],
						p = [],
						d = t,
						f = (e - t) / (n = void 0 !== n ? Math.max(1, n) : 1),
						m = new li,
						g = new si;
					for (s = 0; s <= n; s++) {
						for (c = 0; c <= i; c++) o = r + c / i * a, m.x = d * Math.cos(o), m.y = d * Math.sin(o),
							l.push(m.x, m.y, m.z), u.push(0, 0, 1), g.x = (m.x / e + 1) / 2, g.y = (m.y / e + 1) /
							2, p.push(g.x, g.y);
						d += f
					}
					for (s = 0; s < n; s++) {
						var v = s * (i + 1);
						for (c = 0; c < i; c++) {
							var y = o = c + v,
								x = o + i + 1,
								b = o + i + 2,
								w = o + 1;
							h.push(y, x, w), h.push(x, b, w)
						}
					}
					this.setIndex(h), this.addAttribute("position", new Hn(l, 3)), this.addAttribute("normal",
						new Hn(u, 3)), this.addAttribute("uv", new Hn(p, 2))
				}

				function Sc(t, e, i, n) {
					On.call(this), this.type = "LatheGeometry", this.parameters = {
						points: t,
						segments: e,
						phiStart: i,
						phiLength: n
					}, this.fromBufferGeometry(new Ec(t, e, i, n)), this.mergeVertices()
				}

				function Ec(t, e, i, n) {
					ir.call(this), this.type = "LatheBufferGeometry", this.parameters = {
						points: t,
						segments: e,
						phiStart: i,
						phiLength: n
					}, e = Math.floor(e) || 12, i = i || 0, n = n || 2 * Math.PI, n = oi.clamp(n, 0, 2 * Math
						.PI);
					var r, a, o, s = [],
						c = [],
						h = [],
						l = 1 / e,
						u = new li,
						p = new si;
					for (a = 0; a <= e; a++) {
						var d = i + a * l * n,
							f = Math.sin(d),
							m = Math.cos(d);
						for (o = 0; o <= t.length - 1; o++) u.x = t[o].x * f, u.y = t[o].y, u.z = t[o].x * m, c
							.push(u.x, u.y, u.z), p.x = a / e, p.y = o / (t.length - 1), h.push(p.x, p.y)
					}
					for (a = 0; a < e; a++)
						for (o = 0; o < t.length - 1; o++) {
							var g = r = o + a * t.length,
								v = r + t.length,
								y = r + t.length + 1,
								x = r + 1;
							s.push(g, v, x), s.push(v, y, x)
						}
					if (this.setIndex(s), this.addAttribute("position", new Hn(c, 3)), this.addAttribute("uv",
							new Hn(h, 2)), this.computeVertexNormals(), n === 2 * Math.PI) {
						var b = this.attributes.normal.array,
							w = new li,
							_ = new li,
							M = new li;
						for (r = e * t.length * 3, o = a = 0; a < t.length; a++, o += 3) w.x = b[o + 0], w.y = b[
								o + 1], w.z = b[o + 2], _.x = b[r + o + 0], _.y = b[r + o + 1], _.z = b[r + o +
							2], M.addVectors(w, _).normalize(), b[o + 0] = b[r + o + 0] = M.x, b[o + 1] = b[r +
								o + 1] = M.y, b[o + 2] = b[r + o + 2] = M.z
					}
				}

				function Tc(t, e) {
					On.call(this), this.type = "ShapeGeometry", "object" == typeof e && (console.warn(
							"THREE.ShapeGeometry: Options parameter has been removed."), e = e.curveSegments),
						this.parameters = {
							shapes: t,
							curveSegments: e
						}, this.fromBufferGeometry(new Ac(t, e)), this.mergeVertices()
				}

				function Ac(t, f) {
					ir.call(this), this.type = "ShapeBufferGeometry", this.parameters = {
						shapes: t,
						curveSegments: f
					}, f = f || 12;
					var m = [],
						g = [],
						v = [],
						y = [],
						e = 0,
						x = 0;
					if (!1 === Array.isArray(t)) n(t);
					else
						for (var i = 0; i < t.length; i++) n(t[i]), this.addGroup(e, x, i), e += x, x = 0;

					function n(t) {
						var e, i, n, r = g.length / 3,
							a = t.extractPoints(f),
							o = a.shape,
							s = a.holes;
						for (!1 === uc.isClockWise(o) && (o = o.reverse()), e = 0, i = s.length; e < i; e++) n =
							s[e], !0 === uc.isClockWise(n) && (s[e] = n.reverse());
						var c = uc.triangulateShape(o, s);
						for (e = 0, i = s.length; e < i; e++) n = s[e], o = o.concat(n);
						for (e = 0, i = o.length; e < i; e++) {
							var h = o[e];
							g.push(h.x, h.y, 0), v.push(0, 0, 1), y.push(h.x, h.y)
						}
						for (e = 0, i = c.length; e < i; e++) {
							var l = c[e],
								u = l[0] + r,
								p = l[1] + r,
								d = l[2] + r;
							m.push(u, p, d), x += 3
						}
					}
					this.setIndex(m), this.addAttribute("position", new Hn(g, 3)), this.addAttribute("normal",
						new Hn(v, 3)), this.addAttribute("uv", new Hn(y, 2))
				}

				function Lc(t, e) {
					if (e.shapes = [], Array.isArray(t))
						for (var i = 0, n = t.length; i < n; i++) {
							var r = t[i];
							e.shapes.push(r.uuid)
						} else e.shapes.push(t.uuid);
					return e
				}

				function Pc(t, e) {
					ir.call(this), this.type = "EdgesGeometry", this.parameters = {
						thresholdAngle: e
					}, e = void 0 !== e ? e : 1;
					var i, n, r, a, o = [],
						s = Math.cos(oi.DEG2RAD * e),
						c = [0, 0],
						h = {},
						l = ["a", "b", "c"];
					t.isBufferGeometry ? (a = new On).fromBufferGeometry(t) : a = t.clone(), a.mergeVertices(), a
						.computeFaceNormals();
					for (var u = a.vertices, p = a.faces, d = 0, f = p.length; d < f; d++)
						for (var m = p[d], g = 0; g < 3; g++) i = m[l[g]], n = m[l[(g + 1) % 3]], c[0] = Math.min(
							i, n), c[1] = Math.max(i, n), void 0 === h[r = c[0] + "," + c[1]] ? h[r] = {
							index1: c[0],
							index2: c[1],
							face1: d,
							face2: void 0
						} : h[r].face2 = d;
					for (r in h) {
						var v = h[r];
						if (void 0 === v.face2 || p[v.face1].normal.dot(p[v.face2].normal) <= s) {
							var y = u[v.index1];
							o.push(y.x, y.y, y.z), y = u[v.index2], o.push(y.x, y.y, y.z)
						}
					}
					this.addAttribute("position", new Hn(o, 3))
				}

				function Cc(t, e, i, n, r, a, o, s) {
					On.call(this), this.type = "CylinderGeometry", this.parameters = {
						radiusTop: t,
						radiusBottom: e,
						height: i,
						radialSegments: n,
						heightSegments: r,
						openEnded: a,
						thetaStart: o,
						thetaLength: s
					}, this.fromBufferGeometry(new Rc(t, e, i, n, r, a, o, s)), this.mergeVertices()
				}

				function Rc(v, y, x, b, w, t, _, M) {
					ir.call(this), this.type = "CylinderBufferGeometry", this.parameters = {
						radiusTop: v,
						radiusBottom: y,
						height: x,
						radialSegments: b,
						heightSegments: w,
						openEnded: t,
						thetaStart: _,
						thetaLength: M
					};
					var S = this;
					v = void 0 !== v ? v : 1, y = void 0 !== y ? y : 1, x = x || 1, b = Math.floor(b) || 8, w =
						Math.floor(w) || 1, t = void 0 !== t && t, _ = void 0 !== _ ? _ : 0, M = void 0 !== M ?
						M : 2 * Math.PI;
					var E = [],
						T = [],
						A = [],
						L = [],
						P = 0,
						C = [],
						R = x / 2,
						O = 0;

					function e() {
						var t, e, i = new li,
							n = new li,
							r = 0,
							a = (y - v) / x;
						for (e = 0; e <= w; e++) {
							var o = [],
								s = e / w,
								c = s * (y - v) + v;
							for (t = 0; t <= b; t++) {
								var h = t / b,
									l = h * M + _,
									u = Math.sin(l),
									p = Math.cos(l);
								n.x = c * u, n.y = -s * x + R, n.z = c * p, T.push(n.x, n.y, n.z), i.set(u, a, p)
									.normalize(), A.push(i.x, i.y, i.z), L.push(h, 1 - s), o.push(P++)
							}
							C.push(o)
						}
						for (t = 0; t < b; t++)
							for (e = 0; e < w; e++) {
								var d = C[e][t],
									f = C[e + 1][t],
									m = C[e + 1][t + 1],
									g = C[e][t + 1];
								E.push(d, f, g), E.push(f, m, g), r += 6
							}
						S.addGroup(O, r, 0), O += r
					}

					function i(t) {
						var e, i, n, r = new si,
							a = new li,
							o = 0,
							s = !0 === t ? v : y,
							c = !0 === t ? 1 : -1;
						for (i = P, e = 1; e <= b; e++) T.push(0, R * c, 0), A.push(0, c, 0), L.push(.5, .5), P++;
						for (n = P, e = 0; e <= b; e++) {
							var h = e / b * M + _,
								l = Math.cos(h),
								u = Math.sin(h);
							a.x = s * u, a.y = R * c, a.z = s * l, T.push(a.x, a.y, a.z), A.push(0, c, 0), r.x =
								.5 * l + .5, r.y = .5 * u * c + .5, L.push(r.x, r.y), P++
						}
						for (e = 0; e < b; e++) {
							var p = i + e,
								d = n + e;
							!0 === t ? E.push(d, d + 1, p) : E.push(d + 1, d, p), o += 3
						}
						S.addGroup(O, o, !0 === t ? 1 : 2), O += o
					}
					e(), !1 === t && (0 < v && i(!0), 0 < y && i(!1)), this.setIndex(E), this.addAttribute(
							"position", new Hn(T, 3)), this.addAttribute("normal", new Hn(A, 3)), this
						.addAttribute("uv", new Hn(L, 2))
				}

				function Oc(t, e, i, n, r, a, o) {
					Cc.call(this, 0, t, e, i, n, r, a, o), this.type = "ConeGeometry", this.parameters = {
						radius: t,
						height: e,
						radialSegments: i,
						heightSegments: n,
						openEnded: r,
						thetaStart: a,
						thetaLength: o
					}
				}

				function Ic(t, e, i, n, r, a, o) {
					Rc.call(this, 0, t, e, i, n, r, a, o), this.type = "ConeBufferGeometry", this.parameters = {
						radius: t,
						height: e,
						radialSegments: i,
						heightSegments: n,
						openEnded: r,
						thetaStart: a,
						thetaLength: o
					}
				}

				function Dc(t, e, i, n) {
					On.call(this), this.type = "CircleGeometry", this.parameters = {
						radius: t,
						segments: e,
						thetaStart: i,
						thetaLength: n
					}, this.fromBufferGeometry(new Bc(t, e, i, n)), this.mergeVertices()
				}

				function Bc(t, e, i, n) {
					ir.call(this), this.type = "CircleBufferGeometry", this.parameters = {
							radius: t,
							segments: e,
							thetaStart: i,
							thetaLength: n
						}, t = t || 1, e = void 0 !== e ? Math.max(3, e) : 8, i = void 0 !== i ? i : 0, n =
						void 0 !== n ? n : 2 * Math.PI;
					var r, a, o = [],
						s = [],
						c = [],
						h = [],
						l = new li,
						u = new si;
					for (s.push(0, 0, 0), c.push(0, 0, 1), h.push(.5, .5), a = 0, r = 3; a <= e; a++, r += 3) {
						var p = i + a / e * n;
						l.x = t * Math.cos(p), l.y = t * Math.sin(p), s.push(l.x, l.y, l.z), c.push(0, 0, 1), u
							.x = (s[r] / t + 1) / 2, u.y = (s[r + 1] / t + 1) / 2, h.push(u.x, u.y)
					}
					for (r = 1; r <= e; r++) o.push(r, r + 1, 0);
					this.setIndex(o), this.addAttribute("position", new Hn(s, 3)), this.addAttribute("normal",
						new Hn(c, 3)), this.addAttribute("uv", new Hn(h, 2))
				}
				yc.prototype = Object.create(On.prototype), yc.prototype.constructor = yc, xc.prototype = Object
					.create(mc.prototype), xc.prototype.constructor = xc, bc.prototype = Object.create(On
						.prototype), bc.prototype.constructor = bc, wc.prototype = Object.create(ir.prototype), wc
					.prototype.constructor = wc, _c.prototype = Object.create(On.prototype), _c.prototype
					.constructor = _c, Mc.prototype = Object.create(ir.prototype), Mc.prototype.constructor = Mc,
					Sc.prototype = Object.create(On.prototype), Sc.prototype.constructor = Sc, Ec.prototype =
					Object.create(ir.prototype), Ec.prototype.constructor = Ec, Tc.prototype = Object.create(On
						.prototype), (Tc.prototype.constructor = Tc).prototype.toJSON = function () {
						var t = On.prototype.toJSON.call(this);
						return Lc(this.parameters.shapes, t)
					}, Ac.prototype = Object.create(ir.prototype), (Ac.prototype.constructor = Ac).prototype
					.toJSON = function () {
						var t = ir.prototype.toJSON.call(this);
						return Lc(this.parameters.shapes, t)
					}, Pc.prototype = Object.create(ir.prototype), Pc.prototype.constructor = Pc, Cc.prototype =
					Object.create(On.prototype), Cc.prototype.constructor = Cc, Rc.prototype = Object.create(ir
						.prototype), Rc.prototype.constructor = Rc, Oc.prototype = Object.create(Cc.prototype), Oc
					.prototype.constructor = Oc, Ic.prototype = Object.create(Rc.prototype), Ic.prototype
					.constructor = Ic, Dc.prototype = Object.create(On.prototype), Dc.prototype.constructor = Dc,
					Bc.prototype = Object.create(ir.prototype), Bc.prototype.constructor = Bc;
				var Nc = Object.freeze({
					WireframeGeometry: vs,
					ParametricGeometry: ys,
					ParametricBufferGeometry: xs,
					TetrahedronGeometry: _s,
					TetrahedronBufferGeometry: Ms,
					OctahedronGeometry: Ss,
					OctahedronBufferGeometry: Es,
					IcosahedronGeometry: Ts,
					IcosahedronBufferGeometry: As,
					DodecahedronGeometry: Ls,
					DodecahedronBufferGeometry: Ps,
					PolyhedronGeometry: bs,
					PolyhedronBufferGeometry: ws,
					TubeGeometry: Cs,
					TubeBufferGeometry: Rs,
					TorusKnotGeometry: Os,
					TorusKnotBufferGeometry: Is,
					TorusGeometry: Ds,
					TorusBufferGeometry: Bs,
					TextGeometry: yc,
					TextBufferGeometry: xc,
					SphereGeometry: bc,
					SphereBufferGeometry: wc,
					RingGeometry: _c,
					RingBufferGeometry: Mc,
					PlaneGeometry: ar,
					PlaneBufferGeometry: or,
					LatheGeometry: Sc,
					LatheBufferGeometry: Ec,
					ShapeGeometry: Tc,
					ShapeBufferGeometry: Ac,
					ExtrudeGeometry: fc,
					ExtrudeBufferGeometry: mc,
					EdgesGeometry: Pc,
					ConeGeometry: Oc,
					ConeBufferGeometry: Ic,
					CylinderGeometry: Cc,
					CylinderBufferGeometry: Rc,
					CircleGeometry: Dc,
					CircleBufferGeometry: Bc,
					BoxGeometry: nr,
					BoxBufferGeometry: rr
				});

				function zc(t) {
					Ir.call(this), this.type = "ShadowMaterial", this.color = new Xi(0), this.transparent = !0,
						this.setValues(t)
				}

				function Uc(t) {
					Dr.call(this, t), this.type = "RawShaderMaterial"
				}

				function Gc(t) {
					Ir.call(this), this.defines = {
							STANDARD: ""
						}, this.type = "MeshStandardMaterial", this.color = new Xi(16777215), this.roughness = .5,
						this.metalness = .5, this.map = null, this.lightMap = null, this.lightMapIntensity = 1,
						this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Xi(0), this
						.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1,
						this.normalMap = null, this.normalMapType = ri, this.normalScale = new si(1, 1), this
						.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this
						.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null,
						this.envMapIntensity = 1, this.refractionRatio = .98, this.wireframe = !1, this
						.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin =
						"round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this
						.setValues(t)
				}

				function Fc(t) {
					Gc.call(this), this.defines = {
							PHYSICAL: ""
						}, this.type = "MeshPhysicalMaterial", this.reflectivity = .5, this.clearCoat = 0, this
						.clearCoatRoughness = 0, this.setValues(t)
				}

				function Hc(t) {
					Ir.call(this), this.type = "MeshPhongMaterial", this.color = new Xi(16777215), this.specular =
						new Xi(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this
						.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive =
						new Xi(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this
						.bumpScale = 1, this.normalMap = null, this.normalMapType = ri, this.normalScale = new si(
							1, 1), this.displacementMap = null, this.displacementScale = 1, this
						.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null,
						this.combine = $, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1,
						this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin =
						"round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this
						.setValues(t)
				}

				function kc(t) {
					Hc.call(this), this.defines = {
						TOON: ""
					}, this.type = "MeshToonMaterial", this.gradientMap = null, this.setValues(t)
				}

				function jc(t) {
					Ir.call(this), this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this
						.normalMap = null, this.normalMapType = ri, this.normalScale = new si(1, 1), this
						.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this
						.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this
						.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(t)
				}

				function Vc(t) {
					Ir.call(this), this.type = "MeshLambertMaterial", this.color = new Xi(16777215), this.map =
						null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this
						.aoMapIntensity = 1, this.emissive = new Xi(0), this.emissiveIntensity = 1, this
						.emissiveMap = null, this.specularMap = null, this.alphaMap = null, this.envMap = null,
						this.combine = $, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1,
						this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin =
						"round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this
						.setValues(t)
				}

				function Wc(t) {
					Ir.call(this), this.defines = {
							MATCAP: ""
						}, this.type = "MeshMatcapMaterial", this.color = new Xi(16777215), this.matcap = null,
						this.map = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this
						.normalMapType = ri, this.normalScale = new si(1, 1), this.displacementMap = null, this
						.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.skinning = !
						1, this.morphTargets = !1, this.morphNormals = !1, this.lights = !1, this.setValues(t)
				}

				function qc(t) {
					ss.call(this), this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this
						.gapSize = 1, this.setValues(t)
				}
				zc.prototype = Object.create(Ir.prototype), (zc.prototype.constructor = zc).prototype
					.isShadowMaterial = !0, zc.prototype.copy = function (t) {
						return Ir.prototype.copy.call(this, t), this.color.copy(t.color), this
					}, Uc.prototype = Object.create(Dr.prototype), (Uc.prototype.constructor = Uc).prototype
					.isRawShaderMaterial = !0, Gc.prototype = Object.create(Ir.prototype), (Gc.prototype
						.constructor = Gc).prototype.isMeshStandardMaterial = !0, Gc.prototype.copy = function (
					t) {
						return Ir.prototype.copy.call(this, t), this.defines = {
								STANDARD: ""
							}, this.color.copy(t.color), this.roughness = t.roughness, this.metalness = t
							.metalness, this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t
							.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this
							.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity =
							t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this
							.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(
								t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale =
							t.displacementScale, this.displacementBias = t.displacementBias, this.roughnessMap = t
							.roughnessMap, this.metalnessMap = t.metalnessMap, this.alphaMap = t.alphaMap, this
							.envMap = t.envMap, this.envMapIntensity = t.envMapIntensity, this.refractionRatio = t
							.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t
							.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this
							.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this
							.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this
					}, Fc.prototype = Object.create(Gc.prototype), (Fc.prototype.constructor = Fc).prototype
					.isMeshPhysicalMaterial = !0, Fc.prototype.copy = function (t) {
						return Gc.prototype.copy.call(this, t), this.defines = {
								PHYSICAL: ""
							}, this.reflectivity = t.reflectivity, this.clearCoat = t.clearCoat, this
							.clearCoatRoughness = t.clearCoatRoughness, this
					}, Hc.prototype = Object.create(Ir.prototype), (Hc.prototype.constructor = Hc).prototype
					.isMeshPhongMaterial = !0, Hc.prototype.copy = function (t) {
						return Ir.prototype.copy.call(this, t), this.color.copy(t.color), this.specular.copy(t
								.specular), this.shininess = t.shininess, this.map = t.map, this.lightMap = t
							.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this
							.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap =
							t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap,
							this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t
							.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t
							.displacementMap, this.displacementScale = t.displacementScale, this
							.displacementBias = t.displacementBias, this.specularMap = t.specularMap, this
							.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this
							.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this
							.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this
							.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin,
							this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t
							.morphNormals, this
					}, kc.prototype = Object.create(Hc.prototype), (kc.prototype.constructor = kc).prototype
					.isMeshToonMaterial = !0, kc.prototype.copy = function (t) {
						return Hc.prototype.copy.call(this, t), this.gradientMap = t.gradientMap, this
					}, jc.prototype = Object.create(Ir.prototype), (jc.prototype.constructor = jc).prototype
					.isMeshNormalMaterial = !0, jc.prototype.copy = function (t) {
						return Ir.prototype.copy.call(this, t), this.bumpMap = t.bumpMap, this.bumpScale = t
							.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this
							.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this
							.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias,
							this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this
							.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t
							.morphNormals, this
					}, Vc.prototype = Object.create(Ir.prototype), (Vc.prototype.constructor = Vc).prototype
					.isMeshLambertMaterial = !0, Vc.prototype.copy = function (t) {
						return Ir.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this
							.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t
							.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this
							.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this
							.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this
							.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t
							.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t
							.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this
							.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this
							.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this
					}, Wc.prototype = Object.create(Ir.prototype), (Wc.prototype.constructor = Wc).prototype
					.isMeshMatcapMaterial = !0, Wc.prototype.copy = function (t) {
						return Ir.prototype.copy.call(this, t), this.defines = {
								MATCAP: ""
							}, this.color.copy(t.color), this.matcap = t.matcap, this.map = t.map, this.bumpMap =
							t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this
							.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this
							.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale,
							this.displacementBias = t.displacementBias, this.alphaMap = t.alphaMap, this
							.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t
							.morphNormals, this
					}, qc.prototype = Object.create(ss.prototype), (qc.prototype.constructor = qc).prototype
					.isLineDashedMaterial = !0, qc.prototype.copy = function (t) {
						return ss.prototype.copy.call(this, t), this.scale = t.scale, this.dashSize = t.dashSize,
							this.gapSize = t.gapSize, this
					};
				var Xc = Object.freeze({
						ShadowMaterial: zc,
						SpriteMaterial: es,
						RawShaderMaterial: Uc,
						ShaderMaterial: Dr,
						PointsMaterial: us,
						MeshPhysicalMaterial: Fc,
						MeshStandardMaterial: Gc,
						MeshPhongMaterial: Hc,
						MeshToonMaterial: kc,
						MeshNormalMaterial: jc,
						MeshLambertMaterial: Vc,
						MeshDepthMaterial: yo,
						MeshDistanceMaterial: xo,
						MeshBasicMaterial: zr,
						MeshMatcapMaterial: Wc,
						LineDashedMaterial: qc,
						LineBasicMaterial: ss,
						Material: Ir
					}),
					Yc = {
						arraySlice: function (t, e, i) {
							return Yc.isTypedArray(t) ? new t.constructor(t.subarray(e, void 0 !== i ? i : t
								.length)) : t.slice(e, i)
						},
						convertArray: function (t, e, i) {
							return !t || !i && t.constructor === e ? t : "number" == typeof e
								.BYTES_PER_ELEMENT ? new e(t) : Array.prototype.slice.call(t)
						},
						isTypedArray: function (t) {
							return ArrayBuffer.isView(t) && !(t instanceof DataView)
						},
						getKeyframeOrder: function (i) {
							function t(t, e) {
								return i[t] - i[e]
							}
							for (var e = i.length, n = new Array(e), r = 0; r !== e; ++r) n[r] = r;
							return n.sort(t), n
						},
						sortedArray: function (t, e, i) {
							for (var n = t.length, r = new t.constructor(n), a = 0, o = 0; o !== n; ++a)
								for (var s = i[a] * e, c = 0; c !== e; ++c) r[o++] = t[s + c];
							return r
						},
						flattenJSON: function (t, e, i, n) {
							for (var r = 1, a = t[0]; void 0 !== a && void 0 === a[n];) a = t[r++];
							if (void 0 !== a) {
								var o = a[n];
								if (void 0 !== o)
									if (Array.isArray(o))
										for (; void 0 !== (o = a[n]) && (e.push(a.time), i.push.apply(i, o)),
											void 0 !== (a = t[r++]););
									else if (void 0 !== o.toArray)
									for (; void 0 !== (o = a[n]) && (e.push(a.time), o.toArray(i, i.length)),
										void 0 !== (a = t[r++]););
								else
									for (; void 0 !== (o = a[n]) && (e.push(a.time), i.push(o)), void 0 !== (
											a = t[r++]););
							}
						}
					};

				function Jc(t, e, i, n) {
					this.parameterPositions = t, this._cachedIndex = 0, this.resultBuffer = void 0 !== n ? n :
						new e.constructor(i), this.sampleValues = e, this.valueSize = i
				}

				function Zc(t, e, i, n) {
					Jc.call(this, t, e, i, n), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -
						0, this._offsetNext = -0
				}

				function Qc(t, e, i, n) {
					Jc.call(this, t, e, i, n)
				}

				function Kc(t, e, i, n) {
					Jc.call(this, t, e, i, n)
				}

				function $c(t, e, i, n) {
					if (void 0 === t) throw new Error("THREE.KeyframeTrack: track name is undefined");
					if (void 0 === e || 0 === e.length) throw new Error(
						"THREE.KeyframeTrack: no keyframes in track named " + t);
					this.name = t, this.times = Yc.convertArray(e, this.TimeBufferType), this.values = Yc
						.convertArray(i, this.ValueBufferType), this.setInterpolation(n || this
							.DefaultInterpolation)
				}

				function th(t, e, i) {
					$c.call(this, t, e, i)
				}

				function eh(t, e, i, n) {
					$c.call(this, t, e, i, n)
				}

				function ih(t, e, i, n) {
					$c.call(this, t, e, i, n)
				}

				function nh(t, e, i, n) {
					Jc.call(this, t, e, i, n)
				}

				function rh(t, e, i, n) {
					$c.call(this, t, e, i, n)
				}

				function ah(t, e, i, n) {
					$c.call(this, t, e, i, n)
				}

				function oh(t, e, i, n) {
					$c.call(this, t, e, i, n)
				}

				function sh(t, e, i) {
					this.name = t, this.tracks = i, this.duration = void 0 !== e ? e : -1, this.uuid = oi
						.generateUUID(), this.duration < 0 && this.resetDuration()
				}

				function ch(t) {
					switch (t.toLowerCase()) {
						case "scalar":
						case "double":
						case "float":
						case "number":
						case "integer":
							return ih;
						case "vector":
						case "vector2":
						case "vector3":
						case "vector4":
							return oh;
						case "color":
							return eh;
						case "quaternion":
							return rh;
						case "bool":
						case "boolean":
							return th;
						case "string":
							return ah
					}
					throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + t)
				}

				function hh(t) {
					if (void 0 === t.type) throw new Error(
						"THREE.KeyframeTrack: track type undefined, can not parse");
					var e = ch(t.type);
					if (void 0 === t.times) {
						var i = [],
							n = [];
						Yc.flattenJSON(t.keys, i, n, "value"), t.times = i, t.values = n
					}
					return void 0 !== e.parse ? e.parse(t) : new e(t.name, t.times, t.values, t.interpolation)
				}
				Object.assign(Jc.prototype, {
					evaluate: function (t) {
						var e = this.parameterPositions,
							i = this._cachedIndex,
							n = e[i],
							r = e[i - 1];
						t: {
							e: {
								var a;i: {
									n: if (!(t < n)) {
										for (var o = i + 2;;) {
											if (void 0 === n) {
												if (t < r) break n;
												return i = e.length, this._cachedIndex = i,
													this.afterEnd_(i - 1, t, r)
											}
											if (i === o) break;
											if (r = n, t < (n = e[++i])) break e
										}
										a = e.length;
										break i
									}if (r <= t) break t;
									var s = e[1];t < s && (i = 2, r = s);
									for (o = i - 2;;) {
										if (void 0 === r) return this._cachedIndex = 0, this
											.beforeStart_(0, t, n);
										if (i === o) break;
										if (n = r, (r = e[--i - 1]) <= t) break e
									}
									a = i,
									i = 0
								}
								for (; i < a;) {
									var c = i + a >>> 1;
									t < e[c] ? a = c : i = c + 1
								}
								if (n = e[i], void 0 === (r = e[i - 1])) return this
									._cachedIndex = 0,
								this.beforeStart_(0, t, n);
								if (void 0 === n) return i = e.length,
								this._cachedIndex = i,
								this.afterEnd_(i - 1, r, t)
							}
							this._cachedIndex = i,
							this.intervalChanged_(i, r, n)
						}
						return this.interpolate_(i, r, t, n)
					},
					settings: null,
					DefaultSettings_: {},
					getSettings_: function () {
						return this.settings || this.DefaultSettings_
					},
					copySampleValue_: function (t) {
						for (var e = this.resultBuffer, i = this.sampleValues, n = this.valueSize, r =
								t * n, a = 0; a !== n; ++a) e[a] = i[r + a];
						return e
					},
					interpolate_: function () {
						throw new Error("call to abstract method")
					},
					intervalChanged_: function () {}
				}), Object.assign(Jc.prototype, {
					beforeStart_: Jc.prototype.copySampleValue_,
					afterEnd_: Jc.prototype.copySampleValue_
				}), Zc.prototype = Object.assign(Object.create(Jc.prototype), {
					constructor: Zc,
					DefaultSettings_: {
						endingStart: ke,
						endingEnd: ke
					},
					intervalChanged_: function (t, e, i) {
						var n = this.parameterPositions,
							r = t - 2,
							a = t + 1,
							o = n[r],
							s = n[a];
						if (void 0 === o) switch (this.getSettings_().endingStart) {
							case je:
								r = t, o = 2 * e - i;
								break;
							case Ve:
								o = e + n[r = n.length - 2] - n[r + 1];
								break;
							default:
								r = t, o = i
						}
						if (void 0 === s) switch (this.getSettings_().endingEnd) {
							case je:
								a = t, s = 2 * i - e;
								break;
							case Ve:
								s = i + n[a = 1] - n[0];
								break;
							default:
								a = t - 1, s = e
						}
						var c = .5 * (i - e),
							h = this.valueSize;
						this._weightPrev = c / (e - o), this._weightNext = c / (s - i), this
							._offsetPrev = r * h, this._offsetNext = a * h
					},
					interpolate_: function (t, e, i, n) {
						for (var r = this.resultBuffer, a = this.sampleValues, o = this.valueSize, s =
								t * o, c = s - o, h = this._offsetPrev, l = this._offsetNext, u = this
								._weightPrev, p = this._weightNext, d = (i - e) / (n - e), f = d * d,
								m = f * d, g = -u * m + 2 * u * f - u * d, v = (1 + u) * m + (-1.5 -
									2 * u) * f + (-.5 + u) * d + 1, y = (-1 - p) * m + (1.5 + p) * f +
								.5 * d, x = p * m - p * f, b = 0; b !== o; ++b) r[b] = g * a[h + b] +
							v * a[c + b] + y * a[s + b] + x * a[l + b];
						return r
					}
				}), Qc.prototype = Object.assign(Object.create(Jc.prototype), {
					constructor: Qc,
					interpolate_: function (t, e, i, n) {
						for (var r = this.resultBuffer, a = this.sampleValues, o = this.valueSize, s =
								t * o, c = s - o, h = (i - e) / (n - e), l = 1 - h, u = 0; u !== o; ++
							u) r[u] = a[c + u] * l + a[s + u] * h;
						return r
					}
				}), Kc.prototype = Object.assign(Object.create(Jc.prototype), {
					constructor: Kc,
					interpolate_: function (t) {
						return this.copySampleValue_(t - 1)
					}
				}), Object.assign($c, {
					toJSON: function (t) {
						var e, i = t.constructor;
						if (void 0 !== i.toJSON) e = i.toJSON(t);
						else {
							e = {
								name: t.name,
								times: Yc.convertArray(t.times, Array),
								values: Yc.convertArray(t.values, Array)
							};
							var n = t.getInterpolation();
							n !== t.DefaultInterpolation && (e.interpolation = n)
						}
						return e.type = t.ValueTypeName, e
					}
				}), Object.assign($c.prototype, {
					constructor: $c,
					TimeBufferType: Float32Array,
					ValueBufferType: Float32Array,
					DefaultInterpolation: Fe,
					InterpolantFactoryMethodDiscrete: function (t) {
						return new Kc(this.times, this.values, this.getValueSize(), t)
					},
					InterpolantFactoryMethodLinear: function (t) {
						return new Qc(this.times, this.values, this.getValueSize(), t)
					},
					InterpolantFactoryMethodSmooth: function (t) {
						return new Zc(this.times, this.values, this.getValueSize(), t)
					},
					setInterpolation: function (t) {
						var e;
						switch (t) {
							case Ge:
								e = this.InterpolantFactoryMethodDiscrete;
								break;
							case Fe:
								e = this.InterpolantFactoryMethodLinear;
								break;
							case He:
								e = this.InterpolantFactoryMethodSmooth
						}
						if (void 0 !== e) return this.createInterpolant = e, this;
						var i = "unsupported interpolation for " + this.ValueTypeName +
							" keyframe track named " + this.name;
						if (void 0 === this.createInterpolant) {
							if (t === this.DefaultInterpolation) throw new Error(i);
							this.setInterpolation(this.DefaultInterpolation)
						}
						return console.warn("THREE.KeyframeTrack:", i), this
					},
					getInterpolation: function () {
						switch (this.createInterpolant) {
							case this.InterpolantFactoryMethodDiscrete:
								return Ge;
							case this.InterpolantFactoryMethodLinear:
								return Fe;
							case this.InterpolantFactoryMethodSmooth:
								return He
						}
					},
					getValueSize: function () {
						return this.values.length / this.times.length
					},
					shift: function (t) {
						if (0 !== t)
							for (var e = this.times, i = 0, n = e.length; i !== n; ++i) e[i] += t;
						return this
					},
					scale: function (t) {
						if (1 !== t)
							for (var e = this.times, i = 0, n = e.length; i !== n; ++i) e[i] *= t;
						return this
					},
					trim: function (t, e) {
						for (var i = this.times, n = i.length, r = 0, a = n - 1; r !== n && i[r] < t;)
							++r;
						for (; - 1 !== a && i[a] > e;) --a;
						if (++a, 0 !== r || a !== n) {
							a <= r && (r = (a = Math.max(a, 1)) - 1);
							var o = this.getValueSize();
							this.times = Yc.arraySlice(i, r, a), this.values = Yc.arraySlice(this
								.values, r * o, a * o)
						}
						return this
					},
					validate: function () {
						var t = !0,
							e = this.getValueSize();
						e - Math.floor(e) != 0 && (console.error(
								"THREE.KeyframeTrack: Invalid value size in track.", this), t = !
							1);
						var i = this.times,
							n = this.values,
							r = i.length;
						0 === r && (console.error("THREE.KeyframeTrack: Track is empty.", this), t = !
							1);
						for (var a = null, o = 0; o !== r; o++) {
							var s = i[o];
							if ("number" == typeof s && isNaN(s)) {
								console.error("THREE.KeyframeTrack: Time is not a valid number.",
									this, o, s), t = !1;
								break
							}
							if (null !== a && s < a) {
								console.error("THREE.KeyframeTrack: Out of order keys.", this, o, s,
									a), t = !1;
								break
							}
							a = s
						}
						if (void 0 !== n && Yc.isTypedArray(n)) {
							o = 0;
							for (var c = n.length; o !== c; ++o) {
								var h = n[o];
								if (isNaN(h)) {
									console.error("THREE.KeyframeTrack: Value is not a valid number.",
										this, o, h), t = !1;
									break
								}
							}
						}
						return t
					},
					optimize: function () {
						for (var t = this.times, e = this.values, i = this.getValueSize(), n = this
								.getInterpolation() === He, r = 1, a = t.length - 1, o = 1; o < a; ++
							o) {
							var s = !1,
								c = t[o];
							if (c !== t[o + 1] && (1 !== o || c !== c[0]))
								if (n) s = !0;
								else
									for (var h = o * i, l = h - i, u = h + i, p = 0; p !== i; ++p) {
										var d = e[h + p];
										if (d !== e[l + p] || d !== e[u + p]) {
											s = !0;
											break
										}
									}
							if (s) {
								if (o !== r) {
									t[r] = t[o];
									var f = o * i,
										m = r * i;
									for (p = 0; p !== i; ++p) e[m + p] = e[f + p]
								}++r
							}
						}
						if (0 < a) {
							t[r] = t[a];
							for (f = a * i, m = r * i, p = 0; p !== i; ++p) e[m + p] = e[f + p];
							++r
						}
						return r !== t.length && (this.times = Yc.arraySlice(t, 0, r), this.values =
							Yc.arraySlice(e, 0, r * i)), this
					}
				}), th.prototype = Object.assign(Object.create($c.prototype), {
					constructor: th,
					ValueTypeName: "bool",
					ValueBufferType: Array,
					DefaultInterpolation: Ge,
					InterpolantFactoryMethodLinear: void 0,
					InterpolantFactoryMethodSmooth: void 0
				}), eh.prototype = Object.assign(Object.create($c.prototype), {
					constructor: eh,
					ValueTypeName: "color"
				}), ih.prototype = Object.assign(Object.create($c.prototype), {
					constructor: ih,
					ValueTypeName: "number"
				}), nh.prototype = Object.assign(Object.create(Jc.prototype), {
					constructor: nh,
					interpolate_: function (t, e, i, n) {
						for (var r = this.resultBuffer, a = this.sampleValues, o = this.valueSize, s =
								t * o, c = (i - e) / (n - e), h = s + o; s !== h; s += 4) hi
							.slerpFlat(r, 0, a, s - o, a, s, c);
						return r
					}
				}), rh.prototype = Object.assign(Object.create($c.prototype), {
					constructor: rh,
					ValueTypeName: "quaternion",
					DefaultInterpolation: Fe,
					InterpolantFactoryMethodLinear: function (t) {
						return new nh(this.times, this.values, this.getValueSize(), t)
					},
					InterpolantFactoryMethodSmooth: void 0
				}), ah.prototype = Object.assign(Object.create($c.prototype), {
					constructor: ah,
					ValueTypeName: "string",
					ValueBufferType: Array,
					DefaultInterpolation: Ge,
					InterpolantFactoryMethodLinear: void 0,
					InterpolantFactoryMethodSmooth: void 0
				}), oh.prototype = Object.assign(Object.create($c.prototype), {
					constructor: oh,
					ValueTypeName: "vector"
				}), Object.assign(sh, {
					parse: function (t) {
						for (var e = [], i = t.tracks, n = 1 / (t.fps || 1), r = 0, a = i
							.length; r !== a; ++r) e.push(hh(i[r]).scale(n));
						return new sh(t.name, t.duration, e)
					},
					toJSON: function (t) {
						for (var e = [], i = t.tracks, n = {
								name: t.name,
								duration: t.duration,
								tracks: e,
								uuid: t.uuid
							}, r = 0, a = i.length; r !== a; ++r) e.push($c.toJSON(i[r]));
						return n
					},
					CreateFromMorphTargetSequence: function (t, e, i, n) {
						for (var r = e.length, a = [], o = 0; o < r; o++) {
							var s = [],
								c = [];
							s.push((o + r - 1) % r, o, (o + 1) % r), c.push(0, 1, 0);
							var h = Yc.getKeyframeOrder(s);
							s = Yc.sortedArray(s, 1, h), c = Yc.sortedArray(c, 1, h), n || 0 !== s[
								0] || (s.push(r), c.push(c[0])), a.push(new ih(
									".morphTargetInfluences[" + e[o].name + "]", s, c).scale(1 /
									i))
						}
						return new sh(t, -1, a)
					},
					findByName: function (t, e) {
						var i = t;
						if (!Array.isArray(t)) {
							var n = t;
							i = n.geometry && n.geometry.animations || n.animations
						}
						for (var r = 0; r < i.length; r++)
							if (i[r].name === e) return i[r];
						return null
					},
					CreateClipsFromMorphTargetSequences: function (t, e, i) {
						for (var n = {}, r = /^([\w-]*?)([\d]+)$/, a = 0, o = t.length; a < o; a++) {
							var s = t[a],
								c = s.name.match(r);
							if (c && 1 < c.length) {
								var h = n[u = c[1]];
								h || (n[u] = h = []), h.push(s)
							}
						}
						var l = [];
						for (var u in n) l.push(sh.CreateFromMorphTargetSequence(u, n[u], e, i));
						return l
					},
					parseAnimation: function (t, e) {
						if (!t) return console.error(
							"THREE.AnimationClip: No animation in JSONLoader data."), null;
						for (var i = function (t, e, i, n, r) {
									if (0 !== i.length) {
										var a = [],
											o = [];
										Yc.flattenJSON(i, a, o, n), 0 !== a.length && r.push(new t(e,
											a, o))
									}
								}, n = [], r = t.name || "default", a = t.length || -1, o = t.fps ||
								30, s = t.hierarchy || [], c = 0; c < s.length; c++) {
							var h = s[c].keys;
							if (h && 0 !== h.length)
								if (h[0].morphTargets) {
									for (var l = {}, u = 0; u < h.length; u++)
										if (h[u].morphTargets)
											for (var p = 0; p < h[u].morphTargets.length; p++) l[h[u]
												.morphTargets[p]] = -1;
									for (var d in l) {
										var f = [],
											m = [];
										for (p = 0; p !== h[u].morphTargets.length; ++p) {
											var g = h[u];
											f.push(g.time), m.push(g.morphTarget === d ? 1 : 0)
										}
										n.push(new ih(".morphTargetInfluence[" + d + "]", f, m))
									}
									a = l.length * (o || 1)
								} else {
									var v = ".bones[" + e[c].name + "]";
									i(oh, v + ".position", h, "pos", n), i(rh, v + ".quaternion", h,
										"rot", n), i(oh, v + ".scale", h, "scl", n)
								}
						}
						return 0 === n.length ? null : new sh(r, a, n)
					}
				}), Object.assign(sh.prototype, {
					resetDuration: function () {
						for (var t = 0, e = 0, i = this.tracks.length; e !== i; ++e) {
							var n = this.tracks[e];
							t = Math.max(t, n.times[n.times.length - 1])
						}
						return this.duration = t, this
					},
					trim: function () {
						for (var t = 0; t < this.tracks.length; t++) this.tracks[t].trim(0, this
							.duration);
						return this
					},
					validate: function () {
						for (var t = !0, e = 0; e < this.tracks.length; e++) t = t && this.tracks[e]
							.validate();
						return t
					},
					optimize: function () {
						for (var t = 0; t < this.tracks.length; t++) this.tracks[t].optimize();
						return this
					}
				});
				var lh = {
					enabled: !1,
					files: {},
					add: function (t, e) {
						!1 !== this.enabled && (this.files[t] = e)
					},
					get: function (t) {
						if (!1 !== this.enabled) return this.files[t]
					},
					remove: function (t) {
						delete this.files[t]
					},
					clear: function () {
						this.files = {}
					}
				};

				function uh(t, e, i) {
					var n = this,
						r = !1,
						a = 0,
						o = 0,
						s = void 0;
					this.onStart = void 0, this.onLoad = t, this.onProgress = e, this.onError = i, this
						.itemStart = function (t) {
							o++, !1 === r && void 0 !== n.onStart && n.onStart(t, a, o), r = !0
						}, this.itemEnd = function (t) {
							a++, void 0 !== n.onProgress && n.onProgress(t, a, o), a === o && (r = !1, void 0 !==
								n.onLoad && n.onLoad())
						}, this.itemError = function (t) {
							void 0 !== n.onError && n.onError(t)
						}, this.resolveURL = function (t) {
							return s ? s(t) : t
						}, this.setURLModifier = function (t) {
							return s = t, this
						}
				}
				var ph = new uh,
					dh = {};

				function fh(t) {
					this.manager = void 0 !== t ? t : ph
				}

				function mh(t) {
					this.manager = void 0 !== t ? t : ph
				}

				function gh(t) {
					this.manager = void 0 !== t ? t : ph, this._parser = null
				}

				function vh(t) {
					this.manager = void 0 !== t ? t : ph, this._parser = null
				}

				function yh(t) {
					this.manager = void 0 !== t ? t : ph
				}

				function xh(t) {
					this.manager = void 0 !== t ? t : ph
				}

				function bh(t) {
					this.manager = void 0 !== t ? t : ph
				}

				function wh() {
					this.type = "Curve", this.arcLengthDivisions = 200
				}

				function _h(t, e, i, n, r, a, o, s) {
					wh.call(this), this.type = "EllipseCurve", this.aX = t || 0, this.aY = e || 0, this.xRadius =
						i || 1, this.yRadius = n || 1, this.aStartAngle = r || 0, this.aEndAngle = a || 2 * Math
						.PI, this.aClockwise = o || !1, this.aRotation = s || 0
				}

				function Mh(t, e, i, n, r, a) {
					_h.call(this, t, e, i, i, n, r, a), this.type = "ArcCurve"
				}

				function Sh() {
					var r = 0,
						a = 0,
						o = 0,
						s = 0;

					function h(t, e, i, n) {
						o = -3 * (r = t) + 3 * e - 2 * (a = i) - n, s = 2 * t - 2 * e + i + n
					}
					return {
						initCatmullRom: function (t, e, i, n, r) {
							h(e, i, r * (i - t), r * (n - e))
						},
						initNonuniformCatmullRom: function (t, e, i, n, r, a, o) {
							var s = (e - t) / r - (i - t) / (r + a) + (i - e) / a,
								c = (i - e) / a - (n - e) / (a + o) + (n - i) / o;
							h(e, i, s *= a, c *= a)
						},
						calc: function (t) {
							var e = t * t;
							return r + a * t + o * e + s * (e * t)
						}
					}
				}
				Object.assign(fh.prototype, {
						load: function (o, t, e, i) {
							void 0 === o && (o = ""), void 0 !== this.path && (o = this.path + o), o =
								this.manager.resolveURL(o);
							var s = this,
								n = lh.get(o);
							if (void 0 !== n) return s.manager.itemStart(o), setTimeout(function () {
								t && t(n), s.manager.itemEnd(o)
							}, 0), n;
							if (void 0 === dh[o]) {
								var r = /^data:(.*?)(;base64)?,(.*)$/,
									a = o.match(r);
								if (a) {
									var c = a[1],
										h = !!a[2],
										l = a[3];
									l = decodeURIComponent(l), h && (l = atob(l));
									try {
										var u, p = (this.responseType || "").toLowerCase();
										switch (p) {
											case "arraybuffer":
											case "blob":
												for (var d = new Uint8Array(l.length), f = 0; f < l
													.length; f++) d[f] = l.charCodeAt(f);
												u = "blob" === p ? new Blob([d.buffer], {
													type: c
												}) : d.buffer;
												break;
											case "document":
												var m = new DOMParser;
												u = m.parseFromString(l, c);
												break;
											case "json":
												u = JSON.parse(l);
												break;
											default:
												u = l
										}
										setTimeout(function () {
											t && t(u), s.manager.itemEnd(o)
										}, 0)
									} catch (t) {
										setTimeout(function () {
											i && i(t), s.manager.itemError(o), s.manager.itemEnd(
												o)
										}, 0)
									}
								} else {
									dh[o] = [], dh[o].push({
										onLoad: t,
										onProgress: e,
										onError: i
									});
									var g = new XMLHttpRequest;
									for (var v in g.open("GET", o, !0), g.addEventListener("load",
												function (t) {
													var e = this.response;
													lh.add(o, e);
													var i = dh[o];
													if (delete dh[o], 200 === this.status || 0 === this
														.status) {
														0 === this.status && console.warn(
															"THREE.FileLoader: HTTP Status 0 received."
															);
														for (var n = 0, r = i.length; n < r; n++) {
															(a = i[n]).onLoad && a.onLoad(e)
														}
														s.manager.itemEnd(o)
													} else {
														for (n = 0, r = i.length; n < r; n++) {
															var a;
															(a = i[n]).onError && a.onError(t)
														}
														s.manager.itemError(o), s.manager.itemEnd(o)
													}
												}, !1), g.addEventListener("progress", function (t) {
												for (var e = dh[o], i = 0, n = e.length; i < n; i++) {
													var r = e[i];
													r.onProgress && r.onProgress(t)
												}
											}, !1), g.addEventListener("error", function (t) {
												var e = dh[o];
												delete dh[o];
												for (var i = 0, n = e.length; i < n; i++) {
													var r = e[i];
													r.onError && r.onError(t)
												}
												s.manager.itemError(o), s.manager.itemEnd(o)
											}, !1), g.addEventListener("abort", function (t) {
												var e = dh[o];
												delete dh[o];
												for (var i = 0, n = e.length; i < n; i++) {
													var r = e[i];
													r.onError && r.onError(t)
												}
												s.manager.itemError(o), s.manager.itemEnd(o)
											}, !1), void 0 !== this.responseType && (g.responseType = this
												.responseType), void 0 !== this.withCredentials && (g
												.withCredentials = this.withCredentials), g
											.overrideMimeType && g.overrideMimeType(void 0 !== this
												.mimeType ? this.mimeType : "text/plain"), this
											.requestHeader) g.setRequestHeader(v, this.requestHeader[v]);
									g.send(null)
								}
								return s.manager.itemStart(o), g
							}
							dh[o].push({
								onLoad: t,
								onProgress: e,
								onError: i
							})
						},
						setPath: function (t) {
							return this.path = t, this
						},
						setResponseType: function (t) {
							return this.responseType = t, this
						},
						setWithCredentials: function (t) {
							return this.withCredentials = t, this
						},
						setMimeType: function (t) {
							return this.mimeType = t, this
						},
						setRequestHeader: function (t) {
							return this.requestHeader = t, this
						}
					}), Object.assign(mh.prototype, {
						load: function (t, e, i, n) {
							var r = this,
								a = new fh(r.manager);
							a.setPath(r.path), a.load(t, function (t) {
								e(r.parse(JSON.parse(t)))
							}, i, n)
						},
						parse: function (t, e) {
							for (var i = [], n = 0; n < t.length; n++) {
								var r = sh.parse(t[n]);
								i.push(r)
							}
							e(i)
						},
						setPath: function (t) {
							return this.path = t, this
						}
					}), Object.assign(gh.prototype, {
						load: function (t, a, e, n) {
							var o = this,
								s = [],
								c = new fs;
							c.image = s;
							var r = new fh(this.manager);

							function i(i) {
								r.load(t[i], function (t) {
									var e = o._parser(t, !0);
									s[i] = {
										width: e.width,
										height: e.height,
										format: e.format,
										mipmaps: e.mipmaps
									}, 6 === (h += 1) && (1 === e.mipmapCount && (c
											.minFilter = Ft), c.format = e.format, c
										.needsUpdate = !0, a && a(c))
								}, e, n)
							}
							if (r.setPath(this.path), r.setResponseType("arraybuffer"), Array.isArray(t))
								for (var h = 0, l = 0, u = t.length; l < u; ++l) i(l);
							else r.load(t, function (t) {
								var e = o._parser(t, !0);
								if (e.isCubemap)
									for (var i = e.mipmaps.length / e.mipmapCount, n = 0; n <
										i; n++) {
										s[n] = {
											mipmaps: []
										};
										for (var r = 0; r < e.mipmapCount; r++) s[n].mipmaps.push(
												e.mipmaps[n * e.mipmapCount + r]), s[n].format = e
											.format, s[n].width = e.width, s[n].height = e.height
									} else c.image.width = e.width, c.image.height = e.height, c
										.mipmaps = e.mipmaps;
								1 === e.mipmapCount && (c.minFilter = Ft), c.format = e.format, c
									.needsUpdate = !0, a && a(c)
							}, e, n);
							return c
						},
						setPath: function (t) {
							return this.path = t, this
						}
					}), Object.assign(vh.prototype, {
						load: function (t, i, e, n) {
							var r = this,
								a = new Di,
								o = new fh(this.manager);
							return o.setResponseType("arraybuffer"), o.setPath(this.path), o.load(t,
								function (t) {
									var e = r._parser(t);
									e && (void 0 !== e.image ? a.image = e.image : void 0 !== e
										.data && (a.image.width = e.width, a.image.height = e
											.height, a.image.data = e.data), a.wrapS = void 0 !==
										e.wrapS ? e.wrapS : Bt, a.wrapT = void 0 !== e.wrapT ? e
										.wrapT : Bt, a.magFilter = void 0 !== e.magFilter ? e
										.magFilter : Ft, a.minFilter = void 0 !== e.minFilter ? e
										.minFilter : Wt, a.anisotropy = void 0 !== e.anisotropy ?
										e.anisotropy : 1, void 0 !== e.format && (a.format = e
											.format), void 0 !== e.type && (a.type = e.type),
										void 0 !== e.mipmaps && (a.mipmaps = e.mipmaps), 1 === e
										.mipmapCount && (a.minFilter = Ft), a.needsUpdate = !0,
										i && i(a, e))
								}, e, n), a
						},
						setPath: function (t) {
							return this.path = t, this
						}
					}), Object.assign(yh.prototype, {
						crossOrigin: "anonymous",
						load: function (e, t, i, n) {
							void 0 === e && (e = ""), void 0 !== this.path && (e = this.path + e), e =
								this.manager.resolveURL(e);
							var r = this,
								a = lh.get(e);
							if (void 0 !== a) return r.manager.itemStart(e), setTimeout(function () {
								t && t(a), r.manager.itemEnd(e)
							}, 0), a;
							var o = document.createElement("img");

							function s() {
								o.removeEventListener("load", s, !1), o.removeEventListener("error", c, !
									1), lh.add(e, this), t && t(this), r.manager.itemEnd(e)
							}

							function c(t) {
								o.removeEventListener("load", s, !1), o.removeEventListener("error", c, !
									1), n && n(t), r.manager.itemError(e), r.manager.itemEnd(e)
							}
							return o.addEventListener("load", s, !1), o.addEventListener("error", c, !1),
								"data:" !== e.substr(0, 5) && void 0 !== this.crossOrigin && (o
									.crossOrigin = this.crossOrigin), r.manager.itemStart(e), o.src = e, o
						},
						setCrossOrigin: function (t) {
							return this.crossOrigin = t, this
						},
						setPath: function (t) {
							return this.path = t, this
						}
					}), Object.assign(xh.prototype, {
						crossOrigin: "anonymous",
						load: function (t, i, e, n) {
							var r = new Zr,
								a = new yh(this.manager);
							a.setCrossOrigin(this.crossOrigin), a.setPath(this.path);
							var o = 0;

							function s(e) {
								a.load(t[e], function (t) {
									r.images[e] = t, 6 === ++o && (r.needsUpdate = !0, i && i(r))
								}, void 0, n)
							}
							for (var c = 0; c < t.length; ++c) s(c);
							return r
						},
						setCrossOrigin: function (t) {
							return this.crossOrigin = t, this
						},
						setPath: function (t) {
							return this.path = t, this
						}
					}), Object.assign(bh.prototype, {
						crossOrigin: "anonymous",
						load: function (i, n, t, e) {
							var r = new Ci,
								a = new yh(this.manager);
							return a.setCrossOrigin(this.crossOrigin), a.setPath(this.path), a.load(i,
								function (t) {
									r.image = t;
									var e = 0 < i.search(/\.jpe?g($|\?)/i) || 0 === i.search(
										/^data\:image\/jpeg/);
									r.format = e ? ae : oe, r.needsUpdate = !0, void 0 !== n && n(r)
								}, t, e), r
						},
						setCrossOrigin: function (t) {
							return this.crossOrigin = t, this
						},
						setPath: function (t) {
							return this.path = t, this
						}
					}), Object.assign(wh.prototype, {
						getPoint: function () {
							return console.warn("THREE.Curve: .getPoint() not implemented."), null
						},
						getPointAt: function (t, e) {
							var i = this.getUtoTmapping(t);
							return this.getPoint(i, e)
						},
						getPoints: function (t) {
							void 0 === t && (t = 5);
							for (var e = [], i = 0; i <= t; i++) e.push(this.getPoint(i / t));
							return e
						},
						getSpacedPoints: function (t) {
							void 0 === t && (t = 5);
							for (var e = [], i = 0; i <= t; i++) e.push(this.getPointAt(i / t));
							return e
						},
						getLength: function () {
							var t = this.getLengths();
							return t[t.length - 1]
						},
						getLengths: function (t) {
							if (void 0 === t && (t = this.arcLengthDivisions), this.cacheArcLengths &&
								this.cacheArcLengths.length === t + 1 && !this.needsUpdate) return this
								.cacheArcLengths;
							this.needsUpdate = !1;
							var e, i, n = [],
								r = this.getPoint(0),
								a = 0;
							for (n.push(0), i = 1; i <= t; i++) a += (e = this.getPoint(i / t))
								.distanceTo(r), n.push(a), r = e;
							return this.cacheArcLengths = n
						},
						updateArcLengths: function () {
							this.needsUpdate = !0, this.getLengths()
						},
						getUtoTmapping: function (t, e) {
							var i, n = this.getLengths(),
								r = 0,
								a = n.length;
							i = e || t * n[a - 1];
							for (var o, s = 0, c = a - 1; s <= c;)
								if ((o = n[r = Math.floor(s + (c - s) / 2)] - i) < 0) s = r + 1;
								else {
									if (!(0 < o)) {
										c = r;
										break
									}
									c = r - 1
								} if (n[r = c] === i) return r / (a - 1);
							var h = n[r];
							return (r + (i - h) / (n[r + 1] - h)) / (a - 1)
						},
						getTangent: function (t) {
							var e = 1e-4,
								i = t - e,
								n = t + e;
							i < 0 && (i = 0), 1 < n && (n = 1);
							var r = this.getPoint(i);
							return this.getPoint(n).clone().sub(r).normalize()
						},
						getTangentAt: function (t) {
							var e = this.getUtoTmapping(t);
							return this.getTangent(e)
						},
						computeFrenetFrames: function (t, e) {
							var i, n, r, a = new li,
								o = [],
								s = [],
								c = [],
								h = new li,
								l = new ci;
							for (i = 0; i <= t; i++) n = i / t, o[i] = this.getTangentAt(n), o[i]
								.normalize();
							s[0] = new li, c[0] = new li;
							var u = Number.MAX_VALUE,
								p = Math.abs(o[0].x),
								d = Math.abs(o[0].y),
								f = Math.abs(o[0].z);
							for (p <= u && (u = p, a.set(1, 0, 0)), d <= u && (u = d, a.set(0, 1, 0)),
								f <= u && a.set(0, 0, 1), h.crossVectors(o[0], a).normalize(), s[0]
								.crossVectors(o[0], h), c[0].crossVectors(o[0], s[0]), i = 1; i <= t; i++)
								s[i] = s[i - 1].clone(), c[i] = c[i - 1].clone(), h.crossVectors(o[i - 1],
									o[i]), h.length() > Number.EPSILON && (h.normalize(), r = Math.acos(oi
									.clamp(o[i - 1].dot(o[i]), -1, 1)), s[i].applyMatrix4(l
									.makeRotationAxis(h, r))), c[i].crossVectors(o[i], s[i]);
							if (!0 === e)
								for (r = Math.acos(oi.clamp(s[0].dot(s[t]), -1, 1)), r /= t, 0 < o[0].dot(
										h.crossVectors(s[0], s[t])) && (r = -r), i = 1; i <= t; i++) s[i]
									.applyMatrix4(l.makeRotationAxis(o[i], r * i)), c[i].crossVectors(o[
										i], s[i]);
							return {
								tangents: o,
								normals: s,
								binormals: c
							}
						},
						clone: function () {
							return (new this.constructor).copy(this)
						},
						copy: function (t) {
							return this.arcLengthDivisions = t.arcLengthDivisions, this
						},
						toJSON: function () {
							var t = {
								metadata: {
									version: 4.5,
									type: "Curve",
									generator: "Curve.toJSON"
								}
							};
							return t.arcLengthDivisions = this.arcLengthDivisions, t.type = this.type, t
						},
						fromJSON: function (t) {
							return this.arcLengthDivisions = t.arcLengthDivisions, this
						}
					}), _h.prototype = Object.create(wh.prototype), (_h.prototype.constructor = _h).prototype
					.isEllipseCurve = !0, _h.prototype.getPoint = function (t, e) {
						for (var i = e || new si, n = 2 * Math.PI, r = this.aEndAngle - this.aStartAngle, a = Math
								.abs(r) < Number.EPSILON; r < 0;) r += n;
						for (; n < r;) r -= n;
						r < Number.EPSILON && (r = a ? 0 : n), !0 !== this.aClockwise || a || (r === n ? r = -n :
							r -= n);
						var o = this.aStartAngle + t * r,
							s = this.aX + this.xRadius * Math.cos(o),
							c = this.aY + this.yRadius * Math.sin(o);
						if (0 !== this.aRotation) {
							var h = Math.cos(this.aRotation),
								l = Math.sin(this.aRotation),
								u = s - this.aX,
								p = c - this.aY;
							s = u * h - p * l + this.aX, c = u * l + p * h + this.aY
						}
						return i.set(s, c)
					}, _h.prototype.copy = function (t) {
						return wh.prototype.copy.call(this, t), this.aX = t.aX, this.aY = t.aY, this.xRadius = t
							.xRadius, this.yRadius = t.yRadius, this.aStartAngle = t.aStartAngle, this.aEndAngle =
							t.aEndAngle, this.aClockwise = t.aClockwise, this.aRotation = t.aRotation, this
					}, _h.prototype.toJSON = function () {
						var t = wh.prototype.toJSON.call(this);
						return t.aX = this.aX, t.aY = this.aY, t.xRadius = this.xRadius, t.yRadius = this.yRadius,
							t.aStartAngle = this.aStartAngle, t.aEndAngle = this.aEndAngle, t.aClockwise = this
							.aClockwise, t.aRotation = this.aRotation, t
					}, _h.prototype.fromJSON = function (t) {
						return wh.prototype.fromJSON.call(this, t), this.aX = t.aX, this.aY = t.aY, this.xRadius =
							t.xRadius, this.yRadius = t.yRadius, this.aStartAngle = t.aStartAngle, this
							.aEndAngle = t.aEndAngle, this.aClockwise = t.aClockwise, this.aRotation = t
							.aRotation, this
					}, Mh.prototype = Object.create(_h.prototype), (Mh.prototype.constructor = Mh).prototype
					.isArcCurve = !0;
				var Eh = new li,
					Th = new Sh,
					Ah = new Sh,
					Lh = new Sh;

				function Ph(t, e, i, n) {
					wh.call(this), this.type = "CatmullRomCurve3", this.points = t || [], this.closed = e || !1,
						this.curveType = i || "centripetal", this.tension = n || .5
				}

				function Ch(t, e, i, n, r) {
					var a = .5 * (n - e),
						o = .5 * (r - i),
						s = t * t;
					return (2 * i - 2 * n + a + o) * (t * s) + (-3 * i + 3 * n - 2 * a - o) * s + a * t + i
				}

				function Rh(t, e) {
					var i = 1 - t;
					return i * i * e
				}

				function Oh(t, e) {
					return 2 * (1 - t) * t * e
				}

				function Ih(t, e) {
					return t * t * e
				}

				function Dh(t, e, i, n) {
					return Rh(t, e) + Oh(t, i) + Ih(t, n)
				}

				function Bh(t, e) {
					var i = 1 - t;
					return i * i * i * e
				}

				function Nh(t, e) {
					var i = 1 - t;
					return 3 * i * i * t * e
				}

				function zh(t, e) {
					return 3 * (1 - t) * t * t * e
				}

				function Uh(t, e) {
					return t * t * t * e
				}

				function Gh(t, e, i, n, r) {
					return Bh(t, e) + Nh(t, i) + zh(t, n) + Uh(t, r)
				}

				function Fh(t, e, i, n) {
					wh.call(this), this.type = "CubicBezierCurve", this.v0 = t || new si, this.v1 = e || new si,
						this.v2 = i || new si, this.v3 = n || new si
				}

				function Hh(t, e, i, n) {
					wh.call(this), this.type = "CubicBezierCurve3", this.v0 = t || new li, this.v1 = e || new li,
						this.v2 = i || new li, this.v3 = n || new li
				}

				function kh(t, e) {
					wh.call(this), this.type = "LineCurve", this.v1 = t || new si, this.v2 = e || new si
				}

				function jh(t, e) {
					wh.call(this), this.type = "LineCurve3", this.v1 = t || new li, this.v2 = e || new li
				}

				function Vh(t, e, i) {
					wh.call(this), this.type = "QuadraticBezierCurve", this.v0 = t || new si, this.v1 = e ||
						new si, this.v2 = i || new si
				}

				function Wh(t, e, i) {
					wh.call(this), this.type = "QuadraticBezierCurve3", this.v0 = t || new li, this.v1 = e ||
						new li, this.v2 = i || new li
				}

				function qh(t) {
					wh.call(this), this.type = "SplineCurve", this.points = t || []
				}
				Ph.prototype = Object.create(wh.prototype), (Ph.prototype.constructor = Ph).prototype
					.isCatmullRomCurve3 = !0, Ph.prototype.getPoint = function (t, e) {
						var i, n, r, a, o = e || new li,
							s = this.points,
							c = s.length,
							h = (c - (this.closed ? 0 : 1)) * t,
							l = Math.floor(h),
							u = h - l;
						if (this.closed ? l += 0 < l ? 0 : (Math.floor(Math.abs(l) / c) + 1) * c : 0 === u &&
							l === c - 1 && (l = c - 2, u = 1), i = this.closed || 0 < l ? s[(l - 1) % c] : (Eh
								.subVectors(s[0], s[1]).add(s[0]), Eh), n = s[l % c], r = s[(l + 1) % c], a = this
							.closed || l + 2 < c ? s[(l + 2) % c] : (Eh.subVectors(s[c - 1], s[c - 2]).add(s[c -
								1]), Eh), "centripetal" === this.curveType || "chordal" === this.curveType) {
							var p = "chordal" === this.curveType ? .5 : .25,
								d = Math.pow(i.distanceToSquared(n), p),
								f = Math.pow(n.distanceToSquared(r), p),
								m = Math.pow(r.distanceToSquared(a), p);
							f < 1e-4 && (f = 1), d < 1e-4 && (d = f), m < 1e-4 && (m = f), Th
								.initNonuniformCatmullRom(i.x, n.x, r.x, a.x, d, f, m), Ah
								.initNonuniformCatmullRom(i.y, n.y, r.y, a.y, d, f, m), Lh
								.initNonuniformCatmullRom(i.z, n.z, r.z, a.z, d, f, m)
						} else "catmullrom" === this.curveType && (Th.initCatmullRom(i.x, n.x, r.x, a.x, this
								.tension), Ah.initCatmullRom(i.y, n.y, r.y, a.y, this.tension), Lh
							.initCatmullRom(i.z, n.z, r.z, a.z, this.tension));
						return o.set(Th.calc(u), Ah.calc(u), Lh.calc(u)), o
					}, Ph.prototype.copy = function (t) {
						wh.prototype.copy.call(this, t), this.points = [];
						for (var e = 0, i = t.points.length; e < i; e++) {
							var n = t.points[e];
							this.points.push(n.clone())
						}
						return this.closed = t.closed, this.curveType = t.curveType, this.tension = t.tension,
							this
					}, Ph.prototype.toJSON = function () {
						var t = wh.prototype.toJSON.call(this);
						t.points = [];
						for (var e = 0, i = this.points.length; e < i; e++) {
							var n = this.points[e];
							t.points.push(n.toArray())
						}
						return t.closed = this.closed, t.curveType = this.curveType, t.tension = this.tension, t
					}, Ph.prototype.fromJSON = function (t) {
						wh.prototype.fromJSON.call(this, t), this.points = [];
						for (var e = 0, i = t.points.length; e < i; e++) {
							var n = t.points[e];
							this.points.push((new li).fromArray(n))
						}
						return this.closed = t.closed, this.curveType = t.curveType, this.tension = t.tension,
							this
					}, Fh.prototype = Object.create(wh.prototype), (Fh.prototype.constructor = Fh).prototype
					.isCubicBezierCurve = !0, Fh.prototype.getPoint = function (t, e) {
						var i = e || new si,
							n = this.v0,
							r = this.v1,
							a = this.v2,
							o = this.v3;
						return i.set(Gh(t, n.x, r.x, a.x, o.x), Gh(t, n.y, r.y, a.y, o.y)), i
					}, Fh.prototype.copy = function (t) {
						return wh.prototype.copy.call(this, t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2
							.copy(t.v2), this.v3.copy(t.v3), this
					}, Fh.prototype.toJSON = function () {
						var t = wh.prototype.toJSON.call(this);
						return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
							.v3 = this.v3.toArray(), t
					}, Fh.prototype.fromJSON = function (t) {
						return wh.prototype.fromJSON.call(this, t), this.v0.fromArray(t.v0), this.v1.fromArray(t
							.v1), this.v2.fromArray(t.v2), this.v3.fromArray(t.v3), this
					}, Hh.prototype = Object.create(wh.prototype), (Hh.prototype.constructor = Hh).prototype
					.isCubicBezierCurve3 = !0, Hh.prototype.getPoint = function (t, e) {
						var i = e || new li,
							n = this.v0,
							r = this.v1,
							a = this.v2,
							o = this.v3;
						return i.set(Gh(t, n.x, r.x, a.x, o.x), Gh(t, n.y, r.y, a.y, o.y), Gh(t, n.z, r.z, a.z, o
							.z)), i
					}, Hh.prototype.copy = function (t) {
						return wh.prototype.copy.call(this, t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2
							.copy(t.v2), this.v3.copy(t.v3), this
					}, Hh.prototype.toJSON = function () {
						var t = wh.prototype.toJSON.call(this);
						return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
							.v3 = this.v3.toArray(), t
					}, Hh.prototype.fromJSON = function (t) {
						return wh.prototype.fromJSON.call(this, t), this.v0.fromArray(t.v0), this.v1.fromArray(t
							.v1), this.v2.fromArray(t.v2), this.v3.fromArray(t.v3), this
					}, kh.prototype = Object.create(wh.prototype), (kh.prototype.constructor = kh).prototype
					.isLineCurve = !0, kh.prototype.getPoint = function (t, e) {
						var i = e || new si;
						return 1 === t ? i.copy(this.v2) : (i.copy(this.v2).sub(this.v1), i.multiplyScalar(t).add(
							this.v1)), i
					}, kh.prototype.getPointAt = function (t, e) {
						return this.getPoint(t, e)
					}, kh.prototype.getTangent = function () {
						return this.v2.clone().sub(this.v1).normalize()
					}, kh.prototype.copy = function (t) {
						return wh.prototype.copy.call(this, t), this.v1.copy(t.v1), this.v2.copy(t.v2), this
					}, kh.prototype.toJSON = function () {
						var t = wh.prototype.toJSON.call(this);
						return t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
					}, kh.prototype.fromJSON = function (t) {
						return wh.prototype.fromJSON.call(this, t), this.v1.fromArray(t.v1), this.v2.fromArray(t
							.v2), this
					}, jh.prototype = Object.create(wh.prototype), (jh.prototype.constructor = jh).prototype
					.isLineCurve3 = !0, jh.prototype.getPoint = function (t, e) {
						var i = e || new li;
						return 1 === t ? i.copy(this.v2) : (i.copy(this.v2).sub(this.v1), i.multiplyScalar(t).add(
							this.v1)), i
					}, jh.prototype.getPointAt = function (t, e) {
						return this.getPoint(t, e)
					}, jh.prototype.copy = function (t) {
						return wh.prototype.copy.call(this, t), this.v1.copy(t.v1), this.v2.copy(t.v2), this
					}, jh.prototype.toJSON = function () {
						var t = wh.prototype.toJSON.call(this);
						return t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
					}, jh.prototype.fromJSON = function (t) {
						return wh.prototype.fromJSON.call(this, t), this.v1.fromArray(t.v1), this.v2.fromArray(t
							.v2), this
					}, Vh.prototype = Object.create(wh.prototype), (Vh.prototype.constructor = Vh).prototype
					.isQuadraticBezierCurve = !0, Vh.prototype.getPoint = function (t, e) {
						var i = e || new si,
							n = this.v0,
							r = this.v1,
							a = this.v2;
						return i.set(Dh(t, n.x, r.x, a.x), Dh(t, n.y, r.y, a.y)), i
					}, Vh.prototype.copy = function (t) {
						return wh.prototype.copy.call(this, t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2
							.copy(t.v2), this
					}, Vh.prototype.toJSON = function () {
						var t = wh.prototype.toJSON.call(this);
						return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
					}, Vh.prototype.fromJSON = function (t) {
						return wh.prototype.fromJSON.call(this, t), this.v0.fromArray(t.v0), this.v1.fromArray(t
							.v1), this.v2.fromArray(t.v2), this
					}, Wh.prototype = Object.create(wh.prototype), (Wh.prototype.constructor = Wh).prototype
					.isQuadraticBezierCurve3 = !0, Wh.prototype.getPoint = function (t, e) {
						var i = e || new li,
							n = this.v0,
							r = this.v1,
							a = this.v2;
						return i.set(Dh(t, n.x, r.x, a.x), Dh(t, n.y, r.y, a.y), Dh(t, n.z, r.z, a.z)), i
					}, Wh.prototype.copy = function (t) {
						return wh.prototype.copy.call(this, t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2
							.copy(t.v2), this
					}, Wh.prototype.toJSON = function () {
						var t = wh.prototype.toJSON.call(this);
						return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
					}, Wh.prototype.fromJSON = function (t) {
						return wh.prototype.fromJSON.call(this, t), this.v0.fromArray(t.v0), this.v1.fromArray(t
							.v1), this.v2.fromArray(t.v2), this
					}, qh.prototype = Object.create(wh.prototype), (qh.prototype.constructor = qh).prototype
					.isSplineCurve = !0, qh.prototype.getPoint = function (t, e) {
						var i = e || new si,
							n = this.points,
							r = (n.length - 1) * t,
							a = Math.floor(r),
							o = r - a,
							s = n[0 === a ? a : a - 1],
							c = n[a],
							h = n[a > n.length - 2 ? n.length - 1 : a + 1],
							l = n[a > n.length - 3 ? n.length - 1 : a + 2];
						return i.set(Ch(o, s.x, c.x, h.x, l.x), Ch(o, s.y, c.y, h.y, l.y)), i
					}, qh.prototype.copy = function (t) {
						wh.prototype.copy.call(this, t), this.points = [];
						for (var e = 0, i = t.points.length; e < i; e++) {
							var n = t.points[e];
							this.points.push(n.clone())
						}
						return this
					}, qh.prototype.toJSON = function () {
						var t = wh.prototype.toJSON.call(this);
						t.points = [];
						for (var e = 0, i = this.points.length; e < i; e++) {
							var n = this.points[e];
							t.points.push(n.toArray())
						}
						return t
					}, qh.prototype.fromJSON = function (t) {
						wh.prototype.fromJSON.call(this, t), this.points = [];
						for (var e = 0, i = t.points.length; e < i; e++) {
							var n = t.points[e];
							this.points.push((new si).fromArray(n))
						}
						return this
					};
				var Xh = Object.freeze({
					ArcCurve: Mh,
					CatmullRomCurve3: Ph,
					CubicBezierCurve: Fh,
					CubicBezierCurve3: Hh,
					EllipseCurve: _h,
					LineCurve: kh,
					LineCurve3: jh,
					QuadraticBezierCurve: Vh,
					QuadraticBezierCurve3: Wh,
					SplineCurve: qh
				});

				function Yh() {
					wh.call(this), this.type = "CurvePath", this.curves = [], this.autoClose = !1
				}

				function Jh(t) {
					Yh.call(this), this.type = "Path", this.currentPoint = new si, t && this.setFromPoints(t)
				}

				function Zh(t) {
					Jh.call(this, t), this.uuid = oi.generateUUID(), this.type = "Shape", this.holes = []
				}

				function Qh(t, e) {
					Mn.call(this), this.type = "Light", this.color = new Xi(t), this.intensity = void 0 !== e ?
						e : 1, this.receiveShadow = void 0
				}

				function Kh(t, e, i) {
					Qh.call(this, t, i), this.type = "HemisphereLight", this.castShadow = void 0, this.position
						.copy(Mn.DefaultUp), this.updateMatrix(), this.groundColor = new Xi(e)
				}

				function $h(t) {
					this.camera = t, this.bias = 0, this.radius = 1, this.mapSize = new si(512, 512), this.map =
						null, this.matrix = new ci
				}

				function tl() {
					$h.call(this, new To(50, 1, .5, 500))
				}

				function el(t, e, i, n, r, a) {
					Qh.call(this, t, e), this.type = "SpotLight", this.position.copy(Mn.DefaultUp), this
						.updateMatrix(), this.target = new Mn, Object.defineProperty(this, "power", {
							get: function () {
								return this.intensity * Math.PI
							},
							set: function (t) {
								this.intensity = t / Math.PI
							}
						}), this.distance = void 0 !== i ? i : 0, this.angle = void 0 !== n ? n : Math.PI / 3,
						this.penumbra = void 0 !== r ? r : 0, this.decay = void 0 !== a ? a : 1, this.shadow =
						new tl
				}

				function il(t, e, i, n) {
					Qh.call(this, t, e), this.type = "PointLight", Object.defineProperty(this, "power", {
							get: function () {
								return 4 * this.intensity * Math.PI
							},
							set: function (t) {
								this.intensity = t / (4 * Math.PI)
							}
						}), this.distance = void 0 !== i ? i : 0, this.decay = void 0 !== n ? n : 1, this.shadow =
						new $h(new To(90, 1, .5, 500))
				}

				function nl(t, e, i, n, r, a) {
					Eo.call(this), this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left =
						void 0 !== t ? t : -1, this.right = void 0 !== e ? e : 1, this.top = void 0 !== i ? i : 1,
						this.bottom = void 0 !== n ? n : -1, this.near = void 0 !== r ? r : .1, this.far =
						void 0 !== a ? a : 2e3, this.updateProjectionMatrix()
				}

				function rl() {
					$h.call(this, new nl(-5, 5, 5, -5, .5, 500))
				}

				function al(t, e) {
					Qh.call(this, t, e), this.type = "DirectionalLight", this.position.copy(Mn.DefaultUp), this
						.updateMatrix(), this.target = new Mn, this.shadow = new rl
				}

				function ol(t, e) {
					Qh.call(this, t, e), this.type = "AmbientLight", this.castShadow = void 0
				}

				function sl(t, e, i, n) {
					Qh.call(this, t, e), this.type = "RectAreaLight", this.width = void 0 !== i ? i : 10, this
						.height = void 0 !== n ? n : 10
				}

				function cl(t) {
					this.manager = void 0 !== t ? t : ph, this.textures = {}
				}
				Yh.prototype = Object.assign(Object.create(wh.prototype), {
					constructor: Yh,
					add: function (t) {
						this.curves.push(t)
					},
					closePath: function () {
						var t = this.curves[0].getPoint(0),
							e = this.curves[this.curves.length - 1].getPoint(1);
						t.equals(e) || this.curves.push(new kh(e, t))
					},
					getPoint: function (t) {
						for (var e = t * this.getLength(), i = this.getCurveLengths(), n = 0; n < i
							.length;) {
							if (i[n] >= e) {
								var r = i[n] - e,
									a = this.curves[n],
									o = a.getLength(),
									s = 0 === o ? 0 : 1 - r / o;
								return a.getPointAt(s)
							}
							n++
						}
						return null
					},
					getLength: function () {
						var t = this.getCurveLengths();
						return t[t.length - 1]
					},
					updateArcLengths: function () {
						this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths()
					},
					getCurveLengths: function () {
						if (this.cacheLengths && this.cacheLengths.length === this.curves.length)
							return this.cacheLengths;
						for (var t = [], e = 0, i = 0, n = this.curves.length; i < n; i++) e += this
							.curves[i].getLength(), t.push(e);
						return this.cacheLengths = t
					},
					getSpacedPoints: function (t) {
						void 0 === t && (t = 40);
						for (var e = [], i = 0; i <= t; i++) e.push(this.getPoint(i / t));
						return this.autoClose && e.push(e[0]), e
					},
					getPoints: function (t) {
						t = t || 12;
						for (var e, i = [], n = 0, r = this.curves; n < r.length; n++)
							for (var a = r[n], o = a && a.isEllipseCurve ? 2 * t : a && (a
										.isLineCurve || a.isLineCurve3) ? 1 : a && a.isSplineCurve ?
									t * a.points.length : t, s = a.getPoints(o), c = 0; c < s
								.length; c++) {
								var h = s[c];
								e && e.equals(h) || (i.push(h), e = h)
							}
						return this.autoClose && 1 < i.length && !i[i.length - 1].equals(i[0]) && i
							.push(i[0]), i
					},
					copy: function (t) {
						wh.prototype.copy.call(this, t), this.curves = [];
						for (var e = 0, i = t.curves.length; e < i; e++) {
							var n = t.curves[e];
							this.curves.push(n.clone())
						}
						return this.autoClose = t.autoClose, this
					},
					toJSON: function () {
						var t = wh.prototype.toJSON.call(this);
						t.autoClose = this.autoClose, t.curves = [];
						for (var e = 0, i = this.curves.length; e < i; e++) {
							var n = this.curves[e];
							t.curves.push(n.toJSON())
						}
						return t
					},
					fromJSON: function (t) {
						wh.prototype.fromJSON.call(this, t), this.autoClose = t.autoClose, this
							.curves = [];
						for (var e = 0, i = t.curves.length; e < i; e++) {
							var n = t.curves[e];
							this.curves.push((new Xh[n.type]).fromJSON(n))
						}
						return this
					}
				}), Jh.prototype = Object.assign(Object.create(Yh.prototype), {
					constructor: Jh,
					setFromPoints: function (t) {
						this.moveTo(t[0].x, t[0].y);
						for (var e = 1, i = t.length; e < i; e++) this.lineTo(t[e].x, t[e].y)
					},
					moveTo: function (t, e) {
						this.currentPoint.set(t, e)
					},
					lineTo: function (t, e) {
						var i = new kh(this.currentPoint.clone(), new si(t, e));
						this.curves.push(i), this.currentPoint.set(t, e)
					},
					quadraticCurveTo: function (t, e, i, n) {
						var r = new Vh(this.currentPoint.clone(), new si(t, e), new si(i, n));
						this.curves.push(r), this.currentPoint.set(i, n)
					},
					bezierCurveTo: function (t, e, i, n, r, a) {
						var o = new Fh(this.currentPoint.clone(), new si(t, e), new si(i, n), new si(
							r, a));
						this.curves.push(o), this.currentPoint.set(r, a)
					},
					splineThru: function (t) {
						var e = new qh([this.currentPoint.clone()].concat(t));
						this.curves.push(e), this.currentPoint.copy(t[t.length - 1])
					},
					arc: function (t, e, i, n, r, a) {
						var o = this.currentPoint.x,
							s = this.currentPoint.y;
						this.absarc(t + o, e + s, i, n, r, a)
					},
					absarc: function (t, e, i, n, r, a) {
						this.absellipse(t, e, i, i, n, r, a)
					},
					ellipse: function (t, e, i, n, r, a, o, s) {
						var c = this.currentPoint.x,
							h = this.currentPoint.y;
						this.absellipse(t + c, e + h, i, n, r, a, o, s)
					},
					absellipse: function (t, e, i, n, r, a, o, s) {
						var c = new _h(t, e, i, n, r, a, o, s);
						if (0 < this.curves.length) {
							var h = c.getPoint(0);
							h.equals(this.currentPoint) || this.lineTo(h.x, h.y)
						}
						this.curves.push(c);
						var l = c.getPoint(1);
						this.currentPoint.copy(l)
					},
					copy: function (t) {
						return Yh.prototype.copy.call(this, t), this.currentPoint.copy(t
							.currentPoint), this
					},
					toJSON: function () {
						var t = Yh.prototype.toJSON.call(this);
						return t.currentPoint = this.currentPoint.toArray(), t
					},
					fromJSON: function (t) {
						return Yh.prototype.fromJSON.call(this, t), this.currentPoint.fromArray(t
							.currentPoint), this
					}
				}), Zh.prototype = Object.assign(Object.create(Jh.prototype), {
					constructor: Zh,
					getPointsHoles: function (t) {
						for (var e = [], i = 0, n = this.holes.length; i < n; i++) e[i] = this.holes[
							i].getPoints(t);
						return e
					},
					extractPoints: function (t) {
						return {
							shape: this.getPoints(t),
							holes: this.getPointsHoles(t)
						}
					},
					copy: function (t) {
						Jh.prototype.copy.call(this, t), this.holes = [];
						for (var e = 0, i = t.holes.length; e < i; e++) {
							var n = t.holes[e];
							this.holes.push(n.clone())
						}
						return this
					},
					toJSON: function () {
						var t = Jh.prototype.toJSON.call(this);
						t.uuid = this.uuid, t.holes = [];
						for (var e = 0, i = this.holes.length; e < i; e++) {
							var n = this.holes[e];
							t.holes.push(n.toJSON())
						}
						return t
					},
					fromJSON: function (t) {
						Jh.prototype.fromJSON.call(this, t), this.uuid = t.uuid, this.holes = [];
						for (var e = 0, i = t.holes.length; e < i; e++) {
							var n = t.holes[e];
							this.holes.push((new Jh).fromJSON(n))
						}
						return this
					}
				}), Qh.prototype = Object.assign(Object.create(Mn.prototype), {
					constructor: Qh,
					isLight: !0,
					copy: function (t) {
						return Mn.prototype.copy.call(this, t), this.color.copy(t.color), this
							.intensity = t.intensity, this
					},
					toJSON: function (t) {
						var e = Mn.prototype.toJSON.call(this, t);
						return e.object.color = this.color.getHex(), e.object.intensity = this
							.intensity, void 0 !== this.groundColor && (e.object.groundColor = this
								.groundColor.getHex()), void 0 !== this.distance && (e.object
								.distance = this.distance), void 0 !== this.angle && (e.object.angle =
								this.angle), void 0 !== this.decay && (e.object.decay = this.decay),
							void 0 !== this.penumbra && (e.object.penumbra = this.penumbra),
							void 0 !== this.shadow && (e.object.shadow = this.shadow.toJSON()), e
					}
				}), Kh.prototype = Object.assign(Object.create(Qh.prototype), {
					constructor: Kh,
					isHemisphereLight: !0,
					copy: function (t) {
						return Qh.prototype.copy.call(this, t), this.groundColor.copy(t.groundColor),
							this
					}
				}), Object.assign($h.prototype, {
					copy: function (t) {
						return this.camera = t.camera.clone(), this.bias = t.bias, this.radius = t
							.radius, this.mapSize.copy(t.mapSize), this
					},
					clone: function () {
						return (new this.constructor).copy(this)
					},
					toJSON: function () {
						var t = {};
						return 0 !== this.bias && (t.bias = this.bias), 1 !== this.radius && (t
								.radius = this.radius), 512 === this.mapSize.x && 512 === this.mapSize
							.y || (t.mapSize = this.mapSize.toArray()), t.camera = this.camera.toJSON(
								!1).object, delete t.camera.matrix, t
					}
				}), tl.prototype = Object.assign(Object.create($h.prototype), {
					constructor: tl,
					isSpotLightShadow: !0,
					update: function (t) {
						var e = this.camera,
							i = 2 * oi.RAD2DEG * t.angle,
							n = this.mapSize.width / this.mapSize.height,
							r = t.distance || e.far;
						i === e.fov && n === e.aspect && r === e.far || (e.fov = i, e.aspect = n, e
							.far = r, e.updateProjectionMatrix())
					}
				}), el.prototype = Object.assign(Object.create(Qh.prototype), {
					constructor: el,
					isSpotLight: !0,
					copy: function (t) {
						return Qh.prototype.copy.call(this, t), this.distance = t.distance, this
							.angle = t.angle, this.penumbra = t.penumbra, this.decay = t.decay, this
							.target = t.target.clone(), this.shadow = t.shadow.clone(), this
					}
				}), il.prototype = Object.assign(Object.create(Qh.prototype), {
					constructor: il,
					isPointLight: !0,
					copy: function (t) {
						return Qh.prototype.copy.call(this, t), this.distance = t.distance, this
							.decay = t.decay, this.shadow = t.shadow.clone(), this
					}
				}), nl.prototype = Object.assign(Object.create(Eo.prototype), {
					constructor: nl,
					isOrthographicCamera: !0,
					copy: function (t, e) {
						return Eo.prototype.copy.call(this, t, e), this.left = t.left, this.right = t
							.right, this.top = t.top, this.bottom = t.bottom, this.near = t.near, this
							.far = t.far, this.zoom = t.zoom, this.view = null === t.view ? null :
							Object.assign({}, t.view), this
					},
					setViewOffset: function (t, e, i, n, r, a) {
						null === this.view && (this.view = {
								enabled: !0,
								fullWidth: 1,
								fullHeight: 1,
								offsetX: 0,
								offsetY: 0,
								width: 1,
								height: 1
							}), this.view.enabled = !0, this.view.fullWidth = t, this.view
							.fullHeight = e, this.view.offsetX = i, this.view.offsetY = n, this.view
							.width = r, this.view.height = a, this.updateProjectionMatrix()
					},
					clearViewOffset: function () {
						null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
					},
					updateProjectionMatrix: function () {
						var t = (this.right - this.left) / (2 * this.zoom),
							e = (this.top - this.bottom) / (2 * this.zoom),
							i = (this.right + this.left) / 2,
							n = (this.top + this.bottom) / 2,
							r = i - t,
							a = i + t,
							o = n + e,
							s = n - e;
						if (null !== this.view && this.view.enabled) {
							var c = this.zoom / (this.view.width / this.view.fullWidth),
								h = this.zoom / (this.view.height / this.view.fullHeight),
								l = (this.right - this.left) / this.view.width,
								u = (this.top - this.bottom) / this.view.height;
							a = (r += l * (this.view.offsetX / c)) + l * (this.view.width / c), s = (
								o -= u * (this.view.offsetY / h)) - u * (this.view.height / h)
						}
						this.projectionMatrix.makeOrthographic(r, a, o, s, this.near, this.far), this
							.projectionMatrixInverse.getInverse(this.projectionMatrix)
					},
					toJSON: function (t) {
						var e = Mn.prototype.toJSON.call(this, t);
						return e.object.zoom = this.zoom, e.object.left = this.left, e.object.right =
							this.right, e.object.top = this.top, e.object.bottom = this.bottom, e
							.object.near = this.near, e.object.far = this.far, null !== this.view && (
								e.object.view = Object.assign({}, this.view)), e
					}
				}), rl.prototype = Object.assign(Object.create($h.prototype), {
					constructor: rl
				}), al.prototype = Object.assign(Object.create(Qh.prototype), {
					constructor: al,
					isDirectionalLight: !0,
					copy: function (t) {
						return Qh.prototype.copy.call(this, t), this.target = t.target.clone(), this
							.shadow = t.shadow.clone(), this
					}
				}), ol.prototype = Object.assign(Object.create(Qh.prototype), {
					constructor: ol,
					isAmbientLight: !0
				}), sl.prototype = Object.assign(Object.create(Qh.prototype), {
					constructor: sl,
					isRectAreaLight: !0,
					copy: function (t) {
						return Qh.prototype.copy.call(this, t), this.width = t.width, this.height = t
							.height, this
					},
					toJSON: function (t) {
						var e = Qh.prototype.toJSON.call(this, t);
						return e.object.width = this.width, e.object.height = this.height, e
					}
				}), Object.assign(cl.prototype, {
					load: function (t, e, i, n) {
						var r = this,
							a = new fh(r.manager);
						a.setPath(r.path), a.load(t, function (t) {
							e(r.parse(JSON.parse(t)))
						}, i, n)
					},
					parse: function (t) {
						var e = this.textures;

						function i(t) {
							return void 0 === e[t] && console.warn(
								"THREE.MaterialLoader: Undefined texture", t), e[t]
						}
						var n = new Xc[t.type];
						if (void 0 !== t.uuid && (n.uuid = t.uuid), void 0 !== t.name && (n.name = t
								.name), void 0 !== t.color && n.color.setHex(t.color), void 0 !== t
							.roughness && (n.roughness = t.roughness), void 0 !== t.metalness && (n
								.metalness = t.metalness), void 0 !== t.emissive && n.emissive.setHex(
								t.emissive), void 0 !== t.specular && n.specular.setHex(t.specular),
							void 0 !== t.shininess && (n.shininess = t.shininess), void 0 !== t
							.clearCoat && (n.clearCoat = t.clearCoat), void 0 !== t
							.clearCoatRoughness && (n.clearCoatRoughness = t.clearCoatRoughness),
							void 0 !== t.vertexColors && (n.vertexColors = t.vertexColors), void 0 !==
							t.fog && (n.fog = t.fog), void 0 !== t.flatShading && (n.flatShading = t
								.flatShading), void 0 !== t.blending && (n.blending = t.blending),
							void 0 !== t.combine && (n.combine = t.combine), void 0 !== t.side && (n
								.side = t.side), void 0 !== t.opacity && (n.opacity = t.opacity),
							void 0 !== t.transparent && (n.transparent = t.transparent), void 0 !== t
							.alphaTest && (n.alphaTest = t.alphaTest), void 0 !== t.depthTest && (n
								.depthTest = t.depthTest), void 0 !== t.depthWrite && (n.depthWrite =
								t.depthWrite), void 0 !== t.colorWrite && (n.colorWrite = t
								.colorWrite), void 0 !== t.wireframe && (n.wireframe = t.wireframe),
							void 0 !== t.wireframeLinewidth && (n.wireframeLinewidth = t
								.wireframeLinewidth), void 0 !== t.wireframeLinecap && (n
								.wireframeLinecap = t.wireframeLinecap), void 0 !== t
							.wireframeLinejoin && (n.wireframeLinejoin = t.wireframeLinejoin),
							void 0 !== t.rotation && (n.rotation = t.rotation), 1 !== t.linewidth && (
								n.linewidth = t.linewidth), void 0 !== t.dashSize && (n.dashSize = t
								.dashSize), void 0 !== t.gapSize && (n.gapSize = t.gapSize),
							void 0 !== t.scale && (n.scale = t.scale), void 0 !== t.polygonOffset && (
								n.polygonOffset = t.polygonOffset), void 0 !== t
							.polygonOffsetFactor && (n.polygonOffsetFactor = t.polygonOffsetFactor),
							void 0 !== t.polygonOffsetUnits && (n.polygonOffsetUnits = t
								.polygonOffsetUnits), void 0 !== t.skinning && (n.skinning = t
								.skinning), void 0 !== t.morphTargets && (n.morphTargets = t
								.morphTargets), void 0 !== t.dithering && (n.dithering = t.dithering),
							void 0 !== t.visible && (n.visible = t.visible), void 0 !== t.userData &&
							(n.userData = t.userData), void 0 !== t.uniforms)
							for (var r in t.uniforms) {
								var a = t.uniforms[r];
								switch (n.uniforms[r] = {}, a.type) {
									case "t":
										n.uniforms[r].value = i(a.value);
										break;
									case "c":
										n.uniforms[r].value = (new Xi).setHex(a.value);
										break;
									case "v2":
										n.uniforms[r].value = (new si).fromArray(a.value);
										break;
									case "v3":
										n.uniforms[r].value = (new li).fromArray(a.value);
										break;
									case "v4":
										n.uniforms[r].value = (new Ri).fromArray(a.value);
										break;
									case "m4":
										n.uniforms[r].value = (new ci).fromArray(a.value);
										break;
									default:
										n.uniforms[r].value = a.value
								}
							}
						if (void 0 !== t.defines && (n.defines = t.defines), void 0 !== t
							.vertexShader && (n.vertexShader = t.vertexShader), void 0 !== t
							.fragmentShader && (n.fragmentShader = t.fragmentShader), void 0 !== t
							.extensions)
							for (var o in t.extensions) n.extensions[o] = t.extensions[o];
						if (void 0 !== t.shading && (n.flatShading = 1 === t.shading), void 0 !== t
							.size && (n.size = t.size), void 0 !== t.sizeAttenuation && (n
								.sizeAttenuation = t.sizeAttenuation), void 0 !== t.map && (n.map = i(
								t.map)), void 0 !== t.alphaMap && (n.alphaMap = i(t.alphaMap), n
								.transparent = !0), void 0 !== t.bumpMap && (n.bumpMap = i(t
							.bumpMap)), void 0 !== t.bumpScale && (n.bumpScale = t.bumpScale),
							void 0 !== t.normalMap && (n.normalMap = i(t.normalMap)), void 0 !== t
							.normalMapType && (n.normalMapType = t.normalMapType), void 0 !== t
							.normalScale) {
							var s = t.normalScale;
							!1 === Array.isArray(s) && (s = [s, s]), n.normalScale = (new si)
								.fromArray(s)
						}
						return void 0 !== t.displacementMap && (n.displacementMap = i(t
								.displacementMap)), void 0 !== t.displacementScale && (n
								.displacementScale = t.displacementScale), void 0 !== t
							.displacementBias && (n.displacementBias = t.displacementBias), void 0 !==
							t.roughnessMap && (n.roughnessMap = i(t.roughnessMap)), void 0 !== t
							.metalnessMap && (n.metalnessMap = i(t.metalnessMap)), void 0 !== t
							.emissiveMap && (n.emissiveMap = i(t.emissiveMap)), void 0 !== t
							.emissiveIntensity && (n.emissiveIntensity = t.emissiveIntensity),
							void 0 !== t.specularMap && (n.specularMap = i(t.specularMap)), void 0 !==
							t.envMap && (n.envMap = i(t.envMap)), void 0 !== t.envMapIntensity && (n
								.envMapIntensity = t.envMapIntensity), void 0 !== t.reflectivity && (n
								.reflectivity = t.reflectivity), void 0 !== t.lightMap && (n
								.lightMap = i(t.lightMap)), void 0 !== t.lightMapIntensity && (n
								.lightMapIntensity = t.lightMapIntensity), void 0 !== t.aoMap && (n
								.aoMap = i(t.aoMap)), void 0 !== t.aoMapIntensity && (n
								.aoMapIntensity = t.aoMapIntensity), void 0 !== t.gradientMap && (n
								.gradientMap = i(t.gradientMap)), n
					},
					setPath: function (t) {
						return this.path = t, this
					},
					setTextures: function (t) {
						return this.textures = t, this
					}
				});
				var hl = {
					decodeText: function (t) {
						if ("undefined" != typeof TextDecoder) return (new TextDecoder).decode(t);
						for (var e = "", i = 0, n = t.length; i < n; i++) e += String.fromCharCode(t[i]);
						return decodeURIComponent(escape(e))
					},
					extractUrlBase: function (t) {
						var e = t.lastIndexOf("/");
						return -1 === e ? "./" : t.substr(0, e + 1)
					}
				};

				function ll(t) {
					this.manager = void 0 !== t ? t : ph
				}
				Object.assign(ll.prototype, {
					load: function (t, e, i, n) {
						var r = this,
							a = new fh(r.manager);
						a.setPath(r.path), a.load(t, function (t) {
							e(r.parse(JSON.parse(t)))
						}, i, n)
					},
					parse: function (t) {
						var e = new ir,
							i = t.data.index;
						if (void 0 !== i) {
							var n = new ul[i.type](i.array);
							e.setIndex(new In(n, 1))
						}
						var r = t.data.attributes;
						for (var a in r) {
							var o = r[a];
							n = new ul[o.type](o.array);
							e.addAttribute(a, new In(n, o.itemSize, o.normalized))
						}
						var s = t.data.groups || t.data.drawcalls || t.data.offsets;
						if (void 0 !== s)
							for (var c = 0, h = s.length; c !== h; ++c) {
								var l = s[c];
								e.addGroup(l.start, l.count, l.materialIndex)
							}
						var u = t.data.boundingSphere;
						if (void 0 !== u) {
							var p = new li;
							void 0 !== u.center && p.fromArray(u.center), e.boundingSphere = new Ni(p,
								u.radius)
						}
						return t.name && (e.name = t.name), t.userData && (e.userData = t.userData), e
					},
					setPath: function (t) {
						return this.path = t, this
					}
				});
				var ul = {
					Int8Array: Int8Array,
					Uint8Array: Uint8Array,
					Uint8ClampedArray: "undefined" != typeof Uint8ClampedArray ? Uint8ClampedArray :
						Uint8Array,
					Int16Array: Int16Array,
					Uint16Array: Uint16Array,
					Int32Array: Int32Array,
					Uint32Array: Uint32Array,
					Float32Array: Float32Array,
					Float64Array: Float64Array
				};

				function pl(t) {
					this.manager = void 0 !== t ? t : ph, this.resourcePath = ""
				}
				Object.assign(pl.prototype, {
					crossOrigin: "anonymous",
					load: function (n, r, t, a) {
						var o = this,
							e = void 0 === this.path ? hl.extractUrlBase(n) : this.path;
						this.resourcePath = this.resourcePath || e;
						var i = new fh(o.manager);
						i.setPath(this.path), i.load(n, function (t) {
							var e = null;
							try {
								e = JSON.parse(t)
							} catch (t) {
								return void 0 !== a && a(t), void console.error(
									"THREE:ObjectLoader: Can't parse " + n + ".", t
									.message)
							}
							var i = e.metadata;
							void 0 !== i && void 0 !== i.type && "geometry" !== i.type
								.toLowerCase() ? o.parse(e, r) : console.error(
									"THREE.ObjectLoader: Can't load " + n)
						}, t, a)
					},
					setPath: function (t) {
						return this.path = t, this
					},
					setResourcePath: function (t) {
						return this.resourcePath = t, this
					},
					setCrossOrigin: function (t) {
						return this.crossOrigin = t, this
					},
					parse: function (t, e) {
						var i = this.parseShape(t.shapes),
							n = this.parseGeometries(t.geometries, i),
							r = this.parseImages(t.images, function () {
								void 0 !== e && e(s)
							}),
							a = this.parseTextures(t.textures, r),
							o = this.parseMaterials(t.materials, a),
							s = this.parseObject(t.object, n, o);
						return t.animations && (s.animations = this.parseAnimations(t.animations)),
							void 0 !== t.images && 0 !== t.images.length || void 0 !== e && e(s), s
					},
					parseShape: function (t) {
						var e = {};
						if (void 0 !== t)
							for (var i = 0, n = t.length; i < n; i++) {
								var r = (new Zh).fromJSON(t[i]);
								e[r.uuid] = r
							}
						return e
					},
					parseGeometries: function (t, e) {
						var i = {};
						if (void 0 !== t)
							for (var n = new ll, r = 0, a = t.length; r < a; r++) {
								var o, s = t[r];
								switch (s.type) {
									case "PlaneGeometry":
									case "PlaneBufferGeometry":
										o = new Nc[s.type](s.width, s.height, s.widthSegments, s
											.heightSegments);
										break;
									case "BoxGeometry":
									case "BoxBufferGeometry":
									case "CubeGeometry":
										o = new Nc[s.type](s.width, s.height, s.depth, s
											.widthSegments, s.heightSegments, s.depthSegments);
										break;
									case "CircleGeometry":
									case "CircleBufferGeometry":
										o = new Nc[s.type](s.radius, s.segments, s.thetaStart, s
											.thetaLength);
										break;
									case "CylinderGeometry":
									case "CylinderBufferGeometry":
										o = new Nc[s.type](s.radiusTop, s.radiusBottom, s.height, s
											.radialSegments, s.heightSegments, s.openEnded, s
											.thetaStart, s.thetaLength);
										break;
									case "ConeGeometry":
									case "ConeBufferGeometry":
										o = new Nc[s.type](s.radius, s.height, s.radialSegments, s
											.heightSegments, s.openEnded, s.thetaStart, s
											.thetaLength);
										break;
									case "SphereGeometry":
									case "SphereBufferGeometry":
										o = new Nc[s.type](s.radius, s.widthSegments, s
											.heightSegments, s.phiStart, s.phiLength, s
											.thetaStart, s.thetaLength);
										break;
									case "DodecahedronGeometry":
									case "DodecahedronBufferGeometry":
									case "IcosahedronGeometry":
									case "IcosahedronBufferGeometry":
									case "OctahedronGeometry":
									case "OctahedronBufferGeometry":
									case "TetrahedronGeometry":
									case "TetrahedronBufferGeometry":
										o = new Nc[s.type](s.radius, s.detail);
										break;
									case "RingGeometry":
									case "RingBufferGeometry":
										o = new Nc[s.type](s.innerRadius, s.outerRadius, s
											.thetaSegments, s.phiSegments, s.thetaStart, s
											.thetaLength);
										break;
									case "TorusGeometry":
									case "TorusBufferGeometry":
										o = new Nc[s.type](s.radius, s.tube, s.radialSegments, s
											.tubularSegments, s.arc);
										break;
									case "TorusKnotGeometry":
									case "TorusKnotBufferGeometry":
										o = new Nc[s.type](s.radius, s.tube, s.tubularSegments, s
											.radialSegments, s.p, s.q);
										break;
									case "LatheGeometry":
									case "LatheBufferGeometry":
										o = new Nc[s.type](s.points, s.segments, s.phiStart, s
											.phiLength);
										break;
									case "PolyhedronGeometry":
									case "PolyhedronBufferGeometry":
										o = new Nc[s.type](s.vertices, s.indices, s.radius, s
										.details);
										break;
									case "ShapeGeometry":
									case "ShapeBufferGeometry":
										for (var c = [], h = 0, l = s.shapes.length; h < l; h++) {
											var u = e[s.shapes[h]];
											c.push(u)
										}
										o = new Nc[s.type](c, s.curveSegments);
										break;
									case "ExtrudeGeometry":
									case "ExtrudeBufferGeometry":
										for (c = [], h = 0, l = s.shapes.length; h < l; h++) {
											u = e[s.shapes[h]];
											c.push(u)
										}
										var p = s.options.extrudePath;
										void 0 !== p && (s.options.extrudePath = (new Xh[p.type])
											.fromJSON(p)), o = new Nc[s.type](c, s.options);
										break;
									case "BufferGeometry":
										o = n.parse(s);
										break;
									case "Geometry":
										if ("THREE" in window && "LegacyJSONLoader" in THREE) o = (
											new THREE.LegacyJSONLoader).parse(s, this
											.resourcePath).geometry;
										else console.error(
											'THREE.ObjectLoader: You have to import LegacyJSONLoader in order load geometry data of type "Geometry".'
											);
										break;
									default:
										console.warn(
											'THREE.ObjectLoader: Unsupported geometry type "' + s
											.type + '"');
										continue
								}
								o.uuid = s.uuid, void 0 !== s.name && (o.name = s.name), !0 === o
									.isBufferGeometry && void 0 !== s.userData && (o.userData = s
										.userData), i[s.uuid] = o
							}
						return i
					},
					parseMaterials: function (t, e) {
						var i = {},
							n = {};
						if (void 0 !== t) {
							var r = new cl;
							r.setTextures(e);
							for (var a = 0, o = t.length; a < o; a++) {
								var s = t[a];
								if ("MultiMaterial" === s.type) {
									for (var c = [], h = 0; h < s.materials.length; h++) {
										var l = s.materials[h];
										void 0 === i[l.uuid] && (i[l.uuid] = r.parse(l)), c.push(i[l
											.uuid])
									}
									n[s.uuid] = c
								} else n[s.uuid] = r.parse(s), i[s.uuid] = n[s.uuid]
							}
						}
						return n
					},
					parseAnimations: function (t) {
						for (var e = [], i = 0; i < t.length; i++) {
							var n = t[i],
								r = sh.parse(n);
							void 0 !== n.uuid && (r.uuid = n.uuid), e.push(r)
						}
						return e
					},
					parseImages: function (t, e) {
						var i = this,
							n = {};

						function r(t) {
							return i.manager.itemStart(t), a.load(t, function () {
								i.manager.itemEnd(t)
							}, void 0, function () {
								i.manager.itemError(t), i.manager.itemEnd(t)
							})
						}
						if (void 0 !== t && 0 < t.length) {
							var a = new yh(new uh(e));
							a.setCrossOrigin(this.crossOrigin);
							for (var o = 0, s = t.length; o < s; o++) {
								var c = t[o],
									h = c.url;
								if (Array.isArray(h)) {
									n[c.uuid] = [];
									for (var l = 0, u = h.length; l < u; l++) {
										var p = h[l],
											d = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(p) ? p : i
											.resourcePath + p;
										n[c.uuid].push(r(d))
									}
								} else {
									d = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(c.url) ? c.url : i
										.resourcePath + c.url;
									n[c.uuid] = r(d)
								}
							}
						}
						return n
					},
					parseTextures: function (t, e) {
						function i(t, e) {
							return "number" == typeof t ? t : (console.warn(
								"THREE.ObjectLoader.parseTexture: Constant should be in numeric form.",
								t), e[t])
						}
						var n = {};
						if (void 0 !== t)
							for (var r = 0, a = t.length; r < a; r++) {
								var o, s = t[r];
								void 0 === s.image && console.warn(
										'THREE.ObjectLoader: No "image" specified for', s.uuid),
									void 0 === e[s.image] && console.warn(
										"THREE.ObjectLoader: Undefined image", s.image), (o = Array
										.isArray(e[s.image]) ? new Zr(e[s.image]) : new Ci(e[s.image])
										).needsUpdate = !0, o.uuid = s.uuid, void 0 !== s.name && (o
										.name = s.name), void 0 !== s.mapping && (o.mapping = i(s
										.mapping, yl)), void 0 !== s.offset && o.offset.fromArray(s
										.offset), void 0 !== s.repeat && o.repeat.fromArray(s.repeat),
									void 0 !== s.center && o.center.fromArray(s.center), void 0 !== s
									.rotation && (o.rotation = s.rotation), void 0 !== s.wrap && (o
										.wrapS = i(s.wrap[0], xl), o.wrapT = i(s.wrap[1], xl)),
									void 0 !== s.format && (o.format = s.format), void 0 !== s.type &&
									(o.type = s.type), void 0 !== s.encoding && (o.encoding = s
										.encoding), void 0 !== s.minFilter && (o.minFilter = i(s
										.minFilter, bl)), void 0 !== s.magFilter && (o.magFilter = i(s
										.magFilter, bl)), void 0 !== s.anisotropy && (o.anisotropy = s
										.anisotropy), void 0 !== s.flipY && (o.flipY = s.flipY),
									void 0 !== s.premultiplyAlpha && (o.premultiplyAlpha = s
										.premultiplyAlpha), void 0 !== s.unpackAlignment && (o
										.unpackAlignment = s.unpackAlignment), n[s.uuid] = o
							}
						return n
					},
					parseObject: function (t, e, a) {
						var i;

						function n(t) {
							return void 0 === e[t] && console.warn(
								"THREE.ObjectLoader: Undefined geometry", t), e[t]
						}

						function r(t) {
							if (void 0 !== t) {
								if (Array.isArray(t)) {
									for (var e = [], i = 0, n = t.length; i < n; i++) {
										var r = t[i];
										void 0 === a[r] && console.warn(
											"THREE.ObjectLoader: Undefined material", r), e.push(
											a[r])
									}
									return e
								}
								return void 0 === a[t] && console.warn(
									"THREE.ObjectLoader: Undefined material", t), a[t]
							}
						}
						switch (t.type) {
							case "Scene":
								i = new Ko, void 0 !== t.background && Number.isInteger(t
									.background) && (i.background = new Xi(t.background)), void 0 !==
									t.fog && ("Fog" === t.fog.type ? i.fog = new Qo(t.fog.color, t.fog
										.near, t.fog.far) : "FogExp2" === t.fog.type && (i.fog =
										new Zo(t.fog.color, t.fog.density)));
								break;
							case "PerspectiveCamera":
								i = new To(t.fov, t.aspect, t.near, t.far), void 0 !== t.focus && (i
										.focus = t.focus), void 0 !== t.zoom && (i.zoom = t.zoom),
									void 0 !== t.filmGauge && (i.filmGauge = t.filmGauge), void 0 !==
									t.filmOffset && (i.filmOffset = t.filmOffset), void 0 !== t
									.view && (i.view = Object.assign({}, t.view));
								break;
							case "OrthographicCamera":
								i = new nl(t.left, t.right, t.top, t.bottom, t.near, t.far),
									void 0 !== t.zoom && (i.zoom = t.zoom), void 0 !== t.view && (i
										.view = Object.assign({}, t.view));
								break;
							case "AmbientLight":
								i = new ol(t.color, t.intensity);
								break;
							case "DirectionalLight":
								i = new al(t.color, t.intensity);
								break;
							case "PointLight":
								i = new il(t.color, t.intensity, t.distance, t.decay);
								break;
							case "RectAreaLight":
								i = new sl(t.color, t.intensity, t.width, t.height);
								break;
							case "SpotLight":
								i = new el(t.color, t.intensity, t.distance, t.angle, t.penumbra, t
									.decay);
								break;
							case "HemisphereLight":
								i = new Kh(t.color, t.groundColor, t.intensity);
								break;
							case "SkinnedMesh":
								console.warn(
									"THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet."
									);
							case "Mesh":
								var o = n(t.geometry),
									s = r(t.material);
								i = o.bones && 0 < o.bones.length ? new rs(o, s) : new Ur(o, s);
								break;
							case "LOD":
								i = new ns;
								break;
							case "Line":
								i = new cs(n(t.geometry), r(t.material), t.mode);
								break;
							case "LineLoop":
								i = new ls(n(t.geometry), r(t.material));
								break;
							case "LineSegments":
								i = new hs(n(t.geometry), r(t.material));
								break;
							case "PointCloud":
							case "Points":
								i = new ps(n(t.geometry), r(t.material));
								break;
							case "Sprite":
								i = new is(r(t.material));
								break;
							case "Group":
								i = new So;
								break;
							default:
								i = new Mn
						}
						if (i.uuid = t.uuid, void 0 !== t.name && (i.name = t.name), void 0 !== t
							.matrix ? (i.matrix.fromArray(t.matrix), void 0 !== t.matrixAutoUpdate &&
								(i.matrixAutoUpdate = t.matrixAutoUpdate), i.matrixAutoUpdate && i
								.matrix.decompose(i.position, i.quaternion, i.scale)) : (void 0 !== t
								.position && i.position.fromArray(t.position), void 0 !== t
								.rotation && i.rotation.fromArray(t.rotation), void 0 !== t
								.quaternion && i.quaternion.fromArray(t.quaternion), void 0 !== t
								.scale && i.scale.fromArray(t.scale)), void 0 !== t.castShadow && (i
								.castShadow = t.castShadow), void 0 !== t.receiveShadow && (i
								.receiveShadow = t.receiveShadow), t.shadow && (void 0 !== t.shadow
								.bias && (i.shadow.bias = t.shadow.bias), void 0 !== t.shadow
								.radius && (i.shadow.radius = t.shadow.radius), void 0 !== t.shadow
								.mapSize && i.shadow.mapSize.fromArray(t.shadow.mapSize), void 0 !== t
								.shadow.camera && (i.shadow.camera = this.parseObject(t.shadow
									.camera))), void 0 !== t.visible && (i.visible = t.visible),
							void 0 !== t.frustumCulled && (i.frustumCulled = t.frustumCulled),
							void 0 !== t.renderOrder && (i.renderOrder = t.renderOrder), void 0 !== t
							.userData && (i.userData = t.userData), void 0 !== t.layers && (i.layers
								.mask = t.layers), void 0 !== t.children)
							for (var c = t.children, h = 0; h < c.length; h++) i.add(this.parseObject(
								c[h], e, a));
						if ("LOD" === t.type)
							for (var l = t.levels, u = 0; u < l.length; u++) {
								var p = l[u],
									d = i.getObjectByProperty("uuid", p.object);
								void 0 !== d && i.addLevel(d, p.distance)
							}
						return i
					}
				});
				var dl, fl, ml, gl, vl, yl = {
						UVMapping: st,
						CubeReflectionMapping: ct,
						CubeRefractionMapping: ht,
						EquirectangularReflectionMapping: Pt,
						EquirectangularRefractionMapping: Ct,
						SphericalReflectionMapping: Rt,
						CubeUVReflectionMapping: Ot,
						CubeUVRefractionMapping: It
					},
					xl = {
						RepeatWrapping: Dt,
						ClampToEdgeWrapping: Bt,
						MirroredRepeatWrapping: Nt
					},
					bl = {
						NearestFilter: zt,
						NearestMipMapNearestFilter: Ut,
						NearestMipMapLinearFilter: Gt,
						LinearFilter: Ft,
						LinearMipMapNearestFilter: Vt,
						LinearMipMapLinearFilter: Wt
					};

				function wl(t) {
					"undefined" == typeof createImageBitmap && console.warn(
							"THREE.ImageBitmapLoader: createImageBitmap() not supported."), "undefined" ==
						typeof fetch && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), this
						.manager = void 0 !== t ? t : ph, this.options = void 0
				}

				function _l() {
					this.type = "ShapePath", this.color = new Xi, this.subPaths = [], this.currentPath = null
				}

				function Ml(t) {
					this.type = "Font", this.data = t
				}

				function Sl(t, e, i) {
					for (var n = Array.from ? Array.from(t) : String(t).split(""), r = e / i.resolution, a = (i
								.boundingBox.yMax - i.boundingBox.yMin + i.underlineThickness) * r, o = [], s = 0,
							c = 0, h = 0; h < n.length; h++) {
						var l = n[h];
						if ("\n" === l) s = 0, c -= a;
						else {
							var u = El(l, r, s, c, i);
							s += u.offsetX, o.push(u.path)
						}
					}
					return o
				}

				function El(t, e, i, n, r) {
					var a = r.glyphs[t] || r.glyphs["?"];
					if (a) {
						var o, s, c, h, l, u, p, d, f = new _l;
						if (a.o)
							for (var m = a._cachedOutline || (a._cachedOutline = a.o.split(" ")), g = 0, v = m
									.length; g < v;) {
								switch (m[g++]) {
									case "m":
										o = m[g++] * e + i, s = m[g++] * e + n, f.moveTo(o, s);
										break;
									case "l":
										o = m[g++] * e + i, s = m[g++] * e + n, f.lineTo(o, s);
										break;
									case "q":
										c = m[g++] * e + i, h = m[g++] * e + n, l = m[g++] * e + i, u = m[g++] *
											e + n, f.quadraticCurveTo(l, u, c, h);
										break;
									case "b":
										c = m[g++] * e + i, h = m[g++] * e + n, l = m[g++] * e + i, u = m[g++] *
											e + n, p = m[g++] * e + i, d = m[g++] * e + n, f.bezierCurveTo(l, u,
												p, d, c, h)
								}
							}
						return {
							offsetX: a.ha * e,
							path: f
						}
					}
				}

				function Tl(t) {
					this.manager = void 0 !== t ? t : ph
				}

				function Al() {}
				wl.prototype = {
					constructor: wl,
					setOptions: function (t) {
						return this.options = t, this
					},
					load: function (e, i, t, n) {
						void 0 === e && (e = ""), void 0 !== this.path && (e = this.path + e), e = this
							.manager.resolveURL(e);
						var r = this,
							a = lh.get(e);
						if (void 0 !== a) return r.manager.itemStart(e), setTimeout(function () {
							i && i(a), r.manager.itemEnd(e)
						}, 0), a;
						fetch(e).then(function (t) {
							return t.blob()
						}).then(function (t) {
							return createImageBitmap(t, r.options)
						}).then(function (t) {
							lh.add(e, t), i && i(t), r.manager.itemEnd(e)
						}).catch(function (t) {
							n && n(t), r.manager.itemError(e), r.manager.itemEnd(e)
						})
					},
					setCrossOrigin: function () {
						return this
					},
					setPath: function (t) {
						return this.path = t, this
					}
				}, Object.assign(_l.prototype, {
					moveTo: function (t, e) {
						this.currentPath = new Jh, this.subPaths.push(this.currentPath), this
							.currentPath.moveTo(t, e)
					},
					lineTo: function (t, e) {
						this.currentPath.lineTo(t, e)
					},
					quadraticCurveTo: function (t, e, i, n) {
						this.currentPath.quadraticCurveTo(t, e, i, n)
					},
					bezierCurveTo: function (t, e, i, n, r, a) {
						this.currentPath.bezierCurveTo(t, e, i, n, r, a)
					},
					splineThru: function (t) {
						this.currentPath.splineThru(t)
					},
					toShapes: function (t, e) {
						function i(t) {
							for (var e = [], i = 0, n = t.length; i < n; i++) {
								var r = t[i],
									a = new Zh;
								a.curves = r.curves, e.push(a)
							}
							return e
						}

						function n(t, e) {
							for (var i = e.length, n = !1, r = i - 1, a = 0; a < i; r = a++) {
								var o = e[r],
									s = e[a],
									c = s.x - o.x,
									h = s.y - o.y;
								if (Math.abs(h) > Number.EPSILON) {
									if (h < 0 && (o = e[a], c = -c, s = e[r], h = -h), t.y < o.y || t
										.y > s.y) continue;
									if (t.y === o.y) {
										if (t.x === o.x) return !0
									} else {
										var l = h * (t.x - o.x) - c * (t.y - o.y);
										if (0 === l) return !0;
										if (l < 0) continue;
										n = !n
									}
								} else {
									if (t.y !== o.y) continue;
									if (s.x <= t.x && t.x <= o.x || o.x <= t.x && t.x <= s.x) return !
										0
								}
							}
							return n
						}
						var r = uc.isClockWise,
							a = this.subPaths;
						if (0 === a.length) return [];
						if (!0 === e) return i(a);
						var o, s, c, h = [];
						if (1 === a.length) return s = a[0], (c = new Zh).curves = s.curves, h.push(
							c), h;
						var l = !r(a[0].getPoints());
						l = t ? !l : l;
						var u, p, d = [],
							f = [],
							m = [],
							g = 0;
						f[g] = void 0, m[g] = [];
						for (var v = 0, y = a.length; v < y; v++) o = r(u = (s = a[v]).getPoints()), (
							o = t ? !o : o) ? (!l && f[g] && g++, f[g] = {
							s: new Zh,
							p: u
						}, f[g].s.curves = s.curves, l && g++, m[g] = []) : m[g].push({
							h: s,
							p: u[0]
						});
						if (!f[0]) return i(a);
						if (1 < f.length) {
							for (var x = !1, b = [], w = 0, _ = f.length; w < _; w++) d[w] = [];
							for (w = 0, _ = f.length; w < _; w++)
								for (var M = m[w], S = 0; S < M.length; S++) {
									for (var E = M[S], T = !0, A = 0; A < f.length; A++) n(E.p, f[A]
										.p) && (w !== A && b.push({
										froms: w,
										tos: A,
										hole: S
									}), T ? (T = !1, d[A].push(E)) : x = !0);
									T && d[w].push(E)
								}
							0 < b.length && (x || (m = d))
						}
						v = 0;
						for (var L = f.length; v < L; v++) {
							c = f[v].s, h.push(c);
							for (var P = 0, C = (p = m[v]).length; P < C; P++) c.holes.push(p[P].h)
						}
						return h
					}
				}), Object.assign(Ml.prototype, {
					isFont: !0,
					generateShapes: function (t, e) {
						void 0 === e && (e = 100);
						for (var i = [], n = Sl(t, e, this.data), r = 0, a = n.length; r < a; r++)
							Array.prototype.push.apply(i, n[r].toShapes());
						return i
					}
				}), Object.assign(Tl.prototype, {
					load: function (t, n, e, i) {
						var r = this,
							a = new fh(this.manager);
						a.setPath(this.path), a.load(t, function (e) {
							var i;
							try {
								i = JSON.parse(e)
							} catch (t) {
								console.warn(
									"THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."
									), i = JSON.parse(e.substring(65, e.length - 2))
							}
							var t = r.parse(i);
							n && n(t)
						}, e, i)
					},
					parse: function (t) {
						return new Ml(t)
					},
					setPath: function (t) {
						return this.path = t, this
					}
				}), Al.Handlers = {
					handlers: [],
					add: function (t, e) {
						this.handlers.push(t, e)
					},
					get: function (t) {
						for (var e = this.handlers, i = 0, n = e.length; i < n; i += 2) {
							var r = e[i],
								a = e[i + 1];
							if (r.test(t)) return a
						}
						return null
					}
				}, Object.assign(Al.prototype, {
					crossOrigin: "anonymous",
					onLoadStart: function () {},
					onLoadProgress: function () {},
					onLoadComplete: function () {},
					initMaterials: function (t, e, i) {
						for (var n = [], r = 0; r < t.length; ++r) n[r] = this.createMaterial(t[r], e,
							i);
						return n
					},
					createMaterial: (dl = {
						NoBlending: ft,
						NormalBlending: mt,
						AdditiveBlending: gt,
						SubtractiveBlending: vt,
						MultiplyBlending: yt,
						CustomBlending: xt
					}, fl = new Xi, ml = new bh, gl = new cl, function (t, h, l) {
						var u = {};

						function e(t, e, i, n, r) {
							var a, o = h + t,
								s = Al.Handlers.get(o);
							a = null !== s ? s.load(o) : (ml.setCrossOrigin(l), ml.load(o)),
								void 0 !== e && (a.repeat.fromArray(e), 1 !== e[0] && (a.wrapS =
									Dt), 1 !== e[1] && (a.wrapT = Dt)), void 0 !== i && a.offset
								.fromArray(i), void 0 !== n && ("repeat" === n[0] && (a.wrapS =
									Dt), "mirror" === n[0] && (a.wrapS = Nt), "repeat" === n[
									1] && (a.wrapT = Dt), "mirror" === n[1] && (a.wrapT = Nt)),
								void 0 !== r && (a.anisotropy = r);
							var c = oi.generateUUID();
							return u[c] = a, c
						}
						var i = {
							uuid: oi.generateUUID(),
							type: "MeshLambertMaterial"
						};
						for (var n in t) {
							var r = t[n];
							switch (n) {
								case "DbgColor":
								case "DbgIndex":
								case "opticalDensity":
								case "illumination":
									break;
								case "DbgName":
									i.name = r;
									break;
								case "blending":
									i.blending = dl[r];
									break;
								case "colorAmbient":
								case "mapAmbient":
									console.warn("THREE.Loader.createMaterial:", n,
										"is no longer supported.");
									break;
								case "colorDiffuse":
									i.color = fl.fromArray(r).getHex();
									break;
								case "colorSpecular":
									i.specular = fl.fromArray(r).getHex();
									break;
								case "colorEmissive":
									i.emissive = fl.fromArray(r).getHex();
									break;
								case "specularCoef":
									i.shininess = r;
									break;
								case "shading":
									"basic" === r.toLowerCase() && (i.type = "MeshBasicMaterial"),
										"phong" === r.toLowerCase() && (i.type =
											"MeshPhongMaterial"), "standard" === r
									.toLowerCase() && (i.type = "MeshStandardMaterial");
									break;
								case "mapDiffuse":
									i.map = e(r, t.mapDiffuseRepeat, t.mapDiffuseOffset, t
										.mapDiffuseWrap, t.mapDiffuseAnisotropy);
									break;
								case "mapDiffuseRepeat":
								case "mapDiffuseOffset":
								case "mapDiffuseWrap":
								case "mapDiffuseAnisotropy":
									break;
								case "mapEmissive":
									i.emissiveMap = e(r, t.mapEmissiveRepeat, t.mapEmissiveOffset,
										t.mapEmissiveWrap, t.mapEmissiveAnisotropy);
									break;
								case "mapEmissiveRepeat":
								case "mapEmissiveOffset":
								case "mapEmissiveWrap":
								case "mapEmissiveAnisotropy":
									break;
								case "mapLight":
									i.lightMap = e(r, t.mapLightRepeat, t.mapLightOffset, t
										.mapLightWrap, t.mapLightAnisotropy);
									break;
								case "mapLightRepeat":
								case "mapLightOffset":
								case "mapLightWrap":
								case "mapLightAnisotropy":
									break;
								case "mapAO":
									i.aoMap = e(r, t.mapAORepeat, t.mapAOOffset, t.mapAOWrap, t
										.mapAOAnisotropy);
									break;
								case "mapAORepeat":
								case "mapAOOffset":
								case "mapAOWrap":
								case "mapAOAnisotropy":
									break;
								case "mapBump":
									i.bumpMap = e(r, t.mapBumpRepeat, t.mapBumpOffset, t
										.mapBumpWrap, t.mapBumpAnisotropy);
									break;
								case "mapBumpScale":
									i.bumpScale = r;
									break;
								case "mapBumpRepeat":
								case "mapBumpOffset":
								case "mapBumpWrap":
								case "mapBumpAnisotropy":
									break;
								case "mapNormal":
									i.normalMap = e(r, t.mapNormalRepeat, t.mapNormalOffset, t
										.mapNormalWrap, t.mapNormalAnisotropy);
									break;
								case "mapNormalFactor":
									i.normalScale = r;
									break;
								case "mapNormalRepeat":
								case "mapNormalOffset":
								case "mapNormalWrap":
								case "mapNormalAnisotropy":
									break;
								case "mapSpecular":
									i.specularMap = e(r, t.mapSpecularRepeat, t.mapSpecularOffset,
										t.mapSpecularWrap, t.mapSpecularAnisotropy);
									break;
								case "mapSpecularRepeat":
								case "mapSpecularOffset":
								case "mapSpecularWrap":
								case "mapSpecularAnisotropy":
									break;
								case "mapMetalness":
									i.metalnessMap = e(r, t.mapMetalnessRepeat, t
										.mapMetalnessOffset, t.mapMetalnessWrap, t
										.mapMetalnessAnisotropy);
									break;
								case "mapMetalnessRepeat":
								case "mapMetalnessOffset":
								case "mapMetalnessWrap":
								case "mapMetalnessAnisotropy":
									break;
								case "mapRoughness":
									i.roughnessMap = e(r, t.mapRoughnessRepeat, t
										.mapRoughnessOffset, t.mapRoughnessWrap, t
										.mapRoughnessAnisotropy);
									break;
								case "mapRoughnessRepeat":
								case "mapRoughnessOffset":
								case "mapRoughnessWrap":
								case "mapRoughnessAnisotropy":
									break;
								case "mapAlpha":
									i.alphaMap = e(r, t.mapAlphaRepeat, t.mapAlphaOffset, t
										.mapAlphaWrap, t.mapAlphaAnisotropy);
									break;
								case "mapAlphaRepeat":
								case "mapAlphaOffset":
								case "mapAlphaWrap":
								case "mapAlphaAnisotropy":
									break;
								case "flipSided":
									i.side = kt;
									break;
								case "doubleSided":
									i.side = dt;
									break;
								case "transparency":
									console.warn(
										"THREE.Loader.createMaterial: transparency has been renamed to opacity"
										), i.opacity = r;
									break;
								case "depthTest":
								case "depthWrite":
								case "colorWrite":
								case "opacity":
								case "reflectivity":
								case "transparent":
								case "visible":
								case "wireframe":
									i[n] = r;
									break;
								case "vertexColors":
									!0 === r && (i.vertexColors = z), "face" === r && (i
										.vertexColors = D);
									break;
								default:
									console.error("THREE.Loader.createMaterial: Unsupported", n,
										r)
							}
						}
						return "MeshBasicMaterial" === i.type && delete i.emissive,
							"MeshPhongMaterial" !== i.type && delete i.specular, i.opacity < 1 &&
							(i.transparent = !0), gl.setTextures(u), gl.parse(i)
					})
				});
				var Ll, Pl, Cl, Rl, Ol, Il, Dl, Bl, Nl, zl, Ul, Gl, Fl, Hl, kl, jl, Vl, Wl, ql, Xl = {
					getContext: function () {
						return void 0 === vl && (vl = new(window.AudioContext || window
							.webkitAudioContext)), vl
					},
					setContext: function (t) {
						vl = t
					}
				};

				function Yl(t) {
					this.manager = void 0 !== t ? t : ph
				}

				function Jl() {
					this.type = "StereoCamera", this.aspect = 1, this.eyeSep = .064, this.cameraL = new To, this
						.cameraL.layers.enable(1), this.cameraL.matrixAutoUpdate = !1, this.cameraR = new To, this
						.cameraR.layers.enable(2), this.cameraR.matrixAutoUpdate = !1
				}

				function Zl(t, e, i, n) {
					Mn.call(this), this.type = "CubeCamera";
					var r = 90,
						a = 1,
						o = new To(r, a, t, e);
					o.up.set(0, -1, 0), o.lookAt(new li(1, 0, 0)), this.add(o);
					var s = new To(r, a, t, e);
					s.up.set(0, -1, 0), s.lookAt(new li(-1, 0, 0)), this.add(s);
					var c = new To(r, a, t, e);
					c.up.set(0, 0, 1), c.lookAt(new li(0, 1, 0)), this.add(c);
					var h = new To(r, a, t, e);
					h.up.set(0, 0, -1), h.lookAt(new li(0, -1, 0)), this.add(h);
					var l = new To(r, a, t, e);
					l.up.set(0, -1, 0), l.lookAt(new li(0, 0, 1)), this.add(l);
					var u = new To(r, a, t, e);
					u.up.set(0, -1, 0), u.lookAt(new li(0, 0, -1)), this.add(u), n = n || {
							format: ae,
							magFilter: Ft,
							minFilter: Ft
						}, this.renderTarget = new Ii(i, i, n), this.renderTarget.texture.name = "CubeCamera",
						this.update = function (t, e) {
							null === this.parent && this.updateMatrixWorld();
							var i = this.renderTarget,
								n = i.texture.generateMipmaps;
							i.texture.generateMipmaps = !1, i.activeCubeFace = 0, t.render(e, o, i), i
								.activeCubeFace = 1, t.render(e, s, i), i.activeCubeFace = 2, t.render(e, c, i), i
								.activeCubeFace = 3, t.render(e, h, i), i.activeCubeFace = 4, t.render(e, l, i), i
								.texture.generateMipmaps = n, i.activeCubeFace = 5, t.render(e, u, i), t
								.setRenderTarget(null)
						}, this.clear = function (t, e, i, n) {
							for (var r = this.renderTarget, a = 0; a < 6; a++) r.activeCubeFace = a, t
								.setRenderTarget(r), t.clear(e, i, n);
							t.setRenderTarget(null)
						}
				}

				function Ql(t) {
					this.autoStart = void 0 === t || t, this.startTime = 0, this.oldTime = 0, this.elapsedTime =
						0, this.running = !1
				}

				function Kl() {
					Mn.call(this), this.type = "AudioListener", this.context = Xl.getContext(), this.gain = this
						.context.createGain(), this.gain.connect(this.context.destination), this.filter = null,
						this.timeDelta = 0
				}

				function $l(t) {
					Mn.call(this), this.type = "Audio", this.listener = t, this.context = t.context, this.gain =
						this.context.createGain(), this.gain.connect(t.getInput()), this.autoplay = !1, this
						.buffer = null, this.detune = 0, this.loop = !1, this.startTime = 0, this.offset = 0, this
						.playbackRate = 1, this.isPlaying = !1, this.hasPlaybackControl = !0, this.sourceType =
						"empty", this.filters = []
				}

				function tu(t) {
					$l.call(this, t), this.panner = this.context.createPanner(), this.panner.connect(this.gain)
				}

				function eu(t, e) {
					this.analyser = t.context.createAnalyser(), this.analyser.fftSize = void 0 !== e ? e : 2048,
						this.data = new Uint8Array(this.analyser.frequencyBinCount), t.getOutput().connect(this
							.analyser)
				}

				function iu(t, e, i) {
					this.binding = t, this.valueSize = i;
					var n, r = Float64Array;
					switch (e) {
						case "quaternion":
							n = this._slerp;
							break;
						case "string":
						case "bool":
							r = Array, n = this._select;
							break;
						default:
							n = this._lerp
					}
					this.buffer = new r(4 * i), this._mixBufferRegion = n, this.cumulativeWeight = 0, this
						.useCount = 0, this.referenceCount = 0
				}
				Object.assign(Yl.prototype, {
					load: function (t, i, e, n) {
						var r = new fh(this.manager);
						r.setResponseType("arraybuffer"), r.setPath(this.path), r.load(t, function (
						t) {
							var e = t.slice(0);
							Xl.getContext().decodeAudioData(e, function (t) {
								i(t)
							})
						}, e, n)
					},
					setPath: function (t) {
						return this.path = t, this
					}
				}), Object.assign(Jl.prototype, {
					update: (Nl = new ci, zl = new ci, function (t) {
						if (Ll !== this || Pl !== t.focus || Cl !== t.fov || Rl !== t.aspect *
							this.aspect || Ol !== t.near || Il !== t.far || Dl !== t.zoom ||
							Bl !== this.eyeSep) {
							Ll = this, Pl = t.focus, Cl = t.fov, Rl = t.aspect * this.aspect, Ol =
								t.near, Il = t.far, Dl = t.zoom;
							var e, i, n = t.projectionMatrix.clone(),
								r = (Bl = this.eyeSep / 2) * Ol / Pl,
								a = Ol * Math.tan(oi.DEG2RAD * Cl * .5) / Dl;
							zl.elements[12] = -Bl, Nl.elements[12] = Bl, e = -a * Rl + r, i = a *
								Rl + r, n.elements[0] = 2 * Ol / (i - e), n.elements[8] = (i +
								e) / (i - e), this.cameraL.projectionMatrix.copy(n), e = -a * Rl -
								r, i = a * Rl - r, n.elements[0] = 2 * Ol / (i - e), n.elements[
								8] = (i + e) / (i - e), this.cameraR.projectionMatrix.copy(n)
						}
						this.cameraL.matrixWorld.copy(t.matrixWorld).multiply(zl), this.cameraR
							.matrixWorld.copy(t.matrixWorld).multiply(Nl)
					})
				}), Zl.prototype = Object.create(Mn.prototype), Zl.prototype.constructor = Zl, Object.assign(
					Ql.prototype, {
						start: function () {
							this.startTime = ("undefined" == typeof performance ? Date : performance)
								.now(), this.oldTime = this.startTime, this.elapsedTime = 0, this
								.running = !0
						},
						stop: function () {
							this.getElapsedTime(), this.running = !1, this.autoStart = !1
						},
						getElapsedTime: function () {
							return this.getDelta(), this.elapsedTime
						},
						getDelta: function () {
							var t = 0;
							if (this.autoStart && !this.running) return this.start(), 0;
							if (this.running) {
								var e = ("undefined" == typeof performance ? Date : performance).now();
								t = (e - this.oldTime) / 1e3, this.oldTime = e, this.elapsedTime += t
							}
							return t
						}
					}), Kl.prototype = Object.assign(Object.create(Mn.prototype), {
					constructor: Kl,
					getInput: function () {
						return this.gain
					},
					removeFilter: function () {
						return null !== this.filter && (this.gain.disconnect(this.filter), this.filter
							.disconnect(this.context.destination), this.gain.connect(this.context
								.destination), this.filter = null), this
					},
					getFilter: function () {
						return this.filter
					},
					setFilter: function (t) {
						return null !== this.filter ? (this.gain.disconnect(this.filter), this.filter
								.disconnect(this.context.destination)) : this.gain.disconnect(this
								.context.destination), this.filter = t, this.gain.connect(this
							.filter), this.filter.connect(this.context.destination), this
					},
					getMasterVolume: function () {
						return this.gain.gain.value
					},
					setMasterVolume: function (t) {
						return this.gain.gain.setTargetAtTime(t, this.context.currentTime, .01), this
					},
					updateMatrixWorld: (Ul = new li, Gl = new hi, Fl = new li, Hl = new li, kl = new Ql,
						function (t) {
							Mn.prototype.updateMatrixWorld.call(this, t);
							var e = this.context.listener,
								i = this.up;
							if (this.timeDelta = kl.getDelta(), this.matrixWorld.decompose(Ul, Gl,
								Fl), Hl.set(0, 0, -1).applyQuaternion(Gl), e.positionX) {
								var n = this.context.currentTime + this.timeDelta;
								e.positionX.linearRampToValueAtTime(Ul.x, n), e.positionY
									.linearRampToValueAtTime(Ul.y, n), e.positionZ
									.linearRampToValueAtTime(Ul.z, n), e.forwardX
									.linearRampToValueAtTime(Hl.x, n), e.forwardY
									.linearRampToValueAtTime(Hl.y, n), e.forwardZ
									.linearRampToValueAtTime(Hl.z, n), e.upX.linearRampToValueAtTime(i
										.x, n), e.upY.linearRampToValueAtTime(i.y, n), e.upZ
									.linearRampToValueAtTime(i.z, n)
							} else e.setPosition(Ul.x, Ul.y, Ul.z), e.setOrientation(Hl.x, Hl.y, Hl.z,
								i.x, i.y, i.z)
						})
				}), $l.prototype = Object.assign(Object.create(Mn.prototype), {
					constructor: $l,
					getOutput: function () {
						return this.gain
					},
					setNodeSource: function (t) {
						return this.hasPlaybackControl = !1, this.sourceType = "audioNode", this
							.source = t, this.connect(), this
					},
					setMediaElementSource: function (t) {
						return this.hasPlaybackControl = !1, this.sourceType = "mediaNode", this
							.source = this.context.createMediaElementSource(t), this.connect(), this
					},
					setBuffer: function (t) {
						return this.buffer = t, this.sourceType = "buffer", this.autoplay && this
							.play(), this
					},
					play: function () {
						if (!0 !== this.isPlaying) {
							if (!1 !== this.hasPlaybackControl) {
								var t = this.context.createBufferSource();
								return t.buffer = this.buffer, t.detune.value = this.detune, t.loop =
									this.loop, t.onended = this.onEnded.bind(this), t.playbackRate
									.setValueAtTime(this.playbackRate, this.startTime), this
									.startTime = this.context.currentTime, t.start(this.startTime,
										this.offset), this.isPlaying = !0, this.source = t, this
									.connect()
							}
							console.warn("THREE.Audio: this Audio has no playback control.")
						} else console.warn("THREE.Audio: Audio is already playing.")
					},
					pause: function () {
						if (!1 !== this.hasPlaybackControl) return !0 === this.isPlaying && (this
							.source.stop(), this.source.onended = null, this.offset += (this
								.context.currentTime - this.startTime) * this.playbackRate,
							this.isPlaying = !1), this;
						console.warn("THREE.Audio: this Audio has no playback control.")
					},
					stop: function () {
						if (!1 !== this.hasPlaybackControl) return this.source.stop(), this.source
							.onended = null, this.offset = 0, this.isPlaying = !1, this;
						console.warn("THREE.Audio: this Audio has no playback control.")
					},
					connect: function () {
						if (0 < this.filters.length) {
							this.source.connect(this.filters[0]);
							for (var t = 1, e = this.filters.length; t < e; t++) this.filters[t - 1]
								.connect(this.filters[t]);
							this.filters[this.filters.length - 1].connect(this.getOutput())
						} else this.source.connect(this.getOutput());
						return this
					},
					disconnect: function () {
						if (0 < this.filters.length) {
							this.source.disconnect(this.filters[0]);
							for (var t = 1, e = this.filters.length; t < e; t++) this.filters[t - 1]
								.disconnect(this.filters[t]);
							this.filters[this.filters.length - 1].disconnect(this.getOutput())
						} else this.source.disconnect(this.getOutput());
						return this
					},
					getFilters: function () {
						return this.filters
					},
					setFilters: function (t) {
						return t || (t = []), !0 === this.isPlaying ? (this.disconnect(), this
							.filters = t, this.connect()) : this.filters = t, this
					},
					setDetune: function (t) {
						return this.detune = t, !0 === this.isPlaying && this.source.detune
							.setTargetAtTime(this.detune, this.context.currentTime, .01), this
					},
					getDetune: function () {
						return this.detune
					},
					getFilter: function () {
						return this.getFilters()[0]
					},
					setFilter: function (t) {
						return this.setFilters(t ? [t] : [])
					},
					setPlaybackRate: function (t) {
						if (!1 !== this.hasPlaybackControl) return this.playbackRate = t, !0 === this
							.isPlaying && this.source.playbackRate.setTargetAtTime(this
								.playbackRate, this.context.currentTime, .01), this;
						console.warn("THREE.Audio: this Audio has no playback control.")
					},
					getPlaybackRate: function () {
						return this.playbackRate
					},
					onEnded: function () {
						this.isPlaying = !1
					},
					getLoop: function () {
						return !1 === this.hasPlaybackControl ? (console.warn(
							"THREE.Audio: this Audio has no playback control."), !1) : this.loop
					},
					setLoop: function (t) {
						if (!1 !== this.hasPlaybackControl) return this.loop = t, !0 === this
							.isPlaying && (this.source.loop = this.loop), this;
						console.warn("THREE.Audio: this Audio has no playback control.")
					},
					getVolume: function () {
						return this.gain.gain.value
					},
					setVolume: function (t) {
						return this.gain.gain.setTargetAtTime(t, this.context.currentTime, .01), this
					}
				}), tu.prototype = Object.assign(Object.create($l.prototype), {
					constructor: tu,
					getOutput: function () {
						return this.panner
					},
					getRefDistance: function () {
						return this.panner.refDistance
					},
					setRefDistance: function (t) {
						return this.panner.refDistance = t, this
					},
					getRolloffFactor: function () {
						return this.panner.rolloffFactor
					},
					setRolloffFactor: function (t) {
						return this.panner.rolloffFactor = t, this
					},
					getDistanceModel: function () {
						return this.panner.distanceModel
					},
					setDistanceModel: function (t) {
						return this.panner.distanceModel = t, this
					},
					getMaxDistance: function () {
						return this.panner.maxDistance
					},
					setMaxDistance: function (t) {
						return this.panner.maxDistance = t, this
					},
					setDirectionalCone: function (t, e, i) {
						return this.panner.coneInnerAngle = t, this.panner.coneOuterAngle = e, this
							.panner.coneOuterGain = i, this
					},
					updateMatrixWorld: (jl = new li, Vl = new hi, Wl = new li, ql = new li, function (t) {
						if (Mn.prototype.updateMatrixWorld.call(this, t), !1 !== this.isPlaying) {
							this.matrixWorld.decompose(jl, Vl, Wl), ql.set(0, 0, 1)
								.applyQuaternion(Vl);
							var e = this.panner;
							if (e.positionX) {
								var i = this.context.currentTime + this.listener.timeDelta;
								e.positionX.linearRampToValueAtTime(jl.x, i), e.positionY
									.linearRampToValueAtTime(jl.y, i), e.positionZ
									.linearRampToValueAtTime(jl.z, i), e.orientationX
									.linearRampToValueAtTime(ql.x, i), e.orientationY
									.linearRampToValueAtTime(ql.y, i), e.orientationZ
									.linearRampToValueAtTime(ql.z, i)
							} else e.setPosition(jl.x, jl.y, jl.z), e.setOrientation(ql.x, ql.y,
								ql.z)
						}
					})
				}), Object.assign(eu.prototype, {
					getFrequencyData: function () {
						return this.analyser.getByteFrequencyData(this.data), this.data
					},
					getAverageFrequency: function () {
						for (var t = 0, e = this.getFrequencyData(), i = 0; i < e.length; i++) t += e[
							i];
						return t / e.length
					}
				}), Object.assign(iu.prototype, {
					accumulate: function (t, e) {
						var i = this.buffer,
							n = this.valueSize,
							r = t * n + n,
							a = this.cumulativeWeight;
						if (0 === a) {
							for (var o = 0; o !== n; ++o) i[r + o] = i[o];
							a = e
						} else {
							var s = e / (a += e);
							this._mixBufferRegion(i, r, 0, s, n)
						}
						this.cumulativeWeight = a
					},
					apply: function (t) {
						var e = this.valueSize,
							i = this.buffer,
							n = t * e + e,
							r = this.cumulativeWeight,
							a = this.binding;
						if (this.cumulativeWeight = 0, r < 1) {
							var o = 3 * e;
							this._mixBufferRegion(i, n, o, 1 - r, e)
						}
						for (var s = e, c = e + e; s !== c; ++s)
							if (i[s] !== i[s + e]) {
								a.setValue(i, n);
								break
							}
					},
					saveOriginalState: function () {
						var t = this.binding,
							e = this.buffer,
							i = this.valueSize,
							n = 3 * i;
						t.getValue(e, n);
						for (var r = i, a = n; r !== a; ++r) e[r] = e[n + r % i];
						this.cumulativeWeight = 0
					},
					restoreOriginalState: function () {
						var t = 3 * this.valueSize;
						this.binding.setValue(this.buffer, t)
					},
					_select: function (t, e, i, n, r) {
						if (.5 <= n)
							for (var a = 0; a !== r; ++a) t[e + a] = t[i + a]
					},
					_slerp: function (t, e, i, n) {
						hi.slerpFlat(t, e, t, e, t, i, n)
					},
					_lerp: function (t, e, i, n, r) {
						for (var a = 1 - n, o = 0; o !== r; ++o) {
							var s = e + o;
							t[s] = t[s] * a + t[i + o] * n
						}
					}
				});
				var nu, ru, au, ou, su, cu, hu, lu, uu, pu, du, fu, mu, gu, vu, yu, xu, bu, wu, _u, Mu, Su, Eu,
					Tu, Au, Lu, Pu, Cu, Ru, Ou, Iu, Du, Bu, Nu, zu = "\\[\\]\\.:\\/";

				function Uu(t, e, i) {
					var n = i || Gu.parseTrackName(e);
					this._targetGroup = t, this._bindings = t.subscribe_(e, n)
				}

				function Gu(t, e, i) {
					this.path = e, this.parsedPath = i || Gu.parseTrackName(e), this.node = Gu.findNode(t, this
						.parsedPath.nodeName) || t, this.rootNode = t
				}

				function Fu() {
					this.uuid = oi.generateUUID(), this._objects = Array.prototype.slice.call(arguments), this
						.nCachedObjects_ = 0;
					var t = {};
					this._indicesByUUID = t;
					for (var e = 0, i = arguments.length; e !== i; ++e) t[arguments[e].uuid] = e;
					this._paths = [], this._parsedPaths = [], this._bindings = [], this
						._bindingsIndicesByPath = {};
					var n = this;
					this.stats = {
						objects: {
							get total() {
								return n._objects.length
							},
							get inUse() {
								return this.total - n.nCachedObjects_
							}
						},
						get bindingsPerObject() {
							return n._bindings.length
						}
					}
				}

				function Hu(t, e, i) {
					this._mixer = t, this._clip = e, this._localRoot = i || null;
					for (var n = e.tracks, r = n.length, a = new Array(r), o = {
							endingStart: ke,
							endingEnd: ke
						}, s = 0; s !== r; ++s) {
						var c = n[s].createInterpolant(null);
						(a[s] = c).settings = o
					}
					this._interpolantSettings = o, this._interpolants = a, this._propertyBindings = new Array(r),
						this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null,
						this._weightInterpolant = null, this.loop = ze, this._loopCount = -1, this._startTime =
						null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1,
						this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0,
						this.clampWhenFinished = !1, this.zeroSlopeAtStart = !0, this.zeroSlopeAtEnd = !0
				}

				function ku(t) {
					this._root = t, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this
						.timeScale = 1
				}

				function ju(t) {
					"string" == typeof t && (console.warn("THREE.Uniform: Type parameter is no longer needed."),
						t = arguments[1]), this.value = t
				}

				function Vu() {
					ir.call(this), this.type = "InstancedBufferGeometry", this.maxInstancedCount = void 0
				}

				function Wu(t, e, i) {
					$o.call(this, t, e), this.meshPerAttribute = i || 1
				}

				function qu(t, e, i, n) {
					"number" == typeof i && (n = i, i = !1, console.error(
						"THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument."
						)), In.call(this, t, e, i), this.meshPerAttribute = n || 1
				}

				function Xu(t, e, i, n) {
					this.ray = new Br(t, e), this.near = i || 0, this.far = n || 1 / 0, this.params = {
						Mesh: {},
						Line: {},
						LOD: {},
						Points: {
							threshold: 1
						},
						Sprite: {}
					}, Object.defineProperties(this.params, {
						PointCloud: {
							get: function () {
								return console.warn(
									"THREE.Raycaster: params.PointCloud has been renamed to params.Points."
									), this.Points
							}
						}
					})
				}

				function Yu(t, e) {
					return t.distance - e.distance
				}

				function Ju(t, e, i, n) {
					if (!1 !== t.visible && (t.raycast(e, i), !0 === n))
						for (var r = t.children, a = 0, o = r.length; a < o; a++) Ju(r[a], e, i, !0)
				}

				function Zu(t, e, i) {
					return this.radius = void 0 !== t ? t : 1, this.phi = void 0 !== e ? e : 0, this.theta =
						void 0 !== i ? i : 0, this
				}

				function Qu(t, e, i) {
					return this.radius = void 0 !== t ? t : 1, this.theta = void 0 !== e ? e : 0, this.y =
						void 0 !== i ? i : 0, this
				}

				function Ku(t, e) {
					this.min = void 0 !== t ? t : new si(1 / 0, 1 / 0), this.max = void 0 !== e ? e : new si(-1 /
						0, -1 / 0)
				}

				function $u(t, e) {
					this.start = void 0 !== t ? t : new li, this.end = void 0 !== e ? e : new li
				}

				function tp(t) {
					Mn.call(this), this.material = t, this.render = function () {}
				}

				function ep(t, e, i, n) {
					this.object = t, this.size = void 0 !== e ? e : 1;
					var r = void 0 !== i ? i : 16711680,
						a = void 0 !== n ? n : 1,
						o = 0,
						s = this.object.geometry;
					s && s.isGeometry ? o = 3 * s.faces.length : s && s.isBufferGeometry && (o = s.attributes
						.normal.count);
					var c = new ir,
						h = new Hn(2 * o * 3, 3);
					c.addAttribute("position", h), hs.call(this, c, new ss({
						color: r,
						linewidth: a
					})), this.matrixAutoUpdate = !1, this.update()
				}

				function ip(t, e) {
					Mn.call(this), this.light = t, this.light.updateMatrixWorld(), this.matrix = t.matrixWorld,
						this.matrixAutoUpdate = !1, this.color = e;
					for (var i = new ir, n = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0,
							1, 1, 0, 0, 0, 0, -1, 1
						], r = 0, a = 1, o = 32; r < o; r++, a++) {
						var s = r / o * Math.PI * 2,
							c = a / o * Math.PI * 2;
						n.push(Math.cos(s), Math.sin(s), 1, Math.cos(c), Math.sin(c), 1)
					}
					i.addAttribute("position", new Hn(n, 3));
					var h = new ss({
						fog: !1
					});
					this.cone = new hs(i, h), this.add(this.cone), this.update()
				}

				function np(t) {
					var e = [];
					t && t.isBone && e.push(t);
					for (var i = 0; i < t.children.length; i++) e.push.apply(e, np(t.children[i]));
					return e
				}

				function rp(t) {
					for (var e = np(t), i = new ir, n = [], r = [], a = new Xi(0, 0, 1), o = new Xi(0, 1, 0), s =
							0; s < e.length; s++) {
						var c = e[s];
						c.parent && c.parent.isBone && (n.push(0, 0, 0), n.push(0, 0, 0), r.push(a.r, a.g, a.b), r
							.push(o.r, o.g, o.b))
					}
					i.addAttribute("position", new Hn(n, 3)), i.addAttribute("color", new Hn(r, 3));
					var h = new ss({
						vertexColors: z,
						depthTest: !1,
						depthWrite: !1,
						transparent: !0
					});
					hs.call(this, i, h), this.root = t, this.bones = e, this.matrix = t.matrixWorld, this
						.matrixAutoUpdate = !1
				}

				function ap(t, e, i) {
					this.light = t, this.light.updateMatrixWorld(), this.color = i;
					var n = new wc(e, 4, 2),
						r = new zr({
							wireframe: !0,
							fog: !1
						});
					Ur.call(this, n, r), this.matrix = this.light.matrixWorld, this.matrixAutoUpdate = !1, this
						.update()
				}

				function op(t, e) {
					this.type = "RectAreaLightHelper", this.light = t, this.color = e;
					var i = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0, 1, 1, 0],
						n = new ir;
					n.addAttribute("position", new Hn(i, 3)), n.computeBoundingSphere();
					var r = new ss({
						fog: !1
					});
					cs.call(this, n, r);
					var a = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0],
						o = new ir;
					o.addAttribute("position", new Hn(a, 3)), o.computeBoundingSphere(), this.add(new Ur(o,
						new zr({
							side: THREE.BackSide,
							fog: !1
						}))), this.update()
				}

				function sp(t, e, i) {
					Mn.call(this), this.light = t, this.light.updateMatrixWorld(), this.matrix = t.matrixWorld,
						this.matrixAutoUpdate = !1, this.color = i;
					var n = new Es(e);
					n.rotateY(.5 * Math.PI), this.material = new zr({
						wireframe: !0,
						fog: !1
					}), void 0 === this.color && (this.material.vertexColors = z);
					var r = n.getAttribute("position"),
						a = new Float32Array(3 * r.count);
					n.addAttribute("color", new In(a, 3)), this.add(new Ur(n, this.material)), this.update()
				}

				function cp(t, e, i, n) {
					t = t || 10, e = e || 10, i = new Xi(void 0 !== i ? i : 4473924), n = new Xi(void 0 !== n ?
						n : 8947848);
					for (var r = e / 2, a = t / e, o = t / 2, s = [], c = [], h = 0, l = 0, u = -o; h <= e; h++,
						u += a) {
						s.push(-o, 0, u, o, 0, u), s.push(u, 0, -o, u, 0, o);
						var p = h === r ? i : n;
						p.toArray(c, l), l += 3, p.toArray(c, l), l += 3, p.toArray(c, l), l += 3, p.toArray(c,
							l), l += 3
					}
					var d = new ir;
					d.addAttribute("position", new Hn(s, 3)), d.addAttribute("color", new Hn(c, 3));
					var f = new ss({
						vertexColors: z
					});
					hs.call(this, d, f)
				}

				function hp(t, e, i, n, r, a) {
					t = t || 10, e = e || 16, i = i || 8, n = n || 64, r = new Xi(void 0 !== r ? r : 4473924), a =
						new Xi(void 0 !== a ? a : 8947848);
					var o, s, c, h, l, u, p, d = [],
						f = [];
					for (h = 0; h <= e; h++) c = h / e * (2 * Math.PI), o = Math.sin(c) * t, s = Math.cos(c) * t,
						d.push(0, 0, 0), d.push(o, 0, s), p = 1 & h ? r : a, f.push(p.r, p.g, p.b), f.push(p.r, p
							.g, p.b);
					for (h = 0; h <= i; h++)
						for (p = 1 & h ? r : a, u = t - t / i * h, l = 0; l < n; l++) c = l / n * (2 * Math.PI),
							o = Math.sin(c) * u, s = Math.cos(c) * u, d.push(o, 0, s), f.push(p.r, p.g, p.b), c =
							(l + 1) / n * (2 * Math.PI), o = Math.sin(c) * u, s = Math.cos(c) * u, d.push(o, 0,
							s), f.push(p.r, p.g, p.b);
					var m = new ir;
					m.addAttribute("position", new Hn(d, 3)), m.addAttribute("color", new Hn(f, 3));
					var g = new ss({
						vertexColors: z
					});
					hs.call(this, m, g)
				}

				function lp(t, e, i, n) {
					this.object = t, this.size = void 0 !== e ? e : 1;
					var r = void 0 !== i ? i : 16776960,
						a = void 0 !== n ? n : 1,
						o = 0,
						s = this.object.geometry;
					s && s.isGeometry ? o = s.faces.length : console.warn(
						"THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead."
						);
					var c = new ir,
						h = new Hn(2 * o * 3, 3);
					c.addAttribute("position", h), hs.call(this, c, new ss({
						color: r,
						linewidth: a
					})), this.matrixAutoUpdate = !1, this.update()
				}

				function up(t, e, i) {
					Mn.call(this), this.light = t, this.light.updateMatrixWorld(), this.matrix = t.matrixWorld,
						this.matrixAutoUpdate = !1, this.color = i, void 0 === e && (e = 1);
					var n = new ir;
					n.addAttribute("position", new Hn([-e, e, 0, e, e, 0, e, -e, 0, -e, -e, 0, -e, e, 0], 3));
					var r = new ss({
						fog: !1
					});
					this.lightPlane = new cs(n, r), this.add(this.lightPlane), (n = new ir).addAttribute(
						"position", new Hn([0, 0, 0, 0, 0, 1], 3)), this.targetLine = new cs(n, r), this.add(
						this.targetLine), this.update()
				}

				function pp(t) {
					var e = new ir,
						i = new ss({
							color: 16777215,
							vertexColors: D
						}),
						n = [],
						r = [],
						a = {},
						o = new Xi(16755200),
						s = new Xi(16711680),
						c = new Xi(43775),
						h = new Xi(16777215),
						l = new Xi(3355443);

					function u(t, e, i) {
						p(t, i), p(e, i)
					}

					function p(t, e) {
						n.push(0, 0, 0), r.push(e.r, e.g, e.b), void 0 === a[t] && (a[t] = []), a[t].push(n
							.length / 3 - 1)
					}
					u("n1", "n2", o), u("n2", "n4", o), u("n4", "n3", o), u("n3", "n1", o), u("f1", "f2", o), u(
							"f2", "f4", o), u("f4", "f3", o), u("f3", "f1", o), u("n1", "f1", o), u("n2", "f2",
						o), u("n3", "f3", o), u("n4", "f4", o), u("p", "n1", s), u("p", "n2", s), u("p", "n3", s),
						u("p", "n4", s), u("u1", "u2", c), u("u2", "u3", c), u("u3", "u1", c), u("c", "t", h), u(
							"p", "c", l), u("cn1", "cn2", l), u("cn3", "cn4", l), u("cf1", "cf2", l), u("cf3",
							"cf4", l), e.addAttribute("position", new Hn(n, 3)), e.addAttribute("color", new Hn(r,
							3)), hs.call(this, e, i), this.camera = t, this.camera.updateProjectionMatrix && this
						.camera.updateProjectionMatrix(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1,
						this.pointMap = a, this.update()
				}

				function dp(t, e) {
					this.object = t, void 0 === e && (e = 16776960);
					var i = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3,
							7
						]),
						n = new Float32Array(24),
						r = new ir;
					r.setIndex(new In(i, 1)), r.addAttribute("position", new In(n, 3)), hs.call(this, r, new ss({
						color: e
					})), this.matrixAutoUpdate = !1, this.update()
				}

				function fp(t, e) {
					this.type = "Box3Helper", this.box = t;
					var i = void 0 !== e ? e : 16776960,
						n = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3,
							7
						]),
						r = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1],
						a = new ir;
					a.setIndex(new In(n, 1)), a.addAttribute("position", new Hn(r, 3)), hs.call(this, a, new ss({
						color: i
					})), this.geometry.computeBoundingSphere()
				}

				function mp(t, e, i) {
					this.type = "PlaneHelper", this.plane = t, this.size = void 0 === e ? 1 : e;
					var n = void 0 !== i ? i : 16776960,
						r = [1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 0, 0,
							1, 0, 0, 0
						],
						a = new ir;
					a.addAttribute("position", new Hn(r, 3)), a.computeBoundingSphere(), cs.call(this, a, new ss({
						color: n
					}));
					var o = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1],
						s = new ir;
					s.addAttribute("position", new Hn(o, 3)), s.computeBoundingSphere(), this.add(new Ur(s,
						new zr({
							color: n,
							opacity: .2,
							transparent: !0,
							depthWrite: !1
						})))
				}

				function gp(t, e, i, n, r, a) {
					Mn.call(this), void 0 === t && (t = new THREE.Vector3(0, 0, 1)), void 0 === e && (e =
							new THREE.Vector3(0, 0, 0)), void 0 === i && (i = 1), void 0 === n && (n = 16776960),
						void 0 === r && (r = .2 * i), void 0 === a && (a = .2 * r), void 0 === Iu && ((Iu =
							new ir).addAttribute("position", new Hn([0, 0, 0, 0, 1, 0], 3)), (Du = new Rc(0,
							.5, 1, 5, 1)).translate(0, -.5, 0)), this.position.copy(e), this.line = new cs(Iu,
							new ss({
								color: n
							})), this.line.matrixAutoUpdate = !1, this.add(this.line), this.cone = new Ur(Du,
							new zr({
								color: n
							})), this.cone.matrixAutoUpdate = !1, this.add(this.cone), this.setDirection(t), this
						.setLength(i, r, a)
				}

				function vp(t) {
					var e = [0, 0, 0, t = t || 1, 0, 0, 0, 0, 0, 0, t, 0, 0, 0, 0, 0, 0, t],
						i = [1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1],
						n = new ir;
					n.addAttribute("position", new Hn(e, 3)), n.addAttribute("color", new Hn(i, 3));
					var r = new ss({
						vertexColors: z
					});
					hs.call(this, n, r)
				}

				function yp(t, e, i, n, r, a, o) {
					return console.warn("THREE.Face4 has been removed. A THREE.Face3 will be created instead."),
						new tn(t, e, i, r, a, o)
				}
				Object.assign(Uu.prototype, {
						getValue: function (t, e) {
							this.bind();
							var i = this._targetGroup.nCachedObjects_,
								n = this._bindings[i];
							void 0 !== n && n.getValue(t, e)
						},
						setValue: function (t, e) {
							for (var i = this._bindings, n = this._targetGroup.nCachedObjects_, r = i
									.length; n !== r; ++n) i[n].setValue(t, e)
						},
						bind: function () {
							for (var t = this._bindings, e = this._targetGroup.nCachedObjects_, i = t
									.length; e !== i; ++e) t[e].bind()
						},
						unbind: function () {
							for (var t = this._bindings, e = this._targetGroup.nCachedObjects_, i = t
									.length; e !== i; ++e) t[e].unbind()
						}
					}), Object.assign(Gu, {
						Composite: Uu,
						create: function (t, e, i) {
							return t && t.isAnimationObjectGroup ? new Gu.Composite(t, e, i) : new Gu(t,
								e, i)
						},
						sanitizeNodeName: (uu = new RegExp("[" + zu + "]", "g"), function (t) {
							return t.replace(/\s/g, "_").replace(uu, "")
						}),
						parseTrackName: (nu = "[^" + zu + "]", ru = "[^" + zu.replace("\\.", "") + "]", au =
							/((?:WC+[\/:])*)/.source.replace("WC", nu), ou = /(WCOD+)?/.source.replace(
								"WCOD", ru), su = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", nu),
							cu = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", nu), hu = new RegExp("^" +
								au + ou + su + cu + "$"), lu = ["material", "materials", "bones"],
							function (t) {
								var e = hu.exec(t);
								if (!e) throw new Error("PropertyBinding: Cannot parse trackName: " + t);
								var i = {
										nodeName: e[2],
										objectName: e[3],
										objectIndex: e[4],
										propertyName: e[5],
										propertyIndex: e[6]
									},
									n = i.nodeName && i.nodeName.lastIndexOf(".");
								if (void 0 !== n && -1 !== n) {
									var r = i.nodeName.substring(n + 1); - 1 !== lu.indexOf(r) && (i
										.nodeName = i.nodeName.substring(0, n), i.objectName = r)
								}
								if (null === i.propertyName || 0 === i.propertyName.length)
								throw new Error(
										"PropertyBinding: can not parse propertyName from trackName: " +
										t);
								return i
							}),
						findNode: function (t, r) {
							if (!r || "" === r || "root" === r || "." === r || -1 === r || r === t.name ||
								r === t.uuid) return t;
							if (t.skeleton) {
								var e = t.skeleton.getBoneByName(r);
								if (void 0 !== e) return e
							}
							if (t.children) {
								var a = function (t) {
										for (var e = 0; e < t.length; e++) {
											var i = t[e];
											if (i.name === r || i.uuid === r) return i;
											var n = a(i.children);
											if (n) return n
										}
										return null
									},
									i = a(t.children);
								if (i) return i
							}
							return null
						}
					}), Object.assign(Gu.prototype, {
						_getValue_unavailable: function () {},
						_setValue_unavailable: function () {},
						BindingType: {
							Direct: 0,
							EntireArray: 1,
							ArrayElement: 2,
							HasFromToArray: 3
						},
						Versioning: {
							None: 0,
							NeedsUpdate: 1,
							MatrixWorldNeedsUpdate: 2
						},
						GetterByBindingType: [function (t, e) {
							t[e] = this.node[this.propertyName]
						}, function (t, e) {
							for (var i = this.resolvedProperty, n = 0, r = i.length; n !== r; ++n) t[
								e++] = i[n]
						}, function (t, e) {
							t[e] = this.resolvedProperty[this.propertyIndex]
						}, function (t, e) {
							this.resolvedProperty.toArray(t, e)
						}],
						SetterByBindingTypeAndVersioning: [
							[function (t, e) {
								this.targetObject[this.propertyName] = t[e]
							}, function (t, e) {
								this.targetObject[this.propertyName] = t[e], this.targetObject
									.needsUpdate = !0
							}, function (t, e) {
								this.targetObject[this.propertyName] = t[e], this.targetObject
									.matrixWorldNeedsUpdate = !0
							}],
							[function (t, e) {
								for (var i = this.resolvedProperty, n = 0, r = i.length; n !== r; ++n)
									i[n] = t[e++]
							}, function (t, e) {
								for (var i = this.resolvedProperty, n = 0, r = i.length; n !== r; ++n)
									i[n] = t[e++];
								this.targetObject.needsUpdate = !0
							}, function (t, e) {
								for (var i = this.resolvedProperty, n = 0, r = i.length; n !== r; ++n)
									i[n] = t[e++];
								this.targetObject.matrixWorldNeedsUpdate = !0
							}],
							[function (t, e) {
								this.resolvedProperty[this.propertyIndex] = t[e]
							}, function (t, e) {
								this.resolvedProperty[this.propertyIndex] = t[e], this.targetObject
									.needsUpdate = !0
							}, function (t, e) {
								this.resolvedProperty[this.propertyIndex] = t[e], this.targetObject
									.matrixWorldNeedsUpdate = !0
							}],
							[function (t, e) {
								this.resolvedProperty.fromArray(t, e)
							}, function (t, e) {
								this.resolvedProperty.fromArray(t, e), this.targetObject
									.needsUpdate = !0
							}, function (t, e) {
								this.resolvedProperty.fromArray(t, e), this.targetObject
									.matrixWorldNeedsUpdate = !0
							}]
						],
						getValue: function (t, e) {
							this.bind(), this.getValue(t, e)
						},
						setValue: function (t, e) {
							this.bind(), this.setValue(t, e)
						},
						bind: function () {
							var t = this.node,
								e = this.parsedPath,
								i = e.objectName,
								n = e.propertyName,
								r = e.propertyIndex;
							if (t || (t = Gu.findNode(this.rootNode, e.nodeName) || this.rootNode, this
									.node = t), this.getValue = this._getValue_unavailable, this
								.setValue = this._setValue_unavailable, t) {
								if (i) {
									var a = e.objectIndex;
									switch (i) {
										case "materials":
											if (!t.material) return void console.error(
												"THREE.PropertyBinding: Can not bind to material as node does not have a material.",
												this);
											if (!t.material.materials) return void console.error(
												"THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",
												this);
											t = t.material.materials;
											break;
										case "bones":
											if (!t.skeleton) return void console.error(
												"THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",
												this);
											t = t.skeleton.bones;
											for (var o = 0; o < t.length; o++)
												if (t[o].name === a) {
													a = o;
													break
												} break;
										default:
											if (void 0 === t[i]) return void console.error(
												"THREE.PropertyBinding: Can not bind to objectName of node undefined.",
												this);
											t = t[i]
									}
									if (void 0 !== a) {
										if (void 0 === t[a]) return void console.error(
											"THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",
											this, t);
										t = t[a]
									}
								}
								var s = t[n];
								if (void 0 !== s) {
									var c = this.Versioning.None;
									void 0 !== (this.targetObject = t).needsUpdate ? c = this.Versioning
										.NeedsUpdate : void 0 !== t.matrixWorldNeedsUpdate && (c = this
											.Versioning.MatrixWorldNeedsUpdate);
									var h = this.BindingType.Direct;
									if (void 0 !== r) {
										if ("morphTargetInfluences" === n) {
											if (!t.geometry) return void console.error(
												"THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",
												this);
											if (t.geometry.isBufferGeometry) {
												if (!t.geometry.morphAttributes) return void console
													.error(
														"THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",
														this);
												for (o = 0; o < this.node.geometry.morphAttributes
													.position.length; o++)
													if (t.geometry.morphAttributes.position[o].name ===
														r) {
														r = o;
														break
													}
											} else {
												if (!t.geometry.morphTargets) return void console.error(
													"THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphTargets.",
													this);
												for (o = 0; o < this.node.geometry.morphTargets
													.length; o++)
													if (t.geometry.morphTargets[o].name === r) {
														r = o;
														break
													}
											}
										}
										h = this.BindingType.ArrayElement, this.resolvedProperty = s, this
											.propertyIndex = r
									} else void 0 !== s.fromArray && void 0 !== s.toArray ? (h = this
											.BindingType.HasFromToArray, this.resolvedProperty = s) :
										Array.isArray(s) ? (h = this.BindingType.EntireArray, this
											.resolvedProperty = s) : this.propertyName = n;
									this.getValue = this.GetterByBindingType[h], this.setValue = this
										.SetterByBindingTypeAndVersioning[h][c]
								} else {
									var l = e.nodeName;
									console.error(
										"THREE.PropertyBinding: Trying to update property for track: " +
										l + "." + n + " but it wasn't found.", t)
								}
							} else console.error(
								"THREE.PropertyBinding: Trying to update node for track: " + this
								.path + " but it wasn't found.")
						},
						unbind: function () {
							this.node = null, this.getValue = this._getValue_unbound, this.setValue = this
								._setValue_unbound
						}
					}), Object.assign(Gu.prototype, {
						_getValue_unbound: Gu.prototype.getValue,
						_setValue_unbound: Gu.prototype.setValue
					}), Object.assign(Fu.prototype, {
						isAnimationObjectGroup: !0,
						add: function () {
							for (var t = this._objects, e = t.length, i = this.nCachedObjects_, n = this
									._indicesByUUID, r = this._paths, a = this._parsedPaths, o = this
									._bindings, s = o.length, c = void 0, h = 0, l = arguments
									.length; h !== l; ++h) {
								var u = arguments[h],
									p = u.uuid,
									d = n[p];
								if (void 0 === d) {
									d = e++, n[p] = d, t.push(u);
									for (var f = 0, m = s; f !== m; ++f) o[f].push(new Gu(u, r[f], a[f]))
								} else if (d < i) {
									c = t[d];
									var g = --i,
										v = t[g];
									t[n[v.uuid] = d] = v, t[n[p] = g] = u;
									for (f = 0, m = s; f !== m; ++f) {
										var y = o[f],
											x = y[g],
											b = y[d];
										y[d] = x, void 0 === b && (b = new Gu(u, r[f], a[f])), y[g] = b
									}
								} else t[d] !== c && console.error(
									"THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes."
									)
							}
							this.nCachedObjects_ = i
						},
						remove: function () {
							for (var t = this._objects, e = this.nCachedObjects_, i = this._indicesByUUID,
									n = this._bindings, r = n.length, a = 0, o = arguments.length; a !==
								o; ++a) {
								var s = arguments[a],
									c = s.uuid,
									h = i[c];
								if (void 0 !== h && e <= h) {
									var l = e++,
										u = t[l];
									t[i[u.uuid] = h] = u, t[i[c] = l] = s;
									for (var p = 0, d = r; p !== d; ++p) {
										var f = n[p],
											m = f[l],
											g = f[h];
										f[h] = m, f[l] = g
									}
								}
							}
							this.nCachedObjects_ = e
						},
						uncache: function () {
							for (var t = this._objects, e = t.length, i = this.nCachedObjects_, n = this
									._indicesByUUID, r = this._bindings, a = r.length, o = 0, s =
									arguments.length; o !== s; ++o) {
								var c = arguments[o].uuid,
									h = n[c];
								if (void 0 !== h)
									if (delete n[c], h < i) {
										var l = --i,
											u = t[l],
											p = t[v = --e];
										t[n[u.uuid] = h] = u, t[n[p.uuid] = l] = p, t.pop();
										for (var d = 0, f = a; d !== f; ++d) {
											var m = (y = r[d])[l],
												g = y[v];
											y[h] = m, y[l] = g, y.pop()
										}
									} else {
										var v;
										t[n[(p = t[v = --e]).uuid] = h] = p, t.pop();
										for (d = 0, f = a; d !== f; ++d) {
											var y;
											(y = r[d])[h] = y[v], y.pop()
										}
									}
							}
							this.nCachedObjects_ = i
						},
						subscribe_: function (t, e) {
							var i = this._bindingsIndicesByPath,
								n = i[t],
								r = this._bindings;
							if (void 0 !== n) return r[n];
							var a = this._paths,
								o = this._parsedPaths,
								s = this._objects,
								c = s.length,
								h = this.nCachedObjects_,
								l = new Array(c);
							n = r.length, i[t] = n, a.push(t), o.push(e), r.push(l);
							for (var u = h, p = s.length; u !== p; ++u) {
								var d = s[u];
								l[u] = new Gu(d, t, e)
							}
							return l
						},
						unsubscribe_: function (t) {
							var e = this._bindingsIndicesByPath,
								i = e[t];
							if (void 0 !== i) {
								var n = this._paths,
									r = this._parsedPaths,
									a = this._bindings,
									o = a.length - 1,
									s = a[o];
								a[e[t[o]] = i] = s, a.pop(), r[i] = r[o], r.pop(), n[i] = n[o], n.pop()
							}
						}
					}), Object.assign(Hu.prototype, {
						play: function () {
							return this._mixer._activateAction(this), this
						},
						stop: function () {
							return this._mixer._deactivateAction(this), this.reset()
						},
						reset: function () {
							return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -
								1, this._startTime = null, this.stopFading().stopWarping()
						},
						isRunning: function () {
							return this.enabled && !this.paused && 0 !== this.timeScale && null === this
								._startTime && this._mixer._isActiveAction(this)
						},
						isScheduled: function () {
							return this._mixer._isActiveAction(this)
						},
						startAt: function (t) {
							return this._startTime = t, this
						},
						setLoop: function (t, e) {
							return this.loop = t, this.repetitions = e, this
						},
						setEffectiveWeight: function (t) {
							return this.weight = t, this._effectiveWeight = this.enabled ? t : 0, this
								.stopFading()
						},
						getEffectiveWeight: function () {
							return this._effectiveWeight
						},
						fadeIn: function (t) {
							return this._scheduleFading(t, 0, 1)
						},
						fadeOut: function (t) {
							return this._scheduleFading(t, 1, 0)
						},
						crossFadeFrom: function (t, e, i) {
							if (t.fadeOut(e), this.fadeIn(e), i) {
								var n = this._clip.duration,
									r = t._clip.duration,
									a = r / n,
									o = n / r;
								t.warp(1, a, e), this.warp(o, 1, e)
							}
							return this
						},
						crossFadeTo: function (t, e, i) {
							return t.crossFadeFrom(this, e, i)
						},
						stopFading: function () {
							var t = this._weightInterpolant;
							return null !== t && (this._weightInterpolant = null, this._mixer
								._takeBackControlInterpolant(t)), this
						},
						setEffectiveTimeScale: function (t) {
							return this.timeScale = t, this._effectiveTimeScale = this.paused ? 0 : t,
								this.stopWarping()
						},
						getEffectiveTimeScale: function () {
							return this._effectiveTimeScale
						},
						setDuration: function (t) {
							return this.timeScale = this._clip.duration / t, this.stopWarping()
						},
						syncWith: function (t) {
							return this.time = t.time, this.timeScale = t.timeScale, this.stopWarping()
						},
						halt: function (t) {
							return this.warp(this._effectiveTimeScale, 0, t)
						},
						warp: function (t, e, i) {
							var n = this._mixer,
								r = n.time,
								a = this._timeScaleInterpolant,
								o = this.timeScale;
							null === a && (a = n._lendControlInterpolant(), this._timeScaleInterpolant =
								a);
							var s = a.parameterPositions,
								c = a.sampleValues;
							return s[0] = r, s[1] = r + i, c[0] = t / o, c[1] = e / o, this
						},
						stopWarping: function () {
							var t = this._timeScaleInterpolant;
							return null !== t && (this._timeScaleInterpolant = null, this._mixer
								._takeBackControlInterpolant(t)), this
						},
						getMixer: function () {
							return this._mixer
						},
						getClip: function () {
							return this._clip
						},
						getRoot: function () {
							return this._localRoot || this._mixer._root
						},
						_update: function (t, e, i, n) {
							if (this.enabled) {
								var r = this._startTime;
								if (null !== r) {
									var a = (t - r) * i;
									if (a < 0 || 0 === i) return;
									this._startTime = null, e = i * a
								}
								e *= this._updateTimeScale(t);
								var o = this._updateTime(e),
									s = this._updateWeight(t);
								if (0 < s)
									for (var c = this._interpolants, h = this._propertyBindings, l = 0,
											u = c.length; l !== u; ++l) c[l].evaluate(o), h[l].accumulate(
										n, s)
							} else this._updateWeight(t)
						},
						_updateWeight: function (t) {
							var e = 0;
							if (this.enabled) {
								e = this.weight;
								var i = this._weightInterpolant;
								if (null !== i) {
									var n = i.evaluate(t)[0];
									e *= n, t > i.parameterPositions[1] && (this.stopFading(), 0 === n &&
										(this.enabled = !1))
								}
							}
							return this._effectiveWeight = e
						},
						_updateTimeScale: function (t) {
							var e = 0;
							if (!this.paused) {
								e = this.timeScale;
								var i = this._timeScaleInterpolant;
								if (null !== i) e *= i.evaluate(t)[0], t > i.parameterPositions[1] && (
									this.stopWarping(), 0 === e ? this.paused = !0 : this.timeScale =
									e)
							}
							return this._effectiveTimeScale = e
						},
						_updateTime: function (t) {
							var e = this.time + t,
								i = this._clip.duration,
								n = this.loop,
								r = this._loopCount,
								a = n === Ue;
							if (0 === t) return -1 === r ? e : a && 1 == (1 & r) ? i - e : e;
							if (n === Ne) {
								-1 === r && (this._loopCount = 0, this._setEndings(!0, !0, !1));
								t: {
									if (i <= e) e = i;
									else {
										if (!(e < 0)) break t;
										e = 0
									}
									this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
									this._mixer.dispatchEvent({
										type: "finished",
										action: this,
										direction: t < 0 ? -1 : 1
									})
								}
							} else {
								if (-1 === r && (0 <= t ? (r = 0, this._setEndings(!0, 0 === this
										.repetitions, a)) : this._setEndings(0 === this.repetitions, !
										0, a)), i <= e || e < 0) {
									var o = Math.floor(e / i);
									e -= i * o, r += Math.abs(o);
									var s = this.repetitions - r;
									if (s <= 0) this.clampWhenFinished ? this.paused = !0 : this
										.enabled = !1, e = 0 < t ? i : 0, this._mixer.dispatchEvent({
											type: "finished",
											action: this,
											direction: 0 < t ? 1 : -1
										});
									else {
										if (1 === s) {
											var c = t < 0;
											this._setEndings(c, !c, a)
										} else this._setEndings(!1, !1, a);
										this._loopCount = r, this._mixer.dispatchEvent({
											type: "loop",
											action: this,
											loopDelta: o
										})
									}
								}
								if (a && 1 == (1 & r)) return i - (this.time = e)
							}
							return this.time = e
						},
						_setEndings: function (t, e, i) {
							var n = this._interpolantSettings;
							n.endingEnd = i ? n.endingStart = je : (n.endingStart = t ? this
								.zeroSlopeAtStart ? je : ke : Ve, e ? this.zeroSlopeAtEnd ? je : ke :
								Ve)
						},
						_scheduleFading: function (t, e, i) {
							var n = this._mixer,
								r = n.time,
								a = this._weightInterpolant;
							null === a && (a = n._lendControlInterpolant(), this._weightInterpolant = a);
							var o = a.parameterPositions,
								s = a.sampleValues;
							return o[0] = r, s[0] = e, o[1] = r + t, s[1] = i, this
						}
					}), ku.prototype = Object.assign(Object.create(e.prototype), {
						constructor: ku,
						_bindAction: function (t, e) {
							var i = t._localRoot || this._root,
								n = t._clip.tracks,
								r = n.length,
								a = t._propertyBindings,
								o = t._interpolants,
								s = i.uuid,
								c = this._bindingsByRootAndName,
								h = c[s];
							void 0 === h && (h = {}, c[s] = h);
							for (var l = 0; l !== r; ++l) {
								var u = n[l],
									p = u.name,
									d = h[p];
								if (void 0 !== d) a[l] = d;
								else {
									if (void 0 !== (d = a[l])) {
										null === d._cacheIndex && (++d.referenceCount, this
											._addInactiveBinding(d, s, p));
										continue
									}
									var f = e && e._propertyBindings[l].binding.parsedPath;
									++(d = new iu(Gu.create(i, p, f), u.ValueTypeName, u.getValueSize()))
									.referenceCount, this._addInactiveBinding(d, s, p), a[l] = d
								}
								o[l].resultBuffer = d.buffer
							}
						},
						_activateAction: function (t) {
							if (!this._isActiveAction(t)) {
								if (null === t._cacheIndex) {
									var e = (t._localRoot || this._root).uuid,
										i = t._clip.uuid,
										n = this._actionsByClip[i];
									this._bindAction(t, n && n.knownActions[0]), this._addInactiveAction(
										t, i, e)
								}
								for (var r = t._propertyBindings, a = 0, o = r.length; a !== o; ++a) {
									var s = r[a];
									0 == s.useCount++ && (this._lendBinding(s), s.saveOriginalState())
								}
								this._lendAction(t)
							}
						},
						_deactivateAction: function (t) {
							if (this._isActiveAction(t)) {
								for (var e = t._propertyBindings, i = 0, n = e.length; i !== n; ++i) {
									var r = e[i];
									0 == --r.useCount && (r.restoreOriginalState(), this._takeBackBinding(
										r))
								}
								this._takeBackAction(t)
							}
						},
						_initMemoryManager: function () {
							this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this
								._bindings = [], this._nActiveBindings = 0, this
								._bindingsByRootAndName = {}, this._controlInterpolants = [], this
								._nActiveControlInterpolants = 0;
							var t = this;
							this.stats = {
								actions: {
									get total() {
										return t._actions.length
									},
									get inUse() {
										return t._nActiveActions
									}
								},
								bindings: {
									get total() {
										return t._bindings.length
									},
									get inUse() {
										return t._nActiveBindings
									}
								},
								controlInterpolants: {
									get total() {
										return t._controlInterpolants.length
									},
									get inUse() {
										return t._nActiveControlInterpolants
									}
								}
							}
						},
						_isActiveAction: function (t) {
							var e = t._cacheIndex;
							return null !== e && e < this._nActiveActions
						},
						_addInactiveAction: function (t, e, i) {
							var n = this._actions,
								r = this._actionsByClip,
								a = r[e];
							if (void 0 === a) a = {
								knownActions: [t],
								actionByRoot: {}
							}, t._byClipCacheIndex = 0, r[e] = a;
							else {
								var o = a.knownActions;
								t._byClipCacheIndex = o.length, o.push(t)
							}
							t._cacheIndex = n.length, n.push(t), a.actionByRoot[i] = t
						},
						_removeInactiveAction: function (t) {
							var e = this._actions,
								i = e[e.length - 1],
								n = t._cacheIndex;
							e[i._cacheIndex = n] = i, e.pop(), t._cacheIndex = null;
							var r = t._clip.uuid,
								a = this._actionsByClip,
								o = a[r],
								s = o.knownActions,
								c = s[s.length - 1],
								h = t._byClipCacheIndex;
							s[c._byClipCacheIndex = h] = c, s.pop(), t._byClipCacheIndex = null, delete o
								.actionByRoot[(t._localRoot || this._root).uuid], 0 === s.length &&
								delete a[r], this._removeInactiveBindingsForAction(t)
						},
						_removeInactiveBindingsForAction: function (t) {
							for (var e = t._propertyBindings, i = 0, n = e.length; i !== n; ++i) {
								var r = e[i];
								0 == --r.referenceCount && this._removeInactiveBinding(r)
							}
						},
						_lendAction: function (t) {
							var e = this._actions,
								i = t._cacheIndex,
								n = this._nActiveActions++,
								r = e[n];
							e[t._cacheIndex = n] = t, e[r._cacheIndex = i] = r
						},
						_takeBackAction: function (t) {
							var e = this._actions,
								i = t._cacheIndex,
								n = --this._nActiveActions,
								r = e[n];
							e[t._cacheIndex = n] = t, e[r._cacheIndex = i] = r
						},
						_addInactiveBinding: function (t, e, i) {
							var n = this._bindingsByRootAndName,
								r = n[e],
								a = this._bindings;
							void 0 === r && (r = {}, n[e] = r), (r[i] = t)._cacheIndex = a.length, a.push(
								t)
						},
						_removeInactiveBinding: function (t) {
							var e = this._bindings,
								i = t.binding,
								n = i.rootNode.uuid,
								r = i.path,
								a = this._bindingsByRootAndName,
								o = a[n],
								s = e[e.length - 1],
								c = t._cacheIndex;
							e[s._cacheIndex = c] = s, e.pop(), delete o[r];
							t: {
								for (var h in o) break t;delete a[n]
							}
						},
						_lendBinding: function (t) {
							var e = this._bindings,
								i = t._cacheIndex,
								n = this._nActiveBindings++,
								r = e[n];
							e[t._cacheIndex = n] = t, e[r._cacheIndex = i] = r
						},
						_takeBackBinding: function (t) {
							var e = this._bindings,
								i = t._cacheIndex,
								n = --this._nActiveBindings,
								r = e[n];
							e[t._cacheIndex = n] = t, e[r._cacheIndex = i] = r
						},
						_lendControlInterpolant: function () {
							var t = this._controlInterpolants,
								e = this._nActiveControlInterpolants++,
								i = t[e];
							return void 0 === i && (t[(i = new Qc(new Float32Array(2), new Float32Array(
									2), 1, this._controlInterpolantsResultBuffer)).__cacheIndex =
								e] = i), i
						},
						_takeBackControlInterpolant: function (t) {
							var e = this._controlInterpolants,
								i = t.__cacheIndex,
								n = --this._nActiveControlInterpolants,
								r = e[n];
							e[t.__cacheIndex = n] = t, e[r.__cacheIndex = i] = r
						},
						_controlInterpolantsResultBuffer: new Float32Array(1),
						clipAction: function (t, e) {
							var i = e || this._root,
								n = i.uuid,
								r = "string" == typeof t ? sh.findByName(i, t) : t,
								a = null !== r ? r.uuid : t,
								o = this._actionsByClip[a],
								s = null;
							if (void 0 !== o) {
								var c = o.actionByRoot[n];
								if (void 0 !== c) return c;
								s = o.knownActions[0], null === r && (r = s._clip)
							}
							if (null === r) return null;
							var h = new Hu(this, r, e);
							return this._bindAction(h, s), this._addInactiveAction(h, a, n), h
						},
						existingAction: function (t, e) {
							var i = e || this._root,
								n = i.uuid,
								r = "string" == typeof t ? sh.findByName(i, t) : t,
								a = r ? r.uuid : t,
								o = this._actionsByClip[a];
							return void 0 !== o && o.actionByRoot[n] || null
						},
						stopAllAction: function () {
							var t = this._actions,
								e = this._nActiveActions,
								i = this._bindings,
								n = this._nActiveBindings;
							this._nActiveActions = 0;
							for (var r = this._nActiveBindings = 0; r !== e; ++r) t[r].reset();
							for (r = 0; r !== n; ++r) i[r].useCount = 0;
							return this
						},
						update: function (t) {
							t *= this.timeScale;
							for (var e = this._actions, i = this._nActiveActions, n = this.time += t, r =
									Math.sign(t), a = this._accuIndex ^= 1, o = 0; o !== i; ++o) {
								e[o]._update(n, t, r, a)
							}
							var s = this._bindings,
								c = this._nActiveBindings;
							for (o = 0; o !== c; ++o) s[o].apply(a);
							return this
						},
						getRoot: function () {
							return this._root
						},
						uncacheClip: function (t) {
							var e = this._actions,
								i = t.uuid,
								n = this._actionsByClip,
								r = n[i];
							if (void 0 !== r) {
								for (var a = r.knownActions, o = 0, s = a.length; o !== s; ++o) {
									var c = a[o];
									this._deactivateAction(c);
									var h = c._cacheIndex,
										l = e[e.length - 1];
									c._cacheIndex = null, c._byClipCacheIndex = null, e[l._cacheIndex =
										h] = l, e.pop(), this._removeInactiveBindingsForAction(c)
								}
								delete n[i]
							}
						},
						uncacheRoot: function (t) {
							var e = t.uuid,
								i = this._actionsByClip;
							for (var n in i) {
								var r = i[n].actionByRoot[e];
								void 0 !== r && (this._deactivateAction(r), this._removeInactiveAction(r))
							}
							var a = this._bindingsByRootAndName[e];
							if (void 0 !== a)
								for (var o in a) {
									var s = a[o];
									s.restoreOriginalState(), this._removeInactiveBinding(s)
								}
						},
						uncacheAction: function (t, e) {
							var i = this.existingAction(t, e);
							null !== i && (this._deactivateAction(i), this._removeInactiveAction(i))
						}
					}), ju.prototype.clone = function () {
						return new ju(void 0 === this.value.clone ? this.value : this.value.clone())
					}, Vu.prototype = Object.assign(Object.create(ir.prototype), {
						constructor: Vu,
						isInstancedBufferGeometry: !0,
						copy: function (t) {
							return ir.prototype.copy.call(this, t), this.maxInstancedCount = t
								.maxInstancedCount, this
						},
						clone: function () {
							return (new this.constructor).copy(this)
						}
					}), Wu.prototype = Object.assign(Object.create($o.prototype), {
						constructor: Wu,
						isInstancedInterleavedBuffer: !0,
						copy: function (t) {
							return $o.prototype.copy.call(this, t), this.meshPerAttribute = t
								.meshPerAttribute, this
						}
					}), qu.prototype = Object.assign(Object.create(In.prototype), {
						constructor: qu,
						isInstancedBufferAttribute: !0,
						copy: function (t) {
							return In.prototype.copy.call(this, t), this.meshPerAttribute = t
								.meshPerAttribute, this
						}
					}), Object.assign(Xu.prototype, {
						linePrecision: 1,
						set: function (t, e) {
							this.ray.set(t, e)
						},
						setFromCamera: function (t, e) {
							e && e.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(e
									.matrixWorld), this.ray.direction.set(t.x, t.y, .5).unproject(e)
								.sub(this.ray.origin).normalize()) : e && e.isOrthographicCamera ? (
								this.ray.origin.set(t.x, t.y, (e.near + e.far) / (e.near - e.far))
								.unproject(e), this.ray.direction.set(0, 0, -1).transformDirection(e
									.matrixWorld)) : console.error(
								"THREE.Raycaster: Unsupported camera type.")
						},
						intersectObject: function (t, e, i) {
							var n = i || [];
							return Ju(t, this, n, e), n.sort(Yu), n
						},
						intersectObjects: function (t, e, i) {
							var n = i || [];
							if (!1 === Array.isArray(t)) return console.warn(
								"THREE.Raycaster.intersectObjects: objects is not an Array."), n;
							for (var r = 0, a = t.length; r < a; r++) Ju(t[r], this, n, e);
							return n.sort(Yu), n
						}
					}), Object.assign(Zu.prototype, {
						set: function (t, e, i) {
							return this.radius = t, this.phi = e, this.theta = i, this
						},
						clone: function () {
							return (new this.constructor).copy(this)
						},
						copy: function (t) {
							return this.radius = t.radius, this.phi = t.phi, this.theta = t.theta, this
						},
						makeSafe: function () {
							var t = 1e-6;
							return this.phi = Math.max(t, Math.min(Math.PI - t, this.phi)), this
						},
						setFromVector3: function (t) {
							return this.setFromCartesianCoords(t.x, t.y, t.z)
						},
						setFromCartesianCoords: function (t, e, i) {
							return this.radius = Math.sqrt(t * t + e * e + i * i), 0 === this.radius ? (
								this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(t, i), this
								.phi = Math.acos(oi.clamp(e / this.radius, -1, 1))), this
						}
					}), Object.assign(Qu.prototype, {
						set: function (t, e, i) {
							return this.radius = t, this.theta = e, this.y = i, this
						},
						clone: function () {
							return (new this.constructor).copy(this)
						},
						copy: function (t) {
							return this.radius = t.radius, this.theta = t.theta, this.y = t.y, this
						},
						setFromVector3: function (t) {
							return this.setFromCartesianCoords(t.x, t.y, t.z)
						},
						setFromCartesianCoords: function (t, e, i) {
							return this.radius = Math.sqrt(t * t + i * i), this.theta = Math.atan2(t, i),
								this.y = e, this
						}
					}), Object.assign(Ku.prototype, {
						set: function (t, e) {
							return this.min.copy(t), this.max.copy(e), this
						},
						setFromPoints: function (t) {
							this.makeEmpty();
							for (var e = 0, i = t.length; e < i; e++) this.expandByPoint(t[e]);
							return this
						},
						setFromCenterAndSize: (du = new si, function (t, e) {
							var i = du.copy(e).multiplyScalar(.5);
							return this.min.copy(t).sub(i), this.max.copy(t).add(i), this
						}),
						clone: function () {
							return (new this.constructor).copy(this)
						},
						copy: function (t) {
							return this.min.copy(t.min), this.max.copy(t.max), this
						},
						makeEmpty: function () {
							return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this
						},
						isEmpty: function () {
							return this.max.x < this.min.x || this.max.y < this.min.y
						},
						getCenter: function (t) {
							return void 0 === t && (console.warn(
									"THREE.Box2: .getCenter() target is now required"), t = new si), this
								.isEmpty() ? t.set(0, 0) : t.addVectors(this.min, this.max)
								.multiplyScalar(.5)
						},
						getSize: function (t) {
							return void 0 === t && (console.warn(
									"THREE.Box2: .getSize() target is now required"), t = new si), this
								.isEmpty() ? t.set(0, 0) : t.subVectors(this.max, this.min)
						},
						expandByPoint: function (t) {
							return this.min.min(t), this.max.max(t), this
						},
						expandByVector: function (t) {
							return this.min.sub(t), this.max.add(t), this
						},
						expandByScalar: function (t) {
							return this.min.addScalar(-t), this.max.addScalar(t), this
						},
						containsPoint: function (t) {
							return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y >
								this.max.y)
						},
						containsBox: function (t) {
							return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min
								.y && t.max.y <= this.max.y
						},
						getParameter: function (t, e) {
							return void 0 === e && (console.warn(
									"THREE.Box2: .getParameter() target is now required"), e = new si), e
								.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) /
									(this.max.y - this.min.y))
						},
						intersectsBox: function (t) {
							return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min
								.y || t.min.y > this.max.y)
						},
						clampPoint: function (t, e) {
							return void 0 === e && (console.warn(
									"THREE.Box2: .clampPoint() target is now required"), e = new si), e
								.copy(t).clamp(this.min, this.max)
						},
						distanceToPoint: (pu = new si, function (t) {
							return pu.copy(t).clamp(this.min, this.max).sub(t).length()
						}),
						intersect: function (t) {
							return this.min.max(t.min), this.max.min(t.max), this
						},
						union: function (t) {
							return this.min.min(t.min), this.max.max(t.max), this
						},
						translate: function (t) {
							return this.min.add(t), this.max.add(t), this
						},
						equals: function (t) {
							return t.min.equals(this.min) && t.max.equals(this.max)
						}
					}), Object.assign($u.prototype, {
						set: function (t, e) {
							return this.start.copy(t), this.end.copy(e), this
						},
						clone: function () {
							return (new this.constructor).copy(this)
						},
						copy: function (t) {
							return this.start.copy(t.start), this.end.copy(t.end), this
						},
						getCenter: function (t) {
							return void 0 === t && (console.warn(
									"THREE.Line3: .getCenter() target is now required"), t = new li), t
								.addVectors(this.start, this.end).multiplyScalar(.5)
						},
						delta: function (t) {
							return void 0 === t && (console.warn(
									"THREE.Line3: .delta() target is now required"), t = new li), t
								.subVectors(this.end, this.start)
						},
						distanceSq: function () {
							return this.start.distanceToSquared(this.end)
						},
						distance: function () {
							return this.start.distanceTo(this.end)
						},
						at: function (t, e) {
							return void 0 === e && (console.warn(
								"THREE.Line3: .at() target is now required"), e = new li), this.delta(
								e).multiplyScalar(t).add(this.start)
						},
						closestPointToPointParameter: (fu = new li, mu = new li, function (t, e) {
							fu.subVectors(t, this.start), mu.subVectors(this.end, this.start);
							var i = mu.dot(mu),
								n = mu.dot(fu) / i;
							return e && (n = oi.clamp(n, 0, 1)), n
						}),
						closestPointToPoint: function (t, e, i) {
							var n = this.closestPointToPointParameter(t, e);
							return void 0 === i && (console.warn(
									"THREE.Line3: .closestPointToPoint() target is now required"), i =
								new li), this.delta(i).multiplyScalar(n).add(this.start)
						},
						applyMatrix4: function (t) {
							return this.start.applyMatrix4(t), this.end.applyMatrix4(t), this
						},
						equals: function (t) {
							return t.start.equals(this.start) && t.end.equals(this.end)
						}
					}), tp.prototype = Object.create(Mn.prototype), (tp.prototype.constructor = tp).prototype
					.isImmediateRenderObject = !0, ep.prototype = Object.create(hs.prototype), (ep.prototype
						.constructor = ep).prototype.update = (gu = new li, vu = new li, yu = new ui,
				function () {
						var t = ["a", "b", "c"];
						this.object.updateMatrixWorld(!0), yu.getNormalMatrix(this.object.matrixWorld);
						var e = this.object.matrixWorld,
							i = this.geometry.attributes.position,
							n = this.object.geometry;
						if (n && n.isGeometry)
							for (var r = n.vertices, a = n.faces, o = 0, s = 0, c = a.length; s < c; s++)
								for (var h = a[s], l = 0, u = h.vertexNormals.length; l < u; l++) {
									var p = r[h[t[l]]],
										d = h.vertexNormals[l];
									gu.copy(p).applyMatrix4(e), vu.copy(d).applyMatrix3(yu).normalize()
										.multiplyScalar(this.size).add(gu), i.setXYZ(o, gu.x, gu.y, gu.z),
										o += 1, i.setXYZ(o, vu.x, vu.y, vu.z), o += 1
								} else if (n && n.isBufferGeometry) {
									var f = n.attributes.position,
										m = n.attributes.normal;
									for (l = o = 0, u = f.count; l < u; l++) gu.set(f.getX(l), f.getY(l), f
											.getZ(l)).applyMatrix4(e), vu.set(m.getX(l), m.getY(l), m.getZ(
										l)), vu.applyMatrix3(yu).normalize().multiplyScalar(this.size).add(
										gu), i.setXYZ(o, gu.x, gu.y, gu.z), o += 1, i.setXYZ(o, vu.x, vu.y, vu
											.z), o += 1
								} i.needsUpdate = !0
					}), ip.prototype = Object.create(Mn.prototype), (ip.prototype.constructor = ip).prototype
					.dispose = function () {
						this.cone.geometry.dispose(), this.cone.material.dispose()
					}, ip.prototype.update = (xu = new li, function () {
						this.light.updateMatrixWorld();
						var t = this.light.distance ? this.light.distance : 1e3,
							e = t * Math.tan(this.light.angle);
						this.cone.scale.set(e, e, t), xu.setFromMatrixPosition(this.light.target.matrixWorld),
							this.cone.lookAt(xu), void 0 !== this.color ? this.cone.material.color.set(this
								.color) : this.cone.material.color.copy(this.light.color)
					}), rp.prototype = Object.create(hs.prototype), (rp.prototype.constructor = rp).prototype
					.updateMatrixWorld = (bu = new li, wu = new ci, _u = new ci, function (t) {
						var e = this.bones,
							i = this.geometry,
							n = i.getAttribute("position");
						_u.getInverse(this.root.matrixWorld);
						for (var r = 0, a = 0; r < e.length; r++) {
							var o = e[r];
							o.parent && o.parent.isBone && (wu.multiplyMatrices(_u, o.matrixWorld), bu
								.setFromMatrixPosition(wu), n.setXYZ(a, bu.x, bu.y, bu.z), wu
								.multiplyMatrices(_u, o.parent.matrixWorld), bu.setFromMatrixPosition(wu),
								n.setXYZ(a + 1, bu.x, bu.y, bu.z), a += 2)
						}
						i.getAttribute("position").needsUpdate = !0, Mn.prototype.updateMatrixWorld.call(this,
							t)
					}), ap.prototype = Object.create(Ur.prototype), (ap.prototype.constructor = ap).prototype
					.dispose = function () {
						this.geometry.dispose(), this.material.dispose()
					}, ap.prototype.update = function () {
						void 0 !== this.color ? this.material.color.set(this.color) : this.material.color.copy(
							this.light.color)
					}, op.prototype = Object.create(cs.prototype), (op.prototype.constructor = op).prototype
					.update = function () {
						if (this.scale.set(.5 * this.light.width, .5 * this.light.height, 1), void 0 !== this
							.color) this.material.color.set(this.color), this.children[0].material.color.set(this
							.color);
						else {
							this.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
							var t = this.material.color,
								e = Math.max(t.r, t.g, t.b);
							1 < e && t.multiplyScalar(1 / e), this.children[0].material.color.copy(this.material
								.color)
						}
					}, op.prototype.dispose = function () {
						this.geometry.dispose(), this.material.dispose(), this.children[0].geometry.dispose(),
							this.children[0].material.dispose()
					}, sp.prototype = Object.create(Mn.prototype), (sp.prototype.constructor = sp).prototype
					.dispose = function () {
						this.children[0].geometry.dispose(), this.children[0].material.dispose()
					}, sp.prototype.update = (Mu = new li, Su = new Xi, Eu = new Xi, function () {
						var t = this.children[0];
						if (void 0 !== this.color) this.material.color.set(this.color);
						else {
							var e = t.geometry.getAttribute("color");
							Su.copy(this.light.color), Eu.copy(this.light.groundColor);
							for (var i = 0, n = e.count; i < n; i++) {
								var r = i < n / 2 ? Su : Eu;
								e.setXYZ(i, r.r, r.g, r.b)
							}
							e.needsUpdate = !0
						}
						t.lookAt(Mu.setFromMatrixPosition(this.light.matrixWorld).negate())
					}), cp.prototype = Object.create(hs.prototype), cp.prototype.constructor = cp, hp.prototype =
					Object.create(hs.prototype), hp.prototype.constructor = hp, lp.prototype = Object.create(hs
						.prototype), (lp.prototype.constructor = lp).prototype.update = (Tu = new li, Au = new li,
						Lu = new ui,
						function () {
							this.object.updateMatrixWorld(!0), Lu.getNormalMatrix(this.object.matrixWorld);
							for (var t = this.object.matrixWorld, e = this.geometry.attributes.position, i = this
									.object.geometry, n = i.vertices, r = i.faces, a = 0, o = 0, s = r.length; o <
								s; o++) {
								var c = r[o],
									h = c.normal;
								Tu.copy(n[c.a]).add(n[c.b]).add(n[c.c]).divideScalar(3).applyMatrix4(t), Au.copy(
										h).applyMatrix3(Lu).normalize().multiplyScalar(this.size).add(Tu), e
									.setXYZ(a, Tu.x, Tu.y, Tu.z), a += 1, e.setXYZ(a, Au.x, Au.y, Au.z), a += 1
							}
							e.needsUpdate = !0
						}), up.prototype = Object.create(Mn.prototype), (up.prototype.constructor = up).prototype
					.dispose = function () {
						this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine
							.geometry.dispose(), this.targetLine.material.dispose()
					}, up.prototype.update = (Pu = new li, Cu = new li, Ru = new li, function () {
						Pu.setFromMatrixPosition(this.light.matrixWorld), Cu.setFromMatrixPosition(this.light
								.target.matrixWorld), Ru.subVectors(Cu, Pu), this.lightPlane.lookAt(Cu),
							void 0 !== this.color ? (this.lightPlane.material.color.set(this.color), this
								.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color
								.copy(this.light.color), this.targetLine.material.color.copy(this.light.color)
								), this.targetLine.lookAt(Cu), this.targetLine.scale.z = Ru.length()
					}), pp.prototype = Object.create(hs.prototype), (pp.prototype.constructor = pp).prototype
					.update = function () {
						var c, h, l = new li,
							u = new Eo;

						function i(t, e, i, n) {
							l.set(e, i, n).unproject(u);
							var r = h[t];
							if (void 0 !== r)
								for (var a = c.getAttribute("position"), o = 0, s = r.length; o < s; o++) a
									.setXYZ(r[o], l.x, l.y, l.z)
						}
						return function () {
							c = this.geometry, h = this.pointMap;
							var t = 1,
								e = 1;
							u.projectionMatrix.copy(this.camera.projectionMatrix), i("c", 0, 0, -1), i("t", 0,
									0, 1), i("n1", -t, -e, -1), i("n2", t, -e, -1), i("n3", -t, e, -1), i(
									"n4", t, e, -1), i("f1", -t, -e, 1), i("f2", t, -e, 1), i("f3", -t, e, 1),
								i("f4", t, e, 1), i("u1", .7 * t, 1.1 * e, -1), i("u2", .7 * -t, 1.1 * e, -1),
								i("u3", 0, 2 * e, -1), i("cf1", -t, 0, 1), i("cf2", t, 0, 1), i("cf3", 0, -e,
									1), i("cf4", 0, e, 1), i("cn1", -t, 0, -1), i("cn2", t, 0, -1), i("cn3",
									0, -e, -1), i("cn4", 0, e, -1), c.getAttribute("position").needsUpdate = !
								0
						}
					}(), dp.prototype = Object.create(hs.prototype), (dp.prototype.constructor = dp).prototype
					.update = (Ou = new Bi, function (t) {
						if (void 0 !== t && console.warn(
								"THREE.BoxHelper: .update() has no longer arguments."), void 0 !== this
							.object && Ou.setFromObject(this.object), !Ou.isEmpty()) {
							var e = Ou.min,
								i = Ou.max,
								n = this.geometry.attributes.position,
								r = n.array;
							r[0] = i.x, r[1] = i.y, r[2] = i.z, r[3] = e.x, r[4] = i.y, r[5] = i.z, r[6] = e
								.x, r[7] = e.y, r[8] = i.z, r[9] = i.x, r[10] = e.y, r[11] = i.z, r[12] = i.x,
								r[13] = i.y, r[14] = e.z, r[15] = e.x, r[16] = i.y, r[17] = e.z, r[18] = e.x,
								r[19] = e.y, r[20] = e.z, r[21] = i.x, r[22] = e.y, r[23] = e.z, n
								.needsUpdate = !0, this.geometry.computeBoundingSphere()
						}
					}), dp.prototype.setFromObject = function (t) {
						return this.object = t, this.update(), this
					}, dp.prototype.copy = function (t) {
						return hs.prototype.copy.call(this, t), this.object = t.object, this
					}, dp.prototype.clone = function () {
						return (new this.constructor).copy(this)
					}, fp.prototype = Object.create(hs.prototype), (fp.prototype.constructor = fp).prototype
					.updateMatrixWorld = function (t) {
						var e = this.box;
						e.isEmpty() || (e.getCenter(this.position), e.getSize(this.scale), this.scale
							.multiplyScalar(.5), Mn.prototype.updateMatrixWorld.call(this, t))
					}, mp.prototype = Object.create(cs.prototype), (mp.prototype.constructor = mp).prototype
					.updateMatrixWorld = function (t) {
						var e = -this.plane.constant;
						Math.abs(e) < 1e-8 && (e = 1e-8), this.scale.set(.5 * this.size, .5 * this.size, e), this
							.children[0].material.side = e < 0 ? kt : N, this.lookAt(this.plane.normal), Mn
							.prototype.updateMatrixWorld.call(this, t)
					}, gp.prototype = Object.create(Mn.prototype), (gp.prototype.constructor = gp).prototype
					.setDirection = (Nu = new li, function (t) {
						.99999 < t.y ? this.quaternion.set(0, 0, 0, 1) : t.y < -.99999 ? this.quaternion.set(
							1, 0, 0, 0) : (Nu.set(t.z, 0, -t.x).normalize(), Bu = Math.acos(t.y), this
							.quaternion.setFromAxisAngle(Nu, Bu))
					}), gp.prototype.setLength = function (t, e, i) {
						void 0 === e && (e = .2 * t), void 0 === i && (i = .2 * e), this.line.scale.set(1, Math
								.max(0, t - e), 1), this.line.updateMatrix(), this.cone.scale.set(i, e, i), this
							.cone.position.y = t, this.cone.updateMatrix()
					}, gp.prototype.setColor = function (t) {
						this.line.material.color.copy(t), this.cone.material.color.copy(t)
					}, gp.prototype.copy = function (t) {
						return Mn.prototype.copy.call(this, t, !1), this.line.copy(t.line), this.cone.copy(t
							.cone), this
					}, gp.prototype.clone = function () {
						return (new this.constructor).copy(this)
					}, vp.prototype = Object.create(hs.prototype), vp.prototype.constructor = vp;
				var xp, bp = 0,
					wp = 1;

				function _p(t) {
					return console.warn("THREE.MeshFaceMaterial has been removed. Use an Array instead."), t
				}

				function Mp(t) {
					return void 0 === t && (t = []), console.warn(
							"THREE.MultiMaterial has been removed. Use an Array instead."), t.isMultiMaterial = !
						0, (t.materials = t).clone = function () {
							return t.slice()
						}, t
				}

				function Sp(t, e) {
					return console.warn("THREE.PointCloud has been renamed to THREE.Points."), new ps(t, e)
				}

				function Ep(t) {
					return console.warn("THREE.Particle has been renamed to THREE.Sprite."), new is(t)
				}

				function Tp(t, e) {
					return console.warn("THREE.ParticleSystem has been renamed to THREE.Points."), new ps(t, e)
				}

				function Ap(t) {
					return console.warn("THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial."),
						new us(t)
				}

				function Lp(t) {
					return console.warn("THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial."),
						new us(t)
				}

				function Pp(t) {
					return console.warn("THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial."),
						new us(t)
				}

				function Cp(t, e, i) {
					return console.warn("THREE.Vertex has been removed. Use THREE.Vector3 instead."), new li(t, e,
						i)
				}

				function Rp(t, e) {
					return console.warn(
						"THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead."
						), new In(t, e).setDynamic(!0)
				}

				function Op(t, e) {
					return console.warn(
							"THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead."),
						new Dn(t, e)
				}

				function Ip(t, e) {
					return console.warn(
						"THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead."
						), new Bn(t, e)
				}

				function Dp(t, e) {
					return console.warn(
						"THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead."
						), new Nn(t, e)
				}

				function Bp(t, e) {
					return console.warn(
						"THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead."
						), new zn(t, e)
				}

				function Np(t, e) {
					return console.warn(
						"THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead."
						), new Un(t, e)
				}

				function zp(t, e) {
					return console.warn(
						"THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead."
						), new Gn(t, e)
				}

				function Up(t, e) {
					return console.warn(
						"THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead."
						), new Fn(t, e)
				}

				function Gp(t, e) {
					return console.warn(
						"THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead."
						), new Hn(t, e)
				}

				function Fp(t, e) {
					return console.warn(
						"THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead."
						), new kn(t, e)
				}

				function Hp(t) {
					console.warn(
							"THREE.ClosedSplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."),
						Ph.call(this, t), this.type = "catmullrom", this.closed = !0
				}

				function kp(t) {
					console.warn("THREE.SplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."),
						Ph.call(this, t), this.type = "catmullrom"
				}

				function jp(t) {
					console.warn("THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead."), Ph.call(
						this, t), this.type = "catmullrom"
				}

				function Vp(t) {
					return console.warn("THREE.AxisHelper has been renamed to THREE.AxesHelper."), new vp(t)
				}

				function Wp(t, e) {
					return console.warn(
							"THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead."),
						new dp(t, e)
				}

				function qp(t, e) {
					return console.warn("THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead."),
						new hs(new Pc(t.geometry), new ss({
							color: void 0 !== e ? e : 16777215
						}))
				}

				function Xp(t, e) {
					return console.warn(
							"THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead."),
						new hs(new vs(t.geometry), new ss({
							color: void 0 !== e ? e : 16777215
						}))
				}

				function Yp(t) {
					return console.warn("THREE.XHRLoader has been renamed to THREE.FileLoader."), new fh(t)
				}

				function Jp(t) {
					return console.warn("THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader."),
						new vh(t)
				}
				wh.create = function (t, e) {
						return console.log("THREE.Curve.create() has been deprecated"), t.prototype = Object
							.create(wh.prototype), (t.prototype.constructor = t).prototype.getPoint = e, t
					}, Object.assign(Yh.prototype, {
						createPointsGeometry: function (t) {
							console.warn(
								"THREE.CurvePath: .createPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead."
								);
							var e = this.getPoints(t);
							return this.createGeometry(e)
						},
						createSpacedPointsGeometry: function (t) {
							console.warn(
								"THREE.CurvePath: .createSpacedPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead."
								);
							var e = this.getSpacedPoints(t);
							return this.createGeometry(e)
						},
						createGeometry: function (t) {
							console.warn(
								"THREE.CurvePath: .createGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead."
								);
							for (var e = new On, i = 0, n = t.length; i < n; i++) {
								var r = t[i];
								e.vertices.push(new li(r.x, r.y, r.z || 0))
							}
							return e
						}
					}), Object.assign(Jh.prototype, {
						fromPoints: function (t) {
							console.warn(
									"THREE.Path: .fromPoints() has been renamed to .setFromPoints()."),
								this.setFromPoints(t)
						}
					}), Hp.prototype = Object.create(Ph.prototype), kp.prototype = Object.create(Ph.prototype), jp
					.prototype = Object.create(Ph.prototype), Object.assign(jp.prototype, {
						initFromArray: function () {
							console.error("THREE.Spline: .initFromArray() has been removed.")
						},
						getControlPointsArray: function () {
							console.error("THREE.Spline: .getControlPointsArray() has been removed.")
						},
						reparametrizeByArcLength: function () {
							console.error("THREE.Spline: .reparametrizeByArcLength() has been removed.")
						}
					}), cp.prototype.setColors = function () {
						console.error(
							"THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead."
							)
					}, rp.prototype.update = function () {
						console.error("THREE.SkeletonHelper: update() no longer needs to be called.")
					}, Object.assign(Al.prototype, {
						extractUrlBase: function (t) {
							return console.warn(
								"THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."
								), hl.extractUrlBase(t)
						}
					}), Object.assign(pl.prototype, {
						setTexturePath: function (t) {
							return console.warn(
								"THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath()."
								), this.setResourcePath(t)
						}
					}), Object.assign(Ku.prototype, {
						center: function (t) {
							return console.warn(
								"THREE.Box2: .center() has been renamed to .getCenter()."), this
								.getCenter(t)
						},
						empty: function () {
							return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."),
								this.isEmpty()
						},
						isIntersectionBox: function (t) {
							return console.warn(
								"THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."
								), this.intersectsBox(t)
						},
						size: function (t) {
							return console.warn("THREE.Box2: .size() has been renamed to .getSize()."),
								this.getSize(t)
						}
					}), Object.assign(Bi.prototype, {
						center: function (t) {
							return console.warn(
								"THREE.Box3: .center() has been renamed to .getCenter()."), this
								.getCenter(t)
						},
						empty: function () {
							return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."),
								this.isEmpty()
						},
						isIntersectionBox: function (t) {
							return console.warn(
								"THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."
								), this.intersectsBox(t)
						},
						isIntersectionSphere: function (t) {
							return console.warn(
								"THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."
								), this.intersectsSphere(t)
						},
						size: function (t) {
							return console.warn("THREE.Box3: .size() has been renamed to .getSize()."),
								this.getSize(t)
						}
					}), $u.prototype.center = function (t) {
						return console.warn("THREE.Line3: .center() has been renamed to .getCenter()."), this
							.getCenter(t)
					}, Object.assign(oi, {
						random16: function () {
							return console.warn(
								"THREE.Math: .random16() has been deprecated. Use Math.random() instead."
								), Math.random()
						},
						nearestPowerOfTwo: function (t) {
							return console.warn(
								"THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo()."
								), oi.floorPowerOfTwo(t)
						},
						nextPowerOfTwo: function (t) {
							return console.warn(
								"THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo()."
								), oi.ceilPowerOfTwo(t)
						}
					}), Object.assign(ui.prototype, {
						flattenToArrayOffset: function (t, e) {
							return console.warn(
								"THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."
								), this.toArray(t, e)
						},
						multiplyVector3: function (t) {
							return console.warn(
								"THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."
								), t.applyMatrix3(this)
						},
						multiplyVector3Array: function () {
							console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.")
						},
						applyToBuffer: function (t) {
							return console.warn(
								"THREE.Matrix3: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead."
								), this.applyToBufferAttribute(t)
						},
						applyToVector3Array: function () {
							console.error("THREE.Matrix3: .applyToVector3Array() has been removed.")
						}
					}), Object.assign(ci.prototype, {
						extractPosition: function (t) {
							return console.warn(
								"THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."
								), this.copyPosition(t)
						},
						flattenToArrayOffset: function (t, e) {
							return console.warn(
								"THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."
								), this.toArray(t, e)
						},
						getPosition: function () {
							return void 0 === xp && (xp = new li), console.warn(
								"THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."
								), xp.setFromMatrixColumn(this, 3)
						},
						setRotationFromQuaternion: function (t) {
							return console.warn(
								"THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."
								), this.makeRotationFromQuaternion(t)
						},
						multiplyToArray: function () {
							console.warn("THREE.Matrix4: .multiplyToArray() has been removed.")
						},
						multiplyVector3: function (t) {
							return console.warn(
								"THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."
								), t.applyMatrix4(this)
						},
						multiplyVector4: function (t) {
							return console.warn(
								"THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."
								), t.applyMatrix4(this)
						},
						multiplyVector3Array: function () {
							console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.")
						},
						rotateAxis: function (t) {
							console.warn(
								"THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."
								), t.transformDirection(this)
						},
						crossVector: function (t) {
							return console.warn(
								"THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."
								), t.applyMatrix4(this)
						},
						translate: function () {
							console.error("THREE.Matrix4: .translate() has been removed.")
						},
						rotateX: function () {
							console.error("THREE.Matrix4: .rotateX() has been removed.")
						},
						rotateY: function () {
							console.error("THREE.Matrix4: .rotateY() has been removed.")
						},
						rotateZ: function () {
							console.error("THREE.Matrix4: .rotateZ() has been removed.")
						},
						rotateByAxis: function () {
							console.error("THREE.Matrix4: .rotateByAxis() has been removed.")
						},
						applyToBuffer: function (t) {
							return console.warn(
								"THREE.Matrix4: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead."
								), this.applyToBufferAttribute(t)
						},
						applyToVector3Array: function () {
							console.error("THREE.Matrix4: .applyToVector3Array() has been removed.")
						},
						makeFrustum: function (t, e, i, n, r, a) {
							return console.warn(
								"THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."
								), this.makePerspective(t, e, n, i, r, a)
						}
					}), zi.prototype.isIntersectionLine = function (t) {
						return console.warn(
								"THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."), this
							.intersectsLine(t)
					}, hi.prototype.multiplyVector3 = function (t) {
						return console.warn(
							"THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."
							), t.applyQuaternion(this)
					}, Object.assign(Br.prototype, {
						isIntersectionBox: function (t) {
							return console.warn(
								"THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."
								), this.intersectsBox(t)
						},
						isIntersectionPlane: function (t) {
							return console.warn(
								"THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."
								), this.intersectsPlane(t)
						},
						isIntersectionSphere: function (t) {
							return console.warn(
								"THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."
								), this.intersectsSphere(t)
						}
					}), Object.assign(Nr.prototype, {
						area: function () {
							return console.warn(
								"THREE.Triangle: .area() has been renamed to .getArea()."), this.getArea()
						},
						barycoordFromPoint: function (t, e) {
							return console.warn(
								"THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."
								), this.getBarycoord(t, e)
						},
						midpoint: function (t) {
							return console.warn(
									"THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."),
								this.getMidpoint(t)
						},
						normal: function (t) {
							return console.warn(
									"THREE.Triangle: .normal() has been renamed to .getNormal()."), this
								.getNormal(t)
						},
						plane: function (t) {
							return console.warn(
									"THREE.Triangle: .plane() has been renamed to .getPlane()."), this
								.getPlane(t)
						}
					}), Object.assign(Nr, {
						barycoordFromPoint: function (t, e, i, n, r) {
							return console.warn(
								"THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."
								), Nr.getBarycoord(t, e, i, n, r)
						},
						normal: function (t, e, i, n) {
							return console.warn(
									"THREE.Triangle: .normal() has been renamed to .getNormal()."), Nr
								.getNormal(t, e, i, n)
						}
					}), Object.assign(Zh.prototype, {
						extractAllPoints: function (t) {
							return console.warn(
								"THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."
								), this.extractPoints(t)
						},
						extrude: function (t) {
							return console.warn(
								"THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."
								), new fc(this, t)
						},
						makeGeometry: function (t) {
							return console.warn(
								"THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."
								), new Tc(this, t)
						}
					}), Object.assign(si.prototype, {
						fromAttribute: function (t, e, i) {
							return console.warn(
								"THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."
								), this.fromBufferAttribute(t, e, i)
						},
						distanceToManhattan: function (t) {
							return console.warn(
								"THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."
								), this.manhattanDistanceTo(t)
						},
						lengthManhattan: function () {
							return console.warn(
								"THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."
								), this.manhattanLength()
						}
					}), Object.assign(li.prototype, {
						setEulerFromRotationMatrix: function () {
							console.error(
								"THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead."
								)
						},
						setEulerFromQuaternion: function () {
							console.error(
								"THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead."
								)
						},
						getPositionFromMatrix: function (t) {
							return console.warn(
								"THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."
								), this.setFromMatrixPosition(t)
						},
						getScaleFromMatrix: function (t) {
							return console.warn(
								"THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."
								), this.setFromMatrixScale(t)
						},
						getColumnFromMatrix: function (t, e) {
							return console.warn(
								"THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."
								), this.setFromMatrixColumn(e, t)
						},
						applyProjection: function (t) {
							return console.warn(
								"THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."
								), this.applyMatrix4(t)
						},
						fromAttribute: function (t, e, i) {
							return console.warn(
								"THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."
								), this.fromBufferAttribute(t, e, i)
						},
						distanceToManhattan: function (t) {
							return console.warn(
								"THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."
								), this.manhattanDistanceTo(t)
						},
						lengthManhattan: function () {
							return console.warn(
								"THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."
								), this.manhattanLength()
						}
					}), Object.assign(Ri.prototype, {
						fromAttribute: function (t, e, i) {
							return console.warn(
								"THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."
								), this.fromBufferAttribute(t, e, i)
						},
						lengthManhattan: function () {
							return console.warn(
								"THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."
								), this.manhattanLength()
						}
					}), Object.assign(On.prototype, {
						computeTangents: function () {
							console.error("THREE.Geometry: .computeTangents() has been removed.")
						},
						computeLineDistances: function () {
							console.error(
								"THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead."
								)
						}
					}), Object.assign(Mn.prototype, {
						getChildByName: function (t) {
							return console.warn(
								"THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."
								), this.getObjectByName(t)
						},
						renderDepth: function () {
							console.warn(
								"THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead."
								)
						},
						translate: function (t, e) {
							return console.warn(
								"THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."
								), this.translateOnAxis(e, t)
						},
						getWorldRotation: function () {
							console.error(
								"THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead."
								)
						}
					}), Object.defineProperties(Mn.prototype, {
						eulerOrder: {
							get: function () {
								return console.warn(
									"THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation
									.order
							},
							set: function (t) {
								console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this
									.rotation.order = t
							}
						},
						useQuaternion: {
							get: function () {
								console.warn(
									"THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default."
									)
							},
							set: function () {
								console.warn(
									"THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default."
									)
							}
						}
					}), Object.defineProperties(ns.prototype, {
						objects: {
							get: function () {
								return console.warn("THREE.LOD: .objects has been renamed to .levels."),
									this.levels
							}
						}
					}), Object.defineProperty(as.prototype, "useVertexTexture", {
						get: function () {
							console.warn("THREE.Skeleton: useVertexTexture has been removed.")
						},
						set: function () {
							console.warn("THREE.Skeleton: useVertexTexture has been removed.")
						}
					}), rs.prototype.initBones = function () {
						console.error("THREE.SkinnedMesh: initBones() has been removed.")
					}, Object.defineProperty(wh.prototype, "__arcLengthDivisions", {
						get: function () {
							return console.warn(
									"THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."),
								this.arcLengthDivisions
						},
						set: function (t) {
							console.warn(
								"THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."), this
								.arcLengthDivisions = t
						}
					}), To.prototype.setLens = function (t, e) {
						console.warn(
							"THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."
							), void 0 !== e && (this.filmGauge = e), this.setFocalLength(t)
					}, Object.defineProperties(Qh.prototype, {
						onlyShadow: {
							set: function () {
								console.warn("THREE.Light: .onlyShadow has been removed.")
							}
						},
						shadowCameraFov: {
							set: function (t) {
								console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."),
									this.shadow.camera.fov = t
							}
						},
						shadowCameraLeft: {
							set: function (t) {
								console.warn(
									"THREE.Light: .shadowCameraLeft is now .shadow.camera.left."), this
									.shadow.camera.left = t
							}
						},
						shadowCameraRight: {
							set: function (t) {
								console.warn(
										"THREE.Light: .shadowCameraRight is now .shadow.camera.right."),
									this.shadow.camera.right = t
							}
						},
						shadowCameraTop: {
							set: function (t) {
								console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."),
									this.shadow.camera.top = t
							}
						},
						shadowCameraBottom: {
							set: function (t) {
								console.warn(
										"THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."),
									this.shadow.camera.bottom = t
							}
						},
						shadowCameraNear: {
							set: function (t) {
								console.warn(
									"THREE.Light: .shadowCameraNear is now .shadow.camera.near."), this
									.shadow.camera.near = t
							}
						},
						shadowCameraFar: {
							set: function (t) {
								console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."),
									this.shadow.camera.far = t
							}
						},
						shadowCameraVisible: {
							set: function () {
								console.warn(
									"THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead."
									)
							}
						},
						shadowBias: {
							set: function (t) {
								console.warn("THREE.Light: .shadowBias is now .shadow.bias."), this.shadow
									.bias = t
							}
						},
						shadowDarkness: {
							set: function () {
								console.warn("THREE.Light: .shadowDarkness has been removed.")
							}
						},
						shadowMapWidth: {
							set: function (t) {
								console.warn(
									"THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."), this
									.shadow.mapSize.width = t
							}
						},
						shadowMapHeight: {
							set: function (t) {
								console.warn(
										"THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."),
									this.shadow.mapSize.height = t
							}
						}
					}), Object.defineProperties(In.prototype, {
						length: {
							get: function () {
								return console.warn(
									"THREE.BufferAttribute: .length has been deprecated. Use .count instead."
									), this.array.length
							}
						},
						copyIndicesArray: function () {
							console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.")
						}
					}), Object.assign(ir.prototype, {
						addIndex: function (t) {
							console.warn(
									"THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."),
								this.setIndex(t)
						},
						addDrawCall: function (t, e, i) {
							void 0 !== i && console.warn(
									"THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."
									), console.warn(
									"THREE.BufferGeometry: .addDrawCall() is now .addGroup()."), this
								.addGroup(t, e)
						},
						clearDrawCalls: function () {
							console.warn(
								"THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."), this
								.clearGroups()
						},
						computeTangents: function () {
							console.warn("THREE.BufferGeometry: .computeTangents() has been removed.")
						},
						computeOffsets: function () {
							console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.")
						}
					}), Object.defineProperties(ir.prototype, {
						drawcalls: {
							get: function () {
								return console.error(
										"THREE.BufferGeometry: .drawcalls has been renamed to .groups."),
									this.groups
							}
						},
						offsets: {
							get: function () {
								return console.warn(
										"THREE.BufferGeometry: .offsets has been renamed to .groups."),
									this.groups
							}
						}
					}), Object.assign(mc.prototype, {
						getArrays: function () {
							console.error("THREE.ExtrudeBufferGeometry: .getArrays() has been removed.")
						},
						addShapeList: function () {
							console.error(
								"THREE.ExtrudeBufferGeometry: .addShapeList() has been removed.")
						},
						addShape: function () {
							console.error("THREE.ExtrudeBufferGeometry: .addShape() has been removed.")
						}
					}), Object.defineProperties(ju.prototype, {
						dynamic: {
							set: function () {
								console.warn(
									"THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead."
									)
							}
						},
						onUpdate: {
							value: function () {
								return console.warn(
									"THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."
									), this
							}
						}
					}), Object.defineProperties(Ir.prototype, {
						wrapAround: {
							get: function () {
								console.warn("THREE.Material: .wrapAround has been removed.")
							},
							set: function () {
								console.warn("THREE.Material: .wrapAround has been removed.")
							}
						},
						overdraw: {
							get: function () {
								console.warn("THREE.Material: .overdraw has been removed.")
							},
							set: function () {
								console.warn("THREE.Material: .overdraw has been removed.")
							}
						},
						wrapRGB: {
							get: function () {
								return console.warn("THREE.Material: .wrapRGB has been removed."), new Xi
							}
						},
						shading: {
							get: function () {
								console.error("THREE." + this.type +
									": .shading has been removed. Use the boolean .flatShading instead."
									)
							},
							set: function (t) {
								console.warn("THREE." + this.type +
									": .shading has been removed. Use the boolean .flatShading instead."
									), this.flatShading = t === C
							}
						}
					}), Object.defineProperties(Hc.prototype, {
						metal: {
							get: function () {
								return console.warn(
									"THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead."
									), !1
							},
							set: function () {
								console.warn(
									"THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead"
									)
							}
						}
					}), Object.defineProperties(Dr.prototype, {
						derivatives: {
							get: function () {
								return console.warn(
									"THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."
									), this.extensions.derivatives
							},
							set: function (t) {
								console.warn(
									"THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."
									), this.extensions.derivatives = t
							}
						}
					}), Object.assign(Jo.prototype, {
						clearTarget: function (t, e, i, n) {
							console.warn(
								"THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."
								), this.setRenderTarget(t), this.clear(e, i, n)
						},
						animate: function (t) {
							console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."),
								this.setAnimationLoop(t)
						},
						getCurrentRenderTarget: function () {
							return console.warn(
								"THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."
								), this.getRenderTarget()
						},
						getMaxAnisotropy: function () {
							return console.warn(
								"THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."
								), this.capabilities.getMaxAnisotropy()
						},
						getPrecision: function () {
							return console.warn(
								"THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."
								), this.capabilities.precision
						},
						resetGLState: function () {
							return console.warn(
									"THREE.WebGLRenderer: .resetGLState() is now .state.reset()."), this
								.state.reset()
						},
						supportsFloatTextures: function () {
							return console.warn(
								"THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."
								), this.extensions.get("OES_texture_float")
						},
						supportsHalfFloatTextures: function () {
							return console.warn(
								"THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."
								), this.extensions.get("OES_texture_half_float")
						},
						supportsStandardDerivatives: function () {
							return console.warn(
								"THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."
								), this.extensions.get("OES_standard_derivatives")
						},
						supportsCompressedTextureS3TC: function () {
							return console.warn(
								"THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."
								), this.extensions.get("WEBGL_compressed_texture_s3tc")
						},
						supportsCompressedTexturePVRTC: function () {
							return console.warn(
								"THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."
								), this.extensions.get("WEBGL_compressed_texture_pvrtc")
						},
						supportsBlendMinMax: function () {
							return console.warn(
								"THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."
								), this.extensions.get("EXT_blend_minmax")
						},
						supportsVertexTextures: function () {
							return console.warn(
								"THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."
								), this.capabilities.vertexTextures
						},
						supportsInstancedArrays: function () {
							return console.warn(
								"THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."
								), this.extensions.get("ANGLE_instanced_arrays")
						},
						enableScissorTest: function (t) {
							console.warn(
									"THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."
									), this.setScissorTest(t)
						},
						initMaterial: function () {
							console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.")
						},
						addPrePlugin: function () {
							console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.")
						},
						addPostPlugin: function () {
							console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.")
						},
						updateShadowMap: function () {
							console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.")
						},
						setFaceCulling: function () {
							console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.")
						}
					}), Object.defineProperties(Jo.prototype, {
						shadowMapEnabled: {
							get: function () {
								return this.shadowMap.enabled
							},
							set: function (t) {
								console.warn(
									"THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."
									), this.shadowMap.enabled = t
							}
						},
						shadowMapType: {
							get: function () {
								return this.shadowMap.type
							},
							set: function (t) {
								console.warn(
										"THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."),
									this.shadowMap.type = t
							}
						},
						shadowMapCullFace: {
							get: function () {
								console.warn(
									"THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead."
									)
							},
							set: function () {
								console.warn(
									"THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead."
									)
							}
						}
					}), Object.defineProperties(bo.prototype, {
						cullFace: {
							get: function () {
								console.warn(
									"THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead."
									)
							},
							set: function () {
								console.warn(
									"THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead."
									)
							}
						},
						renderReverseSided: {
							get: function () {
								console.warn(
									"THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead."
									)
							},
							set: function () {
								console.warn(
									"THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead."
									)
							}
						},
						renderSingleSided: {
							get: function () {
								console.warn(
									"THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead."
									)
							},
							set: function () {
								console.warn(
									"THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead."
									)
							}
						}
					}), Object.defineProperties(Oi.prototype, {
						wrapS: {
							get: function () {
								return console.warn(
										"THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this
									.texture.wrapS
							},
							set: function (t) {
								console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."),
									this.texture.wrapS = t
							}
						},
						wrapT: {
							get: function () {
								return console.warn(
										"THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this
									.texture.wrapT
							},
							set: function (t) {
								console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."),
									this.texture.wrapT = t
							}
						},
						magFilter: {
							get: function () {
								return console.warn(
										"THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."),
									this.texture.magFilter
							},
							set: function (t) {
								console.warn(
										"THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."),
									this.texture.magFilter = t
							}
						},
						minFilter: {
							get: function () {
								return console.warn(
										"THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."),
									this.texture.minFilter
							},
							set: function (t) {
								console.warn(
										"THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."),
									this.texture.minFilter = t
							}
						},
						anisotropy: {
							get: function () {
								return console.warn(
									"THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."
									), this.texture.anisotropy
							},
							set: function (t) {
								console.warn(
									"THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."
									), this.texture.anisotropy = t
							}
						},
						offset: {
							get: function () {
								return console.warn(
										"THREE.WebGLRenderTarget: .offset is now .texture.offset."), this
									.texture.offset
							},
							set: function (t) {
								console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."),
									this.texture.offset = t
							}
						},
						repeat: {
							get: function () {
								return console.warn(
										"THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this
									.texture.repeat
							},
							set: function (t) {
								console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."),
									this.texture.repeat = t
							}
						},
						format: {
							get: function () {
								return console.warn(
										"THREE.WebGLRenderTarget: .format is now .texture.format."), this
									.texture.format
							},
							set: function (t) {
								console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."),
									this.texture.format = t
							}
						},
						type: {
							get: function () {
								return console.warn(
										"THREE.WebGLRenderTarget: .type is now .texture.type."), this
									.texture.type
							},
							set: function (t) {
								console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this
									.texture.type = t
							}
						},
						generateMipmaps: {
							get: function () {
								return console.warn(
									"THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."
									), this.texture.generateMipmaps
							},
							set: function (t) {
								console.warn(
									"THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."
									), this.texture.generateMipmaps = t
							}
						}
					}), Object.defineProperties(Xo.prototype, {
						standing: {
							set: function () {
								console.warn("THREE.WebVRManager: .standing has been removed.")
							}
						},
						userHeight: {
							set: function () {
								console.warn("THREE.WebVRManager: .userHeight has been removed.")
							}
						}
					}), $l.prototype.load = function (t) {
						console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");
						var e = this;
						return (new Yl).load(t, function (t) {
							e.setBuffer(t)
						}), this
					}, eu.prototype.getData = function () {
						return console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData()."), this
							.getFrequencyData()
					}, Zl.prototype.updateCubeMap = function (t, e) {
						return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."), this.update(
							t, e)
					};
				var Zp = {
					merge: function (t, e, i) {
						var n;
						console.warn(
							"THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead."
							), e.isMesh && (e.matrixAutoUpdate && e.updateMatrix(), n = e.matrix, e =
							e.geometry), t.merge(e, n, i)
					},
					center: function (t) {
						return console.warn(
							"THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead."
							), t.center()
					}
				};

				function Qp() {
					console.error("THREE.Projector has been moved to /examples/js/renderers/Projector.js."), this
						.projectVector = function (t, e) {
							console.warn("THREE.Projector: .projectVector() is now vector.project()."), t.project(
								e)
						}, this.unprojectVector = function (t, e) {
							console.warn("THREE.Projector: .unprojectVector() is now vector.unproject()."), t
								.unproject(e)
						}, this.pickingRay = function () {
							console.error("THREE.Projector: .pickingRay() is now raycaster.setFromCamera().")
						}
				}

				function Kp() {
					console.error("THREE.CanvasRenderer has been removed")
				}

				function $p() {
					console.error("THREE.JSONLoader has been removed.")
				}
				Li.crossOrigin = void 0, Li.loadTexture = function (t, e, i, n) {
					console.warn(
						"THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead."
						);
					var r = new bh;
					r.setCrossOrigin(this.crossOrigin);
					var a = r.load(t, i, void 0, n);
					return e && (a.mapping = e), a
				}, Li.loadTextureCube = function (t, e, i, n) {
					console.warn(
						"THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead."
						);
					var r = new xh;
					r.setCrossOrigin(this.crossOrigin);
					var a = r.load(t, i, void 0, n);
					return e && (a.mapping = e), a
				}, Li.loadCompressedTexture = function () {
					console.error(
						"THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead."
						)
				}, Li.loadCompressedTextureCube = function () {
					console.error(
						"THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead."
						)
				};
				var td = {
					createMultiMaterialObject: function () {
						console.error(
							"THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js")
					},
					detach: function () {
						console.error(
							"THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js")
					},
					attach: function () {
						console.error(
							"THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js")
					}
				};

				function ed() {
					console.error("THREE.LensFlare has been moved to /examples/js/objects/Lensflare.js")
				}
				t.WebGLRenderTargetCube = Ii, t.WebGLRenderTarget = Oi, t.WebGLRenderer = Jo, t.ShaderLib = Qi, t
					.UniformsLib = Zi, t.UniformsUtils = Wi, t.ShaderChunk = Gi, t.FogExp2 = Zo, t.Fog = Qo, t
					.Scene = Ko, t.Sprite = is, t.LOD = ns, t.SkinnedMesh = rs, t.Skeleton = as, t.Bone = os, t
					.Mesh = Ur, t.LineSegments = hs, t.LineLoop = ls, t.Line = cs, t.Points = ps, t.Group = So, t
					.VideoTexture = ds, t.DataTexture = Di, t.DataTexture3D = Qr, t.CompressedTexture = fs, t
					.CubeTexture = Zr, t.CanvasTexture = ms, t.DepthTexture = gs, t.Texture = Ci, t
					.AnimationLoader = mh, t.CompressedTextureLoader = gh, t.DataTextureLoader = vh, t
					.CubeTextureLoader = xh, t.TextureLoader = bh, t.ObjectLoader = pl, t.MaterialLoader = cl, t
					.BufferGeometryLoader = ll, t.DefaultLoadingManager = ph, t.LoadingManager = uh, t
					.ImageLoader = yh, t.ImageBitmapLoader = wl, t.FontLoader = Tl, t.FileLoader = fh, t.Loader =
					Al, t.LoaderUtils = hl, t.Cache = lh, t.AudioLoader = Yl, t.SpotLightShadow = tl, t
					.SpotLight = el, t.PointLight = il, t.RectAreaLight = sl, t.HemisphereLight = Kh, t
					.DirectionalLightShadow = rl, t.DirectionalLight = al, t.AmbientLight = ol, t.LightShadow =
					$h, t.Light = Qh, t.StereoCamera = Jl, t.PerspectiveCamera = To, t.OrthographicCamera = nl, t
					.CubeCamera = Zl, t.ArrayCamera = Ao, t.Camera = Eo, t.AudioListener = Kl, t.PositionalAudio =
					tu, t.AudioContext = Xl, t.AudioAnalyser = eu, t.Audio = $l, t.VectorKeyframeTrack = oh, t
					.StringKeyframeTrack = ah, t.QuaternionKeyframeTrack = rh, t.NumberKeyframeTrack = ih, t
					.ColorKeyframeTrack = eh, t.BooleanKeyframeTrack = th, t.PropertyMixer = iu, t
					.PropertyBinding = Gu, t.KeyframeTrack = $c, t.AnimationUtils = Yc, t.AnimationObjectGroup =
					Fu, t.AnimationMixer = ku, t.AnimationClip = sh, t.Uniform = ju, t.InstancedBufferGeometry =
					Vu, t.BufferGeometry = ir, t.Geometry = On, t.InterleavedBufferAttribute = ts, t
					.InstancedInterleavedBuffer = Wu, t.InterleavedBuffer = $o, t.InstancedBufferAttribute = qu, t
					.Face3 = tn, t.Object3D = Mn, t.Raycaster = Xu, t.Layers = nn, t.EventDispatcher = e, t
					.Clock = Ql, t.QuaternionLinearInterpolant = nh, t.LinearInterpolant = Qc, t
					.DiscreteInterpolant = Kc, t.CubicInterpolant = Zc, t.Interpolant = Jc, t.Triangle = Nr, t
					.Math = oi, t.Spherical = Zu, t.Cylindrical = Qu, t.Plane = zi, t.Frustum = Ui, t.Sphere = Ni,
					t.Ray = Br, t.Matrix4 = ci, t.Matrix3 = ui, t.Box3 = Bi, t.Box2 = Ku, t.Line3 = $u, t.Euler =
					en, t.Vector4 = Ri, t.Vector3 = li, t.Vector2 = si, t.Quaternion = hi, t.Color = Xi, t
					.ImmediateRenderObject = tp, t.VertexNormalsHelper = ep, t.SpotLightHelper = ip, t
					.SkeletonHelper = rp, t.PointLightHelper = ap, t.RectAreaLightHelper = op, t
					.HemisphereLightHelper = sp, t.GridHelper = cp, t.PolarGridHelper = hp, t.FaceNormalsHelper =
					lp, t.DirectionalLightHelper = up, t.CameraHelper = pp, t.BoxHelper = dp, t.Box3Helper = fp, t
					.PlaneHelper = mp, t.ArrowHelper = gp, t.AxesHelper = vp, t.Shape = Zh, t.Path = Jh, t
					.ShapePath = _l, t.Font = Ml, t.CurvePath = Yh, t.Curve = wh, t.ImageUtils = Li, t
					.ShapeUtils = uc, t.WebGLUtils = Mo, t.WireframeGeometry = vs, t.ParametricGeometry = ys, t
					.ParametricBufferGeometry = xs, t.TetrahedronGeometry = _s, t.TetrahedronBufferGeometry = Ms,
					t.OctahedronGeometry = Ss, t.OctahedronBufferGeometry = Es, t.IcosahedronGeometry = Ts, t
					.IcosahedronBufferGeometry = As, t.DodecahedronGeometry = Ls, t.DodecahedronBufferGeometry =
					Ps, t.PolyhedronGeometry = bs, t.PolyhedronBufferGeometry = ws, t.TubeGeometry = Cs, t
					.TubeBufferGeometry = Rs, t.TorusKnotGeometry = Os, t.TorusKnotBufferGeometry = Is, t
					.TorusGeometry = Ds, t.TorusBufferGeometry = Bs, t.TextGeometry = yc, t.TextBufferGeometry =
					xc, t.SphereGeometry = bc, t.SphereBufferGeometry = wc, t.RingGeometry = _c, t
					.RingBufferGeometry = Mc, t.PlaneGeometry = ar, t.PlaneBufferGeometry = or, t.LatheGeometry =
					Sc, t.LatheBufferGeometry = Ec, t.ShapeGeometry = Tc, t.ShapeBufferGeometry = Ac, t
					.ExtrudeGeometry = fc, t.ExtrudeBufferGeometry = mc, t.EdgesGeometry = Pc, t.ConeGeometry =
					Oc, t.ConeBufferGeometry = Ic, t.CylinderGeometry = Cc, t.CylinderBufferGeometry = Rc, t
					.CircleGeometry = Dc, t.CircleBufferGeometry = Bc, t.BoxGeometry = nr, t.BoxBufferGeometry =
					rr, t.ShadowMaterial = zc, t.SpriteMaterial = es, t.RawShaderMaterial = Uc, t.ShaderMaterial =
					Dr, t.PointsMaterial = us, t.MeshPhysicalMaterial = Fc, t.MeshStandardMaterial = Gc, t
					.MeshPhongMaterial = Hc, t.MeshToonMaterial = kc, t.MeshNormalMaterial = jc, t
					.MeshLambertMaterial = Vc, t.MeshDepthMaterial = yo, t.MeshDistanceMaterial = xo, t
					.MeshBasicMaterial = zr, t.MeshMatcapMaterial = Wc, t.LineDashedMaterial = qc, t
					.LineBasicMaterial = ss, t.Material = Ir, t.Float64BufferAttribute = kn, t
					.Float32BufferAttribute = Hn, t.Uint32BufferAttribute = Fn, t.Int32BufferAttribute = Gn, t
					.Uint16BufferAttribute = Un, t.Int16BufferAttribute = zn, t.Uint8ClampedBufferAttribute = Nn,
					t.Uint8BufferAttribute = Bn, t.Int8BufferAttribute = Dn, t.BufferAttribute = In, t.ArcCurve =
					Mh, t.CatmullRomCurve3 = Ph, t.CubicBezierCurve = Fh, t.CubicBezierCurve3 = Hh, t
					.EllipseCurve = _h, t.LineCurve = kh, t.LineCurve3 = jh, t.QuadraticBezierCurve = Vh, t
					.QuadraticBezierCurve3 = Wh, t.SplineCurve = qh, t.REVISION = Ht, t.MOUSE = E, t
					.CullFaceNone = lt, t.CullFaceBack = ut, t.CullFaceFront = pt, t.CullFaceFrontBack = T, t
					.FrontFaceDirectionCW = A, t.FrontFaceDirectionCCW = L, t.BasicShadowMap = P, t.PCFShadowMap =
					B, t.PCFSoftShadowMap = I, t.FrontSide = N, t.BackSide = kt, t.DoubleSide = dt, t
					.FlatShading = C, t.SmoothShading = R, t.NoColors = O, t.FaceColors = D, t.VertexColors = z, t
					.NoBlending = ft, t.NormalBlending = mt, t.AdditiveBlending = gt, t.SubtractiveBlending = vt,
					t.MultiplyBlending = yt, t.CustomBlending = xt, t.AddEquation = bt, t.SubtractEquation = U, t
					.ReverseSubtractEquation = G, t.MinEquation = F, t.MaxEquation = H, t.ZeroFactor = k, t
					.OneFactor = j, t.SrcColorFactor = V, t.OneMinusSrcColorFactor = W, t.SrcAlphaFactor = q, t
					.OneMinusSrcAlphaFactor = X, t.DstAlphaFactor = Y, t.OneMinusDstAlphaFactor = J, t
					.DstColorFactor = Z, t.OneMinusDstColorFactor = Q, t.SrcAlphaSaturateFactor = K, t
					.NeverDepth = wt, t.AlwaysDepth = _t, t.LessDepth = Mt, t.LessEqualDepth = St, t.EqualDepth =
					Et, t.GreaterEqualDepth = Tt, t.GreaterDepth = At, t.NotEqualDepth = Lt, t.MultiplyOperation =
					$, t.MixOperation = tt, t.AddOperation = et, t.NoToneMapping = it, t.LinearToneMapping = jt, t
					.ReinhardToneMapping = nt, t.Uncharted2ToneMapping = rt, t.CineonToneMapping = at, t
					.ACESFilmicToneMapping = ot, t.UVMapping = st, t.CubeReflectionMapping = ct, t
					.CubeRefractionMapping = ht, t.EquirectangularReflectionMapping = Pt, t
					.EquirectangularRefractionMapping = Ct, t.SphericalReflectionMapping = Rt, t
					.CubeUVReflectionMapping = Ot, t.CubeUVRefractionMapping = It, t.RepeatWrapping = Dt, t
					.ClampToEdgeWrapping = Bt, t.MirroredRepeatWrapping = Nt, t.NearestFilter = zt, t
					.NearestMipMapNearestFilter = Ut, t.NearestMipMapLinearFilter = Gt, t.LinearFilter = Ft, t
					.LinearMipMapNearestFilter = Vt, t.LinearMipMapLinearFilter = Wt, t.UnsignedByteType = qt, t
					.ByteType = Xt, t.ShortType = Yt, t.UnsignedShortType = Jt, t.IntType = Zt, t
					.UnsignedIntType = Qt, t.FloatType = Kt, t.HalfFloatType = $t, t.UnsignedShort4444Type = te, t
					.UnsignedShort5551Type = ee, t.UnsignedShort565Type = ie, t.UnsignedInt248Type = ne, t
					.AlphaFormat = re, t.RGBFormat = ae, t.RGBAFormat = oe, t.LuminanceFormat = se, t
					.LuminanceAlphaFormat = ce, t.RGBEFormat = he, t.DepthFormat = le, t.DepthStencilFormat = ue,
					t.RedFormat = pe, t.RGB_S3TC_DXT1_Format = de, t.RGBA_S3TC_DXT1_Format = fe, t
					.RGBA_S3TC_DXT3_Format = me, t.RGBA_S3TC_DXT5_Format = ge, t.RGB_PVRTC_4BPPV1_Format = ve, t
					.RGB_PVRTC_2BPPV1_Format = ye, t.RGBA_PVRTC_4BPPV1_Format = xe, t.RGBA_PVRTC_2BPPV1_Format =
					be, t.RGB_ETC1_Format = we, t.RGBA_ASTC_4x4_Format = _e, t.RGBA_ASTC_5x4_Format = Me, t
					.RGBA_ASTC_5x5_Format = Se, t.RGBA_ASTC_6x5_Format = Ee, t.RGBA_ASTC_6x6_Format = Te, t
					.RGBA_ASTC_8x5_Format = Ae, t.RGBA_ASTC_8x6_Format = Le, t.RGBA_ASTC_8x8_Format = Pe, t
					.RGBA_ASTC_10x5_Format = Ce, t.RGBA_ASTC_10x6_Format = Re, t.RGBA_ASTC_10x8_Format = Oe, t
					.RGBA_ASTC_10x10_Format = Ie, t.RGBA_ASTC_12x10_Format = De, t.RGBA_ASTC_12x12_Format = Be, t
					.LoopOnce = Ne, t.LoopRepeat = ze, t.LoopPingPong = Ue, t.InterpolateDiscrete = Ge, t
					.InterpolateLinear = Fe, t.InterpolateSmooth = He, t.ZeroCurvatureEnding = ke, t
					.ZeroSlopeEnding = je, t.WrapAroundEnding = Ve, t.TrianglesDrawMode = We, t
					.TriangleStripDrawMode = qe, t.TriangleFanDrawMode = Xe, t.LinearEncoding = Ye, t
					.sRGBEncoding = Je, t.GammaEncoding = Ze, t.RGBEEncoding = Qe, t.LogLuvEncoding = Ke, t
					.RGBM7Encoding = $e, t.RGBM16Encoding = ti, t.RGBDEncoding = ei, t.BasicDepthPacking = ii, t
					.RGBADepthPacking = ni, t.TangentSpaceNormalMap = ri, t.ObjectSpaceNormalMap = ai, t
					.CubeGeometry = nr, t.Face4 = yp, t.LineStrip = bp, t.LinePieces = wp, t.MeshFaceMaterial =
					_p, t.MultiMaterial = Mp, t.PointCloud = Sp, t.Particle = Ep, t.ParticleSystem = Tp, t
					.PointCloudMaterial = Ap, t.ParticleBasicMaterial = Lp, t.ParticleSystemMaterial = Pp, t
					.Vertex = Cp, t.DynamicBufferAttribute = Rp, t.Int8Attribute = Op, t.Uint8Attribute = Ip, t
					.Uint8ClampedAttribute = Dp, t.Int16Attribute = Bp, t.Uint16Attribute = Np, t.Int32Attribute =
					zp, t.Uint32Attribute = Up, t.Float32Attribute = Gp, t.Float64Attribute = Fp, t
					.ClosedSplineCurve3 = Hp, t.SplineCurve3 = kp, t.Spline = jp, t.AxisHelper = Vp, t
					.BoundingBoxHelper = Wp, t.EdgesHelper = qp, t.WireframeHelper = Xp, t.XHRLoader = Yp, t
					.BinaryTextureLoader = Jp, t.GeometryUtils = Zp, t.Projector = Qp, t.CanvasRenderer = Kp, t
					.JSONLoader = $p, t.SceneUtils = td, t.LensFlare = ed, Object.defineProperty(t,
					"__esModule", {
						value: !0
					})
			})(e)
		}, function (t, e, i) {
			"use strict";
			i.r(e);
			var n = i(5);

			function r(t) {
				n.default.call(this, t);
				var e = this,
					i = this.getEvents();
				this._screens["end of level"] = document.querySelector(".screen-end-of-level"), this._splash = this
					._screens["end of level"].querySelector("svg"), this._level = document.querySelectorAll(
						".level-num"), this._screens.start.addEventListener(i.pointerdown, function (t) {
						e._settings.onClickStartScreen.call(e._screens.start, t)
					})
			}
			Object.assign(r.prototype, n.default.prototype, {
				setLevel: function (t) {
					var e;
					for (e = 0; e < this._level.length; e++) this._level[e].innerText = t;
					return this
				},
				setSplashColor: function (t) {
					return this._splash.style.fill = t, this
				}
			}), e.default = r
		}, function (t, e, i) {
			"use strict";

			function n(t) {
				var i = this;
				this._settings = Object.assign({
						app: "#App",
						onResize: function () {},
						onClickRetry: function () {}
					}, t), this._body = document.body, this._app = r("App"), this._header = o("obj-header"), this
					._screens = {
						loading: o("screen-loading"),
						start: o("screen-start"),
						game: o("screen-game"),
						end: o("screen-end")
					}, this._banner = o("obj-banner"), this._classes = {
						hidden: "is-hidden",
						visible: "is-visible",
						landscape: "landscape",
						portrait: "portrait"
					}, this._retry = a("retry"), this._download = a("download"), this._height = 0, this._width = 0,
					window.onresize = d.bind(this), h(this._retry, function (e) {
						e.addEventListener("click", function (t) {
							t.preventDefault(), t.stopImmediatePropagation(), i._settings.onClickRetry
								.call(e, t)
						})
					}), h(this._download, function (t) {
						t.addEventListener("click", function (t) {
							t.preventDefault(), t.stopImmediatePropagation(), _voodooExit()
						})
					}), this._screens.end.addEventListener("click", function () {
						_voodooExit()
					})
			}

			function r(t, e) {
				return (e || document).getElementById(t)
			}

			function a(t, e) {
				return (e || document).getElementsByClassName(t)
			}

			function o(t, e) {
				return a(t, e)[0]
			}

			function s(t, e) {
				t.classList.add(e)
			}

			function c(t, e) {
				t.classList.remove(e)
			}

			function h(t, e) {
				var i;
				for (i = 0; i < t.length; i++) e(t[i])
			}

			function l() {
				return r("App").offsetHeight
			}

			function u() {
				return r("App").offsetWidth
			}
			i.r(e), n.prototype = {
				getEvents: function () {
					return this.isMobile() ? {
						pointerdown: "touchstart",
						pointermove: "touchmove",
						pointerup: "touchend"
					} : {
						pointerdown: "pointerdown",
						pointermove: "pointermove",
						pointerup: "pointerup"
					}
				},
				triggerResize: function () {
					return window.dispatchEvent(new Event("resize")), this
				},
				switchScreen: function (t, e) {
					return this.hideScreen(t).showScreen(e)
				},
				showScreen: function (t) {
					return this._app.setAttribute("data-current-screen", t), this.showElement(this._screens[
						t])
				},
				hideScreen: function (t) {
					return this.hideElement(this._screens[t])
				},
				showElement: function (t) {
					return s(t, this._classes.visible), this
				},
				hideElement: function (t) {
					return c(t, this._classes.visible), this
				},
				isMobile: function () {
					return p()
				},
				getHeight: function () {
					return this._height
				},
				getWidth: function () {
					return this._width
				}
			};
			var p = function () {
				var t = /iPad|iPhone|iPod|Android/i.test(navigator.userAgent);
				return p = function () {
					return t
				}, t
			};

			function d(t) {
				var e = this._app,
					i = this._classes,
					n = i.landscape,
					r = i.portrait,
					a = l(),
					o = u();
				(this._height = a) < (this._width = o) ? (this._body.style.fontSize = a / 540 * 16 + "px", s(e, n), c(
					e, r)) : (this._body.style.fontSize = o / 360 * 16 + "px", s(e, r), c(e, n)), this._settings
					.onResize(t, o, a)
			}
			e.default = n
		}, function (t, e, i) {
			"use strict";

			function n() {
				this._time = 0, this._timeScale = 1, this._gameTime = 0, this._prevTime = 0, this._prevGameTime = 0,
					this._raf
			}
			i.r(e), n.prototype = {
				setTimeScale: function (t) {
					return this._timeScale = t, this
				},
				getTimeScale: function () {
					return this._timeScale
				},
				start: function (n) {
					var r = this,
						a = function (t) {
							r._raf = requestAnimationFrame(a);
							var e = t - r._prevTime,
								i = e / (1e3 / 60) * r._timeScale;
							r._time = t, r._gameTime += e * r._timeScale, n(r._gameTime, i), r._prevTime = t
						};
					return this._raf = requestAnimationFrame(a), this
				},
				stop: function () {
					return cancelAnimationFrame(this._raf), this
				}
			}, e.default = n
		}, function (t, e, i) {
			"use strict";
			i.r(e);
			var a = i(3),
				o = i(8);

			function n(t) {
				o.default.call(this, t);
				var e, i = new a.PlaneGeometry(150, 150, 75, 75),
					n = new a.Mesh(i, new a.MeshPhongMaterial({
						color: this._settings.backgroundColor,
						map: this.base64ToTexture(this._settings.map),
						wireframe: !1,
						shading: a.FlatShading
					})),
					r = [];
				for (e = 0; e < i.vertices.length; e++) r.push({
					position: i.vertices[e].clone(),
					angle: Math.random() * Math.PI * 2,
					amplitude: .25 * Math.random(),
					speed: Math.random() / 40
				});
				n.position.z = -10, n.castShadow = !0, n.receiveShadow = !0, this._waves = r, this._object = n, this
					._object.rotateX(Math.PI / 8)
			}
			Object.assign(n.prototype, o.default.prototype, {
				setColor: function (t) {
					return console.log("[Background] setColor : ", t), this._object.material.color.set(t),
						this
				},
				update: function (t, e) {
					var i, n, r, a = this._object.geometry,
						o = a.vertices;
					for (i = 0; i < o.length; i++) n = o[i], r = this._waves[i], n.z = r.position.z + Math
						.sin(r.angle) * r.amplitude, r.angle += r.speed;
					return a.verticesNeedUpdate = !0, this
				}
			}), e.default = n
		}, function (t, e, i) {
			"use strict";
			i.r(e);
			var r = i(3),
				n = i(9);

			function a(t) {
				this._settings = t, this._animations = {}, this._runningAnimations = []
			}
			a.prototype = {
				removeAnimation: function (t) {
					var e;
					if (1 < arguments.length)
						for (e = 0; e < arguments.length; e++) this.removeAnimation(arguments[e]);
					return delete this._animations[t], this
				},
				addAnimation: function (t, e) {
					return this._animations[t] ? console.error("[Object3dWrapper] Animation" + t +
						" already exists", this) : this._animations[t] = new n.default(t, e), this
				},
				playAnimation: function (t) {
					var e, i = Array.prototype.slice.call(arguments),
						n = i[i.length - 1],
						r = this._runningAnimations.indexOf(this._animations[t]);
					if ("string" != typeof n ? i.splice(-1, 1) : n = void 0, 1 < i.length)
						for (e = 0; e < i.length; e++) this.playAnimation(i[e], n);
					return 0 <= r && !this._animations[t].isMultiple() ? this._animations[t].kill().play(n) :
						(this._runningAnimations.push(this._animations[t]), this._animations[t].play(n)), this
				},
				_animate: function (t) {
					var e, i;
					for (i = 0; i < this._runningAnimations.length; i++)(e = this._runningAnimations[i])
						.update(t), e.isAlive() || (this._runningAnimations.splice(i, 1), i--);
					return this
				},
				getPosition: function (t) {
					return t ? this._object.position.clone() : this._object.position
				},
				getObject: function () {
					return this._object
				},
				update: function () {
					return this
				},
				base64ToTexture: function (t, e) {
					var i = new Image,
						n = new r.Texture;
					return i.src = t, (n.image = i).onload = function () {
						n.needsUpdate = !0, e && e(n)
					}, n
				}
			}, e.default = a
		}, function (t, e, i) {
			"use strict";

			function n(t, e) {
				this._settings = Object.assign({
					duration: 1e3,
					easing: "linear",
					completeOnKill: !0,
					multiple: !1,
					onStart: r,
					onUpdate: r,
					onComplete: r
				}, e), this._start = null, this._isAlive = !1, this._name = t
			}
			i.r(e), n.prototype = {
				isMultiple: function () {
					return this._settings.multiple
				},
				kill: function () {
					return this._start = null, this._isAlive = !1, this._settings.completeOnKill && (this
						._settings.onUpdate(1), this._settings.onComplete(1)), this
				},
				isAlive: function () {
					return this._isAlive
				},
				play: function (t) {
					return this._playOptions = Object.assign({
						onStart: r,
						onUpdate: r,
						onComplete: r
					}, t), this._isAlive = !0, this
				},
				update: function (t) {
					var e, i;
					this.isAlive() && (null === this._start && (this._start = t, this._settings.onStart(0),
						this._playOptions.onStart(0)), e = t - this._start, i = Math.min(n.easing[this
						._settings.easing](e / this._settings.duration), 1), this._settings.onUpdate(
						i), this._playOptions.onUpdate(i), e >= this._settings.duration && (this
						._isAlive = !1, this._start = null, this._settings.onUpdate(1), this
						._playOptions.onUpdate(1), this._settings.onComplete(1), this._playOptions
						.onComplete(1)))
				}
			}, n.easing = {
				linear: function (t) {
					return t
				},
				easeInQuad: function (t) {
					return t * t
				},
				easeOutQuad: function (t) {
					return t * (2 - t)
				},
				easeInOutQuad: function (t) {
					return t < .5 ? 2 * t * t : (4 - 2 * t) * t - 1
				},
				easeInCubic: function (t) {
					return t * t * t
				},
				easeOutCubic: function (t) {
					return --t * t * t + 1
				},
				easeInOutCubic: function (t) {
					return t < .5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1
				},
				easeInQuart: function (t) {
					return t * t * t * t
				},
				easeOutQuart: function (t) {
					return 1 - --t * t * t * t
				},
				easeInOutQuart: function (t) {
					return t < .5 ? 8 * t * t * t * t : 1 - 8 * --t * t * t * t
				},
				easeInQuint: function (t) {
					return t * t * t * t * t
				},
				easeOutQuint: function (t) {
					return 1 + --t * t * t * t * t
				},
				easeInOutQuint: function (t) {
					return t < .5 ? 16 * t * t * t * t * t : 1 + 16 * --t * t * t * t * t
				}
			};
			var r = function () {};
			e.default = n
		}, function (t, e, i) {
			"use strict";
			i.r(e);
			var u = i(3),
				p = i(8),
				d = i(11),
				f = i(12);

			function n(t) {
				p.default.call(this, t);
				var e, i, n, r, a = this,
					o = this._settings.width,
					s = this._settings.height,
					c = this._settings.map.slice(),
					h = new u.Mesh(new u.PlaneBufferGeometry(o, s, o, s), new u.MeshPhongMaterial({
						color: this._settings.floorColor,
						wireframe: !1
					})),
					l = this.base64ToTexture(this._settings.paintDrop);
				for (h.receiveShadow = !0, this._radius = Math.sqrt(o * o + s * s) / 2, this._width = o, this
					._height = s, this._line = [], this._map = c, this._elements = [], this._startPosition = new u
					.Vector3, this._object = new u.Group, this._object.add(h), i = 0; i < c.length; i++) n = m.call(
						this, i), 1 === c[i] ? e = new f.default({
						position: n
					}) : (e = new d.default({
						position: n,
						color: this._settings.paintColor,
						paintDropMap: l
					}), 2 === c[i] && (e.show(!1), this._startPosition.copy(n))), this._object.add(e.getObject()),
					this._elements.push(e);
				this.addAnimation("end of level", ((r = new u.Group).position.z = 5, r.rotateX(Math.PI / 8), {
					duration: 1e3,
					easing: "easeInOutQuad",
					onStart: function () {
						var t, e, i, n = a._settings.particleColors;
						for (i = 0; i < 600; i++) e = Math.random() / 2, (t = new u.Mesh(new u
								.PlaneBufferGeometry(e, e), new u.MeshBasicMaterial({
									color: n[Math.floor(Math.random() * n.length)],
									transparent: !0
								}))).userData.position = new u.Vector2(40 * Math.random() - 20, 40 *
								Math.random() - 20).normalize().multiplyScalar(30 * Math.random()), t
							.userData.rotation = 2 * Math.PI + Math.random() * Math.PI * 10, r.add(t);
						a._object.add(r)
					},
					onUpdate: function (t) {
						var e, i;
						for (i = 0; i < r.children.length; i++)(e = r.children[i]).position.x = e
							.userData.position.x * t, e.position.y = e.userData.position.y * t, e
							.userData.position.y -= .1 * t, e.rotation.z += e.userData.rotation, e
							.material.opacity = 1 - t
					},
					onComplete: function () {
						a._object.remove(r)
					}
				}))
			}

			function o(t) {
				var e = this._settings.width,
					i = this._settings.height;
				return Math.floor(Math.abs(t.y - i / 2)) * e + Math.floor(t.x + e / 2)
			}

			function m(t) {
				var e = this._settings.width,
					i = this._settings.height;
				return new u.Vector3(t % e - e / 2 + .5, i / 2 - Math.floor(t / e) - .5, 0)
			}
			Object.assign(n.prototype, p.default.prototype, {
				getRadius: function () {
					return this._radius
				},
				getWidth: function () {
					return this._width
				},
				getHeight: function () {
					return this._height
				},
				getStartPosition: function (t) {
					return t ? this._startPosition.clone() : this._startPosition
				},
				getNextPosition: function (t, e) {
					var i, n = this._settings.width,
						r = (this._settings.height, o.call(this, t)),
						a = this._settings.map;
					switch (e) {
						case "left":
							i = -1;
							break;
						case "right":
							i = 1;
							break;
						case "top":
							i = -1 * n;
							break;
						case "bottom":
							i = n
					}
					for (this._line.push(r); void 0 !== a[r] && 1 !== a[r + i];) r += i, this._line.push(
						r);
					return this._elements[r].getPosition()
				},
				controlLine: function () {
					var t, e = this._map,
						i = this._line;
					for (t = 0; t < i.length; t++) 0 === e[i[t]] && (e[i[t]] = 2, this._elements[i[t]]
						.show(!1));
					return this._line = [], this
				},
				controlPlayerPosition: function (t) {
					var e = this._map,
						i = o.call(this, t);
					return 0 === e[i] && (e[i] = 2, this._elements[i].show()), this
				},
				isFinish: function () {
					var t = this,
						e = -1 === this._map.indexOf(0);
					return e && setTimeout(function () {
						t.playAnimation("end of level")
					}, 750), e
				},
				update: function (t, e) {
					var i;
					for (this._animate(t), i = 0; i < this._elements.length; i++) this._elements[i]
						.update(t, e);
					return this
				}
			}), e.default = n
		}, function (t, e, i) {
			"use strict";
			i.r(e);
			var a = i(3),
				o = i(8);

			function n(t) {
				o.default.call(this, t);
				var n, r = this;
				this._plane = new a.Mesh(new a.PlaneBufferGeometry(1, 1), new a.MeshPhongMaterial({
						color: this._settings.color,
						opacity: 0,
						visible: !1,
						transparent: !0,
						wireframe: !1
					})), this._object = new a.Group, this._object.position.copy(this._settings.position), this._object
					.position.z = .1, this._object.add(this._plane), this.addAnimation("show", {
						duration: 66.6664,
						easing: "linear",
						onUpdate: function (t) {
							r._plane.material.opacity = t
						},
						onComplete: function () {
							r._plane.material.transparent = !1
						}
					}), this.addAnimation("paintDrop", (n = [], {
						duration: 750,
						easing: "easeInOutQuad",
						onStart: function () {
							var t, e, i;
							for (i = 0; i < 25; i++) e = Math.random() / 4, (t = new a.Mesh(new a
								.PlaneBufferGeometry(e, e), new a.MeshBasicMaterial({
									color: r._settings.color,
									map: r._settings.paintDropMap,
									transparent: !0
								}))).userData.position = new a.Vector2(4 * Math.random() - 2, 4 * Math
								.random()), n.push(t), r._object.add(t)
						},
						onUpdate: function (t) {
							var e, i;
							for (i = 0; i < n.length; i++)(e = n[i]).position.x = e.userData.position.x *
								t, e.position.y = e.userData.position.y * t, e.userData.position.y -= .1 *
								t, e.material.opacity = 1 - t
						},
						onComplete: function () {
							var t;
							for (t = 0; t < n.length; t++) r._object.remove(n[t])
						}
					}))
			}
			Object.assign(n.prototype, o.default.prototype, {
				show: function (t) {
					return this._plane.material.visible || (!(this._plane.material.visible = !0) !== t ?
							this.playAnimation("show", "paintDrop") : this._plane.material.opacity = 1),
						this
				},
				update: function (t, e) {
					return this._animate(t), this
				}
			}), e.default = n
		}, function (t, e, i) {
			"use strict";
			i.r(e);
			var n = i(3),
				r = i(8);

			function a(t) {
				r.default.call(this, t), this._object = new n.Mesh(new n.BoxBufferGeometry(1, 1, .5), new n
					.MeshPhongMaterial({
						color: "#ffffff"
					})), this._object.position.copy(this._settings.position), this._object.position.z = .25
			}
			Object.assign(a.prototype, r.default.prototype, {}), e.default = a
		}, function (t, e, i) {
			"use strict";
			i.r(e);
			var h = i(3),
				n = i(8);

			function r(t) {
				n.default.call(this, t), this._camera = new h.PerspectiveCamera(75, 1, .1, 400), this._camera.position
					.z = 15, this._camera.position.y = -.5, this._width = 1, this._height = 1, this._object = new h
					.Group, this._object.add(this._camera), this._object.rotateX(Math.PI / 8)
			}
			Object.assign(r.prototype, n.default.prototype, {
				setDistance: function (t, e, i) {
					var n = this,
						r = this._camera,
						a = r.aspect,
						o = t / e,
						s = new h.Vector3(0, -.5, 15).normalize(),
						c = r.position.clone();
					return o < a ? s.multiplyScalar(1.55 * e) : s.multiplyScalar(1.75 * t), this
						.addAnimation("move", {
							duration: 1e3,
							easing: "easeInOutQuad",
							onUpdate: function (t) {
								r.position.z = c.z + (s.z - c.z) * t, r.position.y = c.y + (s.y -
									c.y) * t
							},
							onComplete: function () {
								n.removeAnimation("move")
							}
						}), this.playAnimation("move"), this
				},
				getCamera: function () {
					return this._camera
				},
				updateCamera: function (t, e) {
					var i = t / e;
					return this._width = t, this._height = e, this._camera.aspect = i, this._camera
						.updateProjectionMatrix(), this
				},
				update: function (t, e) {
					return this._animate(t), this
				}
			}), e.default = r
		}, function (t, e, i) {
			"use strict";
			i.r(e);
			var o = i(3),
				n = i(8);

			function r(t) {
				n.default.call(this, t);
				var e = this;
				this._tail = new o.Mesh(new o.PlaneBufferGeometry(16, .8), new o.MeshBasicMaterial({
						map: this.base64ToTexture(this._settings.tail, function (t) {
							t.wrapS = o.RepeatWrapping, t.wrapT = o.RepeatWrapping, t.rotation = Math
								.PI, t.needsUpdate = !0
						}),
						transparent: !0
					})), this._tail.geometry.applyMatrix((new o.Matrix4).makeTranslation(8, 0, 0)), this._tail.scale
					.x = 0, this._ball = new o.Mesh(new o.SphereBufferGeometry(.5, 32, 32), new o.MeshPhongMaterial({
						color: "#ffffff",
						opacity: .5,
						transparent: !0
					})), this._innerBall = new o.Mesh(new o.SphereBufferGeometry(.4, 32, 32), new o
				.MeshPhongMaterial({
						color: "#ffffff"
					})), this._isMoving = !1, this._object = new o.Group, this._ball.add(this._innerBall), this
					._object.add(this._tail, this._ball), this.addAnimation("strech-top", {
						duration: 125,
						easing: "easeInOutQuad",
						onUpdate: function (t) {
							e._ball.position.y = t < .5 ? (e._ball.scale.set(1, 1 - t, 1), t) : (e._ball.scale
									.set(1, t - .5 + .5, 1), .5 - (t - .5)), e._tail.scale.x = e._tail
								.userData.scaleX * (1 - t)
						},
						onComplete: function () {
							e._ball.scale.set(1, 1, 1), e._ball.position.y = 0
						}
					}), this.addAnimation("strech-bottom", {
						duration: 125,
						easing: "easeInOutQuad",
						onUpdate: function (t) {
							e._ball.position.y = t < .5 ? (e._ball.scale.set(1, 1 - t, 1), -1 * t) : (e._ball
									.scale.set(1, t - .5 + .5, 1), -1 * (.5 - (t - .5))), e._tail.scale.x = e
								._tail.userData.scaleX * (1 - t)
						},
						onComplete: function () {
							e._ball.scale.set(1, 1, 1), e._ball.position.y = 0
						}
					}), this.addAnimation("strech-right", {
						duration: 125,
						easing: "easeInOutQuad",
						onUpdate: function (t) {
							e._ball.position.x = t < .5 ? (e._ball.scale.set(1 - t, 1, 1), t) : (e._ball.scale
									.set(t - .5 + .5, 1, 1), .5 - (t - .5)), e._tail.scale.x = e._tail
								.userData.scaleX * (1 - t)
						},
						onComplete: function () {
							e._ball.scale.set(1, 1, 1), e._ball.position.x = 0
						}
					}), this.addAnimation("strech-left", {
						duration: 125,
						easing: "easeInOutQuad",
						onUpdate: function (t) {
							e._ball.position.x = t < .5 ? (e._ball.scale.set(1 - t, 1, 1), -1 * t) : (e._ball
									.scale.set(t - .5 + .5, 1, 1), -1 * (.5 - (t - .5))), e._tail.scale.x = e
								._tail.userData.scaleX * (1 - t)
						},
						onComplete: function () {
							e._ball.scale.set(1, 1, 1), e._ball.position.x = 0
						}
					})
			}

			function s(t, e) {
				return t <= 0 && 0 <= e ? Math.abs(t) + e : 0 <= t && e <= 0 ? -1 * (Math.abs(e) + t) : e - t
			}
			Object.assign(r.prototype, n.default.prototype, {
				setColor: function (t) {
					return this._ball.material.color.set(t), this._innerBall.material.color.set(t), this
				},
				isMoving: function () {
					return this._isMoving
				},
				moveTo: function (t, e, i) {
					if (!this._isMoving) {
						this._isMoving = !0;
						var n = this,
							r = this.getPosition().clone(),
							a = new o.Vector2(s(r.x, t.x), s(r.y, t.y));
						this._tail.rotation.z = a.angle() + Math.PI, this.addAnimation("move", {
							duration: 40 * a.length(),
							easing: "easeInQuad",
							onUpdate: function (t) {
								n._object.position.x = r.x + a.x * t, n._object.position.y = r
									.y + a.y * t, n._tail.scale.x = Math.abs(a.x + a.y) / 16 *
									t, i.onUpdate(t)
							},
							onComplete: function () {
								n.removeAnimation("move"), n._tail.userData.scaleX = n._tail
									.scale.x, n.playAnimation("strech-" + e, {
										onComplete: function () {
											n._isMoving = !1, i.onComplete()
										}
									})
							}
						}).playAnimation("move")
					}
					return this
				},
				setPosition: function (t) {
					return this._object.position.copy(t), this._object.position.z = .5, this
				},
				update: function (t, e) {
					return this._animate(t), this
				}
			}), e.default = r
		}, function (t, e, i) {
			"use strict";

			function n(t) {
				this._currentState = t.currentState || 0, this._states = t.states, this._debug = t.debug
			}
			i.r(e), n.prototype = {
				set: function (t) {
					var e = this._states.indexOf(t);
					return -1 === e && console.error("[StatesManager] set : state " + t + " doesn't exist"),
						this._currentState !== t && this._debug && console.log("[StatesManager] set : " + t),
						this._currentState = e, this
				},
				is: function (t) {
					return this._currentState === this._states.indexOf(t)
				}
			}, e.default = n
		}]);
	</script>


</body>

</html>