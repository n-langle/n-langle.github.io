<!DOCTYPE html>
<html>

<head>
	<meta name="viewport" content="initial-scale=1.0,maximum-scale=1.0,user-scalable=no" />
	<meta charset="utf-8">
	<link rel="icon" type="image/png"
		href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAMAAAAoyzS7AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyhpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTQwIDc5LjE2MDQ1MSwgMjAxNy8wNS8wNi0wMTowODoyMSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTggKE1hY2ludG9zaCkiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6NjI2QjdCNzk5MzA5MTFFOEFERERDQ0U0Njc3NUIzODciIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6NjI2QjdCN0E5MzA5MTFFOEFERERDQ0U0Njc3NUIzODciPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo2MjZCN0I3NzkzMDkxMUU4QURERENDRTQ2Nzc1QjM4NyIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo2MjZCN0I3ODkzMDkxMUU4QURERENDRTQ2Nzc1QjM4NyIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/Ppp54RwAAAAGUExURf///wAAAFXC034AAAAMSURBVHjaYmAACDAAAAIAAU9tWeEAAAAASUVORK5CYII=" />

	<style>
		#App,
		#App canvas,
		.obj-banner::before,
		body,
		html {
			width: 100%;
			height: 100%
		}

		a,
		abbr,
		acronym,
		address,
		applet,
		article,
		aside,
		audio,
		b,
		big,
		blockquote,
		body,
		canvas,
		caption,
		center,
		cite,
		code,
		dd,
		del,
		details,
		dfn,
		div,
		dl,
		dt,
		em,
		embed,
		fieldset,
		figcaption,
		figure,
		footer,
		form,
		h1,
		h2,
		h3,
		h4,
		h5,
		h6,
		header,
		hgroup,
		html,
		i,
		iframe,
		img,
		ins,
		kbd,
		label,
		legend,
		li,
		mark,
		menu,
		nav,
		object,
		ol,
		output,
		p,
		pre,
		q,
		ruby,
		s,
		samp,
		section,
		small,
		span,
		strike,
		strong,
		sub,
		summary,
		sup,
		table,
		tbody,
		td,
		tfoot,
		th,
		thead,
		time,
		tr,
		tt,
		u,
		ul,
		var,
		video {
			margin: 0;
			padding: 0;
			border: 0;
			font: inherit;
			vertical-align: baseline
		}

		.obj-banner,
		.obj-header {
			box-sizing: border-box;
			font-family: Helvetica, Arial, sans-serif;
			left: 0
		}

		article,
		aside,
		details,
		figcaption,
		figure,
		footer,
		header,
		hgroup,
		menu,
		nav,
		section {
			display: block
		}

		body {
			-webkit-user-select: none;
			-moz-user-select: none;
			-ms-user-select: none;
			user-select: none;
			line-height: 1
		}

		ol,
		ul {
			list-style: none
		}

		blockquote,
		q {
			quotes: none
		}

		blockquote:after,
		blockquote:before,
		q:after,
		q:before {
			content: '';
			content: none
		}

		.obj-banner::before,
		.obj-header::before,
		.obj-screen.screen-end::before {
			content: ""
		}

		table {
			border-collapse: collapse;
			border-spacing: 0
		}

		@font-face {
			font-family: fffforwa;
			src: url('data:application/x-font-woff;charset=utf-8;base64,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') format('woff2');
			font-weight: 400;
			font-style: normal
		}

		button {
			-webkit-appearance: none;
			-moz-appearance: none;
			appearance: none;
			background: 0 0;
			border: 0;
			padding: 0
		}

		.button {
			background: #ff5151;
			border-radius: 5px;
			color: #fff;
			cursor: pointer;
			display: inline-block;
			font-size: .625em;
			padding: 1em
		}

		#App,
		body,
		html {
			background: #e3e3e3;
			overflow: hidden
		}

		#App>svg:first-child {
			display: none
		}

		#App {
			position: relative;
			z-index: 0
		}

		.obj-banner {
			bottom: 0;
			color: #000;
			display: table;
			padding: 1em 1.5em;
			position: fixed;
			text-align: center;
			width: 100%;
			z-index: 100
		}

		.obj-banner::before {
			background: #000;
			left: 0;
			opacity: .5;
			position: absolute;
			top: 0
		}

		.obj-banner>div {
			display: table-cell;
			position: relative;
			vertical-align: middle;
			z-index: 2
		}

		.obj-banner h1 br,
		.obj-header {
			display: none
		}

		.obj-banner>div:first-child {
			width: 3em
		}

		.obj-banner>div:nth-child(2) {
			line-height: 1em;
			padding: 0 1em;
			text-align: left
		}

		.obj-banner small {
			font-size: .75em;
			font-weight: 700
		}

		.obj-banner img {
			border-radius: .25em;
			vertical-align: text-bottom;
			width: 100%
		}

		.obj-header {
			padding: 1em 1.5em;
			position: fixed;
			text-align: center;
			top: 0;
			width: 100%;
			z-index: 100
		}

		.obj-header.is-visible,
		.obj-screen.screen-game .boss-infos span {
			display: block
		}

		.obj-header::before {
			background: #000;
			height: 100%;
			left: 0;
			position: absolute;
			opacity: .5;
			top: 0;
			width: 100%
		}

		.obj-header p {
			font-size: 1em;
			font-weight: 900;
			position: relative;
			z-index: 1
		}

		.obj-loader {
			-webkit-animation: loader 1s infinite ease-in-out;
			animation: loader 1s infinite ease-in-out;
			border: 6px solid #fff;
			border-radius: .75em;
			height: 2em;
			margin: 0 auto;
			width: 2em
		}

		@-webkit-keyframes loader {
			0% {
				opacity: .25;
				-webkit-transform: rotate(0);
				transform: rotate(0)
			}

			50% {
				opacity: 1
			}

			100% {
				opacity: .25;
				-webkit-transform: rotate(360deg);
				transform: rotate(360deg)
			}
		}

		@keyframes loader {
			0% {
				opacity: .25;
				-webkit-transform: rotate(0);
				transform: rotate(0)
			}

			50% {
				opacity: 1
			}

			100% {
				opacity: .25;
				-webkit-transform: rotate(360deg);
				transform: rotate(360deg)
			}
		}

		.screen-container {
			height: 100%;
			position: relative;
			width: 100%;
			z-index: 1
		}

		.obj-screen {
			font-family: fffforwa;
			left: -100%;
			opacity: 0;
			position: absolute;
			text-align: center;
			width: 100%;
			z-index: 2
		}

		.obj-screen.is-visible {
			left: 0;
			opacity: 1
		}

		.obj-screen .v-align-center {
			position: absolute;
			top: 50%;
			-webkit-transform: translateY(-50%);
			-ms-transform: translateY(-50%);
			transform: translateY(-50%);
			width: 100%
		}

		.screen-container.perspective-enabled {
			-webkit-perspective: 500px;
			perspective: 500px
		}

		.screen-container.perspective-enabled>* {
			-webkit-transform: translateY(-5em) rotateY(20deg) rotateX(45deg) rotateZ(-10deg);
			transform: translateY(-5em) rotateY(20deg) rotateX(45deg) rotateZ(-10deg)
		}

		.obj-screen .stroke-text,
		.obj-screen .stroke-text-blue,
		.obj-screen .stroke-text-red {
			text-shadow: -.125em -.125em 0 #fff, .125em -.125em 0 #fff, -.125em .125em 0 #fff, .125em .125em 0 #fff
		}

		.obj-screen .stroke-text-blue {
			color: #488fcc
		}

		.anim-translate-top,
		.anim-translate-top-from-parent {
			opacity: 0;
			-webkit-transform: translateY(8em);
			-ms-transform: translateY(8em);
			transform: translateY(8em);
			-webkit-transition: opacity .5s cubic-bezier(.175, .885, .32, 1.275), -webkit-transform .5s cubic-bezier(.175, .885, .32, 1.275);
			transition: opacity .5s cubic-bezier(.175, .885, .32, 1.275), transform .5s cubic-bezier(.175, .885, .32, 1.275)
		}

		.anim-translate-top.is-visible,
		.is-visible .anim-translate-top-from-parent {
			opacity: 1;
			-webkit-transform: translateY(0);
			-ms-transform: translateY(0);
			transform: translateY(0)
		}

		.anim-translate-top.is-hidden,
		.is-hidden .anim-translate-top-from-parent {
			opacity: 0;
			-webkit-transform: translateY(-8em);
			-ms-transform: translateY(-8em);
			transform: translateY(-8em);
			-webkit-transition-timing-function: cubic-bezier(.6, -.28, .735, .045);
			transition-timing-function: cubic-bezier(.6, -.28, .735, .045)
		}

		.obj-screen.screen-loading {
			background: #000;
			height: 100%;
			width: 100%;
			z-index: 200
		}

		.obj-screen.screen-start {
			height: 100%;
			width: 100%
		}

		.obj-screen.screen-start .instruction {
			left: 50%;
			position: absolute;
			top: 50%;
			-webkit-transform: translate(-50%, -50%);
			-ms-transform: translate(-50%, -50%);
			transform: translate(-50%, -50%)
		}

		.obj-screen.screen-start img {
			-webkit-animation: swip ease-in-out 2s infinite;
			animation: swip ease-in-out 2s infinite;
			width: 6em
		}

		.obj-screen.screen-start .anim-translate-top-from-parent {
			-webkit-transition-delay: 1s;
			transition-delay: 1s
		}

		@-webkit-keyframes swip {

			0%,
			100% {
				-webkit-transform: translateX(0);
				transform: translateX(0)
			}

			25% {
				-webkit-transform: translateX(-5em);
				transform: translateX(-5em)
			}

			75% {
				-webkit-transform: translateX(5em);
				transform: translateX(5em)
			}
		}

		@keyframes swip {

			0%,
			100% {
				-webkit-transform: translateX(0);
				transform: translateX(0)
			}

			25% {
				-webkit-transform: translateX(-5em);
				transform: translateX(-5em)
			}

			75% {
				-webkit-transform: translateX(5em);
				transform: translateX(5em)
			}
		}

		.obj-screen.screen-game {
			height: 100%;
			width: 100%
		}

		.obj-screen.screen-game .progress {
			display: flex;
			height: 1.5em;
			left: 20%;
			position: absolute;
			top: 2em;
			width: 60%
		}

		.obj-screen.screen-game .progress .num {
			background: #fff;
			color: #000;
			font-size: .5em;
			height: 100%;
			line-height: 3em;
			width: 3em
		}

		.obj-screen.screen-game .boss-infos .name,
		.obj-screen.screen-game .congrat {
			font-size: 1.5em
		}

		.obj-screen.screen-game .progress .bar {
			background: #000;
			height: .5em;
			margin-top: .5em;
			overflow: hidden;
			width: calc(100% - 3em)
		}

		.obj-screen.screen-game .progress .bar div {
			background: #fff;
			height: 100%;
			-webkit-transition: width .25s;
			transition: width .25s;
			width: 0
		}

		.obj-screen.screen-game .text-container {
			left: 0;
			position: absolute;
			top: 50%;
			-webkit-transform: translateY(-50%);
			-ms-transform: translateY(-50%);
			transform: translateY(-50%);
			width: 100%
		}

		.obj-screen.screen-game .anim-translate-top {
			left: -100%;
			position: absolute;
			width: 100%
		}

		.obj-screen.screen-game .anim-translate-top.is-visible {
			left: 0;
			position: relative
		}

		.obj-screen.screen-game p {
			line-height: 2em
		}

		.obj-screen.screen-end {
			color: #fff;
			height: 100%;
			line-height: 2em;
			width: 100%
		}

		.obj-screen.screen-end::before {
			background: #000;
			height: 100%;
			left: 0;
			position: absolute;
			opacity: .5;
			top: 0;
			width: 100%
		}

		.obj-screen.screen-end img {
			border-radius: 1em;
			margin-bottom: .75em;
			width: 5em
		}

		.obj-screen.screen-end .button {
			border-radius: 0;
			line-height: 1em;
			margin: 2em 0
		}

		.obj-screen.screen-end .button~.button {
			margin-bottom: 0
		}

		#modal {
			z-index: 100
		}
	</style>
	<style>
		#App {
			background-color: #e3e3e3;
			background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR4AWNwL/BhAAADCQEEiiqnjQAAAABJRU5ErkJggg==');
			background-repeat: no-repeat;
			background-size: auto;
		}

		/* header */
		.obj-header::before {
			background: #000000;
			opacity: 0.8;
		}

		.obj-header p {
			color: #ffffff;
			font-size: 1em;
		}

		/* text between match */
		.obj-screen .stroke-text-blue {
			color: #488fcc;
		}

		/* progress */
		.obj-screen.screen-game .progress .num {
			background: #fffd14;
			color: #000000;
		}

		.obj-screen.screen-game .progress .bar {
			background: #000000;
		}

		.obj-screen.screen-game .progress .bar>div {
			background: #fff;
		}

		/* banner */
		.obj-banner {
			color: #ffffff;
		}

		.obj-banner::before {
			background: #000000;
			opacity: 0.8;
		}

		#App .button.download {
			background: #ccc;
			color: #ffffff;
			cursor: default;
		}
	</style>

	<script type="text/javascript"></script>
	<script type='text/javascript'>
		window._voodooProvider = 'applovin'
	</script>
</head>

<body>


	<div id="App">
		<div class="obj-header">
			<p>I dare you to beat Dr Mustache</p>
		</div>

		<div class="screen-container ">
			<div class="obj-screen screen-loading is-visible">
				<div class="v-align-center">
					<h1>Dodgeball Duel</h1>
					<div class="obj-loader"></div>
				</div>
			</div>

			<div class="obj-screen screen-start">
				<div class="instruction">
					<img class="anim-translate-top-from-parent"
						src="data:image/png;base64,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"
						alt="" />
					<p class="anim-translate-top-from-parent"><span class="stroke-text-blue">Catch the ball !</span></p>
				</div>
			</div>

			<div class="obj-screen screen-game">

				<div class="progress">
					<div class="num from">1</div>
					<div class="bar">
						<div></div>
					</div>
					<div class="num to">2</div>
				</div>

				<div class="text-container stroke-text-blue">

					<p class="congrat anim-translate-top">Wrecked!</p>
					<p class="congrat anim-translate-top">Unstoppable</p>
					<p class="congrat anim-translate-top">Wrecked!</p>
					<p class="congrat anim-translate-top">Unstoppable</p>
					<p class="congrat anim-translate-top">Wrecked!</p>
					<p class="congrat anim-translate-top">Unstoppable</p>
					<p class="congrat anim-translate-top">Wrecked!</p>
					<p class="congrat anim-translate-top">Unstoppable</p>

					<p class="boss-infos anim-translate-top">
						<span class="name"></span>
						<span class="sub"></span>
					</p>
				</div>


			</div>

			<div class="obj-screen screen-end-of-level">
			</div>

			<div class="obj-screen screen-end">
				<div class="v-align-center">
					<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMgAAADICAMAAACahl6sAAADAFBMVEX86e375un74+f65Of/3uj63eL93+b7y9P7vcr8tsf4uMj9wM/6wsz71Nz63+X64eb62+H93eP6ssT0vsj60Nn92uH7xdH7rsL8ztjz3uP92+X6qb7819/62N72rbr0pbn7orr2tsHw2t75sr76mrP0xs/1na3/x9f5qLX4oa76pLT0pLL5m636kq38jqz1larpqrT11dv7kqP6iqX6g5/1lKL3fJn6fJv6eJf3dZb6dpj6c5T2c5L5b4/3a4zsjpz6a4z5aIj0aIb3Zoj2YYP5bZD6Y4Xy0df6Zoj0X33sWHflT2b5XX/4VnjzUHDnRGToRFfgQGDsOljyM1f3Nl30RmnYOU/oM03wOmP1OFr3N2D5OV77NVzyzNT5TnH6u8XiQW70e5Loa4HnxMzovMX1ucPms7zldojzm6b5m6b0qrX0O1L4OFP9M1T2L1PVR3fdS2LMTH7EUIe2WY6pY5GgYavXUmXVc4N4lMttmeRwodtop+yPsNWkl8KocK/MVmraSlqYibU2qPoknfwpofouov4ym/4aq/kqnv0en/0ul/5Wrd+cXpUnqv6LdbIrpvYxnvAqnO4tnvUiqfUpquzIS2FPrfAll/0mnvWYbpOKk8Yso/sipP2DfsF0drjFV3Uko/M+tPUoof4zqu/2N0wop//VZ3m3X3Vwhb1fiszPh5EirvwqpvnonKYupv4qqfktqv4spvosqvnkpK4sq/fVV3Xkn68vr/704+bmzNPn1dwssfnMnazWqrjv4uno3eQsrvnYw8wqrfnRuMWzs8rn4+jZzNTe4ObY2+PZ1dw4teYorv4swuORu+Qnse/FyNaDx+q3xdjd5OrM0tzLzt/X4ehvxvLM1uAssPiRwuHO2+W6zeCnyuLB1uPO4OeWyuiz0uSj0uWSzfC61eTF2+jT5Ou92+efz+3L3unM4+yN0e2s0ua92OmKzPCy1+rH4OnC3uqr1+qEz++32uma1OvD4+y73+vF5e+m2emt2+yz3uyi1+yZ1u+74u2m2eyt3u9ZT0a8AAAtrUlEQVR4AayWCXeiTBOFRwm4ZIAm7gjqzJd9wez78v//1Xf7Uk2a6XA0Oe9TjZ6eDFKPt1R+NdAqaePwWm2w47eDTlfodXs/pi/VSLcn19j9HQZRFMdtDVsBbA61JS0jwgeKqDjp9LvdPuhZ7GHZJTTu5ck5z1btd/sQ6XcHwx0tEtdFWt8SoQrPbmuRON5R0WhMiz5baGIi9WMoxav0B9NkFjiRfE9EQwcSUyTc1a+/13c7t0po2jeXDSSo00lnQRCYSOoqG1xKV1rYHkESqXTYlWGpdf9fI6n0KTLykwDAxA5lO5HWp4jxiAItoqZ90fhW93NZDfsmFeY+zvwkSpiJHcrm4aIpD68SiZGHn0a+yjt6AKyG2A/qy7WBxtPMHDLs3xBJtEhQReJ5pcgmWhUUoUeEPFJfpWO+/gK9SycLPGzLci6spJqZLODyRwsNQpVChJFsLdIqq+IXXWKYRJHvp393st3/zc1suG1Kf8vVigceWHNusebl3mhUuyYxLTPpTSOllB9FcdujQUXzeLUcE/6ABCKitMjCpAFWtWJP27GsSlZF3WeBK+11lIjQZCsRxwPIZEFEqVkadjlK4lDB99xlX1bTPzQjPgs9ZAepFkk4WjT5cSIRRJJIQWQ07XGILA2HfdekqmodlscGLf2hWi3GKlcq9QOYMJOfJ0IPX4HsaA8Sx3UN0+oJH7E2YtzsDV/BzQVrkOY5IwmiSGfyg0Q8isQRv7KUymfhGAbzU3uO3OZ/jrwZn5zCZTlIsyxVKUVo4n07EZzilb+FfuqnmVLhro7irIrBcI4OzlGyu9g3xaWLy+ybOWGVAQnLfpZlI4qIyUaRliviiUiSqlRlftid769OT/WA77ucY4F9KbRMqMAHgTJcYmvAuTxRwFUgsv8nRCKjNIlkuNqOiCMjFvLEFNsx8DUqz/9mPThAwh6li3p9RYHCsvbAmNV01rbGPpNfLoZZlue5GlW/ipZGcyZ1kXYlorRIuMcLGNgCq9GAFgazR33N/hqFZeAX2+U0LEX8RpHmRDQU4W+IBJJfTRd6js9NFA3v/nVBboqbRvDH4sY1WsOlfJJoVpBZjpEIGPGLqxTxtk0EeOYuyxZZcpQ5A/90bzXvCtxKuRS6iGNlkll2SxHlJ1Ea8WcR0EOqMRGi04AJRBKZrDwbr+hhWRQoJsCWsGrdG25kVVvHp6IWE1M564VhKeJDhSKabRKhhySif0MUPEZ5Hoa7h/hQInmiu7++cYHCdrghMR0ioZA9iEDF3HJVIlslQhFOVholCh6jPIPI+gIepYgM0h1knAjI/WfdP2juzf7h4fahZvTlsOm49/WETUKJREQEmmxMBMpVIClFMoj01gVEOFHUsDOwNNAnuG9CtGBUz0c8rGxggTVnIq6Im0iVRM2EKlHka5T2GGZLHfnNGhJuCg8ovtv3qIeHR8PTJ48W+B+iyjNJLRR+5MoBm4ZXYZZdsZUgioNSow59GjwgYr57IYJ8h6viYo2vTVzD9YABJe4fUej/+enlVXh5Loubp6fnxyeU5l6sxaVmw3AYPkSyqyzMfaVFJBPP8ZCqi3i2CL+yMnhMV0VBEcEKgwo0YASvL6i3Fxyvb1jvZekdC3/V0MaM2lcuBbi+uDjCaGXh1UwpigTaxPOaE/lHgz+HDEQ8huP9m+KjuLUdxALN8G2mwqtulrzgeH9/f6sQJUG7cOAwZv/I2KkUvzFbEFFaxI/KSDzQmAixRGKKwGNUinSRxZofSkuClEH8n3gzfU/b6rb4p1vmDFiV1eJwwyU2mODrB/A8MjiyIQythBoNGHee2///47uWto7Dawp189TO8ggEWz/WXnsfHSvHVHTAzTO8t87arXa73YnUvsAN3n/2Bjp9E8LAHAmNQpmfNnGGhCAkUY5ACx1RUhgQOZQhWhJunM/mQqUaiTjGEcEBqEmGFtXptKimGanV7uA+3isCUuTM0dHBLM0dlGwpcwmQFzOW3MeRWztmQchhZBsE2W9E4QYHM3Ek9UQbWEc4wDYP17wwzSuTXy6uInUAc9G96HZwN2+TBYXXRCUyU4dHR4cEYmj2ZvOS1zOXtVkQHNhSR+Y5AIJniyGGkRcQ4SDKgXAAQyhYSh04caHU7fagt5F6b3u9blceAR+tAQkKjcYgWIcQuh1JZscLQLTL2prM9gUgc/mQkIsk6XyyllnTLjOxV+IFMegFJJmgmniF3zQB0cYrjqPs9wbD0RejLy3LhsZ8hyzoy9Gw1zc7iEuv22mFT2nidWifsM2pKlNdOdQr/f8M44UMRYAICXbb5hvXUhBIgyOXWmyLICree3jx3me7ZaJYQidQPv3BwBlZX72zXMvzQ43xDuE7FyhfAcYBDJ5Af9rN1pV51QoTdhKyHCoSqbCt9AsNeb8Dwi2V+4CoXTkBMZARvbGDOcyRRz8OTw6F4w3qqdnsSD0BYuhYrm3ZOGbPxsEHk4AiDr5MxmN77OPxd5blDoeDfvgkxgliNyMMXiL6sq9QtuI1rbQGR6AoJOIISO4H8olEHa+Hdq0ZKS5BJBnAgOgF0212kG/E2Oz3B9ORa7lj2x/L0U/GSsI0mfh8D3zQeO8sZ0oU+sI+INkHCecLUx+lpXGTMUo1dGDmhCTKEWgpiOIgCDkAYlxrpaSsYw84MEjBRssme9U0GeGQAoXjugE1tifhF8+yFQhNoS02KT3PDXzLGo2GA5DgB5jSq8+azZAFMGru72QvjVKmpq0JyKwj0BKQp+pPCc+fhxxsWdeGno0yDgxaIdMCLySM6AJj6rgUDhfJ9nikgRu4nut6fgTi4TZrLMRA9QHJBvfXrDBWJguMLGGBcYFDX5iVVSNW0moaVo5zjlCLQZ4KyHOCoDSZkGsjlTuiHQdHauXR6gDDxAEM+nBj6Lo2DpEHx5oCje35gAGSMgT3jz28j32PpAHT4uNprjscmP3uQFpFWGAhCleYjMpxziiVLjOa1NZdR5aDkENAQJIxMtp1LPW/Rwf7SAYxZPJh4IUFDoy3X1qu70cvt7QouTWBxpEmoXyJP1LCf8gHffjiDPqDC4m+qUhOSLJHkBhAaoaALHXkzmIx2l6EwmGYuc6U1rVU4xtGXLnRuer0Oai7fRONajzBm08FoMD7EqmsCC85Jv7YFlcYe+hKck8WeHLyKrV+bVxnIIBwBRzt1N1qCQh2Xrjp8EJAtJKuxRtRpyII1yAmf7HZ5+DzbH/i4/jvpyAKvbrtoZvBFMS+b3Z7QtJpiSuHx+iQWyn92lj/5yBPQ0eiBTyebVwacCSxM+tHGI4+0jFAxtGYeCzj+4JEen8Hys+2WF+MGyosJGlxrNCTs/9P6OvGuiEg2BZaDiIcavkegcgJlWaUUter+4LRAgYpwNAFBjlQHpMAnz4QxONs8RF7d+SApAcYoHSIIquwHYDEYjEtIpHzxAUgwJgD4TAEhxbTrlO6XmHKiWGSo08NhlMXIQ8Y6cD3PtARxmrCBuCOLXc6gPpEuWBSBOWb1ZJOEE0DyPsOPAeiOJSeEESdGWoEicX19MabkAOdSuyAMMYxGOwwtcD5UEf4HVAYHpgyvSVRvbj5TVlXICRhrSwAEQ4l4BJEGWLEtPWknt6+ajYjjn7E4XB0jDH++IbvPgjEp/B8z8MDnu2RRKFw3LebzW8rqbR+B+TJvUAgGiIgmp4JQUyAKA6CDDGViUGGIADLB4EIC0Z9dAeWzAMqAjHbGPXfbqRWAGL8E5BwrfgEi5NPySFnVOsxfSWV2ANGx1ThwErd9u/o9rgWCw3hr++efb7lCImEHgv85k7qu3QpRJG4y/UpT2Z7112Qp3MghrGu69+nVr+BHaYpHL2w694fZDmHulc55XLOg4QsJnTW2k+trJT00n+BPJkDWeoIoh4DyA/x3IkJMeX9Hv1w7eBfcmQexOZEGYYgWBW321f7ie/jpTTzThCZJfd0RNbvNCQW09PpH5Ivzy7MKObkQNcd/9uOqOfbYfPqDweKxDxZXUmm0uslpmRN/laCWfK3jiBLAlKjIeRIFRLVdv+iKymnHxaa1L/tyFhpIp5Q/W4fuy7N8g/xuK7rYW1lnoklf++IAqm9oCG6no7HC9k6KARjKH6Mg4fKSDCBJ2HixZOuaVYKCUx3xD1ay8s28N87AoWG1GiIHr9JFlYbvT5QiMHxMUarfJCMqFNIH55MI5Ru/6JaTCRW0nq0TIElPMT7OCKVhdJiZd38UMjmAILFFQ2ZvoMfNobXg2WEnmAJN5xKceEl3C4msis64i6jZAGIghA/oM9kzwGGSGUlsvnVNtqh5NxVv9V/GCksP/QEOwE45drL/lCIR+Nd4g4MBaI0D/I/nwkIDCFIMrH6Y9mU8E2njgUI6CFB+EaQKCeD7jerhUIirstMfJEJQWQXeAmILLOgqGfFk9l8/tUF/UBAXMsbPxJIwMXwdDjoDQYnuXwxESeJJpY8w9827wmyFm6eIOorydVyvt6fhhwOt94eGERpzMDjl0LtSj6P67JTUW2RJNpyXF5aar0YJgQt62V+ByA9Niz68VggQQAS9slB+xWuQUzSEtYWSHgtGlCWgzyHI1hlyRDBlfDFXCX3zSD8iS46ymOCeCguetKtl3HVqVjCU15e+MSUgGRZaX3+7HZ1koIh+dxm7qfplIXleY8HIht5znA4nE579Uo+lyWIfguizq+WOPI5HBGQdIpRz1Ur3wKEE50/+9FAPDvwsD9MkMZmuZwtxOMKhFcLPZHimgNRU/0ZLnWQqMc4Q4rFXK5aP3PQeB0v3LZVM+yh5QbYBPccxGQ6/eb165doXDfptMQ9XDcChJNkOYgs4EOQSuXnRvvtlEnnjrr7SBy+h01JThPW1sl7kGsjBHkmIE+XgIAjAknHbxLF/Obr7Z2uAw53HED2Yzlij+mIZTkAOd0gSPEmnl6PhSCw5D4gEhEdIMV8eXNje6/rOI7ledwrsR/LEZsxHAPEGTqt3Y2X5dASDsVMaEmU9iUgatNBT8OQXPll9ZfDHnfiPBXwxyHxZDPcC0ZTp1vfeFUuRyDqjFe1rUUgn4IDIKEh2WK5slndOh06rhV4sp/2WI4EtyBYdO1sVCvlfBa1dQsiJPcDQUIqr6u79bbjBBYSInvQj0USbd4F1tSZ7v1SrVTyxZubCCRzDxAkRKKevimgsja3ATISkHA78dE4kHaA2BOkZPrNL9XXFQmJ2hZCCBj3WRA0Y9zxCffgpWmFQwQgRVbWdn3fxCS0lw/CD8dbfq5FV9C4mlsb1U3E/YcVWpKp1VRI5H/3UQqEJBFITRbwK2HPqgJkYPGM8LFA1E9SIB5B6lUFgpmYwWn42jzInCPqTKRQ/LWyAZDjgeUF3sdxBPJsxzEb29XNSq5YuFnhcK9J2hc58mS2srDpUMiXK9XqbuPUAUgw/kiOAMRyuju72+hbxUKSfUvTsMUjaZ8HoaLKmpmGAKk3WiMYEnw8R7zf3AFApLa4TNE4E59By0DkHDcCqTAiDdP6fYK2+7EcCWzPGu40drc30bcKBGFtrakG/JcgyhCDYz1ZLJdhyPlO15pM7I/myO8A8YbfAGSDtXUTV9tCBIHmQVRlRSe5STbf6vbWzk733R+TP9G2Po4jXvD7xB4e1CUkBNGjP5XcAZFrTyCAPMc11+i+KiI0pH6+Pwq837zJXUeCULwoAOsI13N9vMknka++kws3bu9273yHHyg3qfmHPW/yh+XZx+f1+jZDUggniSYXZ/NCYK6AwbIYpMApgoScH3wReN4CEAgguEWQRSLTYi17HjBc748JQJrnjfov1WgFPAvy5K9AUFtr2GFUUwRZr+Pq97a1BATb8iGIOtav595mxJsLHhu5I9wB3XmQv5kgJkCq1ddMu2wCL3ZEbfoKSPyGIFU60uM49P5Dy9n+tJHccfxV28sd6K7imhKph4QikAlIPQx+zct7EVWsN1eDD6LLRcqF9drFBtvguAVj7w7rDcXGrh+CHXCJk8AlpL32H+x3Hna1GWyHRrrvrFHOc072w2d+O7MPsBrufy9QYPA9kYMd7NdFE5T61j1/ZiRYHunhe38CSGAG17d4tQNkmNXIAJA/iCU8an0aJTI3H1ejAOl3U/O7sOBge4EknJZIrLM4+yf6nG63j/e7cfoYEu6AY3mkhldx/PX7Z6ZZtfOTK3e1JYOIWQSPqrESeXR7LDKFaX3hh6C6SsdWTxAkzDgERGLj/bg06LvaifTpRGgfJQmurIBF+WEBIKh2dymPdWMfEH6Wy4++uJmAWqcg849Dy7GwvnKvnxH1W8YBEOzLppSNTewR2+MN2in3Op3eTyY9nVxKGENi6fG8APkUIPcBMjwYRCxQBAhKZP4hQFZplfQxglHMhIi9SSaTKfbCV2eHELcPjW9XOlOs8QCHdjInKyqGVuihF4ROiV/JIOKQhUUj/xmkL4e/vDmEg9bY7+/MaHML/vQylghAofkO48jBcIDAsUjH1dZ25smTDGtZ/MlN5q8bCN6Vksnif81sbyU2E3/LIM679Att2/j7dvD34tukRP+i7vrn/TO02h85c/tXv8N33lmieEF+5YCMMhBc853U/PPzOTVKQXRaJ+AIyyDfcZDEXr5gmGTfKhaLhaIn9tOdg4Odp6QoUhCNFAt/twr5w4NUartEykdFKZVq+R97G4naA4CEY2p6YT6gURBW7aMUBCQDQHCeC5DPnKPvAkBWHSMIQKQshwGC+tipN2zbbtqWRdiG/yBodqO+8yyVetogtmhOLNuySX3n4DC1XS1Wi57P0U9axf1iFSBxHKCVlZiaw2GLrbY+aITVCEC4EYCw09y5H3L3YmGVLhNoVkAi4h1aAuSo3CN2JpVK7WR7dB5hq+/ByLFpm5bnXRYQm3u0TJZVZWVVD8FIQKy2BhvhxQ4QxwhAAn7/41B0VddXowDhJBJIOExLHYW+ly8etUjVKkgp1ncOU4f1YqH5fqu0G0ajmH9+cLLzpNBo2gUR0W2RMjGONzdO1x8sK/pqOPTY7w/w9W9/IxIILvoOOSBzDERdierhaLh38DwihGzu5NmIsImUYv3w5BAgRI5lm4Tk905ODp8UG0dXPlfpNKsA2VhfhJLVaOgxpvapO9PXNwIQPrSmmZGtJQoSjaoAkaTwLDOQzc29fxY7Z0cdu9Ns8o3nyK4fguRpoynlqFhoHRVePD88SWVMUib4iOF+DiEdu7q3iaEFI6oeCz30c5BrGhmeFUYEyNzDUAwg3agadUhWopKQ5QcMJN84suwOsSq82cTiBQ0jJ8/r0MXeoNLYq/yStOzGC2ok07Y6lhNCW8Wu4LP7x8nN03VMJEr33tIWQO5cz4hz3ZetUDC0fGsw8mpJx7Cir6hoUr5VF4MMxMTuWwCR0sg+pyAFS0qToE7sPDoPsx2bNOV+uwmQTYA8WMQ3UV965Z/TZsRRa4JPiHzVyCKDoJevGWEk4tP+SEHAgNYfZJmBHOyVAUJ6gNQZSKMHCDbWmekJgqF1fLCZiAeDalR3QCL8HPGaIL9hIGO+NY0Z4QED36RGjQQ/ykijQxrl435GSNNuMyPBRVWPUhC/xo9aQ9cGuUnXWjAySUG6DgiF0HuQLCtiaH2sEYD0M5LkRgDCjfj+PxDcBWWLxklhRJDQJsx4NxiJY2h9XI2Q7QFG9q8Y8UXola2b1wIZpiBi9asFPENLNMeM8zWsCiPlX8AIrxEdcUG+p0ZGPwgyDJBRCoIaGZuSjfRq1EgucfpRRiy7PMhIlRtxQALiWuNn4qR9sBEOgiUKP7G6akRuYfUXrZHaelBRu8KIOEPkIMN9QNi5LkCcC6Y3IhFfQMPMHtOVboyRdPFyAZyoAIknXh/s5ZkR2xIxEDoxCpCCIeIBMTCPwMjJk7ZdsZqiOSEdwo5a8aCiqLEo1lrams8XucGu/o66RmBABnFmRA/ImoZFYyzKQRwAOeBYP+VGbM/QEjtdKfQFsZropEOLgRQsvlVEI7xGaLFzkAAHoUY+DCKGFr3LM85AAgDpMpCuUCJnGSCuERkE71gySJNtBjVCGvnzk3NuRA6MdBwjeqzLQcZgZOg9kM8HGOH33W6MjVGQhVDXMSJH5ZsSzMFIkoMMMCIFRjrcyHMvSFMIsSxhpPYAIFGcjzCQsRt0zShAwAGQQUZw2OLVDpBatKt3oz04FL4JEBg5q1imF6RlmJbJjJwDpGXw5sYslEiB1Uh2kJH1xUVF76oAYbV+e2RIgIhaH2CETSQjHEQL1LpdjCvZBEQ4JEounoYRCmIAxHBAQGJVzApAMHzqliGBdBwj514j3mIXRhZVFQettAAZ/wQg7J4VSPqDuM8ywsj4WOSOFgjs0sroqlGPCZWyAERswXh64zUHMarE8oJACamDgw4tSUkHRixq5BxGSH8jAMHQCqW1NQ2LeH41HiDcyK8HGRlmDwaNPLpxGyCatqvH9G5X9fhQGYvioCzm4gk6tF4wI3QwnVnmmdXiIK6RqyAoqHaeGQGIeQWEzyMUBGcSSloLaL4IhtYQA/mGno5IIAhl4Zd+kVn3HNFHx9ZWqNvFlKRQCBcAUfkLicd3T+lRCyBWlRjeUJjsxfn5RdYSBC5IybBIu/00A8psuV0hhhSrwodWIqjcXYqFtjRtasqH6XBk4iZ/Zku6GeoBQSiIuGPlVPtPAOEUaK4HvDgGjAAERtwakVKog+MiW+QILRek1amQs2p5++LkIlt5UySVlgRSst+yGgkG8e+GfgKIj56N8FrHzdABIL91imSULeR5tS/k6KGJQngxvImv754mk46R1vsx2tmLi4vtepEjeHrOTGKVAALKyn7HNKScVQgv9jhA1NwCB/n++iDiwQeA0Gqf1NbSIU7AKWQOaiRdc0BMCQTp1C+QeodCeTnMM4OYnXqGgjTbbbMlgaCCYCR5WruLGTGUXtPWpiJjAJmYQIn0A6Hl4v4AzKw7t9+OTE+trb0KMQ0UQ6YQJZKGkWd9QIwK3dcMQKSY7beEtMpZ2lk2jbJL0OLNMsgbtkRJ53Ql9Aoc03RkjeCEnV166GuE/0jSV+K2Lg5b9OZbZPJyciundBVZhgzCjbR6GHlXz9axvbwC8rZTMd/ms7SbmBXikot21iH/On6GoZWOq0ptS1ubno6Mj4+MTFCQWYAMMAIQZ2zdnPhkhM4kkcvJhZruGLmaHLb19Ckz0uo5tKxy3szny235fVKtls22USckn7femeUeIG/o0ErXKMjCzCVG1vgjBnIfQgYboSBQgqE1gbn9U4BMX05e7gojfTiokdfUyMvKWQ+Ql+Xy/n7p6I15FSRvtjtlo9T5d+Hdz6UrICVSpSDrtbu6snupTU67IKM9QT7Hb8LFk0HiiYFbX1CQ2fv3JyZGHo3/GIlMa19vhfQ/98FAQ61TIwfH+Zdl06yaMsjbUunnEl6t68StEbaq/M92Mnm6W7ur1ra+9v/368iPbGTd/+ZL9rzWLXpSRUHEL6WjNFDCQW59cQs/yjP7P1buwDOSM4zj+HEKaBIWDKQyFVSKN39BAIvB3UGBgJkd7YGcxiQCM4nuibqYuHYwt2WPSIa97GZ33+xmZrKTaZre/9Xf8847k/cmbW3aeyarVhfvx/d5s4dzzSZBGvbXy2ztW94L/vZqFA9B8DWC1RqeHo/al536jPzi6cwrKYu8PTwnCL7anwc9/gN/+XKlZa0S5EtAlnBUHPmfIFREX2+iCCQW/QJm3/O+8xBhFAz6KYqE7w6OjtuDh0WkQykyJ8k/vCTIxNl64fan36yxZbtFQTYRZF1fQpECIiUVBJm0BU3TdJEEEBNJVhhb43znO09Zp2dQVAzckLLIFYp8TsjbwwtAIqxWsMOnjDEEEZvVFBAcVdwQjPqXM/EWkC/wP3WdIEJitexlxjnfwC8OdZ1kCdxzPAISocjVhd8BZPTIqVZw9LDIHiCvAifY4JwhiNUwzU0JwWbhuPRnxhgSBRIvFEWWdEgEJDEbkNgMyxXRcj0TBOQwPMMTFAMaOO6LDAa/DOYFnMupIHWJ/1oWcSME4bbdapkyCM6o6TgrIDh4rEJiuMDA4EMpJMnmpmlalm3ba31G192gH1omg14oIQdBZJGjE0A6/xlSk7T9w+vdcDvqurjq0zUbQVAkSSQEDvxoiwsEWVQgi1qslZB1vYlJcEskhAfGJ0tFRfAST1kElx2r9aE64f+FoMiYVqs7CWbZ9CscpNEwV8Vm6ZBo9JBEW5QQ/Mvw8WIcxzcxTQ4IkjTTtJkklMTCbvW5SOLg2M8NQ24UxjOcLTzuJIoIMvj1on1JgOEI48sZyfFrA4MyPn2i4yvQsf/zyV4YRq+iXjblywxBTATZTNP1NKUimFjDJtHzNH76pHBgNNJouYQkgKzK3ZryDRdffZ63JS4IAAJhOFA4YrW2C8jRgQ8IJPND1HLiw+dlseP2UBQBhPOVzCIIguBsOo1wVBKC4D+lI6bVqpKgiJDQL66dADfEo1sOCV6UAo8Yt3sWhQXktVJkPBrTqw65kFODlIDq/Xu//fvudhhFvRnnzEIQUSQhSCocBaWcJ4UDMTDaTX5TJEnTBFMkYSzj/cgzQCABxikNEhL9CMiJKHJRFiGH+nos5Ce/PSZISJuFvRAOBElFkFzL4cCB7yGF4wZbRQ8+kOs5zAVFJMlsNuv3AgdJHM+RG6U4APmXIuVrDshQhfh++2oPkH1cddvObuEwRQ8cDkeEIxcSrYIUPahInlMRDDlUiM35zA28LcH4dCau60Zn5R1pX47mLVJOBZG+8v3A7/zxbjsMZ1mGA9w1yAEIBgw46Kw0sQqhd7RZJKEmGEViZYxNsx6Wy6vFmDgugoivEQE5PbgvMq5NCSnf1yFjIICp7tSBf3q99ybc/5Mgd3eNWxFETI75qOWoUYeQAiOcJUOF2PaMZVFANV6oS4VnIjYLRZTVIsnjIUOCjIcV5P1v17tv9mczJLm7s1oyiHTgnHShVUiBkJKPeTUCAsmtdWtjRzPWi1zPcFxpQI5JF4juWXcShbLIh8FfrNmBTiJHHMdxH8nnaB9D4gucyW25RcumLUnIwaWHm4I2xmwqemPclVtCBCjuzrq7gMAJ5ezd0/T3/y+jW03jNfAfIIbjkvn4nSFJdC/csmvz8z/m6b8rEMsImhzD898sYWmnuVxX9uR2xtvyHhwsoWGJmg31w82fN5RDMdTZ8iCRgGz2uh/2977/UUHI0GzW60fUA3e9VOs4FWHYL0Ls5QeeQViiIBhLHGTzuaAXUBAvc7UVLiEpxw1WGqIkj0UidbbCLUhA6X3c7L7eTx2qPRhO6vVXJ+hxAoi2YhF12pTk0iiU9ZzehWNb4tcZcpF0EOz2OeSG3iKHKhL324N2O7wKucm2xNnqfqzvf0eXvUk3AzmqiEGnCq/5kjakIu6l+z+nkRoGKYhVcPRagCJS4nijR9imiVMOLtJPQ/AGD1HwiFAEECxAQs/ztpGkh8NVb6IGGEcYpKie7Gq1XVCqpZLWIojfWAGC4TJJFEOMdD0XwCGxg5Ag2BGCRAmDFoYbJBBGMKWfLJL045j+XxiSw5MZSZDeh/0jOlV0MdBhZ2dXuy3Wdqv501IpiyK+4borQdQAcmCJll4bBzJYOgbsGERRHyt6gHAXgqSDLC300bgPCIoklIyUvQwk3Xp9jx2UY2c3rw0nk6J2Wj3FHwK5yGTVIvTCUQ6sgtD1gIqQIxxcYTtxO8bGIsKQIj0bUGA9QhiMHpQElBCSKz5cvW1INpcQuh3VvHY7+aXQMbVTjNZpochqkFQSQA6dMSRyKqcECdEDjCjuJ0nSCCJspAx44gNYRI4xA5oQA4lEFG7SbOJQvSZHdlgQxrvyxCwCUjR9gaM1clcc9a12bolDgkDCQWhiJInUYLP/KpLOESWLJ24nkPYTSL5eb+LrlhxmRYwcp1GxzOzZWbH4fi0Qeyl5a70tfwJkekeQQUiOQYwkysFLFSGImpSlz5JowBJ14TNM6fby1VcEyZ8NJ8IwRqOOXbGOi8U3li2uXddfUxH30BI/jfVxENx5UxUkHvRj5XhCASRlmEW0eNihIEyRBCFKnhj5H8xbHKyf/ULLaIjJsWmarri+dhvuegZFxOUnQKZTOFQPVURRZljPIXhXORgSA8KUcB5600QSBN1cUKtWS1nDFwhi2OLCcDoFwzSPbR9F1gb5I7kjd3fT6V9z7sEMBWHJLHoGiZhBT8VYEIQlc1CmoEhPBjLA1Gq/Z4cd/8IwLgy7Vf611bouG8ethu2/DPlmqWOJxmd9TJB5OLhXQRiiZkaUSEEoRYQXnuhBslgsYqbcgwKJhyXZodf0N2ZBOA2DboRhvx/hdFX+dp2GX3GNb9/3i5DzMUEQZH7/GGSBRQIl4QgM4R9VEnZQjQiOlCQMiZI49C+fhwWfboaYuK13nY4oG63OxHUchjTWVWSEIl8Ygt/k15hnQRI8ZukilEEVoQfWYjZDCSASxlese5LM5//wXj+/iRtxFMDzf3dPe+kBVT004lzkIyutFFni4ItlccgWpZhtbPBPTBiDvSQ4u+ne+96XgaksaNMf3jeWo0QofD9+M0uWx2Q6G88A8XvWtY14Hm6u7fILuvF44aZXO7bOpZ+34/Gf3zs0ktyjkLnMQkiAfJQl24ciAADhyeAFHxR0MKc+YjrmhEyZ8Zvxm17fcVtP2AxoJP8ScnOCTGz/LkqTJAMEkxgHdxcdATcQlhCuhKNPB17xZ0kc4zF8iNkIMk2ms9nszv+ub/FUt+P9TVyd1zcyeedHd4Dcz+dzjnKbC0RiKuFFwJUohAWlYdAR3MZiwS+C47dkOh4vo3BgXf/guZbdivu/QNqNLNNZktHBUfLbPDDREp53aYQMoQjSJM+DPM5joQACyn0yS6Pw7VuZqutGbjxriEaitBAIE8QYKThDaTUiDEMRx600IpV8uJ8ms5Xf+9n2Jk53W8s0ws+RaJkmRXZw5DEZLQkdDA87I4fHIEwjUolA5kmCRvzee9sdua4ZwL2QCw63/YO/aOS9Hz2kxTpTlORYHCo2CrkdQwglupHSQJhYICJZb2JAtv5oZOF8LP4RpC25DGk1Qkhygkj0eeeo5yFlGeDSC20wVRXjIkTNs2ydJGkaPfR+/H44sSyWcvlJt783eSXcnlhDWxopMqU4Rl5pSc4JyZCvGN1A+J1BcEmqXBwiIWRdABKFfQd/lNy4lHQEYfAnineEzCmpKKk5m4xID9dHLNOIcQTGgUIksYqVylSWZQUln8K+ZY+Gh7d2u2zE49barR9RScUIJeCSTaMhdBBCUUmHxDAMpFKKFEBQCSR+2P/l3dAxkP+cC40QsiqKR9lamlLrQsDRM3N+aK4oktOhT0hd5nULQgbCzbXbYXP5fn8xlPd2O4XYvv+02u0BUZU6VqIjEh2RXOFGg2lDHAaC36EjlaCTJTu5HrlM941gaymEgxgJHzbvRoJGhGEOeV3XOa+8yZumaqpn9axUw1sm532XbiNK3O4hdvj0tCqkEY7AcZo6l1UePKYTNIKbcQBSyisrOCoN0YsQVrLcLqMwdBbfABLprYVUkADCSg4YU0lAiRx2HRjYBm4NIBLVPDN0bNRm80gJKNhdfu96KJ8nOotXpv36y7BfrdBfbj/vNxu8fXNMVVdVfeqlPOWqNKnzsq4IQRu5dpwgdBDCTraUhIPFEP8xXHQEsReeFX4h5IVvz1GUQGREsZRGwjOiC6mPhRiH4iUM0wglu9UWkC/hwBo5TleNuI6jIXiACjNwGImuRFNajWiHBC9tkGcYyNDZMI8v6xdAdqvVcumHYX/w09DpCiKNPPyORrC3NpiA8zSmFKYNOSH4Eu0wCmEQgrxAUuwBWW1xTEJ+nnQEsTx7IWfkMyBwIIIRiaHU5yFo7WvztTlAzjk2aGS/RycpTjwkA6urRmzXRiOftjtClBnl1ElzFiKRRv6oxY591EaiMIDn/6+j7VFKuhMShRuLMpEsKsQ1h6DIakfBWZux7bE95r5vnp/jdbjTaiHfw5yuiJgf3zwUpWAfxetNCBv5cbmkaQrJ0XBPnv5YI3H8GY3YLEtL3q0JhBIwfs4h6tD1kE5mDpFcmPQHO8mOB3vGnkTR+s80so7ZCCG8WuUc8rMa9+RFIC8TBxkFIQUgxWvJCfleXsakIdh4eziwk8/L6NtqjSNt4n0U7R+UZL1MdmfzXGPbf+DzeRQ6AqbAIC8cCSDqqDBiCBP4dHyXuQE52jM7WXxdfotWgGAeB4nWCSD58xEQfH4ZHHIqQkIKzMs/ZADCd4YMDLsYN0T7uHDmkiyDxBh0stg/EDBpZC+NuMulLGlRiTYinQwBZFJIgZv1ypc6JGSUjTJGSN3aw+nATqLV4yXrKNmdjK1rNEKJlMKT8Yg8KlK9jJBqvFpFRSgZuh/TOhoM49RByNHaw9/hdu0fnnXCRiwbYSUq+QXB8KsfG6lkKhRSgSGOSR0NusBrhLiUkzH18fnZ2i0lXx4PWSbbk2kJYSMXhVAiEAYWOT+vlkoKpmQbMmNEAgRHHGnmSGmPBpIcv128W3H8OMdmhatlurZ2rtFGgsRjwvct4fH50kYKgbAPr+shCAwQMikcMmDggaSzB3NCJ4DEqwcW8vmvCI0AUjeA8BRKwRknkp8VK+GOUMF+CnHwYnnvfzE0+GY4NDjnBgYqaa01Z5PDwix2i3i9/rL68O5HcRztnnZMfrb2yC+sAYQjEg8LS2GqIvTAq8U3/C9tQyFFWZSl/80hkiZNHSRZHSD1seXCn8z5nO+QJ0gWa0D2H4fsN4uFOEzX9VmGb463gYxRwjOSQghCwicyCj5DI+TOHQJJiZFCMo400trWGmtMnudDJ/jhvKeRKAmOPDfYkBYQl4ZGtBIJIRJCtBFetBDBwuF/cyCwOErQBMbxvWWstZ1BhLLg9fg4JEkCBAxjbQsJP5eNUDKDSIZG6CmGsDH/CodKRoZMCBxEUNNmvUgYSrAo8ksc39nINj9YOHrH8EZLphDPUQkgM4cgPJ5pHXyUQUdd1xkHiFol3PkA+fot2n/5GIRJogCho3WS0TGR8LBIoEwhVQD60eH1Yl0bd22uTkNGn/U9JTUUAjly5a1UslglUMQfhsSAbLfmRAg+5b8kHin8DMIIhJIAaXwjoYJ1iKUHw/UiEQgecQiE/zC8vOcvXuvNio2YrutafNBYyVzimRmk0j4GRKkIhgpNjfSS9k0shpI857LDcWtHIuS9jeSmsy0Y9QC5NpN4TolBZpDRIW28jRjCUytlxqADQSOyI/dANtyR3NgOKzIUclWIBmeU4xacCYQKZl7IlYWMEAAIueWwbaeNPOEodzdicsub5TS43ohyPF5aiK8oEQgZA4WlqYHjruqoxYG0bxwdBg4LiPmfRhg63tsIrxYkarlyJsV4jgSSqggQT4lmlPCPMS6E+y0BZBJLBh0CkR252Uik/3kPZJvnYdkzgVzHKIWdKINPAUhRTRiIp0IcjkPGmHaajmM7tsEYa/IdIIvlTUgk7+9rxBjTDY30InEchdDBUQra+MRmZnUIROKYiaPGTO4UJmAmjTwlmzshbGT4+VUKFdoJx19pmZRSfJo4AhRk1qEMvno3OvAiZqwDDoSMDg42wh15QCN5ZwCRXPuhkRGCl+dogPgXSbNvHE6V3kUAAAAASUVORK5CYII="
					alt="" />

					<h2>NICE GAME</h2>

					<p class="txt">
						<span>First game?</span><br />
						<span>Compete online</span><br />
						<span>Many skins available</span>
					</p>

					<span class="button retry">RETRY</span>
					<p class="or">Or</p>
					<span class="button download">DOWNLOAD</span>
				</div>
			</div>

			<canvas id="canvas"></canvas>
		</div>

		<div class="obj-banner" onclick="_voodooExit()">
			<div>
				<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMgAAADICAMAAACahl6sAAADAFBMVEX86e375un74+f65Of/3uj63eL93+b7y9P7vcr8tsf4uMj9wM/6wsz71Nz63+X64eb62+H93eP6ssT0vsj60Nn92uH7xdH7rsL8ztjz3uP92+X6qb7819/62N72rbr0pbn7orr2tsHw2t75sr76mrP0xs/1na3/x9f5qLX4oa76pLT0pLL5m636kq38jqz1larpqrT11dv7kqP6iqX6g5/1lKL3fJn6fJv6eJf3dZb6dpj6c5T2c5L5b4/3a4zsjpz6a4z5aIj0aIb3Zoj2YYP5bZD6Y4Xy0df6Zoj0X33sWHflT2b5XX/4VnjzUHDnRGToRFfgQGDsOljyM1f3Nl30RmnYOU/oM03wOmP1OFr3N2D5OV77NVzyzNT5TnH6u8XiQW70e5Loa4HnxMzovMX1ucPms7zldojzm6b5m6b0qrX0O1L4OFP9M1T2L1PVR3fdS2LMTH7EUIe2WY6pY5GgYavXUmXVc4N4lMttmeRwodtop+yPsNWkl8KocK/MVmraSlqYibU2qPoknfwpofouov4ym/4aq/kqnv0en/0ul/5Wrd+cXpUnqv6LdbIrpvYxnvAqnO4tnvUiqfUpquzIS2FPrfAll/0mnvWYbpOKk8Yso/sipP2DfsF0drjFV3Uko/M+tPUoof4zqu/2N0wop//VZ3m3X3Vwhb1fiszPh5EirvwqpvnonKYupv4qqfktqv4spvosqvnkpK4sq/fVV3Xkn68vr/704+bmzNPn1dwssfnMnazWqrjv4uno3eQsrvnYw8wqrfnRuMWzs8rn4+jZzNTe4ObY2+PZ1dw4teYorv4swuORu+Qnse/FyNaDx+q3xdjd5OrM0tzLzt/X4ehvxvLM1uAssPiRwuHO2+W6zeCnyuLB1uPO4OeWyuiz0uSj0uWSzfC61eTF2+jT5Ou92+efz+3L3unM4+yN0e2s0ua92OmKzPCy1+rH4OnC3uqr1+qEz++32uma1OvD4+y73+vF5e+m2emt2+yz3uyi1+yZ1u+74u2m2eyt3u9ZT0a8AAAtrUlEQVR4AayWCXeiTBOFRwm4ZIAm7gjqzJd9wez78v//1Xf7Uk2a6XA0Oe9TjZ6eDFKPt1R+NdAqaePwWm2w47eDTlfodXs/pi/VSLcn19j9HQZRFMdtDVsBbA61JS0jwgeKqDjp9LvdPuhZ7GHZJTTu5ck5z1btd/sQ6XcHwx0tEtdFWt8SoQrPbmuRON5R0WhMiz5baGIi9WMoxav0B9NkFjiRfE9EQwcSUyTc1a+/13c7t0po2jeXDSSo00lnQRCYSOoqG1xKV1rYHkESqXTYlWGpdf9fI6n0KTLykwDAxA5lO5HWp4jxiAItoqZ90fhW93NZDfsmFeY+zvwkSpiJHcrm4aIpD68SiZGHn0a+yjt6AKyG2A/qy7WBxtPMHDLs3xBJtEhQReJ5pcgmWhUUoUeEPFJfpWO+/gK9SycLPGzLci6spJqZLODyRwsNQpVChJFsLdIqq+IXXWKYRJHvp393st3/zc1suG1Kf8vVigceWHNusebl3mhUuyYxLTPpTSOllB9FcdujQUXzeLUcE/6ABCKitMjCpAFWtWJP27GsSlZF3WeBK+11lIjQZCsRxwPIZEFEqVkadjlK4lDB99xlX1bTPzQjPgs9ZAepFkk4WjT5cSIRRJJIQWQ07XGILA2HfdekqmodlscGLf2hWi3GKlcq9QOYMJOfJ0IPX4HsaA8Sx3UN0+oJH7E2YtzsDV/BzQVrkOY5IwmiSGfyg0Q8isQRv7KUymfhGAbzU3uO3OZ/jrwZn5zCZTlIsyxVKUVo4n07EZzilb+FfuqnmVLhro7irIrBcI4OzlGyu9g3xaWLy+ybOWGVAQnLfpZlI4qIyUaRliviiUiSqlRlftid769OT/WA77ucY4F9KbRMqMAHgTJcYmvAuTxRwFUgsv8nRCKjNIlkuNqOiCMjFvLEFNsx8DUqz/9mPThAwh6li3p9RYHCsvbAmNV01rbGPpNfLoZZlue5GlW/ipZGcyZ1kXYlorRIuMcLGNgCq9GAFgazR33N/hqFZeAX2+U0LEX8RpHmRDQU4W+IBJJfTRd6js9NFA3v/nVBboqbRvDH4sY1WsOlfJJoVpBZjpEIGPGLqxTxtk0EeOYuyxZZcpQ5A/90bzXvCtxKuRS6iGNlkll2SxHlJ1Ea8WcR0EOqMRGi04AJRBKZrDwbr+hhWRQoJsCWsGrdG25kVVvHp6IWE1M564VhKeJDhSKabRKhhySif0MUPEZ5Hoa7h/hQInmiu7++cYHCdrghMR0ioZA9iEDF3HJVIlslQhFOVholCh6jPIPI+gIepYgM0h1knAjI/WfdP2juzf7h4fahZvTlsOm49/WETUKJREQEmmxMBMpVIClFMoj01gVEOFHUsDOwNNAnuG9CtGBUz0c8rGxggTVnIq6Im0iVRM2EKlHka5T2GGZLHfnNGhJuCg8ovtv3qIeHR8PTJ48W+B+iyjNJLRR+5MoBm4ZXYZZdsZUgioNSow59GjwgYr57IYJ8h6viYo2vTVzD9YABJe4fUej/+enlVXh5Loubp6fnxyeU5l6sxaVmw3AYPkSyqyzMfaVFJBPP8ZCqi3i2CL+yMnhMV0VBEcEKgwo0YASvL6i3Fxyvb1jvZekdC3/V0MaM2lcuBbi+uDjCaGXh1UwpigTaxPOaE/lHgz+HDEQ8huP9m+KjuLUdxALN8G2mwqtulrzgeH9/f6sQJUG7cOAwZv/I2KkUvzFbEFFaxI/KSDzQmAixRGKKwGNUinSRxZofSkuClEH8n3gzfU/b6rb4p1vmDFiV1eJwwyU2mODrB/A8MjiyIQythBoNGHee2///47uWto7Dawp189TO8ggEWz/WXnsfHSvHVHTAzTO8t87arXa73YnUvsAN3n/2Bjp9E8LAHAmNQpmfNnGGhCAkUY5ACx1RUhgQOZQhWhJunM/mQqUaiTjGEcEBqEmGFtXptKimGanV7uA+3isCUuTM0dHBLM0dlGwpcwmQFzOW3MeRWztmQchhZBsE2W9E4QYHM3Ek9UQbWEc4wDYP17wwzSuTXy6uInUAc9G96HZwN2+TBYXXRCUyU4dHR4cEYmj2ZvOS1zOXtVkQHNhSR+Y5AIJniyGGkRcQ4SDKgXAAQyhYSh04caHU7fagt5F6b3u9blceAR+tAQkKjcYgWIcQuh1JZscLQLTL2prM9gUgc/mQkIsk6XyyllnTLjOxV+IFMegFJJmgmniF3zQB0cYrjqPs9wbD0RejLy3LhsZ8hyzoy9Gw1zc7iEuv22mFT2nidWifsM2pKlNdOdQr/f8M44UMRYAICXbb5hvXUhBIgyOXWmyLICree3jx3me7ZaJYQidQPv3BwBlZX72zXMvzQ43xDuE7FyhfAcYBDJ5Af9rN1pV51QoTdhKyHCoSqbCt9AsNeb8Dwi2V+4CoXTkBMZARvbGDOcyRRz8OTw6F4w3qqdnsSD0BYuhYrm3ZOGbPxsEHk4AiDr5MxmN77OPxd5blDoeDfvgkxgliNyMMXiL6sq9QtuI1rbQGR6AoJOIISO4H8olEHa+Hdq0ZKS5BJBnAgOgF0212kG/E2Oz3B9ORa7lj2x/L0U/GSsI0mfh8D3zQeO8sZ0oU+sI+INkHCecLUx+lpXGTMUo1dGDmhCTKEWgpiOIgCDkAYlxrpaSsYw84MEjBRssme9U0GeGQAoXjugE1tifhF8+yFQhNoS02KT3PDXzLGo2GA5DgB5jSq8+azZAFMGru72QvjVKmpq0JyKwj0BKQp+pPCc+fhxxsWdeGno0yDgxaIdMCLySM6AJj6rgUDhfJ9nikgRu4nut6fgTi4TZrLMRA9QHJBvfXrDBWJguMLGGBcYFDX5iVVSNW0moaVo5zjlCLQZ4KyHOCoDSZkGsjlTuiHQdHauXR6gDDxAEM+nBj6Lo2DpEHx5oCje35gAGSMgT3jz28j32PpAHT4uNprjscmP3uQFpFWGAhCleYjMpxziiVLjOa1NZdR5aDkENAQJIxMtp1LPW/Rwf7SAYxZPJh4IUFDoy3X1qu70cvt7QouTWBxpEmoXyJP1LCf8gHffjiDPqDC4m+qUhOSLJHkBhAaoaALHXkzmIx2l6EwmGYuc6U1rVU4xtGXLnRuer0Oai7fRONajzBm08FoMD7EqmsCC85Jv7YFlcYe+hKck8WeHLyKrV+bVxnIIBwBRzt1N1qCQh2Xrjp8EJAtJKuxRtRpyII1yAmf7HZ5+DzbH/i4/jvpyAKvbrtoZvBFMS+b3Z7QtJpiSuHx+iQWyn92lj/5yBPQ0eiBTyebVwacCSxM+tHGI4+0jFAxtGYeCzj+4JEen8Hys+2WF+MGyosJGlxrNCTs/9P6OvGuiEg2BZaDiIcavkegcgJlWaUUter+4LRAgYpwNAFBjlQHpMAnz4QxONs8RF7d+SApAcYoHSIIquwHYDEYjEtIpHzxAUgwJgD4TAEhxbTrlO6XmHKiWGSo08NhlMXIQ8Y6cD3PtARxmrCBuCOLXc6gPpEuWBSBOWb1ZJOEE0DyPsOPAeiOJSeEESdGWoEicX19MabkAOdSuyAMMYxGOwwtcD5UEf4HVAYHpgyvSVRvbj5TVlXICRhrSwAEQ4l4BJEGWLEtPWknt6+ajYjjn7E4XB0jDH++IbvPgjEp/B8z8MDnu2RRKFw3LebzW8rqbR+B+TJvUAgGiIgmp4JQUyAKA6CDDGViUGGIADLB4EIC0Z9dAeWzAMqAjHbGPXfbqRWAGL8E5BwrfgEi5NPySFnVOsxfSWV2ANGx1ThwErd9u/o9rgWCw3hr++efb7lCImEHgv85k7qu3QpRJG4y/UpT2Z7112Qp3MghrGu69+nVr+BHaYpHL2w694fZDmHulc55XLOg4QsJnTW2k+trJT00n+BPJkDWeoIoh4DyA/x3IkJMeX9Hv1w7eBfcmQexOZEGYYgWBW321f7ie/jpTTzThCZJfd0RNbvNCQW09PpH5Ivzy7MKObkQNcd/9uOqOfbYfPqDweKxDxZXUmm0uslpmRN/laCWfK3jiBLAlKjIeRIFRLVdv+iKymnHxaa1L/tyFhpIp5Q/W4fuy7N8g/xuK7rYW1lnoklf++IAqm9oCG6no7HC9k6KARjKH6Mg4fKSDCBJ2HixZOuaVYKCUx3xD1ay8s28N87AoWG1GiIHr9JFlYbvT5QiMHxMUarfJCMqFNIH55MI5Ru/6JaTCRW0nq0TIElPMT7OCKVhdJiZd38UMjmAILFFQ2ZvoMfNobXg2WEnmAJN5xKceEl3C4msis64i6jZAGIghA/oM9kzwGGSGUlsvnVNtqh5NxVv9V/GCksP/QEOwE45drL/lCIR+Nd4g4MBaI0D/I/nwkIDCFIMrH6Y9mU8E2njgUI6CFB+EaQKCeD7jerhUIirstMfJEJQWQXeAmILLOgqGfFk9l8/tUF/UBAXMsbPxJIwMXwdDjoDQYnuXwxESeJJpY8w9827wmyFm6eIOorydVyvt6fhhwOt94eGERpzMDjl0LtSj6P67JTUW2RJNpyXF5aar0YJgQt62V+ByA9Niz68VggQQAS9slB+xWuQUzSEtYWSHgtGlCWgzyHI1hlyRDBlfDFXCX3zSD8iS46ymOCeCguetKtl3HVqVjCU15e+MSUgGRZaX3+7HZ1koIh+dxm7qfplIXleY8HIht5znA4nE579Uo+lyWIfguizq+WOPI5HBGQdIpRz1Ur3wKEE50/+9FAPDvwsD9MkMZmuZwtxOMKhFcLPZHimgNRU/0ZLnWQqMc4Q4rFXK5aP3PQeB0v3LZVM+yh5QbYBPccxGQ6/eb165doXDfptMQ9XDcChJNkOYgs4EOQSuXnRvvtlEnnjrr7SBy+h01JThPW1sl7kGsjBHkmIE+XgIAjAknHbxLF/Obr7Z2uAw53HED2Yzlij+mIZTkAOd0gSPEmnl6PhSCw5D4gEhEdIMV8eXNje6/rOI7ledwrsR/LEZsxHAPEGTqt3Y2X5dASDsVMaEmU9iUgatNBT8OQXPll9ZfDHnfiPBXwxyHxZDPcC0ZTp1vfeFUuRyDqjFe1rUUgn4IDIKEh2WK5slndOh06rhV4sp/2WI4EtyBYdO1sVCvlfBa1dQsiJPcDQUIqr6u79bbjBBYSInvQj0USbd4F1tSZ7v1SrVTyxZubCCRzDxAkRKKevimgsja3ATISkHA78dE4kHaA2BOkZPrNL9XXFQmJ2hZCCBj3WRA0Y9zxCffgpWmFQwQgRVbWdn3fxCS0lw/CD8dbfq5FV9C4mlsb1U3E/YcVWpKp1VRI5H/3UQqEJBFITRbwK2HPqgJkYPGM8LFA1E9SIB5B6lUFgpmYwWn42jzInCPqTKRQ/LWyAZDjgeUF3sdxBPJsxzEb29XNSq5YuFnhcK9J2hc58mS2srDpUMiXK9XqbuPUAUgw/kiOAMRyuju72+hbxUKSfUvTsMUjaZ8HoaLKmpmGAKk3WiMYEnw8R7zf3AFApLa4TNE4E59By0DkHDcCqTAiDdP6fYK2+7EcCWzPGu40drc30bcKBGFtrakG/JcgyhCDYz1ZLJdhyPlO15pM7I/myO8A8YbfAGSDtXUTV9tCBIHmQVRlRSe5STbf6vbWzk733R+TP9G2Po4jXvD7xB4e1CUkBNGjP5XcAZFrTyCAPMc11+i+KiI0pH6+Pwq837zJXUeCULwoAOsI13N9vMknka++kws3bu9273yHHyg3qfmHPW/yh+XZx+f1+jZDUggniSYXZ/NCYK6AwbIYpMApgoScH3wReN4CEAgguEWQRSLTYi17HjBc748JQJrnjfov1WgFPAvy5K9AUFtr2GFUUwRZr+Pq97a1BATb8iGIOtav595mxJsLHhu5I9wB3XmQv5kgJkCq1ddMu2wCL3ZEbfoKSPyGIFU60uM49P5Dy9n+tJHccfxV28sd6K7imhKph4QikAlIPQx+zct7EVWsN1eDD6LLRcqF9drFBtvguAVj7w7rDcXGrh+CHXCJk8AlpL32H+x3Hna1GWyHRrrvrFHOc072w2d+O7MPsBrufy9QYPA9kYMd7NdFE5T61j1/ZiRYHunhe38CSGAG17d4tQNkmNXIAJA/iCU8an0aJTI3H1ejAOl3U/O7sOBge4EknJZIrLM4+yf6nG63j/e7cfoYEu6AY3mkhldx/PX7Z6ZZtfOTK3e1JYOIWQSPqrESeXR7LDKFaX3hh6C6SsdWTxAkzDgERGLj/bg06LvaifTpRGgfJQmurIBF+WEBIKh2dymPdWMfEH6Wy4++uJmAWqcg849Dy7GwvnKvnxH1W8YBEOzLppSNTewR2+MN2in3Op3eTyY9nVxKGENi6fG8APkUIPcBMjwYRCxQBAhKZP4hQFZplfQxglHMhIi9SSaTKfbCV2eHELcPjW9XOlOs8QCHdjInKyqGVuihF4ROiV/JIOKQhUUj/xmkL4e/vDmEg9bY7+/MaHML/vQylghAofkO48jBcIDAsUjH1dZ25smTDGtZ/MlN5q8bCN6Vksnif81sbyU2E3/LIM679Att2/j7dvD34tukRP+i7vrn/TO02h85c/tXv8N33lmieEF+5YCMMhBc853U/PPzOTVKQXRaJ+AIyyDfcZDEXr5gmGTfKhaLhaIn9tOdg4Odp6QoUhCNFAt/twr5w4NUartEykdFKZVq+R97G4naA4CEY2p6YT6gURBW7aMUBCQDQHCeC5DPnKPvAkBWHSMIQKQshwGC+tipN2zbbtqWRdiG/yBodqO+8yyVetogtmhOLNuySX3n4DC1XS1Wi57P0U9axf1iFSBxHKCVlZiaw2GLrbY+aITVCEC4EYCw09y5H3L3YmGVLhNoVkAi4h1aAuSo3CN2JpVK7WR7dB5hq+/ByLFpm5bnXRYQm3u0TJZVZWVVD8FIQKy2BhvhxQ4QxwhAAn7/41B0VddXowDhJBJIOExLHYW+ly8etUjVKkgp1ncOU4f1YqH5fqu0G0ajmH9+cLLzpNBo2gUR0W2RMjGONzdO1x8sK/pqOPTY7w/w9W9/IxIILvoOOSBzDERdierhaLh38DwihGzu5NmIsImUYv3w5BAgRI5lm4Tk905ODp8UG0dXPlfpNKsA2VhfhJLVaOgxpvapO9PXNwIQPrSmmZGtJQoSjaoAkaTwLDOQzc29fxY7Z0cdu9Ns8o3nyK4fguRpoynlqFhoHRVePD88SWVMUib4iOF+DiEdu7q3iaEFI6oeCz30c5BrGhmeFUYEyNzDUAwg3agadUhWopKQ5QcMJN84suwOsSq82cTiBQ0jJ8/r0MXeoNLYq/yStOzGC2ok07Y6lhNCW8Wu4LP7x8nN03VMJEr33tIWQO5cz4hz3ZetUDC0fGsw8mpJx7Cir6hoUr5VF4MMxMTuWwCR0sg+pyAFS0qToE7sPDoPsx2bNOV+uwmQTYA8WMQ3UV965Z/TZsRRa4JPiHzVyCKDoJevGWEk4tP+SEHAgNYfZJmBHOyVAUJ6gNQZSKMHCDbWmekJgqF1fLCZiAeDalR3QCL8HPGaIL9hIGO+NY0Z4QED36RGjQQ/ykijQxrl435GSNNuMyPBRVWPUhC/xo9aQ9cGuUnXWjAySUG6DgiF0HuQLCtiaH2sEYD0M5LkRgDCjfj+PxDcBWWLxklhRJDQJsx4NxiJY2h9XI2Q7QFG9q8Y8UXola2b1wIZpiBi9asFPENLNMeM8zWsCiPlX8AIrxEdcUG+p0ZGPwgyDJBRCoIaGZuSjfRq1EgucfpRRiy7PMhIlRtxQALiWuNn4qR9sBEOgiUKP7G6akRuYfUXrZHaelBRu8KIOEPkIMN9QNi5LkCcC6Y3IhFfQMPMHtOVboyRdPFyAZyoAIknXh/s5ZkR2xIxEDoxCpCCIeIBMTCPwMjJk7ZdsZqiOSEdwo5a8aCiqLEo1lrams8XucGu/o66RmBABnFmRA/ImoZFYyzKQRwAOeBYP+VGbM/QEjtdKfQFsZropEOLgRQsvlVEI7xGaLFzkAAHoUY+DCKGFr3LM85AAgDpMpCuUCJnGSCuERkE71gySJNtBjVCGvnzk3NuRA6MdBwjeqzLQcZgZOg9kM8HGOH33W6MjVGQhVDXMSJH5ZsSzMFIkoMMMCIFRjrcyHMvSFMIsSxhpPYAIFGcjzCQsRt0zShAwAGQQUZw2OLVDpBatKt3oz04FL4JEBg5q1imF6RlmJbJjJwDpGXw5sYslEiB1Uh2kJH1xUVF76oAYbV+e2RIgIhaH2CETSQjHEQL1LpdjCvZBEQ4JEounoYRCmIAxHBAQGJVzApAMHzqliGBdBwj514j3mIXRhZVFQettAAZ/wQg7J4VSPqDuM8ywsj4WOSOFgjs0sroqlGPCZWyAERswXh64zUHMarE8oJACamDgw4tSUkHRixq5BxGSH8jAMHQCqW1NQ2LeH41HiDcyK8HGRlmDwaNPLpxGyCatqvH9G5X9fhQGYvioCzm4gk6tF4wI3QwnVnmmdXiIK6RqyAoqHaeGQGIeQWEzyMUBGcSSloLaL4IhtYQA/mGno5IIAhl4Zd+kVn3HNFHx9ZWqNvFlKRQCBcAUfkLicd3T+lRCyBWlRjeUJjsxfn5RdYSBC5IybBIu/00A8psuV0hhhSrwodWIqjcXYqFtjRtasqH6XBk4iZ/Zku6GeoBQSiIuGPlVPtPAOEUaK4HvDgGjAAERtwakVKog+MiW+QILRek1amQs2p5++LkIlt5UySVlgRSst+yGgkG8e+GfgKIj56N8FrHzdABIL91imSULeR5tS/k6KGJQngxvImv754mk46R1vsx2tmLi4vtepEjeHrOTGKVAALKyn7HNKScVQgv9jhA1NwCB/n++iDiwQeA0Gqf1NbSIU7AKWQOaiRdc0BMCQTp1C+QeodCeTnMM4OYnXqGgjTbbbMlgaCCYCR5WruLGTGUXtPWpiJjAJmYQIn0A6Hl4v4AzKw7t9+OTE+trb0KMQ0UQ6YQJZKGkWd9QIwK3dcMQKSY7beEtMpZ2lk2jbJL0OLNMsgbtkRJ53Ql9Aoc03RkjeCEnV166GuE/0jSV+K2Lg5b9OZbZPJyciundBVZhgzCjbR6GHlXz9axvbwC8rZTMd/ms7SbmBXikot21iH/On6GoZWOq0ptS1ubno6Mj4+MTFCQWYAMMAIQZ2zdnPhkhM4kkcvJhZruGLmaHLb19Ckz0uo5tKxy3szny235fVKtls22USckn7femeUeIG/o0ErXKMjCzCVG1vgjBnIfQgYboSBQgqE1gbn9U4BMX05e7gojfTiokdfUyMvKWQ+Ql+Xy/n7p6I15FSRvtjtlo9T5d+Hdz6UrICVSpSDrtbu6snupTU67IKM9QT7Hb8LFk0HiiYFbX1CQ2fv3JyZGHo3/GIlMa19vhfQ/98FAQ61TIwfH+Zdl06yaMsjbUunnEl6t68StEbaq/M92Mnm6W7ur1ra+9v/368iPbGTd/+ZL9rzWLXpSRUHEL6WjNFDCQW59cQs/yjP7P1buwDOSM4zj+HEKaBIWDKQyFVSKN39BAIvB3UGBgJkd7YGcxiQCM4nuibqYuHYwt2WPSIa97GZ33+xmZrKTaZre/9Xf8847k/cmbW3aeyarVhfvx/d5s4dzzSZBGvbXy2ztW94L/vZqFA9B8DWC1RqeHo/al536jPzi6cwrKYu8PTwnCL7anwc9/gN/+XKlZa0S5EtAlnBUHPmfIFREX2+iCCQW/QJm3/O+8xBhFAz6KYqE7w6OjtuDh0WkQykyJ8k/vCTIxNl64fan36yxZbtFQTYRZF1fQpECIiUVBJm0BU3TdJEEEBNJVhhb43znO09Zp2dQVAzckLLIFYp8TsjbwwtAIqxWsMOnjDEEEZvVFBAcVdwQjPqXM/EWkC/wP3WdIEJitexlxjnfwC8OdZ1kCdxzPAISocjVhd8BZPTIqVZw9LDIHiCvAifY4JwhiNUwzU0JwWbhuPRnxhgSBRIvFEWWdEgEJDEbkNgMyxXRcj0TBOQwPMMTFAMaOO6LDAa/DOYFnMupIHWJ/1oWcSME4bbdapkyCM6o6TgrIDh4rEJiuMDA4EMpJMnmpmlalm3ba31G192gH1omg14oIQdBZJGjE0A6/xlSk7T9w+vdcDvqurjq0zUbQVAkSSQEDvxoiwsEWVQgi1qslZB1vYlJcEskhAfGJ0tFRfAST1kElx2r9aE64f+FoMiYVqs7CWbZ9CscpNEwV8Vm6ZBo9JBEW5QQ/Mvw8WIcxzcxTQ4IkjTTtJkklMTCbvW5SOLg2M8NQ24UxjOcLTzuJIoIMvj1on1JgOEI48sZyfFrA4MyPn2i4yvQsf/zyV4YRq+iXjblywxBTATZTNP1NKUimFjDJtHzNH76pHBgNNJouYQkgKzK3ZryDRdffZ63JS4IAAJhOFA4YrW2C8jRgQ8IJPND1HLiw+dlseP2UBQBhPOVzCIIguBsOo1wVBKC4D+lI6bVqpKgiJDQL66dADfEo1sOCV6UAo8Yt3sWhQXktVJkPBrTqw65kFODlIDq/Xu//fvudhhFvRnnzEIQUSQhSCocBaWcJ4UDMTDaTX5TJEnTBFMkYSzj/cgzQCABxikNEhL9CMiJKHJRFiGH+nos5Ce/PSZISJuFvRAOBElFkFzL4cCB7yGF4wZbRQ8+kOs5zAVFJMlsNuv3AgdJHM+RG6U4APmXIuVrDshQhfh++2oPkH1cddvObuEwRQ8cDkeEIxcSrYIUPahInlMRDDlUiM35zA28LcH4dCau60Zn5R1pX47mLVJOBZG+8v3A7/zxbjsMZ1mGA9w1yAEIBgw46Kw0sQqhd7RZJKEmGEViZYxNsx6Wy6vFmDgugoivEQE5PbgvMq5NCSnf1yFjIICp7tSBf3q99ybc/5Mgd3eNWxFETI75qOWoUYeQAiOcJUOF2PaMZVFANV6oS4VnIjYLRZTVIsnjIUOCjIcV5P1v17tv9mczJLm7s1oyiHTgnHShVUiBkJKPeTUCAsmtdWtjRzPWi1zPcFxpQI5JF4juWXcShbLIh8FfrNmBTiJHHMdxH8nnaB9D4gucyW25RcumLUnIwaWHm4I2xmwqemPclVtCBCjuzrq7gMAJ5ezd0/T3/y+jW03jNfAfIIbjkvn4nSFJdC/csmvz8z/m6b8rEMsImhzD898sYWmnuVxX9uR2xtvyHhwsoWGJmg31w82fN5RDMdTZ8iCRgGz2uh/2977/UUHI0GzW60fUA3e9VOs4FWHYL0Ls5QeeQViiIBhLHGTzuaAXUBAvc7UVLiEpxw1WGqIkj0UidbbCLUhA6X3c7L7eTx2qPRhO6vVXJ+hxAoi2YhF12pTk0iiU9ZzehWNb4tcZcpF0EOz2OeSG3iKHKhL324N2O7wKucm2xNnqfqzvf0eXvUk3AzmqiEGnCq/5kjakIu6l+z+nkRoGKYhVcPRagCJS4nijR9imiVMOLtJPQ/AGD1HwiFAEECxAQs/ztpGkh8NVb6IGGEcYpKie7Gq1XVCqpZLWIojfWAGC4TJJFEOMdD0XwCGxg5Ag2BGCRAmDFoYbJBBGMKWfLJL045j+XxiSw5MZSZDeh/0jOlV0MdBhZ2dXuy3Wdqv501IpiyK+4borQdQAcmCJll4bBzJYOgbsGERRHyt6gHAXgqSDLC300bgPCIoklIyUvQwk3Xp9jx2UY2c3rw0nk6J2Wj3FHwK5yGTVIvTCUQ6sgtD1gIqQIxxcYTtxO8bGIsKQIj0bUGA9QhiMHpQElBCSKz5cvW1INpcQuh3VvHY7+aXQMbVTjNZpochqkFQSQA6dMSRyKqcECdEDjCjuJ0nSCCJspAx44gNYRI4xA5oQA4lEFG7SbOJQvSZHdlgQxrvyxCwCUjR9gaM1clcc9a12bolDgkDCQWhiJInUYLP/KpLOESWLJ24nkPYTSL5eb+LrlhxmRYwcp1GxzOzZWbH4fi0Qeyl5a70tfwJkekeQQUiOQYwkysFLFSGImpSlz5JowBJ14TNM6fby1VcEyZ8NJ8IwRqOOXbGOi8U3li2uXddfUxH30BI/jfVxENx5UxUkHvRj5XhCASRlmEW0eNihIEyRBCFKnhj5H8xbHKyf/ULLaIjJsWmarri+dhvuegZFxOUnQKZTOFQPVURRZljPIXhXORgSA8KUcB5600QSBN1cUKtWS1nDFwhi2OLCcDoFwzSPbR9F1gb5I7kjd3fT6V9z7sEMBWHJLHoGiZhBT8VYEIQlc1CmoEhPBjLA1Gq/Z4cd/8IwLgy7Vf611bouG8ethu2/DPlmqWOJxmd9TJB5OLhXQRiiZkaUSEEoRYQXnuhBslgsYqbcgwKJhyXZodf0N2ZBOA2DboRhvx/hdFX+dp2GX3GNb9/3i5DzMUEQZH7/GGSBRQIl4QgM4R9VEnZQjQiOlCQMiZI49C+fhwWfboaYuK13nY4oG63OxHUchjTWVWSEIl8Ygt/k15hnQRI8ZukilEEVoQfWYjZDCSASxlese5LM5//wXj+/iRtxFMDzf3dPe+kBVT004lzkIyutFFni4ItlccgWpZhtbPBPTBiDvSQ4u+ne+96XgaksaNMf3jeWo0QofD9+M0uWx2Q6G88A8XvWtY14Hm6u7fILuvF44aZXO7bOpZ+34/Gf3zs0ktyjkLnMQkiAfJQl24ciAADhyeAFHxR0MKc+YjrmhEyZ8Zvxm17fcVtP2AxoJP8ScnOCTGz/LkqTJAMEkxgHdxcdATcQlhCuhKNPB17xZ0kc4zF8iNkIMk2ms9nszv+ub/FUt+P9TVyd1zcyeedHd4Dcz+dzjnKbC0RiKuFFwJUohAWlYdAR3MZiwS+C47dkOh4vo3BgXf/guZbdivu/QNqNLNNZktHBUfLbPDDREp53aYQMoQjSJM+DPM5joQACyn0yS6Pw7VuZqutGbjxriEaitBAIE8QYKThDaTUiDEMRx600IpV8uJ8ms5Xf+9n2Jk53W8s0ws+RaJkmRXZw5DEZLQkdDA87I4fHIEwjUolA5kmCRvzee9sdua4ZwL2QCw63/YO/aOS9Hz2kxTpTlORYHCo2CrkdQwglupHSQJhYICJZb2JAtv5oZOF8LP4RpC25DGk1Qkhygkj0eeeo5yFlGeDSC20wVRXjIkTNs2ydJGkaPfR+/H44sSyWcvlJt783eSXcnlhDWxopMqU4Rl5pSc4JyZCvGN1A+J1BcEmqXBwiIWRdABKFfQd/lNy4lHQEYfAnineEzCmpKKk5m4xID9dHLNOIcQTGgUIksYqVylSWZQUln8K+ZY+Gh7d2u2zE49barR9RScUIJeCSTaMhdBBCUUmHxDAMpFKKFEBQCSR+2P/l3dAxkP+cC40QsiqKR9lamlLrQsDRM3N+aK4oktOhT0hd5nULQgbCzbXbYXP5fn8xlPd2O4XYvv+02u0BUZU6VqIjEh2RXOFGg2lDHAaC36EjlaCTJTu5HrlM941gaymEgxgJHzbvRoJGhGEOeV3XOa+8yZumaqpn9axUw1sm532XbiNK3O4hdvj0tCqkEY7AcZo6l1UePKYTNIKbcQBSyisrOCoN0YsQVrLcLqMwdBbfABLprYVUkADCSg4YU0lAiRx2HRjYBm4NIBLVPDN0bNRm80gJKNhdfu96KJ8nOotXpv36y7BfrdBfbj/vNxu8fXNMVVdVfeqlPOWqNKnzsq4IQRu5dpwgdBDCTraUhIPFEP8xXHQEsReeFX4h5IVvz1GUQGREsZRGwjOiC6mPhRiH4iUM0wglu9UWkC/hwBo5TleNuI6jIXiACjNwGImuRFNajWiHBC9tkGcYyNDZMI8v6xdAdqvVcumHYX/w09DpCiKNPPyORrC3NpiA8zSmFKYNOSH4Eu0wCmEQgrxAUuwBWW1xTEJ+nnQEsTx7IWfkMyBwIIIRiaHU5yFo7WvztTlAzjk2aGS/RycpTjwkA6urRmzXRiOftjtClBnl1ElzFiKRRv6oxY591EaiMIDn/6+j7VFKuhMShRuLMpEsKsQ1h6DIakfBWZux7bE95r5vnp/jdbjTaiHfw5yuiJgf3zwUpWAfxetNCBv5cbmkaQrJ0XBPnv5YI3H8GY3YLEtL3q0JhBIwfs4h6tD1kE5mDpFcmPQHO8mOB3vGnkTR+s80so7ZCCG8WuUc8rMa9+RFIC8TBxkFIQUgxWvJCfleXsakIdh4eziwk8/L6NtqjSNt4n0U7R+UZL1MdmfzXGPbf+DzeRQ6AqbAIC8cCSDqqDBiCBP4dHyXuQE52jM7WXxdfotWgGAeB4nWCSD58xEQfH4ZHHIqQkIKzMs/ZADCd4YMDLsYN0T7uHDmkiyDxBh0stg/EDBpZC+NuMulLGlRiTYinQwBZFJIgZv1ypc6JGSUjTJGSN3aw+nATqLV4yXrKNmdjK1rNEKJlMKT8Yg8KlK9jJBqvFpFRSgZuh/TOhoM49RByNHaw9/hdu0fnnXCRiwbYSUq+QXB8KsfG6lkKhRSgSGOSR0NusBrhLiUkzH18fnZ2i0lXx4PWSbbk2kJYSMXhVAiEAYWOT+vlkoKpmQbMmNEAgRHHGnmSGmPBpIcv128W3H8OMdmhatlurZ2rtFGgsRjwvct4fH50kYKgbAPr+shCAwQMikcMmDggaSzB3NCJ4DEqwcW8vmvCI0AUjeA8BRKwRknkp8VK+GOUMF+CnHwYnnvfzE0+GY4NDjnBgYqaa01Z5PDwix2i3i9/rL68O5HcRztnnZMfrb2yC+sAYQjEg8LS2GqIvTAq8U3/C9tQyFFWZSl/80hkiZNHSRZHSD1seXCn8z5nO+QJ0gWa0D2H4fsN4uFOEzX9VmGb463gYxRwjOSQghCwicyCj5DI+TOHQJJiZFCMo400trWGmtMnudDJ/jhvKeRKAmOPDfYkBYQl4ZGtBIJIRJCtBFetBDBwuF/cyCwOErQBMbxvWWstZ1BhLLg9fg4JEkCBAxjbQsJP5eNUDKDSIZG6CmGsDH/CodKRoZMCBxEUNNmvUgYSrAo8ksc39nINj9YOHrH8EZLphDPUQkgM4cgPJ5pHXyUQUdd1xkHiFol3PkA+fot2n/5GIRJogCho3WS0TGR8LBIoEwhVQD60eH1Yl0bd22uTkNGn/U9JTUUAjly5a1UslglUMQfhsSAbLfmRAg+5b8kHin8DMIIhJIAaXwjoYJ1iKUHw/UiEQgecQiE/zC8vOcvXuvNio2YrutafNBYyVzimRmk0j4GRKkIhgpNjfSS9k0shpI857LDcWtHIuS9jeSmsy0Y9QC5NpN4TolBZpDRIW28jRjCUytlxqADQSOyI/dANtyR3NgOKzIUclWIBmeU4xacCYQKZl7IlYWMEAAIueWwbaeNPOEodzdicsub5TS43ohyPF5aiK8oEQgZA4WlqYHjruqoxYG0bxwdBg4LiPmfRhg63tsIrxYkarlyJsV4jgSSqggQT4lmlPCPMS6E+y0BZBJLBh0CkR252Uik/3kPZJvnYdkzgVzHKIWdKINPAUhRTRiIp0IcjkPGmHaajmM7tsEYa/IdIIvlTUgk7+9rxBjTDY30InEchdDBUQra+MRmZnUIROKYiaPGTO4UJmAmjTwlmzshbGT4+VUKFdoJx19pmZRSfJo4AhRk1qEMvno3OvAiZqwDDoSMDg42wh15QCN5ZwCRXPuhkRGCl+dogPgXSbNvHE6V3kUAAAAASUVORK5CYII="
					alt="" />
			</div>
			<div>
				<small>Voodoo</small>
				<h1>Dodgeball Duel</h1>
			</div>
			<div>
				<span class="button download">DOWNLOAD</span>
			</div>
		</div>
	</div>


	<script type='text/javascript'>
		window._voodooIOS = "https://itunes.apple.com/us/app/dodgeball-duel/id1431556749?mt=8";
		window._voodooANDROID = "";

		var _gameplay = {

			nbMatchByLevel: 3,
			maxLevel: 2,

			maxSpeed: 1.5,
			speedIncrementation: 0.05,


			player: {
				color: '#488fcc',
				hand: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAEACAMAAABrrFhUAAAA+VBMVEVHcExGkM1GkM1DiMA7bZdFjMc9dKIjHyBCgrhGkM1GkM02XX85Zo1Dhr1ChLs3X4IxS2NGkM1GkM1GkM1GkM0+dqUlJislJCc/eaoqNEEoLjZGkM1GkM1GkM1GkM1Bf7MwSmEsPE08cJtAe61Ei8ZFjcgzVHEuQlVFjso4YoYjHyFGkM1GkM1GkM1GkM1GkM1GkM1GkM03YYQ2W3wuRFgvR15Gj8xGkM1GkM1GkM1GkM1GkM1GkM1GkM04ZIpGkM1GkM1Dh78pMz8wSmIrN0UxTmdEisRGkM1GkM1GkM1GkM1GkM1GkM0zUW1GkM1GkM1GkM1GkM1GkM1BJV4dAAAAU3RSTlMA//D////////yIP///////zBKsLr///////+AkGB0////////////////5vE34OsV0///////Li0bHNwG2f9b/f///////+pa+uQkTv/hTPZCzm40p5EAAAJzSURBVHgB7NvVYcYwDIDBn4JlZubuP2BncFSSc98GvieTFpIkSZpry9paAQAAAAAAAABKAdab5DVBgLZLXg8AAAAAAAAAmD3AMBZVE8CkAAAAAAAAAAAVAGxtl7QTB8hdCwAAAAAAAAAAAAAAAAAAAAAAsNzdi7WfGyDeBgAAAAAAAACQDuAg1mF6gGAjAAAAAAAAAAAAgKwAR7GOHYYAAACQHgAAAAAATk5jnXkeBwAAAAAAAAAAAAAAAAAAAAD87wAAAAAAAAAAAAAAAAAAAAAAAAAAOL+IdZkNwCcpAAAAAAAAAMBVrOukAMbmAAAAAAAAAAAAANzEuk0P4DQIAAAAAAAAALi7j/XgeRwAAAAAAAAAAAAAAAAAAAAAAADA7/b4VNJzfQD9ckKVAQAAAAAAAACrouoDWC3KAgAAAAAAAAAAeOn/V69dWW/vAYB/2MfnxPV/tUMPhoFAARiD32mPq23bdvffpWZqty9/Nvjy4gG1+V88oDb/r67ysmrzd/eUl2X3F7u/2P2l9+vr+0j/D6h/IP6rBuX+oWfL448//mG5f2Q0/vjP6xuT+8fjjz/+H1X8E3L/5JTbPz1zwz+r8KO5+WvEwuKb/LYD9NsO0G87sAR/PQeWn+Vf+QV/PQdWl1/oX/uRfrS+8fwD8G9ulRrafskB+m0H6LcdoN92gH7bAfptB+i3HaDfdoB+2wH6bQfotx2g33ZgB37LgYYLfyv8mgP/Gu74dyv0o719HLjpn5os9Xdw+wD9tgOz8OsOwK87AL/uAPy6A/DrDsCvOwC/8AD8wgPwCw/ALzwAv/AA/L4Dhx/qTymllFJKKR0DR5qhWI7ZxdEAAAAASUVORK5CYII=',
				head: 'data:image/png;base64,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'
			},
			opponent: [{
					color: '#ee3347',
					hand: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAEACAMAAABrrFhUAAAC01BMVEVHcEzuMEnuMEnuMEnuMEnuMEnuMEnuMEnuMEnuMEnuMEnuMEnuMEnuMEnuMEnuMEnuMEnuMEnuMEnuMEnuMEnuMEnuMEnuMEnuMEnuMEnuMEnuMEnuMEnuMEnuMEnuMEnuMEnuMEnuMEnuMEnuMEnuMEnuMEnuMEnuMEnuMEnuMEnuMEnuMEnuMEnuMEnuMEnuMEnuMEnuMEnuMEnuMEnuMEnuMEnuMEnuMEnuMEnuMEnuMEnuMEnuMEnuMEnuMEnuMEnuMEnuMEnuMEnuMEnuMEnuMEnuMEnuMEnuMEnuMEnuMEnuMEnuMEnuMEnuMEnuMEnuMEnuMEnuMEnuMEnuMEnuMEnuMEnuMEnuMEnuMEnuMEnuMEnuMEnuMEnuMEnuMEnuMEnuMEnuMEnuMEnuMEnuMEnuMEnoL0jhL0bVLkTOLUPHLUG8LD+0Kz2uKzyiKjqaKTiUKDeJKDWAJzN6JjJvJS9nJS6OKDbqMEjiL0fXLkTRLkPJLUG9LD+3Kz6vKzyjKjqdKTmWKTeKKDWDJzN8JjJwJTBpJS5jJC1WIypQIylJIig8ISU1ISQvICIjHyDtMEnaLkXTLkTALEC5LD6mKjugKTmMKDWGJzRzJjBsJS9ZJCtSIyk/ISY4ISQwICMlHyDjL0fcL0XJLULDLECpKjuPKDZ1JjFcJCtVIypBIiY7ISUoHyHmL0ffL0bMLULFLUGyKz2sKjyYKTiSKDZ/JzJ4JjFlJS1eJCxLIihEIicxICMqICHoMEjPLUPILUG1Kz2bKTiVKTeBJzN7JjJhJC1NIylHIic0ICMtICIkHyDSLkN5JjHuMEmFJzTuMEnuMEnuMEnuMEnuMEnuMEnZLkVAISZ3JjHuMEnuMEmeKTnuMEnuMEnuMEnuMEneL0ZmJS7sMElrJS82ISQpICHpMEixKz3uMEnuMEnuMEnuMEnuMEnuMEm6LD81ICTuMEkU8wPMAAAA8XRSTlMAChIgKjJAS1Nga3OAi5SglwUGEB8nMD9HUF9ocIiQqLHAydHg6fL/zAMbJDxEXGR9hZ2lsL3G0N7m8P4YOEFZYXmCmqK6wtvj+w0VLTVNVm52jpavt8/X7/gJEUpSk6u01Oz0An/I8f///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////5v/RXs2Rup4////+e7/deH36///////////KPzczcq+//+JZCQdMgAABJNJREFUeAHswQUBgDAAALDj7t6/KDWQbQEAAAAAgHeI4iTN8qKs6qbt+mGcwkfNy7rtx3ndkpKW4ZGV45dXUFRSVlFVU0cHGkM9BDSFtbTFdHQl9fRlDAzljIxNTM3MLSytrNVxgKEbAsI2zGK2dpL2DjKOTnLOLiaububuHlaeOD02ZEPAy5vZx5fNz58zIJAnKJg/JFQxLFwlIhKn+4dsCERFg0qjmFhwaRTHH5+gqJGokpSM05nDIwRSUuVNFNOApRFA6ThdM6xDICVEHcAMPV0HEEABEC13bdtm7GRj22Zh+Y/5zk4Hd/oZ0AF4P/yBXvtRDCdIimZYjhdESVZU2ANwfk03TMt2XM8PwihO0iwvyqpu2ldFf3oA3j+gDw5ZwyPu6FgwPhFPTmXTM+XsXDfffhz8gV/7FxbxpWXKXWGDVSFek7P1jXJzq9v+GAd/4Pf+nV18b586OGSPjoWTU/nsPL+4rK6uPzbAH/i9/0bHb++oe4Z9eBSentmhawMrgCiMwhGuIZ4gt4GNtgZCGsAlRJ6FuDN0QEwLRLg7g3sjWMS/+uPcd+Z0cL6rne6149dvnLp5qxjlFJD/S+eK33AI6P/tUgACxj9AwPgHCPj/+QWsf4CA8Z9AAPBvCAD+DQHAvyEA+J9AAPBvCAD+DQHAvyEA+PcE8v/7AoB/QwDwbwgA/j0BwL8v4P0DBIx/gIDxDxBI9u8LAP4NAcC/IQD49wSMf4CA8Q8QMP4BAtZ/fgHAvyEA+DcEjH+AgPFPEJD/O0c603d4THdTC8j/zzUoiQX0PzeALyD/BAAVuCf/CAAVGJF/BIAKjMg/BqDcFwD5ZwCcEgD5ZwI8mD9pD1c4zd2UGuA3tAYA0AAaQANoAA2gATSARzO1x0u/9gQDUGPiKAA1hgLggg/g/2cCOGkAGP84gBpsgBpsgBpsgBpkAP1/emB8l/d869CQAuj/s5I5AVjE/FcA4L8CAP8VAPivAMB/BQD+KwDwXwGA/woA/FcA4L8CAP8VAPivAMB/BQD+KwDwXwGA/woA/FcA4L8CAP8VAPivAMB/BQD+KwDwXwGA/woA/FcA4L8CAP8VAPivAMB/BQD+l/MKgPsvx0MB9D927pqwgdPznAA1fleHUwLUYAPU4AL87v84kgzgd/9HJxfAYv3nAazSfyJAfNeLUae1ayboZVqA39SKFAANoAE0gAbQABpAA2gAt1+xAW5fCi6A/gMB9D9e//Dp+jejE/U2C4D+b9jyw//vYuo68P/owP+jA/+PDvw/OvD/6MD/o0P4P/t+16R9APx//Nz+HFggEEABANUoR1wDxNEYTZAAjdAO0QhHABqhaaqrqqoRgiLH8XHu6ry3wdsuw/z9/f39/f39/f39/f39/f39/f39/f39/f39/f39N3nEbt/8Py1mVVbziCKtz2Hd1L9d/v7+/v7+LfyPpf9pFDHtR5yziEvycW3h/0t6t878/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f3974+80uJbR/9x/v7+/v7+/v9snJUNkojJ8O1Z9x8AAOAFK2gLFWeabd0AAAAASUVORK5CYII=',
					head: 'data:image/png;base64,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bS9waG90b3Nob3AvMS4wLyIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0RXZ0PSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VFdmVudCMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTggKE1hY2ludG9zaCkiIHhtcDpDcmVhdGVEYXRlPSIxOTA0LTAxLTAxVDAxOjAwKzAxOjAwIiB4bXA6TW9kaWZ5RGF0ZT0iMjAxOS0wMS0xOFQxNzowMDowNyswMTowMCIgeG1wOk1ldGFkYXRhRGF0ZT0iMjAxOS0wMS0xOFQxNzowMDowNyswMTowMCIgZGM6Zm9ybWF0PSJpbWFnZS9wbmciIHBob3Rvc2hvcDpDb2xvck1vZGU9IjMiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6MTRmZDVjMzMtMDcyNS00YjBiLTk2NzctNTM3N2Q5MjlmMDUzIiB4bXBNTTpEb2N1bWVudElEPSJhZG9iZTpkb2NpZDpwaG90b3Nob3A6MGE0N2NkYmQtNTQzNC1iNzRiLWJiMjktY2Y4ZmMwMmYwMjQ2IiB4bXBNTTpPcmlnaW5hbERvY3VtZW50SUQ9InhtcC5kaWQ6ODQzMDA2MjYtY2M5NC00ZTc0LTllOWUtZDk2NjgxMzUwYjkwIj4gPHhtcE1NOkhpc3Rvcnk+IDxyZGY6U2VxPiA8cmRmOmxpIHN0RXZ0OmFjdGlvbj0iY3JlYXRlZCIgc3RFdnQ6aW5zdGFuY2VJRD0ieG1wLmlpZDo4NDMwMDYyNi1jYzk0LTRlNzQtOWU5ZS1kOTY2ODEzNTBiOTAiIHN0RXZ0OndoZW49IjE5MDQtMDEtMDFUMDE6MDArMDE6MDAiIHN0RXZ0OnNvZnR3YXJlQWdlbnQ9IkFkb2JlIFBob3Rvc2hvcCBDQyAyMDE4IChNYWNpbnRvc2gpIi8+IDxyZGY6bGkgc3RFdnQ6YWN0aW9uPSJzYXZlZCIgc3RFdnQ6aW5zdGFuY2VJRD0ieG1wLmlpZDoxNGZkNWMzMy0wNzI1LTRiMGItOTY3Ny01Mzc3ZDkyOWYwNTMiIHN0RXZ0OndoZW49IjIwMTktMDEt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'
				},
				{
					color: '#faa325',
					hand: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAEACAMAAABrrFhUAAAA/1BMVEVHcEz6oyT6oyTqmSS3eiPyniTFgiMjHyDgkyT6oyT6oySZZyKqciPnlyTjlSScaiJ2UiL6oyT6oyT6oyT6oyTIhCMwJyAsJSDPiSNLOCE/MCH6oyT6oyT6oyT6oyTZjyN0USJbQSG8fSPSiyPxnST0nySHXSJlRyH3oSSibSIkICD2oCT6oyT6oyT6oyT6oyT6oyT6oyT6oySgbCKWZSJpSiFwTiH4oiT6oyT6oyT6oyT6oyT6oyT6oyT6oySncCL6oyT6oyTpmSRJNiF1USJROyF8VSLunCT6oyT6oyT6oyT6oyT6oyT6oySCWSKIXSL6oyT6oyT6oyT6oyT6oyR9eFrQAAAAVXRSTlMA//D////////yIP///////zBKsLr///////+AkGB0/////////////////+bxN+DrFdP//////y4tGxzcBtn/W/3////////qWvrkJE7//+FM9kLOpQXVRwAAAnNJREFUeAHs28VhxUAMQMHP4DAzM/RfX2qQFdJ6Xgea0+JIkiRJQ23cWhMAAAAAAAAAQBRgOivePAmwWBZvBWDwAAAAAAAAAMC6C9UWQI8aAAAAAAAAAAAAbGxG2qoPkGsBAAAAAAAAAAAAAAAAAAAAAAAw3t7JtVsdINusHAAAAAAAAAAAYC/XfnmAZF1VAAAAAAAAAAAAAAAHuQ7LA9gNAgAAAAAAAACOjnOduB4HAAAAAAAAAAAAAAAAAAAAAPzvAAAAAAAAAAAAAAAAAAAAAAAAAAA4Pct1Xg3AIykAAAAAAAAAwEWuy6IAvs0BAAAAAAAAAAAAuMp1XR7AbhAAAAAAAAAAcHOb6871OAAAAAAAAAAAAAAAAAAAAAAAAIDf7f4h0mN7AKtxrwAAAAAAAICmACah2gOYjGIBAAAAAAAAAAA8rf5Xz8tYL68JgH/Y23tw/o9xHqD+/HmA+vOPP7/aoavDhmIAiqEuDfL+y8zMTPuvUkaVMYl1tcFR+Vq1+QcGy9ey+4vdX+z+MtT6hv/A30mNjMb/0JjcP/5pefzxxz8h909OxX9b/MPTcv9M/B1V/PHHPyv3z827/QuLT/xLCj9aXnlErK79yG87QL/tAP22A+vw13Ng41P+zS746zmwtfFF/zb8HdnO7qcP0L+3X2rogAdkfh7w+XnA5+cBn58HfH4e8Pl5wOfnAZ+fB3x+HvD5eeATfsuBQ4mfB5o7/5HFzwN9zQv/cYV+dHKKA0/983Ol/s6eHdD5eWDJ5ucBi58HfH4e8Pl5wOfnAZ+fB3x+HvD5ecDn5wGfnwd8fh7Q+Xng/E/9KaWUUkoppUvIR6QNlnO2eAAAAABJRU5ErkJggg==',
					head: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAEACAMAAABrrFhUAAACl1BMVEVHcEz6oyX6oyX6oyX6oyX6oyX6oyX6oyX6oyX6oyX6oyX6oyX6oyX6oyX6pCj80JD6piv94rv92ab////8w3L/+/b7skj+8Nv6py793rD93a/8x3v//Pn7tE7+8+L6qDL94rr6oyb8zIb8y4X//vz7uFb+9ef6qjb+5cL6pCf//v37u17/9+z7rDv/9+v+6cr91Jn8v2f/+fD7r0H+7NL6pSr92KT8wm//+/X7sUb+79n93a78x3r8xnn//Pj7tEz+8uD6qDD94bj8y4T//fv7t1T7tlP+9eb6qTT+5cH8z437ulz6rDr+6Mn+6Mj905f7vWP7rj/+7NH916H916D8wW3/+vT7sEX+7tj6pi393Kv8xnf8y4P92aXEgR6tchy6iUDHnmPEml3nlyMPDggEBwdmaGi7vLx+VBY1ODhxc3N9UxbrmSMSEAkJDAz5+fklKCh/VRbOzs7X19funCSdnp6MjY3tmyP6oyWGWhdqbGxCRET6oyUWEwk6PDzv7+8HCgoNEBD8/PynqKjxnSQbFgrT09NdX18aFQqOXhiho6P9/f0WGRlwcnLDxMSTYhg+QEB4enqSYRj0nyQgGQoPEhL+/v4tMDCWYxnZ2dng4OD1oCSmp6eTlJSdaBp0dnZJS0v2oSUmHAtFR0fz8/MLDg4TFhawsbH4oiUqHwzc3NxjZWUpHgulbRusra0cHh4sIAx6fHzLy8unbhtISkqBg4Ombhv5oiUyJA0YGho0Nzf6oyXi4+Pl5uYFCAj6oyX6oyWvsLCcnZ20dhx/gYFSVFSzdhw5KQ1OUFD39/cOERG1fzHo177/9ur8yYD+5MD90pT8wGn905j7uFf/+O7/+O/+5sP6oyX6oyX6oyX6oyX6oyX6oyUG11KcAAAA3XRSTlMAQP8KvrIGtQSlA6ZD0//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////r////Lf//////////////////////////////////////////////////////////////////////////////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'
				},
				{
					color: '#ee3347',
					hand: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAEACAMAAABrrFhUAAAA/1BMVEVHcEzuMEnuMEnfL0avKzznL0i8LD8jHyDVLkTuMEnuMEmSKDeiKjrcLkXZLkWWKTdyJjDuMEnuMEnuMEnuMEm/LEAwICMsICLFLUFJIig9ISXuMEnuMEnuMEnuMEnPLUNvJS9YIyu0Kz3JLUHlL0foMEiCJzNhJC3rMEibKTgkHyDqMEjuMEnuMEnuMEnuMEnuMEnuMEnuMEmZKTiPKDZlJS1rJS/sMEnuMEnuMEnuMEnuMEnuMEnuMEnuMEmfKTnuMEnuMEneL0ZHIidwJTBPIyl3JjHjL0fuMEnuMEnuMEnuMEnuMEnuMEl9JzKDJzPuMEnuMEnuMEnuMEnuMEl+BHAzAAAAVXRSTlMA//D////////yIP///////zBKsLr///////+AkGB0/////////////////+bxN+DrFdP//////y4tGxzcBtn/W/3////////qWvrkJE7//+FM9kLOpQXVRwAAAnNJREFUeAHs28VhxUAMQMHP4DAzM/RfX2qQFdJ6Xgea0+JIkiRJQ23cWhMAAAAAAAAAQBRgOivePAmwWBZvBWDwAAAAAAAAAMC6C9UWQI8aAAAAAAAAAAAAbGxG2qoPkGsBAAAAAAAAAAAAAAAAAAAAAAAw3t7JtVsdINusHAAAAAAAAAAAYC/XfnmAZF1VAAAAAAAAAAAAAAAHuQ7LA9gNAgAAAAAAAACOjnOduB4HAAAAAAAAAAAAAAAAAAAAAPzvAAAAAAAAAAAAAAAAAAAAAAAAAAA4Pct1Xg3AIykAAAAAAAAAwEWuy6IAvs0BAAAAAAAAAAAAuMp1XR7AbhAAAAAAAAAAcHOb6871OAAAAAAAAAAAAAAAAAAAAAAAAIDf7f4h0mN7AKtxrwAAAAAAAICmACah2gOYjGIBAAAAAAAAAAA8rf5Xz8tYL68JgH/Y23tw/o9xHqD+/HmA+vOPP7/aoavDhmIAiqEuDfL+y8zMTPuvUkaVMYl1tcFR+Vq1+QcGy9ey+4vdX+z+MtT6hv/A30mNjMb/0JjcP/5pefzxxz8h909OxX9b/MPTcv9M/B1V/PHHPyv3z827/QuLT/xLCj9aXnlErK79yG87QL/tAP22A+vw13Ng41P+zS746zmwtfFF/zb8HdnO7qcP0L+3X2rogAdkfh7w+XnA5+cBn58HfH4e8Pl5wOfnAZ+fB3x+HvD5eeATfsuBQ4mfB5o7/5HFzwN9zQv/cYV+dHKKA0/983Ol/s6eHdD5eWDJ5ucBi58HfH4e8Pl5wOfnAZ+fB3x+HvD5ecDn5wGfnwd8fh7Q+Xng/E/9KaWUUkoppUvIR6QNlnO2eAAAAABJRU5ErkJggg==',
					head: 'data:image/png;base64,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'
				}
			],
			boss: [{
					color: '#dc2ab6',
					hand: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAEACAMAAABrrFhUAAAAkFBMVEVHcEzcKrbcKrbPKKumIInWKbEAAADBJaDcKrbcKraRHHi6JJpTEEU5Cy+YHX7cKrbcKrbcKrZyFl7cKrbcKrbZKrSOG3YYBRQcBRetIY/cKrbcKrYZBRXEJaLaKrVPD0F1FmHcKrbcKrbcKrbcKrbcKrbcKrbcKrbcKrZ8GGfcKrbcKrbYKbJDDTiUHHvcKraZyZpfAAAAMHRSTlMA//D///////EQ//////9wgiD/0Nb///////qg///////M0xXHLesG4f9C9v///8ky47U+AAACLElEQVR4AezbxQHDMBRAsXDKzN1/z87gBu3ojaCL8WeSJElaanlqFQAAAAAAAACAUICyiry6I0DVRF67eAAAAAAAAAAAwGodVEoAfwUAAAAAABIAAABgU4VUJgHQoQoAAAAAAAAAAAAAAAAAAAAAACDf7rq1jx2gawcAAAAAAAAAQHQAx26dogfo2BkAAAAAAAAAAACArbDDEAAAAAAAAADA46jncQAAAAAAAAAAAAAAAAAAAAAAgBkGAAAAAAAAAAAAAAAAAAAAAAAAAEBZdevilxgAAAAAAAAAwNhcFAEAAAAAAAAAAAAAcO3WzWEIAAAAAAAAiB/gXnbr4XV43AAAAAAAAAAAAAAAAAAAAAAAAAA8XyG90wNo86ASBAAAAAAAAAAAfL5BpQdQZGHlAAAAAAAAAID3a1792qFzI4SBKIzBz3Vw3zf03x0hBEp2HNiz+tXBp2XrgNWIATNsvWn0b4eeBozwtw/ozN8+oDP/sKu2evPvD9WW3V92f9n9tZi+4wT+OXU6y/3xxx9//PHHH7/AH3/88ccff/zxX65/hpvPX3V//BDPl8nPB0x+PmDy8wGTnw+Y/HzA5OcDJj8fMPn5gMnPB0x+PmDy8wGfnw84/HzA5OcDJj8fMPn5gM/PB9CvOgB+1QHwqw6AX3UA/LID4HcdeINfdQD8mgPgVx0Av+oA+GUHwC87AH7ZAfDLDoBfdgD8sgPglx0Av+vAZwK/qpRSSiml9AXFbN9XVLEvwQAAAABJRU5ErkJggg==',
					head: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAEACAMAAABrrFhUAAACVVBMVEVHcEzcKrbcKrbcKrbcKrbcKrbcKrbcKrbVKrHCKKHcKrbQKa03IDDcKrYjHyDTKa4kHyGaJoDmZMr64/bocc/75fb+/P7maMv////+9/zlX8j99PvjVsX97/riTsP76PfhSMDgQb752/PfPL341fHeN7r2y+3eMrn1wurdL7hCITnzuOfcLLc5IDLyrePcK7bwod/uldvsiNfqfdP//f48IDSvJ5HkWcbriNb0vungQr7++f3nbc3tkdrrhNXztebfObvsjNjvnd72yu353fPdLbfjUsTysOTxq+L64PXiUMPpedH2xezhRcDumdzeNbr87PnhSsHxpuH52fL40e/odNC/KJ6WJn62aKXPm8S+ebChPYyLJXSQjo7NzMykoqJmZGS7urr4+PgmIyPQz8/k5ORRTk6+vL0yLi9/fH1LR0jo5+ddWluysbF4dXY2MjOHhYbh4OBhXl+xsLCMiovd3NxlY2O3tbYqJif9/f2XlZXHxsYuKiv39vaopqfS0dJ7eHn5+fmsq6tKR0dzcHGmpaVXVFSfnZ6CgIDJyMiRj5Dz8/PDwsNOS0zZ1thAPT78/PxtamtGQkOWlJTp6elIIT63KJjFKaN7JGfYKrPu7e5lI1YmICIwICucJoJRIkXHKaWGJXDbKrWbmZpwJF6mJ4paIk3NKaoqHyaRJnk7ODkyJC3UyNHNQa/JMqn7+/u+i7Pp6Ojh3ODGUa3EpLzWMrTAZqzOvcrRO7G+f7CTM33KSa6pXpnBmLfZLrSpXZjBWarCoLrDW63cKrbcKrbcKrbcKrbYXsEpAAAAx3RSTlMADJOqD8n/C///hP//kf/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////TFV9R9LO1lQAACGRJREFUeAHk0LUBQ0EAgNB/rvvPm5ImdlUENnhcDwox/VUxXEflUv+skq1+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',
					scale: 1.6,
					name: 'THE BRUTE',
					sub: 'Hits Hard, Reacts Slow'
				},
				{
					color: '#f68e4e',
					hand: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAEACAMAAABrrFhUAAAA/1BMVEVHcEz2jk/2jk/mhku1bEDvik3Cc0MjHyDcgUn2jk/2jk+XXDqnZT3jhEvggkqaXjt1SjL2jk/2jk/2jk/2jk/FdEQwJiMsJCLMeEZLNCk+LSb2jk/2jk/2jk/2jk/WfUhySTJaPCy6bkLPekbtiU3wi06FUzZkQS7zjE6gYTwkHyDyjE72jk/2jk/2jk/2jk/2jk/2jk/2jk+dXzuUWjloQy9uRzH0jU/2jk/2jk/2jk/2jk/2jk/2jk/2jk+kYz32jk/2jk/lhUtIMyhzSTJRNyp6TTPqiEz2jk/2jk/2jk/2jk/2jk/2jk+BUDWGUzb2jk/2jk/2jk/2jk/2jk8BLjgVAAAAVXRSTlMA//D////////yIP///////zBKsLr///////+AkGB0/////////////////+bxN+DrFdP//////y4tGxzcBtn/W/3////////qWvrkJE7//+FM9kLOpQXVRwAAAnNJREFUeAHs28VhxUAMQMHP4DAzM/RfX2qQFdJ6Xgea0+JIkiRJQ23cWhMAAAAAAAAAQBRgOivePAmwWBZvBWDwAAAAAAAAAMC6C9UWQI8aAAAAAAAAAAAAbGxG2qoPkGsBAAAAAAAAAAAAAAAAAAAAAAAw3t7JtVsdINusHAAAAAAAAAAAYC/XfnmAZF1VAAAAAAAAAAAAAAAHuQ7LA9gNAgAAAAAAAACOjnOduB4HAAAAAAAAAAAAAAAAAAAAAPzvAAAAAAAAAAAAAAAAAAAAAAAAAAA4Pct1Xg3AIykAAAAAAAAAwEWuy6IAvs0BAAAAAAAAAAAAuMp1XR7AbhAAAAAAAAAAcHOb6871OAAAAAAAAAAAAAAAAAAAAAAAAIDf7f4h0mN7AKtxrwAAAAAAAICmACah2gOYjGIBAAAAAAAAAAA8rf5Xz8tYL68JgH/Y23tw/o9xHqD+/HmA+vOPP7/aoavDhmIAiqEuDfL+y8zMTPuvUkaVMYl1tcFR+Vq1+QcGy9ey+4vdX+z+MtT6hv/A30mNjMb/0JjcP/5pefzxxz8h909OxX9b/MPTcv9M/B1V/PHHPyv3z827/QuLT/xLCj9aXnlErK79yG87QL/tAP22A+vw13Ng41P+zS746zmwtfFF/zb8HdnO7qcP0L+3X2rogAdkfh7w+XnA5+cBn58HfH4e8Pl5wOfnAZ+fB3x+HvD5eeATfsuBQ4mfB5o7/5HFzwN9zQv/cYV+dHKKA0/983Ol/s6eHdD5eWDJ5ucBi58HfH4e8Pl5wOfnAZ+fB3x+HvD5ecDn5wGfnwd8fh7Q+Xng/E/9KaWUUkoppUvIR6QNlnO2eAAAAABJRU5ErkJggg==',
					head: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAEACAMAAABrrFhUAAAC91BMVEVHcEyaXTphPy0jHyAuJSKAUDRjQS4yJyOCUTVmQi9pRC83KSSFUjVtRjCGUzZwRzE8LCaGUzZySDF1SjJCLyeHVDZ2SzIlICB5TDNIMyiKVTYmISGMVjd9TjNNNSkpIiGMVjdUOStVOiuDUTQwJiNaPCxdPS02KSRBLyYsIyI5KiU9LCZALiZJMyhPNip1SjKUWzmwaT/Ld0Tggknwi032jk7qh0vYfkjCckKnZD2KVTZpRC9DMCeBUDSjYjzXfUf0jU3uikzFdENkQS5cPSydXzvaf0iHUzZHMihZOyznhkvSe0Y+LSYzJyOEUjW8cEFmQi+gYDvcgEiAUDREMCetaD7zjE3lhUpfPi21a0BkQS5TOCpWOiu4bUCqZj3TfEZtRjBwRzFrRTBiQC5MNCnIdkQ7LCXNeEWPWDd4SzKMVjd8TjPegUmsZj62bEC/cULkhEqbXjqZXTp3SzKGUzaYXTqjYjy0az+9cELEw8T///9TT1D3n2f969/Jd0S7urpKRkf3mmD949OtrKxAPD33lVj838ySkJH9/f0qJif++PP//v7807vxi02/cUF3dXXi4eH96dz6wp/2jk6+vL35r4L39/eHhYb6upL2jk7CwcHv7u7+7+b7yKk6NjelpKT4o25jYGHPzs75t47U09NnZWX4qXj+8ur2kFH94M///fxDQEDd3d2SWTixsLDKycn/+/gxLS7Y2Nj5s4hwbm7z8/P95NX5+fl/fX3q6ur82MG6bkF8eXre3t72k1aioKFYVVX6vZf7zrL82cPihEqXXDnRekb2jk72jk72jk72jk72jk72jk72jk72jk72jk72jk72jk72jk72jk72jk72jk72jk72jk72jk72jk72jk72jk72jk72jk72jk72jk72jk72jk72jk72jk72jk72jk72jk72jk72jk4jHyDbgEhkQS4jHyAjHyA1KSQjHyAjHyAjHyAjHyDFdEMjHyAjHyAjHyAjHyAjHyD2jk4jHyAjHyAjHyB6ZDnZAAAA/XRSTlMAAtb//2LQ/lLHwPxDuEKu+zSnnPcnlv+F9Bz/FHPv/wzo5gX/39z/+P//////////////////////////Ev////////////////////////////8G//////8u////////////////////////////////z8fAu7iy//////+u//////////////////+hFf////+g//////8P////////////////////////////////////////////////////////////CeR4JJcB6y2lAy7xN7IF9kK++r9OylrTFWTWad0cdISIlpD/i2D3adguowx5x2eKSe5yHk6o4Y+BJwAACdNJREFUeAHc0IVhAkAUwNBCcHd3Z/8FOwEuOX42ePl7W5ks3yqX/3MT/OkfKPDNiqXU/GVwD/h+94Dvlw4E8Ac4UMGpWkvDX4cABwS/cED1Cwfi+6HacP1N7Fpt09+BAAcEf5ADvt894PvdA13Sqdf/vn8wJMABwR/kgO93D/h+98AoQT+MJ1/zTyH+Ad9vHvD9woEAfhjPPu2fJ+2HxezD/iXEP+D7/QO+XzoQwA+L1Wf8+R/xw3r1EX8O4h/w/f4B368fCOCHzfad/tKOn2u/faO/CPEP+H7/gO/3D0TywyHzur925IfLZl72VyH+Ad/vH/D9/oGYfig87W+3CFE5gl844PvdA77fPRDLD5UH/f0Twao/5u8Rrrrv9w/4fveA7Pdr3uWfjAlbx/b7B2y/f8D2+wdkv1/3in+2IH7Dge33D0Txn/+ptYeFOYIoiuPRM8TJZ45xxrZtmzEfP84mHHTXvfXfd1ed37quNVqdRnPxSBkBefZf6Q1Gk9lixc9sdofT5fbc20vAK8d+rcHnD+DPBUPG8OlmAvd/2394xH/8o0g0hv8UCMUTm/zqvnz7k74UNivtymwrwH5/NmfHFgXyhXubC/Df7ykGsW2l8tXGAhXe+z3VAHYp5fo3wcGTH/tPzjjPv3bWsGv18qP/CLDff+AKYp/8jf8IMN+fjGHfmhf/EWjxnX/HBwWyGf71hIQzQLsEZWpmpQRw1aBUlo58AKddKFitLBuAxw9l6z2SCqCdgtI5TiUCKFihfP1raQAGAaiRPSMJwFCd/YBFKwXASK39QOlaAoCxFerlz7IHmAShZtMD5gAzC9TNxBvgYA61W7AGcEL9GowBlhBQSsMWwBOEiEL3mAI8mkNMcaYAKwiqlmAJ4LFCVFOWACGIa80QYACBpbLsAA6eQWRRdgAuCK3mYQZwaoPYqswAVhBcwMMK4MoG0T1nBVCG8GrXjADulSA+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',
					scale: 1.2,
					name: 'THE BRUTE',
					sub: 'Hits Hard, Reacts Slow'
				}
			],
			ball: {
				color: '#ee3347',
				particle1: '#488fcc',
				particle2: '#ee3347',
				particle3: '#000000',
				particle4: '#f4990d',
				texture: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAEACAMAAABrrFhUAAABO1BMVEVHcEzuL0juL0juL0juL0juL0juL0juL0juL0juL0juL0juL0juL0juL0juL0juL0juL0juL0juL0juL0juL0juL0juL0juL0juL0juL0juL0juL0juL0juL0juL0juL0juL0juL0juL0juL0juL0juL0juL0juL0juL0juL0juL0juL0juL0juL0juL0juL0juL0juL0juL0juL0juL0juL0juL0juL0juL0juL0juL0juL0juL0juL0juL0juL0juL0juL0juL0juL0juL0juL0juL0juL0juL0juL0juL0juL0juL0juL0juL0juL0juL0juL0juL0juL0juL0juL0juL0juL0juL0juL0juL0juL0juL0juL0juL0juL0juL0juL0juL0juL0juL0juL0juL0juL0juL0hkVQN3AAAAaXRSTlMAGzVOZnuQorTD0d3n8Pf8/xU6XoHC4RlGcpzF7SdZi7vrUIe98i1ppN4xcbDvJq0LU5ngeMFHlAlaqfkSZLdovGNYsUWh/SuJa8uoGn7iTbMW5kKs1yWStdYQgvQoPbJPxl9s5XXxfAM6X+/WAAAGfUlEQVR4AdzBgwHDUBQAwBfbtu1k/926Qa2fO/g2DCdIimZYjhdESVZUVZElUeA5lqEpksAxOC1NN0zGstUbbIsxDV2DU3Fczw9C9QFh4HuuA2cQxUmaqU/J0iSOAGVOXpSV+pKqLHIHkFQ3bae+Rdc2NSCmH8ZJfaNpHHpAxtwsk/p209LMgIB12w/1Q459Wy/c1oOVZGEQhuFeHK6+NY4mhGFzjLZ5beUfwYYwfV1VTwbvz6J+8S+vUKqrS8rPQbP1C6X71WrSrG93uj1UotfttMnlX9/cokK3N9e08u/uUbH7OzpLcPpwghqcPJzS6H98Qk2eHgnkP7/0UZv+y3PN+YPhR9Tq43BQ5+UfjVG78ei0rv4/E5Aw+VNL/nQ2BxHz2bT6/sUShCwXFeevZmuQsp6tquzfbEHOdlNd/2gHgnajivL3BxB12FfR31RAltIsv/+9CsLU9yXna7oB0gxdK7Pf/Afy/pnl9Vs2GLCtsvodFyy4Tjn93g5M7Lwy+v0AbAR+8f1hBEaisOj+uAdWenGh+ckPsPMjKbBfB0N6cSvwAyz9KOz+g6mC3oGwB6Z6YRH9fgS2Ir+A+S8AY0HumdDZgbWdk6/fcsGca+XpN22wZ5vZ+7V/EOCf1shKhwh61v73BkQw3mfrb6oQQm1m6d8rEEPZN9I7QJBD+v4RRBml7d/sIMpuk65/tYUw21UjjRnEmaXpX6whznpxfP90CYGWUyIXgP4l+DOHSPM/x/WfTiDU5JTACER/HBqMIdZ40HjdEHL9Z68e0xsIACAMf7XbiWvb5hbh0/tfKDb/7+Q9w0D/jJRbVogt5xglr1DLM0KmoFArZBjqPquQy94zTFqhl2aIYF+htx8w2K8M/DJQ8CcDfwGDfMvCNwO8/8jCzzv9fcjEB/19ysQnfb1+ycTXK/28ycYbfZwmZSN5Sq9nGXmmx/2LjLzc0+1BVh7o9igrj3S5fZKVp1s6ncnMGZ3uZOaODpc3MnNzSbsr2bmi3bXsXNPm9EZ2bk6dP6D7B85l6Jym1IUMXaRoOJSlQxqOZOmIhmNZOqZu50SWTnao2ZWpXWr2ZGqPmn2Z2qeC1IFMHaSoWJetdSo2ZGuDik3Z2qRiS7a2ACLbsrUdAaIyFgViMhYD4jIWB+ZkbA5IyFgCSMpYEiZkbYJJWZtkStammJa1aWZkbYZZWZtlTtbmmJe1eRZkbYFFWVtkSdaWWJa1ZVZkbYVVWVtlTdbWkDlkblwB9xEc32CJvTuoAiCEgRhaCesKHv4FrQTu5FcFtDNJ/SHkKVz/DPkO1xciVmL1pai1eP0w4jRWP446j8cDEiIyQlJicu2gpKissLS4vMJEuTKjNKU2pzipOqs8rT6fBShAaICowOgAKUFpganB6VWBipCaoKqwusDK0Nrg6vD6BAsUGyQrNDtES1RbZGt0e4SLlJukq7S7xMvU2+Tr9Puzv4dnz33W+Z6ds+Y+P3fwbRwhFEUB9AYUcAMCDVUoIqECRkJr8d7TfwVqAfPZ4b1z4FMtH2t8/1Cpn2+s8vVHlf6+sFJAlQKs9XunQvdfrHZ7Up3nDRsEVCfAFo83lXk/sMkrpCrhCxv5VMXHZjEVibFdlFCNJMIObkolUhe7WAVVKCzslFOFHHtlDhVwMuxW1hSvLnFA1VK4tsIhTUjRwgYHdQMFGzoc1k8Ua+phwOhRKG+EETOFmmGITZFsmLLkFChfYMxiUxx7gUmzR1G8GYaNEwWZRhjXDxRj6HGCLqQQYYdTNC1FaBucpKopQF3hNKXDy3NKnCjLC15akWc4l5XywlILp3MTXlbi4gOimBcVR/iM/+7gAdGRIAwD4B87+WLbtie2ff+r7A32ubsnVbsXBPTaETOPJ4TzfBBDt9MdQrmfbsTW5QqBXC/E3PF0hiDOpyPx4DtACAcfcVLb7cHdflcjfjZbM7gybzfE13K1Bjfr1ZL4my/AyWJOQqjNYuAgNquRKKTJFIxNJxKJRBqNwdB4JJFoev3BEEwMB/0eCanT9eDPebodElem1cafarcyJLZavdHEH2k26jWSgUq2WsavK1ezFZKNQrFUxi8ql4oFkplMNpfHr8jnshmSJW8imUrjR9KpZMJLchaORGNxfEs8Fo2E6R14ff5AMIQvCAUDfp+X3ord4XTp3B58wOPWuZwOO70thVKl1mh1eoPRZLZYbYDNajGbjAa9TqtRq5QKYuwf7Mw1sIr8kBMAAAAASUVORK5CYII='
			},
			background: {
				particlesEnabled: true,
				nbParticle: 11,
				minMinSize: 1,
				maxMinSize: 5,
				minMaxSize: 10,
				maxMaxSize: 20,
				particleMap: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAEAAQMAAABmvDolAAAABlBMVEVHcEz///+flKJDAAAAAXRSTlMAQObYZgAAAE9JREFUeAHt1bUBgEAQAEE6oCT674Ycd5cQ+dnk5Sa/aFlS7Xs9AAAAAAAgb+8xAPwCAEB1EwAAAAAArwTpdrmPAcAPAACMvR0AAAAAAFADxZv+G+f+PJ4AAAAASUVORK5CYII=',
				particle1: '#ddb0b5',
				particle2: '#e1caaa',
				particle3: '#f0e6e7',

				fixedBackgroundEnabled: false,
				backgroundMap: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAgAAAAQAAgMAAADqxglTAAAADFBMVEVqiGn///+3W1z69fU/9oBiAAACAklEQVR4Ae3VsRHCQAxEUZpUQgn05QDcmZs40hsgw5o9z7yfbfYi6aZ4kiRJkiRJkiRJkiRJkiRJkiRJkiRJkiRJkiocAAAAwAqA+2tqng1tVR/zCwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA0F4eAAAAAHDqKd7HOKK/4Fn1uDwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgWhwAAAAA4BcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD8DQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAANjHOE4GNLc+AAAAAGCaHW0/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4fIAAAAAgHSSJEmSJEmSJEmSJEmSJEmSJEmSJEmSJEmS9AYHbvXxZPkJKgAAAABJRU5ErkJggg==',
				backgroundColor: '#fff'
			}
		};
	</script>
	<script type='text/javascript'>
		! function (t) {
			var e = {};

			function i(n) {
				if (e[n]) return e[n].exports;
				var r = e[n] = {
					i: n,
					l: !1,
					exports: {}
				};
				return t[n].call(r.exports, r, r.exports, i), r.l = !0, r.exports
			}
			i.m = t, i.c = e, i.d = function (t, e, n) {
				i.o(t, e) || Object.defineProperty(t, e, {
					enumerable: !0,
					get: n
				})
			}, i.r = function (t) {
				"undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, {
					value: "Module"
				}), Object.defineProperty(t, "__esModule", {
					value: !0
				})
			}, i.t = function (t, e) {
				if (1 & e && (t = i(t)), 8 & e) return t;
				if (4 & e && "object" == typeof t && t && t.__esModule) return t;
				var n = Object.create(null);
				if (i.r(n), Object.defineProperty(n, "default", {
						enumerable: !0,
						value: t
					}), 2 & e && "string" != typeof t)
					for (var r in t) i.d(n, r, function (e) {
						return t[e]
					}.bind(null, r));
				return n
			}, i.n = function (t) {
				var e = t && t.__esModule ? function () {
					return t.default
				} : function () {
					return t
				};
				return i.d(e, "a", e), e
			}, i.o = function (t, e) {
				return Object.prototype.hasOwnProperty.call(t, e)
			}, i.p = "", i(i.s = 0)
		}([function (t, e, i) {
			"use strict";
			i.r(e);
			var n = i(1);
			window.onload = function () {
				new n.default(_gameplay).launch()
			}
		}, function (t, e, i) {
			"use strict";
			i.r(e);
			var n = i(2);

			function r(t) {
				this._gameOptions = t
			}
			r.prototype = {
				start: function () {
					window.game = new n.default(this._gameOptions)
				},
				launch: function () {
					window._voodooExit = function () {}
					this.start();

					return this
				}
			}, e.default = r
		}, function (t, e, i) {
			"use strict";
			i.r(e);
			var n = i(3),
				r = i(4),
				a = i(6),
				o = i(10),
				s = i(13),
				c = i(14),
				h = (i(15), i(16));

			function l(t) {
				var e, i = this,
					a = document.getElementById("canvas");
				this._settings = t, this._renderLoop = new s.default, this._renderer = new n.WebGLRenderer({
						canvas: a,
						context: a.getContext("webgl"),
						antialias: !0
					}), this._renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)), this._interface = new r
					.default({
						onResize: function (t, e, i) {
							this._player.updateCamera(e / i), this._renderer.setSize(e, i)
						}.bind(this),
						onClickStartScreen: function () {
							i._interface.switchScreen("start", "game"), i._match.start()
						},
						onClickRetry: function (t) {
							t.preventDefault(), t.stopPropagation(), i.resetGame(), i._interface.switchScreen(
								"end", "start")
						}
					}), this._statesManager = new h.default({
						debug: !1,
						states: ["intro", "match", "end of level", "game over", "static"]
					}), this._scene = new n.Scene, e = this._interface.getEvents(), this._pointer = {
						isDown: !1,
						start: new n.Vector3,
						delta: new n.Vector3
					}, document.addEventListener(e.pointerdown, function (t) {
						t = u(t), this._pointer.isDown = !0, this._pointer.start.x = t.clientX, this._pointer
							.delta.x = 0, this._player.startMoveX()
					}.bind(this)), document.addEventListener(e.pointermove, function (t) {
						t = u(t), this._pointer.isDown && (this._pointer.delta.x = t.clientX - this._pointer.start
							.x, this._player.moveX(this._pointer.delta.x / 10))
					}.bind(this)), document.addEventListener(e.pointerup, function (t) {
						t = u(t), this._pointer.isDown = !1, this._pointer.delta.x = 0
					}.bind(this)), this._background = new c.default(this._settings.background), this._scene.add(this
						._background.getObject()), this.initializeGame(), this._interface.switchScreen("loading",
						"start")
			}
			l.prototype = {
				resetGame: function () {
					return this.stopRender(), this._scene.remove(this._match.getObject(), this._player
						.getObject()), this.initializeGame(), this
				},
				initializeGame: function () {
					return this._player = new a.default(this._settings.player), this._scene.add(this._player
							.getObject()), this._match = new o.default({
							player: this._player,
							opponent: this._settings.opponent,
							boss: this._settings.boss,
							ball: this._settings.ball,
							nbMatchByLevel: this._settings.nbMatchByLevel,
							maxLevel: this._settings.maxLevel
						}), this._match.initialize(), this._scene.add(this._match.getObject()), this._player
						.show(), this._statesManager.set("match"), this._interface.triggerResize(), this
						._renderLoop.setTimeScale(1), this.startRender(), this
				},
				startRender: function () {
					var t = this,
						e = this._renderer,
						i = this._scene,
						n = this._player,
						r = this._statesManager,
						a = this._interface,
						o = this._match,
						s = this._settings,
						c = this._background,
						h = n.getCamera();
					return this._renderLoop.start(function (l, u) {
						n.update(l, u), o.update(l, u), c.update(l, u), r.is("match") && (o
							.isBallCatched() && t._renderLoop.setTimeScale(Math.min(t._renderLoop
								.getTimeScale() + s.speedIncrementation, s.maxSpeed)), o
							.isOpponentDead() ? o.hasReachedMaxLevel() ? (r.set("static"), a
								.switchScreen("game", "end")) : (a.setProgress(o.getProgress())
								.showRandomWord(), r.set("static"), n.replace({
									onComplete: function () {
										r.set("match"), o.initialize(), o.isBossMatch() ?
											setTimeout(function () {
												a.showBossInfos(o.getBossInfos(),
													function () {
														o.start(500)
													})
											}, 1e3) : o.start(2e3)
									}
								})) : n.isAlive() || (r.set("static"), a.switchScreen("game",
								"end"))), e.render(i, h)
					}), this
				},
				stopRender: function () {
					return this._renderLoop.stop(), this
				}
			};
			var u = function (t) {
				return (u = t.touches ? function (t) {
					return t.touches[0]
				} : function (t) {
					return t
				})(t)
			};
			e.default = l
		}, function (t, e, i) {
			! function (t) {
				"use strict";

				function e() {}
				void 0 === Number.EPSILON && (Number.EPSILON = Math.pow(2, -52)), void 0 === Number.isInteger && (
					Number.isInteger = function (t) {
						return "number" == typeof t && isFinite(t) && Math.floor(t) === t
					}), void 0 === Math.sign && (Math.sign = function (t) {
					return t < 0 ? -1 : t > 0 ? 1 : +t
				}), "name" in Function.prototype == 0 && Object.defineProperty(Function.prototype, "name", {
					get: function () {
						return this.toString().match(/^\s*function\s*([^\(\s]*)/)[1]
					}
				}), void 0 === Object.assign && (Object.assign = function (t) {
					if (null == t) throw new TypeError("Cannot convert undefined or null to object");
					for (var e = Object(t), i = 1; i < arguments.length; i++) {
						var n = arguments[i];
						if (null != n)
							for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r])
					}
					return e
				}), Object.assign(e.prototype, {
					addEventListener: function (t, e) {
						void 0 === this._listeners && (this._listeners = {});
						var i = this._listeners;
						void 0 === i[t] && (i[t] = []), -1 === i[t].indexOf(e) && i[t].push(e)
					},
					hasEventListener: function (t, e) {
						if (void 0 === this._listeners) return !1;
						var i = this._listeners;
						return void 0 !== i[t] && -1 !== i[t].indexOf(e)
					},
					removeEventListener: function (t, e) {
						if (void 0 !== this._listeners) {
							var i = this._listeners,
								n = i[t];
							if (void 0 !== n) {
								var r = n.indexOf(e); - 1 !== r && n.splice(r, 1)
							}
						}
					},
					dispatchEvent: function (t) {
						if (void 0 !== this._listeners) {
							var e = this._listeners,
								i = e[t.type];
							if (void 0 !== i) {
								t.target = this;
								for (var n = i.slice(0), r = 0, a = n.length; r < a; r++) n[r].call(this,
									t)
							}
						}
					}
				});
				var i, n, r, a, o, s, c, h, l, u, p, d, f = "100",
					m = 0,
					g = 1,
					v = 2,
					y = 1,
					x = 2,
					b = 0,
					_ = 1,
					w = 2,
					M = 0,
					S = 1,
					E = 2,
					T = 0,
					A = 1,
					L = 2,
					P = 3,
					C = 4,
					R = 5,
					O = 100,
					I = 101,
					D = 102,
					B = 103,
					z = 104,
					N = 200,
					U = 201,
					G = 202,
					F = 203,
					H = 204,
					k = 205,
					j = 206,
					V = 207,
					W = 208,
					q = 209,
					X = 210,
					Y = 0,
					J = 1,
					Z = 2,
					Q = 3,
					K = 4,
					$ = 5,
					tt = 6,
					et = 7,
					it = 0,
					nt = 1,
					rt = 2,
					at = 0,
					ot = 1,
					st = 2,
					ct = 3,
					ht = 4,
					lt = 5,
					ut = 301,
					pt = 302,
					dt = 303,
					ft = 304,
					mt = 305,
					gt = 306,
					vt = 307,
					yt = 1e3,
					xt = 1001,
					bt = 1002,
					_t = 1003,
					wt = 1004,
					Mt = 1005,
					St = 1006,
					Et = 1007,
					Tt = 1008,
					At = 1009,
					Lt = 1010,
					Pt = 1011,
					Ct = 1012,
					Rt = 1013,
					Ot = 1014,
					It = 1015,
					Dt = 1016,
					Bt = 1017,
					zt = 1018,
					Nt = 1019,
					Ut = 1020,
					Gt = 1021,
					Ft = 1022,
					Ht = 1023,
					kt = 1024,
					jt = 1025,
					Vt = Ht,
					Wt = 1026,
					qt = 1027,
					Xt = 1028,
					Yt = 33776,
					Jt = 33777,
					Zt = 33778,
					Qt = 33779,
					Kt = 35840,
					$t = 35841,
					te = 35842,
					ee = 35843,
					ie = 36196,
					ne = 37808,
					re = 37809,
					ae = 37810,
					oe = 37811,
					se = 37812,
					ce = 37813,
					he = 37814,
					le = 37815,
					ue = 37816,
					pe = 37817,
					de = 37818,
					fe = 37819,
					me = 37820,
					ge = 37821,
					ve = 2201,
					ye = 2400,
					xe = 0,
					be = 1,
					_e = 2,
					we = 3e3,
					Me = 3001,
					Se = 3007,
					Ee = 3002,
					Te = 3004,
					Ae = 3005,
					Le = 3006,
					Pe = 3200,
					Ce = 3201,
					Re = 0,
					Oe = 1,
					Ie = {
						DEG2RAD: Math.PI / 180,
						RAD2DEG: 180 / Math.PI,
						generateUUID: function () {
							for (var t = [], e = 0; e < 256; e++) t[e] = (e < 16 ? "0" : "") + e.toString(16);
							return function () {
								var e = 4294967295 * Math.random() | 0,
									i = 4294967295 * Math.random() | 0,
									n = 4294967295 * Math.random() | 0,
									r = 4294967295 * Math.random() | 0,
									a = t[255 & e] + t[e >> 8 & 255] + t[e >> 16 & 255] + t[e >> 24 & 255] +
									"-" + t[255 & i] + t[i >> 8 & 255] + "-" + t[i >> 16 & 15 | 64] + t[i >>
										24 & 255] + "-" + t[63 & n | 128] + t[n >> 8 & 255] + "-" + t[n >>
										16 & 255] + t[n >> 24 & 255] + t[255 & r] + t[r >> 8 & 255] + t[r >>
										16 & 255] + t[r >> 24 & 255];
								return a.toUpperCase()
							}
						}(),
						clamp: function (t, e, i) {
							return Math.max(e, Math.min(i, t))
						},
						euclideanModulo: function (t, e) {
							return (t % e + e) % e
						},
						mapLinear: function (t, e, i, n, r) {
							return n + (t - e) * (r - n) / (i - e)
						},
						lerp: function (t, e, i) {
							return (1 - i) * t + i * e
						},
						smoothstep: function (t, e, i) {
							return t <= e ? 0 : t >= i ? 1 : (t = (t - e) / (i - e)) * t * (3 - 2 * t)
						},
						smootherstep: function (t, e, i) {
							return t <= e ? 0 : t >= i ? 1 : (t = (t - e) / (i - e)) * t * t * (t * (6 * t - 15) +
								10)
						},
						randInt: function (t, e) {
							return t + Math.floor(Math.random() * (e - t + 1))
						},
						randFloat: function (t, e) {
							return t + Math.random() * (e - t)
						},
						randFloatSpread: function (t) {
							return t * (.5 - Math.random())
						},
						degToRad: function (t) {
							return t * Ie.DEG2RAD
						},
						radToDeg: function (t) {
							return t * Ie.RAD2DEG
						},
						isPowerOfTwo: function (t) {
							return 0 == (t & t - 1) && 0 !== t
						},
						ceilPowerOfTwo: function (t) {
							return Math.pow(2, Math.ceil(Math.log(t) / Math.LN2))
						},
						floorPowerOfTwo: function (t) {
							return Math.pow(2, Math.floor(Math.log(t) / Math.LN2))
						}
					};

				function De(t, e) {
					this.x = t || 0, this.y = e || 0
				}

				function Be() {
					this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], arguments.length > 0 && console
						.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")
				}

				function ze(t, e, i, n) {
					this._x = t || 0, this._y = e || 0, this._z = i || 0, this._w = void 0 !== n ? n : 1
				}

				function Ne(t, e, i) {
					this.x = t || 0, this.y = e || 0, this.z = i || 0
				}

				function Ue() {
					this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1], arguments.length > 0 && console.error(
						"THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")
				}
				Object.defineProperties(De.prototype, {
					width: {
						get: function () {
							return this.x
						},
						set: function (t) {
							this.x = t
						}
					},
					height: {
						get: function () {
							return this.y
						},
						set: function (t) {
							this.y = t
						}
					}
				}), Object.assign(De.prototype, {
					isVector2: !0,
					set: function (t, e) {
						return this.x = t, this.y = e, this
					},
					setScalar: function (t) {
						return this.x = t, this.y = t, this
					},
					setX: function (t) {
						return this.x = t, this
					},
					setY: function (t) {
						return this.y = t, this
					},
					setComponent: function (t, e) {
						switch (t) {
							case 0:
								this.x = e;
								break;
							case 1:
								this.y = e;
								break;
							default:
								throw new Error("index is out of range: " + t)
						}
						return this
					},
					getComponent: function (t) {
						switch (t) {
							case 0:
								return this.x;
							case 1:
								return this.y;
							default:
								throw new Error("index is out of range: " + t)
						}
					},
					clone: function () {
						return new this.constructor(this.x, this.y)
					},
					copy: function (t) {
						return this.x = t.x, this.y = t.y, this
					},
					add: function (t, e) {
						return void 0 !== e ? (console.warn(
							"THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."
							), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this)
					},
					addScalar: function (t) {
						return this.x += t, this.y += t, this
					},
					addVectors: function (t, e) {
						return this.x = t.x + e.x, this.y = t.y + e.y, this
					},
					addScaledVector: function (t, e) {
						return this.x += t.x * e, this.y += t.y * e, this
					},
					sub: function (t, e) {
						return void 0 !== e ? (console.warn(
							"THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."
							), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this)
					},
					subScalar: function (t) {
						return this.x -= t, this.y -= t, this
					},
					subVectors: function (t, e) {
						return this.x = t.x - e.x, this.y = t.y - e.y, this
					},
					multiply: function (t) {
						return this.x *= t.x, this.y *= t.y, this
					},
					multiplyScalar: function (t) {
						return this.x *= t, this.y *= t, this
					},
					divide: function (t) {
						return this.x /= t.x, this.y /= t.y, this
					},
					divideScalar: function (t) {
						return this.multiplyScalar(1 / t)
					},
					applyMatrix3: function (t) {
						var e = this.x,
							i = this.y,
							n = t.elements;
						return this.x = n[0] * e + n[3] * i + n[6], this.y = n[1] * e + n[4] * i + n[7],
							this
					},
					min: function (t) {
						return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this
					},
					max: function (t) {
						return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this
					},
					clamp: function (t, e) {
						return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math
							.min(e.y, this.y)), this
					},
					clampScalar: (p = new De, d = new De, function (t, e) {
						return p.set(t, t), d.set(e, e), this.clamp(p, d)
					}),
					clampLength: function (t, e) {
						var i = this.length();
						return this.divideScalar(i || 1).multiplyScalar(Math.max(t, Math.min(e, i)))
					},
					floor: function () {
						return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this
					},
					ceil: function () {
						return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this
					},
					round: function () {
						return this.x = Math.round(this.x), this.y = Math.round(this.y), this
					},
					roundToZero: function () {
						return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this
							.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this
					},
					negate: function () {
						return this.x = -this.x, this.y = -this.y, this
					},
					dot: function (t) {
						return this.x * t.x + this.y * t.y
					},
					cross: function (t) {
						return this.x * t.y - this.y * t.x
					},
					lengthSq: function () {
						return this.x * this.x + this.y * this.y
					},
					length: function () {
						return Math.sqrt(this.x * this.x + this.y * this.y)
					},
					manhattanLength: function () {
						return Math.abs(this.x) + Math.abs(this.y)
					},
					normalize: function () {
						return this.divideScalar(this.length() || 1)
					},
					angle: function () {
						var t = Math.atan2(this.y, this.x);
						return t < 0 && (t += 2 * Math.PI), t
					},
					distanceTo: function (t) {
						return Math.sqrt(this.distanceToSquared(t))
					},
					distanceToSquared: function (t) {
						var e = this.x - t.x,
							i = this.y - t.y;
						return e * e + i * i
					},
					manhattanDistanceTo: function (t) {
						return Math.abs(this.x - t.x) + Math.abs(this.y - t.y)
					},
					setLength: function (t) {
						return this.normalize().multiplyScalar(t)
					},
					lerp: function (t, e) {
						return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this
					},
					lerpVectors: function (t, e, i) {
						return this.subVectors(e, t).multiplyScalar(i).add(t)
					},
					equals: function (t) {
						return t.x === this.x && t.y === this.y
					},
					fromArray: function (t, e) {
						return void 0 === e && (e = 0), this.x = t[e], this.y = t[e + 1], this
					},
					toArray: function (t, e) {
						return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this.x, t[e +
							1] = this.y, t
					},
					fromBufferAttribute: function (t, e, i) {
						return void 0 !== i && console.warn(
								"THREE.Vector2: offset has been removed from .fromBufferAttribute()."),
							this.x = t.getX(e), this.y = t.getY(e), this
					},
					rotateAround: function (t, e) {
						var i = Math.cos(e),
							n = Math.sin(e),
							r = this.x - t.x,
							a = this.y - t.y;
						return this.x = r * i - a * n + t.x, this.y = r * n + a * i + t.y, this
					}
				}), Object.assign(Be.prototype, {
					isMatrix4: !0,
					set: function (t, e, i, n, r, a, o, s, c, h, l, u, p, d, f, m) {
						var g = this.elements;
						return g[0] = t, g[4] = e, g[8] = i, g[12] = n, g[1] = r, g[5] = a, g[9] = o, g[
							13] = s, g[2] = c, g[6] = h, g[10] = l, g[14] = u, g[3] = p, g[7] = d, g[
							11] = f, g[15] = m, this
					},
					identity: function () {
						return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
					},
					clone: function () {
						return (new Be).fromArray(this.elements)
					},
					copy: function (t) {
						var e = this.elements,
							i = t.elements;
						return e[0] = i[0], e[1] = i[1], e[2] = i[2], e[3] = i[3], e[4] = i[4], e[5] = i[
								5], e[6] = i[6], e[7] = i[7], e[8] = i[8], e[9] = i[9], e[10] = i[10], e[
								11] = i[11], e[12] = i[12], e[13] = i[13], e[14] = i[14], e[15] = i[15],
							this
					},
					copyPosition: function (t) {
						var e = this.elements,
							i = t.elements;
						return e[12] = i[12], e[13] = i[13], e[14] = i[14], this
					},
					extractBasis: function (t, e, i) {
						return t.setFromMatrixColumn(this, 0), e.setFromMatrixColumn(this, 1), i
							.setFromMatrixColumn(this, 2), this
					},
					makeBasis: function (t, e, i) {
						return this.set(t.x, e.x, i.x, 0, t.y, e.y, i.y, 0, t.z, e.z, i.z, 0, 0, 0, 0, 1),
							this
					},
					extractRotation: (u = new Ne, function (t) {
						var e = this.elements,
							i = t.elements,
							n = 1 / u.setFromMatrixColumn(t, 0).length(),
							r = 1 / u.setFromMatrixColumn(t, 1).length(),
							a = 1 / u.setFromMatrixColumn(t, 2).length();
						return e[0] = i[0] * n, e[1] = i[1] * n, e[2] = i[2] * n, e[3] = 0, e[4] = i[
								4] * r, e[5] = i[5] * r, e[6] = i[6] * r, e[7] = 0, e[8] = i[8] * a,
							e[9] = i[9] * a, e[10] = i[10] * a, e[11] = 0, e[12] = 0, e[13] = 0, e[
							14] = 0, e[15] = 1, this
					}),
					makeRotationFromEuler: function (t) {
						t && t.isEuler || console.error(
							"THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order."
							);
						var e = this.elements,
							i = t.x,
							n = t.y,
							r = t.z,
							a = Math.cos(i),
							o = Math.sin(i),
							s = Math.cos(n),
							c = Math.sin(n),
							h = Math.cos(r),
							l = Math.sin(r);
						if ("XYZ" === t.order) {
							var u = a * h,
								p = a * l,
								d = o * h,
								f = o * l;
							e[0] = s * h, e[4] = -s * l, e[8] = c, e[1] = p + d * c, e[5] = u - f * c, e[
								9] = -o * s, e[2] = f - u * c, e[6] = d + p * c, e[10] = a * s
						} else if ("YXZ" === t.order) {
							var m = s * h,
								g = s * l,
								v = c * h,
								y = c * l;
							e[0] = m + y * o, e[4] = v * o - g, e[8] = a * c, e[1] = a * l, e[5] = a * h,
								e[9] = -o, e[2] = g * o - v, e[6] = y + m * o, e[10] = a * s
						} else if ("ZXY" === t.order) {
							var m = s * h,
								g = s * l,
								v = c * h,
								y = c * l;
							e[0] = m - y * o, e[4] = -a * l, e[8] = v + g * o, e[1] = g + v * o, e[5] =
								a * h, e[9] = y - m * o, e[2] = -a * c, e[6] = o, e[10] = a * s
						} else if ("ZYX" === t.order) {
							var u = a * h,
								p = a * l,
								d = o * h,
								f = o * l;
							e[0] = s * h, e[4] = d * c - p, e[8] = u * c + f, e[1] = s * l, e[5] = f * c +
								u, e[9] = p * c - d, e[2] = -c, e[6] = o * s, e[10] = a * s
						} else if ("YZX" === t.order) {
							var x = a * s,
								b = a * c,
								_ = o * s,
								w = o * c;
							e[0] = s * h, e[4] = w - x * l, e[8] = _ * l + b, e[1] = l, e[5] = a * h, e[
								9] = -o * h, e[2] = -c * h, e[6] = b * l + _, e[10] = x - w * l
						} else if ("XZY" === t.order) {
							var x = a * s,
								b = a * c,
								_ = o * s,
								w = o * c;
							e[0] = s * h, e[4] = -l, e[8] = c * h, e[1] = x * l + w, e[5] = a * h, e[9] =
								b * l - _, e[2] = _ * l - b, e[6] = o * h, e[10] = w * l + x
						}
						return e[3] = 0, e[7] = 0, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1,
							this
					},
					makeRotationFromQuaternion: (h = new Ne(0, 0, 0), l = new Ne(1, 1, 1), function (t) {
						return this.compose(h, t, l)
					}),
					lookAt: (o = new Ne, s = new Ne, c = new Ne, function (t, e, i) {
						var n = this.elements;
						return c.subVectors(t, e), 0 === c.lengthSq() && (c.z = 1), c.normalize(), o
							.crossVectors(i, c), 0 === o.lengthSq() && (1 === Math.abs(i.z) ? c.x +=
								1e-4 : c.z += 1e-4, c.normalize(), o.crossVectors(i, c)), o
							.normalize(), s.crossVectors(c, o), n[0] = o.x, n[4] = s.x, n[8] = c.x, n[
								1] = o.y, n[5] = s.y, n[9] = c.y, n[2] = o.z, n[6] = s.z, n[10] = c.z,
							this
					}),
					multiply: function (t, e) {
						return void 0 !== e ? (console.warn(
							"THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."
							), this.multiplyMatrices(t, e)) : this.multiplyMatrices(this, t)
					},
					premultiply: function (t) {
						return this.multiplyMatrices(t, this)
					},
					multiplyMatrices: function (t, e) {
						var i = t.elements,
							n = e.elements,
							r = this.elements,
							a = i[0],
							o = i[4],
							s = i[8],
							c = i[12],
							h = i[1],
							l = i[5],
							u = i[9],
							p = i[13],
							d = i[2],
							f = i[6],
							m = i[10],
							g = i[14],
							v = i[3],
							y = i[7],
							x = i[11],
							b = i[15],
							_ = n[0],
							w = n[4],
							M = n[8],
							S = n[12],
							E = n[1],
							T = n[5],
							A = n[9],
							L = n[13],
							P = n[2],
							C = n[6],
							R = n[10],
							O = n[14],
							I = n[3],
							D = n[7],
							B = n[11],
							z = n[15];
						return r[0] = a * _ + o * E + s * P + c * I, r[4] = a * w + o * T + s * C + c * D,
							r[8] = a * M + o * A + s * R + c * B, r[12] = a * S + o * L + s * O + c * z,
							r[1] = h * _ + l * E + u * P + p * I, r[5] = h * w + l * T + u * C + p * D, r[
								9] = h * M + l * A + u * R + p * B, r[13] = h * S + l * L + u * O + p * z,
							r[2] = d * _ + f * E + m * P + g * I, r[6] = d * w + f * T + m * C + g * D, r[
								10] = d * M + f * A + m * R + g * B, r[14] = d * S + f * L + m * O + g *
							z, r[3] = v * _ + y * E + x * P + b * I, r[7] = v * w + y * T + x * C + b * D,
							r[11] = v * M + y * A + x * R + b * B, r[15] = v * S + y * L + x * O + b * z,
							this
					},
					multiplyScalar: function (t) {
						var e = this.elements;
						return e[0] *= t, e[4] *= t, e[8] *= t, e[12] *= t, e[1] *= t, e[5] *= t, e[9] *=
							t, e[13] *= t, e[2] *= t, e[6] *= t, e[10] *= t, e[14] *= t, e[3] *= t, e[
							7] *= t, e[11] *= t, e[15] *= t, this
					},
					applyToBufferAttribute: function () {
						var t = new Ne;
						return function (e) {
							for (var i = 0, n = e.count; i < n; i++) t.x = e.getX(i), t.y = e.getY(i),
								t.z = e.getZ(i), t.applyMatrix4(this), e.setXYZ(i, t.x, t.y, t.z);
							return e
						}
					}(),
					determinant: function () {
						var t = this.elements,
							e = t[0],
							i = t[4],
							n = t[8],
							r = t[12],
							a = t[1],
							o = t[5],
							s = t[9],
							c = t[13],
							h = t[2],
							l = t[6],
							u = t[10],
							p = t[14],
							d = t[3],
							f = t[7],
							m = t[11],
							g = t[15];
						return d * (+r * s * l - n * c * l - r * o * u + i * c * u + n * o * p - i * s *
							p) + f * (+e * s * p - e * c * u + r * a * u - n * a * p + n * c * h - r *
							s * h) + m * (+e * c * l - e * o * p - r * a * l + i * a * p + r * o * h -
							i * c * h) + g * (-n * o * h - e * s * l + e * o * u + n * a * l - i * a *
							u + i * s * h)
					},
					transpose: function () {
						var t, e = this.elements;
						return t = e[1], e[1] = e[4], e[4] = t, t = e[2], e[2] = e[8], e[8] = t, t = e[6],
							e[6] = e[9], e[9] = t, t = e[3], e[3] = e[12], e[12] = t, t = e[7], e[7] = e[
								13], e[13] = t, t = e[11], e[11] = e[14], e[14] = t, this
					},
					setPosition: function (t) {
						var e = this.elements;
						return e[12] = t.x, e[13] = t.y, e[14] = t.z, this
					},
					getInverse: function (t, e) {
						var i = this.elements,
							n = t.elements,
							r = n[0],
							a = n[1],
							o = n[2],
							s = n[3],
							c = n[4],
							h = n[5],
							l = n[6],
							u = n[7],
							p = n[8],
							d = n[9],
							f = n[10],
							m = n[11],
							g = n[12],
							v = n[13],
							y = n[14],
							x = n[15],
							b = d * y * u - v * f * u + v * l * m - h * y * m - d * l * x + h * f * x,
							_ = g * f * u - p * y * u - g * l * m + c * y * m + p * l * x - c * f * x,
							w = p * v * u - g * d * u + g * h * m - c * v * m - p * h * x + c * d * x,
							M = g * d * l - p * v * l - g * h * f + c * v * f + p * h * y - c * d * y,
							S = r * b + a * _ + o * w + s * M;
						if (0 === S) {
							var E = "THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0";
							if (!0 === e) throw new Error(E);
							return console.warn(E), this.identity()
						}
						var T = 1 / S;
						return i[0] = b * T, i[1] = (v * f * s - d * y * s - v * o * m + a * y * m + d *
								o * x - a * f * x) * T, i[2] = (h * y * s - v * l * s + v * o * u - a *
								y * u - h * o * x + a * l * x) * T, i[3] = (d * l * s - h * f * s - d *
								o * u + a * f * u + h * o * m - a * l * m) * T, i[4] = _ * T, i[5] = (p *
								y * s - g * f * s + g * o * m - r * y * m - p * o * x + r * f * x) * T, i[
								6] = (g * l * s - c * y * s - g * o * u + r * y * u + c * o * x - r * l *
								x) * T, i[7] = (c * f * s - p * l * s + p * o * u - r * f * u - c * o *
								m + r * l * m) * T, i[8] = w * T, i[9] = (g * d * s - p * v * s - g * a *
								m + r * v * m + p * a * x - r * d * x) * T, i[10] = (c * v * s - g * h *
								s + g * a * u - r * v * u - c * a * x + r * h * x) * T, i[11] = (p * h *
								s - c * d * s - p * a * u + r * d * u + c * a * m - r * h * m) * T, i[
							12] = M * T, i[13] = (p * v * o - g * d * o + g * a * f - r * v * f - p * a *
								y + r * d * y) * T, i[14] = (g * h * o - c * v * o - g * a * l + r * v *
								l + c * a * y - r * h * y) * T, i[15] = (c * d * o - p * h * o + p * a *
								l - r * d * l - c * a * f + r * h * f) * T, this
					},
					scale: function (t) {
						var e = this.elements,
							i = t.x,
							n = t.y,
							r = t.z;
						return e[0] *= i, e[4] *= n, e[8] *= r, e[1] *= i, e[5] *= n, e[9] *= r, e[2] *=
							i, e[6] *= n, e[10] *= r, e[3] *= i, e[7] *= n, e[11] *= r, this
					},
					getMaxScaleOnAxis: function () {
						var t = this.elements,
							e = t[0] * t[0] + t[1] * t[1] + t[2] * t[2],
							i = t[4] * t[4] + t[5] * t[5] + t[6] * t[6],
							n = t[8] * t[8] + t[9] * t[9] + t[10] * t[10];
						return Math.sqrt(Math.max(e, i, n))
					},
					makeTranslation: function (t, e, i) {
						return this.set(1, 0, 0, t, 0, 1, 0, e, 0, 0, 1, i, 0, 0, 0, 1), this
					},
					makeRotationX: function (t) {
						var e = Math.cos(t),
							i = Math.sin(t);
						return this.set(1, 0, 0, 0, 0, e, -i, 0, 0, i, e, 0, 0, 0, 0, 1), this
					},
					makeRotationY: function (t) {
						var e = Math.cos(t),
							i = Math.sin(t);
						return this.set(e, 0, i, 0, 0, 1, 0, 0, -i, 0, e, 0, 0, 0, 0, 1), this
					},
					makeRotationZ: function (t) {
						var e = Math.cos(t),
							i = Math.sin(t);
						return this.set(e, -i, 0, 0, i, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
					},
					makeRotationAxis: function (t, e) {
						var i = Math.cos(e),
							n = Math.sin(e),
							r = 1 - i,
							a = t.x,
							o = t.y,
							s = t.z,
							c = r * a,
							h = r * o;
						return this.set(c * a + i, c * o - n * s, c * s + n * o, 0, c * o + n * s, h * o +
							i, h * s - n * a, 0, c * s - n * o, h * s + n * a, r * s * s + i, 0, 0, 0,
							0, 1), this
					},
					makeScale: function (t, e, i) {
						return this.set(t, 0, 0, 0, 0, e, 0, 0, 0, 0, i, 0, 0, 0, 0, 1), this
					},
					makeShear: function (t, e, i) {
						return this.set(1, e, i, 0, t, 1, i, 0, t, e, 1, 0, 0, 0, 0, 1), this
					},
					compose: function (t, e, i) {
						var n = this.elements,
							r = e._x,
							a = e._y,
							o = e._z,
							s = e._w,
							c = r + r,
							h = a + a,
							l = o + o,
							u = r * c,
							p = r * h,
							d = r * l,
							f = a * h,
							m = a * l,
							g = o * l,
							v = s * c,
							y = s * h,
							x = s * l,
							b = i.x,
							_ = i.y,
							w = i.z;
						return n[0] = (1 - (f + g)) * b, n[1] = (p + x) * b, n[2] = (d - y) * b, n[3] = 0,
							n[4] = (p - x) * _, n[5] = (1 - (u + g)) * _, n[6] = (m + v) * _, n[7] = 0, n[
								8] = (d + y) * w, n[9] = (m - v) * w, n[10] = (1 - (u + f)) * w, n[11] =
							0, n[12] = t.x, n[13] = t.y, n[14] = t.z, n[15] = 1, this
					},
					decompose: (r = new Ne, a = new Be, function (t, e, i) {
						var n = this.elements,
							o = r.set(n[0], n[1], n[2]).length(),
							s = r.set(n[4], n[5], n[6]).length(),
							c = r.set(n[8], n[9], n[10]).length(),
							h = this.determinant();
						h < 0 && (o = -o), t.x = n[12], t.y = n[13], t.z = n[14], a.copy(this);
						var l = 1 / o,
							u = 1 / s,
							p = 1 / c;
						return a.elements[0] *= l, a.elements[1] *= l, a.elements[2] *= l, a.elements[
								4] *= u, a.elements[5] *= u, a.elements[6] *= u, a.elements[8] *= p, a
							.elements[9] *= p, a.elements[10] *= p, e.setFromRotationMatrix(a), i.x =
							o, i.y = s, i.z = c, this
					}),
					makePerspective: function (t, e, i, n, r, a) {
						void 0 === a && console.warn(
							"THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs."
							);
						var o = this.elements,
							s = 2 * r / (e - t),
							c = 2 * r / (i - n),
							h = (e + t) / (e - t),
							l = (i + n) / (i - n),
							u = -(a + r) / (a - r),
							p = -2 * a * r / (a - r);
						return o[0] = s, o[4] = 0, o[8] = h, o[12] = 0, o[1] = 0, o[5] = c, o[9] = l, o[
							13] = 0, o[2] = 0, o[6] = 0, o[10] = u, o[14] = p, o[3] = 0, o[7] = 0, o[
							11] = -1, o[15] = 0, this
					},
					makeOrthographic: function (t, e, i, n, r, a) {
						var o = this.elements,
							s = 1 / (e - t),
							c = 1 / (i - n),
							h = 1 / (a - r),
							l = (e + t) * s,
							u = (i + n) * c,
							p = (a + r) * h;
						return o[0] = 2 * s, o[4] = 0, o[8] = 0, o[12] = -l, o[1] = 0, o[5] = 2 * c, o[
							9] = 0, o[13] = -u, o[2] = 0, o[6] = 0, o[10] = -2 * h, o[14] = -p, o[3] = 0,
							o[7] = 0, o[11] = 0, o[15] = 1, this
					},
					equals: function (t) {
						for (var e = this.elements, i = t.elements, n = 0; n < 16; n++)
							if (e[n] !== i[n]) return !1;
						return !0
					},
					fromArray: function (t, e) {
						void 0 === e && (e = 0);
						for (var i = 0; i < 16; i++) this.elements[i] = t[i + e];
						return this
					},
					toArray: function (t, e) {
						void 0 === t && (t = []), void 0 === e && (e = 0);
						var i = this.elements;
						return t[e] = i[0], t[e + 1] = i[1], t[e + 2] = i[2], t[e + 3] = i[3], t[e + 4] =
							i[4], t[e + 5] = i[5], t[e + 6] = i[6], t[e + 7] = i[7], t[e + 8] = i[8], t[
								e + 9] = i[9], t[e + 10] = i[10], t[e + 11] = i[11], t[e + 12] = i[12], t[
								e + 13] = i[13], t[e + 14] = i[14], t[e + 15] = i[15], t
					}
				}), Object.assign(ze, {
					slerp: function (t, e, i, n) {
						return i.copy(t).slerp(e, n)
					},
					slerpFlat: function (t, e, i, n, r, a, o) {
						var s = i[n + 0],
							c = i[n + 1],
							h = i[n + 2],
							l = i[n + 3],
							u = r[a + 0],
							p = r[a + 1],
							d = r[a + 2],
							f = r[a + 3];
						if (l !== f || s !== u || c !== p || h !== d) {
							var m = 1 - o,
								g = s * u + c * p + h * d + l * f,
								v = g >= 0 ? 1 : -1,
								y = 1 - g * g;
							if (y > Number.EPSILON) {
								var x = Math.sqrt(y),
									b = Math.atan2(x, g * v);
								m = Math.sin(m * b) / x, o = Math.sin(o * b) / x
							}
							var _ = o * v;
							if (s = s * m + u * _, c = c * m + p * _, h = h * m + d * _, l = l * m + f *
								_, m === 1 - o) {
								var w = 1 / Math.sqrt(s * s + c * c + h * h + l * l);
								s *= w, c *= w, h *= w, l *= w
							}
						}
						t[e] = s, t[e + 1] = c, t[e + 2] = h, t[e + 3] = l
					}
				}), Object.defineProperties(ze.prototype, {
					x: {
						get: function () {
							return this._x
						},
						set: function (t) {
							this._x = t, this.onChangeCallback()
						}
					},
					y: {
						get: function () {
							return this._y
						},
						set: function (t) {
							this._y = t, this.onChangeCallback()
						}
					},
					z: {
						get: function () {
							return this._z
						},
						set: function (t) {
							this._z = t, this.onChangeCallback()
						}
					},
					w: {
						get: function () {
							return this._w
						},
						set: function (t) {
							this._w = t, this.onChangeCallback()
						}
					}
				}), Object.assign(ze.prototype, {
					isQuaternion: !0,
					set: function (t, e, i, n) {
						return this._x = t, this._y = e, this._z = i, this._w = n, this
						.onChangeCallback(), this
					},
					clone: function () {
						return new this.constructor(this._x, this._y, this._z, this._w)
					},
					copy: function (t) {
						return this._x = t.x, this._y = t.y, this._z = t.z, this._w = t.w, this
							.onChangeCallback(), this
					},
					setFromEuler: function (t, e) {
						if (!t || !t.isEuler) throw new Error(
							"THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order."
							);
						var i = t._x,
							n = t._y,
							r = t._z,
							a = t.order,
							o = Math.cos,
							s = Math.sin,
							c = o(i / 2),
							h = o(n / 2),
							l = o(r / 2),
							u = s(i / 2),
							p = s(n / 2),
							d = s(r / 2);
						return "XYZ" === a ? (this._x = u * h * l + c * p * d, this._y = c * p * l - u *
								h * d, this._z = c * h * d + u * p * l, this._w = c * h * l - u * p * d) :
							"YXZ" === a ? (this._x = u * h * l + c * p * d, this._y = c * p * l - u * h *
								d, this._z = c * h * d - u * p * l, this._w = c * h * l + u * p * d) :
							"ZXY" === a ? (this._x = u * h * l - c * p * d, this._y = c * p * l + u * h *
								d, this._z = c * h * d + u * p * l, this._w = c * h * l - u * p * d) :
							"ZYX" === a ? (this._x = u * h * l - c * p * d, this._y = c * p * l + u * h *
								d, this._z = c * h * d - u * p * l, this._w = c * h * l + u * p * d) :
							"YZX" === a ? (this._x = u * h * l + c * p * d, this._y = c * p * l + u * h *
								d, this._z = c * h * d - u * p * l, this._w = c * h * l - u * p * d) :
							"XZY" === a && (this._x = u * h * l - c * p * d, this._y = c * p * l - u * h *
								d, this._z = c * h * d + u * p * l, this._w = c * h * l + u * p * d), !
							1 !== e && this.onChangeCallback(), this
					},
					setFromAxisAngle: function (t, e) {
						var i = e / 2,
							n = Math.sin(i);
						return this._x = t.x * n, this._y = t.y * n, this._z = t.z * n, this._w = Math
							.cos(i), this.onChangeCallback(), this
					},
					setFromRotationMatrix: function (t) {
						var e, i = t.elements,
							n = i[0],
							r = i[4],
							a = i[8],
							o = i[1],
							s = i[5],
							c = i[9],
							h = i[2],
							l = i[6],
							u = i[10],
							p = n + s + u;
						return p > 0 ? (e = .5 / Math.sqrt(p + 1), this._w = .25 / e, this._x = (l - c) *
							e, this._y = (a - h) * e, this._z = (o - r) * e) : n > s && n > u ? (e =
							2 * Math.sqrt(1 + n - s - u), this._w = (l - c) / e, this._x = .25 * e,
							this._y = (r + o) / e, this._z = (a + h) / e) : s > u ? (e = 2 * Math
							.sqrt(1 + s - n - u), this._w = (a - h) / e, this._x = (r + o) / e, this
							._y = .25 * e, this._z = (c + l) / e) : (e = 2 * Math.sqrt(1 + u - n - s),
							this._w = (o - r) / e, this._x = (a + h) / e, this._y = (c + l) / e, this
							._z = .25 * e), this.onChangeCallback(), this
					},
					setFromUnitVectors: function () {
						var t, e = new Ne;
						return function (i, n) {
							return void 0 === e && (e = new Ne), (t = i.dot(n) + 1) < 1e-6 ? (t = 0,
									Math.abs(i.x) > Math.abs(i.z) ? e.set(-i.y, i.x, 0) : e.set(0, -i
										.z, i.y)) : e.crossVectors(i, n), this._x = e.x, this._y = e
								.y, this._z = e.z, this._w = t, this.normalize()
						}
					}(),
					angleTo: function (t) {
						return 2 * Math.acos(Math.abs(Ie.clamp(this.dot(t), -1, 1)))
					},
					rotateTowards: function (t, e) {
						var i = this.angleTo(t);
						if (0 === i) return this;
						var n = Math.min(1, e / i);
						return this.slerp(t, n), this
					},
					inverse: function () {
						return this.conjugate()
					},
					conjugate: function () {
						return this._x *= -1, this._y *= -1, this._z *= -1, this.onChangeCallback(), this
					},
					dot: function (t) {
						return this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w
					},
					lengthSq: function () {
						return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this
							._w
					},
					length: function () {
						return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this
							._w * this._w)
					},
					normalize: function () {
						var t = this.length();
						return 0 === t ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (t = 1 /
							t, this._x = this._x * t, this._y = this._y * t, this._z = this._z * t,
							this._w = this._w * t), this.onChangeCallback(), this
					},
					multiply: function (t, e) {
						return void 0 !== e ? (console.warn(
							"THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."
							), this.multiplyQuaternions(t, e)) : this.multiplyQuaternions(this, t)
					},
					premultiply: function (t) {
						return this.multiplyQuaternions(t, this)
					},
					multiplyQuaternions: function (t, e) {
						var i = t._x,
							n = t._y,
							r = t._z,
							a = t._w,
							o = e._x,
							s = e._y,
							c = e._z,
							h = e._w;
						return this._x = i * h + a * o + n * c - r * s, this._y = n * h + a * s + r * o -
							i * c, this._z = r * h + a * c + i * s - n * o, this._w = a * h - i * o - n *
							s - r * c, this.onChangeCallback(), this
					},
					slerp: function (t, e) {
						if (0 === e) return this;
						if (1 === e) return this.copy(t);
						var i = this._x,
							n = this._y,
							r = this._z,
							a = this._w,
							o = a * t._w + i * t._x + n * t._y + r * t._z;
						if (o < 0 ? (this._w = -t._w, this._x = -t._x, this._y = -t._y, this._z = -t._z,
								o = -o) : this.copy(t), o >= 1) return this._w = a, this._x = i, this._y =
							n, this._z = r, this;
						var s = 1 - o * o;
						if (s <= Number.EPSILON) {
							var c = 1 - e;
							return this._w = c * a + e * this._w, this._x = c * i + e * this._x, this._y =
								c * n + e * this._y, this._z = c * r + e * this._z, this.normalize()
						}
						var h = Math.sqrt(s),
							l = Math.atan2(h, o),
							u = Math.sin((1 - e) * l) / h,
							p = Math.sin(e * l) / h;
						return this._w = a * u + this._w * p, this._x = i * u + this._x * p, this._y = n *
							u + this._y * p, this._z = r * u + this._z * p, this.onChangeCallback(), this
					},
					equals: function (t) {
						return t._x === this._x && t._y === this._y && t._z === this._z && t._w === this
							._w
					},
					fromArray: function (t, e) {
						return void 0 === e && (e = 0), this._x = t[e], this._y = t[e + 1], this._z = t[
							e + 2], this._w = t[e + 3], this.onChangeCallback(), this
					},
					toArray: function (t, e) {
						return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this._x, t[e +
							1] = this._y, t[e + 2] = this._z, t[e + 3] = this._w, t
					},
					onChange: function (t) {
						return this.onChangeCallback = t, this
					},
					onChangeCallback: function () {}
				}), Object.assign(Ne.prototype, {
					isVector3: !0,
					set: function (t, e, i) {
						return this.x = t, this.y = e, this.z = i, this
					},
					setScalar: function (t) {
						return this.x = t, this.y = t, this.z = t, this
					},
					setX: function (t) {
						return this.x = t, this
					},
					setY: function (t) {
						return this.y = t, this
					},
					setZ: function (t) {
						return this.z = t, this
					},
					setComponent: function (t, e) {
						switch (t) {
							case 0:
								this.x = e;
								break;
							case 1:
								this.y = e;
								break;
							case 2:
								this.z = e;
								break;
							default:
								throw new Error("index is out of range: " + t)
						}
						return this
					},
					getComponent: function (t) {
						switch (t) {
							case 0:
								return this.x;
							case 1:
								return this.y;
							case 2:
								return this.z;
							default:
								throw new Error("index is out of range: " + t)
						}
					},
					clone: function () {
						return new this.constructor(this.x, this.y, this.z)
					},
					copy: function (t) {
						return this.x = t.x, this.y = t.y, this.z = t.z, this
					},
					add: function (t, e) {
						return void 0 !== e ? (console.warn(
							"THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."
							), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this.z += t.z,
							this)
					},
					addScalar: function (t) {
						return this.x += t, this.y += t, this.z += t, this
					},
					addVectors: function (t, e) {
						return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this
					},
					addScaledVector: function (t, e) {
						return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this
					},
					sub: function (t, e) {
						return void 0 !== e ? (console.warn(
							"THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."
							), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this.z -= t.z,
							this)
					},
					subScalar: function (t) {
						return this.x -= t, this.y -= t, this.z -= t, this
					},
					subVectors: function (t, e) {
						return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this
					},
					multiply: function (t, e) {
						return void 0 !== e ? (console.warn(
							"THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."
							), this.multiplyVectors(t, e)) : (this.x *= t.x, this.y *= t.y, this.z *=
							t.z, this)
					},
					multiplyScalar: function (t) {
						return this.x *= t, this.y *= t, this.z *= t, this
					},
					multiplyVectors: function (t, e) {
						return this.x = t.x * e.x, this.y = t.y * e.y, this.z = t.z * e.z, this
					},
					applyEuler: (n = new ze, function (t) {
						return t && t.isEuler || console.error(
							"THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."
							), this.applyQuaternion(n.setFromEuler(t))
					}),
					applyAxisAngle: function () {
						var t = new ze;
						return function (e, i) {
							return this.applyQuaternion(t.setFromAxisAngle(e, i))
						}
					}(),
					applyMatrix3: function (t) {
						var e = this.x,
							i = this.y,
							n = this.z,
							r = t.elements;
						return this.x = r[0] * e + r[3] * i + r[6] * n, this.y = r[1] * e + r[4] * i + r[
							7] * n, this.z = r[2] * e + r[5] * i + r[8] * n, this
					},
					applyMatrix4: function (t) {
						var e = this.x,
							i = this.y,
							n = this.z,
							r = t.elements,
							a = 1 / (r[3] * e + r[7] * i + r[11] * n + r[15]);
						return this.x = (r[0] * e + r[4] * i + r[8] * n + r[12]) * a, this.y = (r[1] * e +
							r[5] * i + r[9] * n + r[13]) * a, this.z = (r[2] * e + r[6] * i + r[10] *
							n + r[14]) * a, this
					},
					applyQuaternion: function (t) {
						var e = this.x,
							i = this.y,
							n = this.z,
							r = t.x,
							a = t.y,
							o = t.z,
							s = t.w,
							c = s * e + a * n - o * i,
							h = s * i + o * e - r * n,
							l = s * n + r * i - a * e,
							u = -r * e - a * i - o * n;
						return this.x = c * s + u * -r + h * -o - l * -a, this.y = h * s + u * -a + l * -
							r - c * -o, this.z = l * s + u * -o + c * -a - h * -r, this
					},
					project: function (t) {
						return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix)
					},
					unproject: function () {
						var t = new Be;
						return function (e) {
							return this.applyMatrix4(t.getInverse(e.projectionMatrix)).applyMatrix4(e
								.matrixWorld)
						}
					}(),
					transformDirection: function (t) {
						var e = this.x,
							i = this.y,
							n = this.z,
							r = t.elements;
						return this.x = r[0] * e + r[4] * i + r[8] * n, this.y = r[1] * e + r[5] * i + r[
							9] * n, this.z = r[2] * e + r[6] * i + r[10] * n, this.normalize()
					},
					divide: function (t) {
						return this.x /= t.x, this.y /= t.y, this.z /= t.z, this
					},
					divideScalar: function (t) {
						return this.multiplyScalar(1 / t)
					},
					min: function (t) {
						return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z =
							Math.min(this.z, t.z), this
					},
					max: function (t) {
						return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z =
							Math.max(this.z, t.z), this
					},
					clamp: function (t, e) {
						return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math
							.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this
					},
					clampScalar: function () {
						var t = new Ne,
							e = new Ne;
						return function (i, n) {
							return t.set(i, i, i), e.set(n, n, n), this.clamp(t, e)
						}
					}(),
					clampLength: function (t, e) {
						var i = this.length();
						return this.divideScalar(i || 1).multiplyScalar(Math.max(t, Math.min(e, i)))
					},
					floor: function () {
						return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math
							.floor(this.z), this
					},
					ceil: function () {
						return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(
							this.z), this
					},
					round: function () {
						return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math
							.round(this.z), this
					},
					roundToZero: function () {
						return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this
							.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math
							.ceil(this.z) : Math.floor(this.z), this
					},
					negate: function () {
						return this.x = -this.x, this.y = -this.y, this.z = -this.z, this
					},
					dot: function (t) {
						return this.x * t.x + this.y * t.y + this.z * t.z
					},
					lengthSq: function () {
						return this.x * this.x + this.y * this.y + this.z * this.z
					},
					length: function () {
						return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
					},
					manhattanLength: function () {
						return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
					},
					normalize: function () {
						return this.divideScalar(this.length() || 1)
					},
					setLength: function (t) {
						return this.normalize().multiplyScalar(t)
					},
					lerp: function (t, e) {
						return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t
							.z - this.z) * e, this
					},
					lerpVectors: function (t, e, i) {
						return this.subVectors(e, t).multiplyScalar(i).add(t)
					},
					cross: function (t, e) {
						return void 0 !== e ? (console.warn(
							"THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."
							), this.crossVectors(t, e)) : this.crossVectors(this, t)
					},
					crossVectors: function (t, e) {
						var i = t.x,
							n = t.y,
							r = t.z,
							a = e.x,
							o = e.y,
							s = e.z;
						return this.x = n * s - r * o, this.y = r * a - i * s, this.z = i * o - n * a,
							this
					},
					projectOnVector: function (t) {
						var e = t.dot(this) / t.lengthSq();
						return this.copy(t).multiplyScalar(e)
					},
					projectOnPlane: function () {
						var t = new Ne;
						return function (e) {
							return t.copy(this).projectOnVector(e), this.sub(t)
						}
					}(),
					reflect: function () {
						var t = new Ne;
						return function (e) {
							return this.sub(t.copy(e).multiplyScalar(2 * this.dot(e)))
						}
					}(),
					angleTo: function (t) {
						var e = this.dot(t) / Math.sqrt(this.lengthSq() * t.lengthSq());
						return Math.acos(Ie.clamp(e, -1, 1))
					},
					distanceTo: function (t) {
						return Math.sqrt(this.distanceToSquared(t))
					},
					distanceToSquared: function (t) {
						var e = this.x - t.x,
							i = this.y - t.y,
							n = this.z - t.z;
						return e * e + i * i + n * n
					},
					manhattanDistanceTo: function (t) {
						return Math.abs(this.x - t.x) + Math.abs(this.y - t.y) + Math.abs(this.z - t.z)
					},
					setFromSpherical: function (t) {
						return this.setFromSphericalCoords(t.radius, t.phi, t.theta)
					},
					setFromSphericalCoords: function (t, e, i) {
						var n = Math.sin(e) * t;
						return this.x = n * Math.sin(i), this.y = Math.cos(e) * t, this.z = n * Math.cos(
							i), this
					},
					setFromCylindrical: function (t) {
						return this.setFromCylindricalCoords(t.radius, t.theta, t.y)
					},
					setFromCylindricalCoords: function (t, e, i) {
						return this.x = t * Math.sin(e), this.y = i, this.z = t * Math.cos(e), this
					},
					setFromMatrixPosition: function (t) {
						var e = t.elements;
						return this.x = e[12], this.y = e[13], this.z = e[14], this
					},
					setFromMatrixScale: function (t) {
						var e = this.setFromMatrixColumn(t, 0).length(),
							i = this.setFromMatrixColumn(t, 1).length(),
							n = this.setFromMatrixColumn(t, 2).length();
						return this.x = e, this.y = i, this.z = n, this
					},
					setFromMatrixColumn: function (t, e) {
						return this.fromArray(t.elements, 4 * e)
					},
					equals: function (t) {
						return t.x === this.x && t.y === this.y && t.z === this.z
					},
					fromArray: function (t, e) {
						return void 0 === e && (e = 0), this.x = t[e], this.y = t[e + 1], this.z = t[e +
							2], this
					},
					toArray: function (t, e) {
						return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this.x, t[e +
							1] = this.y, t[e + 2] = this.z, t
					},
					fromBufferAttribute: function (t, e, i) {
						return void 0 !== i && console.warn(
								"THREE.Vector3: offset has been removed from .fromBufferAttribute()."),
							this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this
					}
				}), Object.assign(Ue.prototype, {
					isMatrix3: !0,
					set: function (t, e, i, n, r, a, o, s, c) {
						var h = this.elements;
						return h[0] = t, h[1] = n, h[2] = o, h[3] = e, h[4] = r, h[5] = s, h[6] = i, h[
							7] = a, h[8] = c, this
					},
					identity: function () {
						return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this
					},
					clone: function () {
						return (new this.constructor).fromArray(this.elements)
					},
					copy: function (t) {
						var e = this.elements,
							i = t.elements;
						return e[0] = i[0], e[1] = i[1], e[2] = i[2], e[3] = i[3], e[4] = i[4], e[5] = i[
							5], e[6] = i[6], e[7] = i[7], e[8] = i[8], this
					},
					setFromMatrix4: function (t) {
						var e = t.elements;
						return this.set(e[0], e[4], e[8], e[1], e[5], e[9], e[2], e[6], e[10]), this
					},
					applyToBufferAttribute: function () {
						var t = new Ne;
						return function (e) {
							for (var i = 0, n = e.count; i < n; i++) t.x = e.getX(i), t.y = e.getY(i),
								t.z = e.getZ(i), t.applyMatrix3(this), e.setXYZ(i, t.x, t.y, t.z);
							return e
						}
					}(),
					multiply: function (t) {
						return this.multiplyMatrices(this, t)
					},
					premultiply: function (t) {
						return this.multiplyMatrices(t, this)
					},
					multiplyMatrices: function (t, e) {
						var i = t.elements,
							n = e.elements,
							r = this.elements,
							a = i[0],
							o = i[3],
							s = i[6],
							c = i[1],
							h = i[4],
							l = i[7],
							u = i[2],
							p = i[5],
							d = i[8],
							f = n[0],
							m = n[3],
							g = n[6],
							v = n[1],
							y = n[4],
							x = n[7],
							b = n[2],
							_ = n[5],
							w = n[8];
						return r[0] = a * f + o * v + s * b, r[3] = a * m + o * y + s * _, r[6] = a * g +
							o * x + s * w, r[1] = c * f + h * v + l * b, r[4] = c * m + h * y + l * _, r[
								7] = c * g + h * x + l * w, r[2] = u * f + p * v + d * b, r[5] = u * m +
							p * y + d * _, r[8] = u * g + p * x + d * w, this
					},
					multiplyScalar: function (t) {
						var e = this.elements;
						return e[0] *= t, e[3] *= t, e[6] *= t, e[1] *= t, e[4] *= t, e[7] *= t, e[2] *=
							t, e[5] *= t, e[8] *= t, this
					},
					determinant: function () {
						var t = this.elements,
							e = t[0],
							i = t[1],
							n = t[2],
							r = t[3],
							a = t[4],
							o = t[5],
							s = t[6],
							c = t[7],
							h = t[8];
						return e * a * h - e * o * c - i * r * h + i * o * s + n * r * c - n * a * s
					},
					getInverse: function (t, e) {
						t && t.isMatrix4 && console.error(
							"THREE.Matrix3: .getInverse() no longer takes a Matrix4 argument.");
						var i = t.elements,
							n = this.elements,
							r = i[0],
							a = i[1],
							o = i[2],
							s = i[3],
							c = i[4],
							h = i[5],
							l = i[6],
							u = i[7],
							p = i[8],
							d = p * c - h * u,
							f = h * l - p * s,
							m = u * s - c * l,
							g = r * d + a * f + o * m;
						if (0 === g) {
							var v = "THREE.Matrix3: .getInverse() can't invert matrix, determinant is 0";
							if (!0 === e) throw new Error(v);
							return console.warn(v), this.identity()
						}
						var y = 1 / g;
						return n[0] = d * y, n[1] = (o * u - p * a) * y, n[2] = (h * a - o * c) * y, n[
							3] = f * y, n[4] = (p * r - o * l) * y, n[5] = (o * s - h * r) * y, n[6] = m *
							y, n[7] = (a * l - u * r) * y, n[8] = (c * r - a * s) * y, this
					},
					transpose: function () {
						var t, e = this.elements;
						return t = e[1], e[1] = e[3], e[3] = t, t = e[2], e[2] = e[6], e[6] = t, t = e[5],
							e[5] = e[7], e[7] = t, this
					},
					getNormalMatrix: function (t) {
						return this.setFromMatrix4(t).getInverse(this).transpose()
					},
					transposeIntoArray: function (t) {
						var e = this.elements;
						return t[0] = e[0], t[1] = e[3], t[2] = e[6], t[3] = e[1], t[4] = e[4], t[5] = e[
							7], t[6] = e[2], t[7] = e[5], t[8] = e[8], this
					},
					setUvTransform: function (t, e, i, n, r, a, o) {
						var s = Math.cos(r),
							c = Math.sin(r);
						this.set(i * s, i * c, -i * (s * a + c * o) + a + t, -n * c, n * s, -n * (-c * a +
							s * o) + o + e, 0, 0, 1)
					},
					scale: function (t, e) {
						var i = this.elements;
						return i[0] *= t, i[3] *= t, i[6] *= t, i[1] *= e, i[4] *= e, i[7] *= e, this
					},
					rotate: function (t) {
						var e = Math.cos(t),
							i = Math.sin(t),
							n = this.elements,
							r = n[0],
							a = n[3],
							o = n[6],
							s = n[1],
							c = n[4],
							h = n[7];
						return n[0] = e * r + i * s, n[3] = e * a + i * c, n[6] = e * o + i * h, n[1] = -
							i * r + e * s, n[4] = -i * a + e * c, n[7] = -i * o + e * h, this
					},
					translate: function (t, e) {
						var i = this.elements;
						return i[0] += t * i[2], i[3] += t * i[5], i[6] += t * i[8], i[1] += e * i[2], i[
							4] += e * i[5], i[7] += e * i[8], this
					},
					equals: function (t) {
						for (var e = this.elements, i = t.elements, n = 0; n < 9; n++)
							if (e[n] !== i[n]) return !1;
						return !0
					},
					fromArray: function (t, e) {
						void 0 === e && (e = 0);
						for (var i = 0; i < 9; i++) this.elements[i] = t[i + e];
						return this
					},
					toArray: function (t, e) {
						void 0 === t && (t = []), void 0 === e && (e = 0);
						var i = this.elements;
						return t[e] = i[0], t[e + 1] = i[1], t[e + 2] = i[2], t[e + 3] = i[3], t[e + 4] =
							i[4], t[e + 5] = i[5], t[e + 6] = i[6], t[e + 7] = i[7], t[e + 8] = i[8], t
					}
				});
				var Ge, Fe, He, ke, je, Ve = {
						getDataURL: function (t) {
							var e;
							if ("undefined" == typeof HTMLCanvasElement) return t.src;
							if (t instanceof HTMLCanvasElement) e = t;
							else {
								void 0 === i && (i = document.createElement("canvas")), i.width = t.width, i
									.height = t.height;
								var n = i.getContext("2d");
								t instanceof ImageData ? n.putImageData(t, 0, 0) : n.drawImage(t, 0, 0, t.width, t
									.height), e = i
							}
							return e.width > 2048 || e.height > 2048 ? e.toDataURL("image/jpeg", .6) : e
								.toDataURL("image/png")
						}
					},
					We = 0;

				function qe(t, e, i, n, r, a, o, s, c, h) {
					Object.defineProperty(this, "id", {
							value: We++
						}), this.uuid = Ie.generateUUID(), this.name = "", this.image = void 0 !== t ? t : qe
						.DEFAULT_IMAGE, this.mipmaps = [], this.mapping = void 0 !== e ? e : qe.DEFAULT_MAPPING, this
						.wrapS = void 0 !== i ? i : xt, this.wrapT = void 0 !== n ? n : xt, this.magFilter =
						void 0 !== r ? r : St, this.minFilter = void 0 !== a ? a : Tt, this.anisotropy = void 0 !==
						c ? c : 1, this.format = void 0 !== o ? o : Ht, this.type = void 0 !== s ? s : At, this
						.offset = new De(0, 0), this.repeat = new De(1, 1), this.center = new De(0, 0), this
						.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new Ue, this.generateMipmaps = !0,
						this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.encoding =
						void 0 !== h ? h : we, this.version = 0, this.onUpdate = null
				}

				function Xe(t, e, i, n) {
					this.x = t || 0, this.y = e || 0, this.z = i || 0, this.w = void 0 !== n ? n : 1
				}

				function Ye(t, e, i) {
					this.width = t, this.height = e, this.scissor = new Xe(0, 0, t, e), this.scissorTest = !1, this
						.viewport = new Xe(0, 0, t, e), i = i || {}, this.texture = new qe(void 0, void 0, i.wrapS, i
							.wrapT, i.magFilter, i.minFilter, i.format, i.type, i.anisotropy, i.encoding), this
						.texture.generateMipmaps = void 0 !== i.generateMipmaps && i.generateMipmaps, this.texture
						.minFilter = void 0 !== i.minFilter ? i.minFilter : St, this.depthBuffer = void 0 === i
						.depthBuffer || i.depthBuffer, this.stencilBuffer = void 0 === i.stencilBuffer || i
						.stencilBuffer, this.depthTexture = void 0 !== i.depthTexture ? i.depthTexture : null
				}

				function Je(t, e, i) {
					Ye.call(this, t, e, i), this.activeCubeFace = 0, this.activeMipMapLevel = 0
				}

				function Ze(t, e, i, n, r, a, o, s, c, h, l, u) {
					qe.call(this, null, a, o, s, c, h, n, r, l, u), this.image = {
							data: t,
							width: e,
							height: i
						}, this.magFilter = void 0 !== c ? c : _t, this.minFilter = void 0 !== h ? h : _t, this
						.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1
				}

				function Qe(t, e) {
					this.min = void 0 !== t ? t : new Ne(1 / 0, 1 / 0, 1 / 0), this.max = void 0 !== e ? e : new Ne(-
						1 / 0, -1 / 0, -1 / 0)
				}

				function Ke(t, e) {
					this.center = void 0 !== t ? t : new Ne, this.radius = void 0 !== e ? e : 0
				}

				function $e(t, e) {
					this.normal = void 0 !== t ? t : new Ne(1, 0, 0), this.constant = void 0 !== e ? e : 0
				}

				function ti(t, e, i, n, r, a) {
					this.planes = [void 0 !== t ? t : new $e, void 0 !== e ? e : new $e, void 0 !== i ? i : new $e,
						void 0 !== n ? n : new $e, void 0 !== r ? r : new $e, void 0 !== a ? a : new $e
					]
				}
				qe.DEFAULT_IMAGE = void 0, qe.DEFAULT_MAPPING = 300, qe.prototype = Object.assign(Object.create(e
						.prototype), {
						constructor: qe,
						isTexture: !0,
						updateMatrix: function () {
							this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this
								.repeat.y, this.rotation, this.center.x, this.center.y)
						},
						clone: function () {
							return (new this.constructor).copy(this)
						},
						copy: function (t) {
							return this.name = t.name, this.image = t.image, this.mipmaps = t.mipmaps.slice(
								0), this.mapping = t.mapping, this.wrapS = t.wrapS, this.wrapT = t.wrapT, this
								.magFilter = t.magFilter, this.minFilter = t.minFilter, this.anisotropy = t
								.anisotropy, this.format = t.format, this.type = t.type, this.offset.copy(t
									.offset), this.repeat.copy(t.repeat), this.center.copy(t.center), this
								.rotation = t.rotation, this.matrixAutoUpdate = t.matrixAutoUpdate, this
								.matrix.copy(t.matrix), this.generateMipmaps = t.generateMipmaps, this
								.premultiplyAlpha = t.premultiplyAlpha, this.flipY = t.flipY, this
								.unpackAlignment = t.unpackAlignment, this.encoding = t.encoding, this
						},
						toJSON: function (t) {
							var e = void 0 === t || "string" == typeof t;
							if (!e && void 0 !== t.textures[this.uuid]) return t.textures[this.uuid];
							var i = {
								metadata: {
									version: 4.5,
									type: "Texture",
									generator: "Texture.toJSON"
								},
								uuid: this.uuid,
								name: this.name,
								mapping: this.mapping,
								repeat: [this.repeat.x, this.repeat.y],
								offset: [this.offset.x, this.offset.y],
								center: [this.center.x, this.center.y],
								rotation: this.rotation,
								wrap: [this.wrapS, this.wrapT],
								format: this.format,
								type: this.type,
								encoding: this.encoding,
								minFilter: this.minFilter,
								magFilter: this.magFilter,
								anisotropy: this.anisotropy,
								flipY: this.flipY,
								premultiplyAlpha: this.premultiplyAlpha,
								unpackAlignment: this.unpackAlignment
							};
							if (void 0 !== this.image) {
								var n = this.image;
								if (void 0 === n.uuid && (n.uuid = Ie.generateUUID()), !e && void 0 === t
									.images[n.uuid]) {
									var r;
									if (Array.isArray(n)) {
										r = [];
										for (var a = 0, o = n.length; a < o; a++) r.push(Ve.getDataURL(n[a]))
									} else r = Ve.getDataURL(n);
									t.images[n.uuid] = {
										uuid: n.uuid,
										url: r
									}
								}
								i.image = n.uuid
							}
							return e || (t.textures[this.uuid] = i), i
						},
						dispose: function () {
							this.dispatchEvent({
								type: "dispose"
							})
						},
						transformUv: function (t) {
							if (300 !== this.mapping) return t;
							if (t.applyMatrix3(this.matrix), t.x < 0 || t.x > 1) switch (this.wrapS) {
								case yt:
									t.x = t.x - Math.floor(t.x);
									break;
								case xt:
									t.x = t.x < 0 ? 0 : 1;
									break;
								case bt:
									1 === Math.abs(Math.floor(t.x) % 2) ? t.x = Math.ceil(t.x) - t.x : t
										.x = t.x - Math.floor(t.x)
							}
							if (t.y < 0 || t.y > 1) switch (this.wrapT) {
								case yt:
									t.y = t.y - Math.floor(t.y);
									break;
								case xt:
									t.y = t.y < 0 ? 0 : 1;
									break;
								case bt:
									1 === Math.abs(Math.floor(t.y) % 2) ? t.y = Math.ceil(t.y) - t.y : t
										.y = t.y - Math.floor(t.y)
							}
							return this.flipY && (t.y = 1 - t.y), t
						}
					}), Object.defineProperty(qe.prototype, "needsUpdate", {
						set: function (t) {
							!0 === t && this.version++
						}
					}), Object.assign(Xe.prototype, {
						isVector4: !0,
						set: function (t, e, i, n) {
							return this.x = t, this.y = e, this.z = i, this.w = n, this
						},
						setScalar: function (t) {
							return this.x = t, this.y = t, this.z = t, this.w = t, this
						},
						setX: function (t) {
							return this.x = t, this
						},
						setY: function (t) {
							return this.y = t, this
						},
						setZ: function (t) {
							return this.z = t, this
						},
						setW: function (t) {
							return this.w = t, this
						},
						setComponent: function (t, e) {
							switch (t) {
								case 0:
									this.x = e;
									break;
								case 1:
									this.y = e;
									break;
								case 2:
									this.z = e;
									break;
								case 3:
									this.w = e;
									break;
								default:
									throw new Error("index is out of range: " + t)
							}
							return this
						},
						getComponent: function (t) {
							switch (t) {
								case 0:
									return this.x;
								case 1:
									return this.y;
								case 2:
									return this.z;
								case 3:
									return this.w;
								default:
									throw new Error("index is out of range: " + t)
							}
						},
						clone: function () {
							return new this.constructor(this.x, this.y, this.z, this.w)
						},
						copy: function (t) {
							return this.x = t.x, this.y = t.y, this.z = t.z, this.w = void 0 !== t.w ? t.w :
								1, this
						},
						add: function (t, e) {
							return void 0 !== e ? (console.warn(
								"THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."
								), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this.z += t.z,
								this.w += t.w, this)
						},
						addScalar: function (t) {
							return this.x += t, this.y += t, this.z += t, this.w += t, this
						},
						addVectors: function (t, e) {
							return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this.w = t.w +
								e.w, this
						},
						addScaledVector: function (t, e) {
							return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this.w += t.w * e,
								this
						},
						sub: function (t, e) {
							return void 0 !== e ? (console.warn(
								"THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."
								), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this.z -= t.z,
								this.w -= t.w, this)
						},
						subScalar: function (t) {
							return this.x -= t, this.y -= t, this.z -= t, this.w -= t, this
						},
						subVectors: function (t, e) {
							return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this.w = t.w -
								e.w, this
						},
						multiplyScalar: function (t) {
							return this.x *= t, this.y *= t, this.z *= t, this.w *= t, this
						},
						applyMatrix4: function (t) {
							var e = this.x,
								i = this.y,
								n = this.z,
								r = this.w,
								a = t.elements;
							return this.x = a[0] * e + a[4] * i + a[8] * n + a[12] * r, this.y = a[1] * e + a[
									5] * i + a[9] * n + a[13] * r, this.z = a[2] * e + a[6] * i + a[10] * n +
								a[14] * r, this.w = a[3] * e + a[7] * i + a[11] * n + a[15] * r, this
						},
						divideScalar: function (t) {
							return this.multiplyScalar(1 / t)
						},
						setAxisAngleFromQuaternion: function (t) {
							this.w = 2 * Math.acos(t.w);
							var e = Math.sqrt(1 - t.w * t.w);
							return e < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = t.x / e, this
								.y = t.y / e, this.z = t.z / e), this
						},
						setAxisAngleFromRotationMatrix: function (t) {
							var e, i, n, r, a = t.elements,
								o = a[0],
								s = a[4],
								c = a[8],
								h = a[1],
								l = a[5],
								u = a[9],
								p = a[2],
								d = a[6],
								f = a[10];
							if (Math.abs(s - h) < .01 && Math.abs(c - p) < .01 && Math.abs(u - d) < .01) {
								if (Math.abs(s + h) < .1 && Math.abs(c + p) < .1 && Math.abs(u + d) < .1 &&
									Math.abs(o + l + f - 3) < .1) return this.set(1, 0, 0, 0), this;
								e = Math.PI;
								var m = (o + 1) / 2,
									g = (l + 1) / 2,
									v = (f + 1) / 2,
									y = (s + h) / 4,
									x = (c + p) / 4,
									b = (u + d) / 4;
								return m > g && m > v ? m < .01 ? (i = 0, n = .707106781, r = .707106781) : (
									i = Math.sqrt(m), n = y / i, r = x / i) : g > v ? g < .01 ? (i =
									.707106781, n = 0, r = .707106781) : (n = Math.sqrt(g), i = y / n, r =
									b / n) : v < .01 ? (i = .707106781, n = .707106781, r = 0) : (r = Math
									.sqrt(v), i = x / r, n = b / r), this.set(i, n, r, e), this
							}
							var _ = Math.sqrt((d - u) * (d - u) + (c - p) * (c - p) + (h - s) * (h - s));
							return Math.abs(_) < .001 && (_ = 1), this.x = (d - u) / _, this.y = (c - p) / _,
								this.z = (h - s) / _, this.w = Math.acos((o + l + f - 1) / 2), this
						},
						min: function (t) {
							return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z =
								Math.min(this.z, t.z), this.w = Math.min(this.w, t.w), this
						},
						max: function (t) {
							return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z =
								Math.max(this.z, t.z), this.w = Math.max(this.w, t.w), this
						},
						clamp: function (t, e) {
							return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math
									.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this
								.w = Math.max(t.w, Math.min(e.w, this.w)), this
						},
						clampScalar: function () {
							var t, e;
							return function (i, n) {
								return void 0 === t && (t = new Xe, e = new Xe), t.set(i, i, i, i), e.set(
									n, n, n, n), this.clamp(t, e)
							}
						}(),
						clampLength: function (t, e) {
							var i = this.length();
							return this.divideScalar(i || 1).multiplyScalar(Math.max(t, Math.min(e, i)))
						},
						floor: function () {
							return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math
								.floor(this.z), this.w = Math.floor(this.w), this
						},
						ceil: function () {
							return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(
								this.z), this.w = Math.ceil(this.w), this
						},
						round: function () {
							return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math
								.round(this.z), this.w = Math.round(this.w), this
						},
						roundToZero: function () {
							return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this
								.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math
								.ceil(this.z) : Math.floor(this.z), this.w = this.w < 0 ? Math.ceil(this.w) :
								Math.floor(this.w), this
						},
						negate: function () {
							return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w,
								this
						},
						dot: function (t) {
							return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w
						},
						lengthSq: function () {
							return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
						},
						length: function () {
							return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w *
								this.w)
						},
						manhattanLength: function () {
							return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
						},
						normalize: function () {
							return this.divideScalar(this.length() || 1)
						},
						setLength: function (t) {
							return this.normalize().multiplyScalar(t)
						},
						lerp: function (t, e) {
							return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t
								.z - this.z) * e, this.w += (t.w - this.w) * e, this
						},
						lerpVectors: function (t, e, i) {
							return this.subVectors(e, t).multiplyScalar(i).add(t)
						},
						equals: function (t) {
							return t.x === this.x && t.y === this.y && t.z === this.z && t.w === this.w
						},
						fromArray: function (t, e) {
							return void 0 === e && (e = 0), this.x = t[e], this.y = t[e + 1], this.z = t[e +
								2], this.w = t[e + 3], this
						},
						toArray: function (t, e) {
							return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this.x, t[e +
								1] = this.y, t[e + 2] = this.z, t[e + 3] = this.w, t
						},
						fromBufferAttribute: function (t, e, i) {
							return void 0 !== i && console.warn(
									"THREE.Vector4: offset has been removed from .fromBufferAttribute()."),
								this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this.w = t.getW(
								e), this
						}
					}), Ye.prototype = Object.assign(Object.create(e.prototype), {
						constructor: Ye,
						isWebGLRenderTarget: !0,
						setSize: function (t, e) {
							this.width === t && this.height === e || (this.width = t, this.height = e, this
								.dispose()), this.viewport.set(0, 0, t, e), this.scissor.set(0, 0, t, e)
						},
						clone: function () {
							return (new this.constructor).copy(this)
						},
						copy: function (t) {
							return this.width = t.width, this.height = t.height, this.viewport.copy(t
									.viewport), this.texture = t.texture.clone(), this.depthBuffer = t
								.depthBuffer, this.stencilBuffer = t.stencilBuffer, this.depthTexture = t
								.depthTexture, this
						},
						dispose: function () {
							this.dispatchEvent({
								type: "dispose"
							})
						}
					}), Je.prototype = Object.create(Ye.prototype), Je.prototype.constructor = Je, Je.prototype
					.isWebGLRenderTargetCube = !0, Ze.prototype = Object.create(qe.prototype), Ze.prototype
					.constructor = Ze, Ze.prototype.isDataTexture = !0, Object.assign(Qe.prototype, {
						isBox3: !0,
						set: function (t, e) {
							return this.min.copy(t), this.max.copy(e), this
						},
						setFromArray: function (t) {
							for (var e = 1 / 0, i = 1 / 0, n = 1 / 0, r = -1 / 0, a = -1 / 0, o = -1 / 0, s =
									0, c = t.length; s < c; s += 3) {
								var h = t[s],
									l = t[s + 1],
									u = t[s + 2];
								h < e && (e = h), l < i && (i = l), u < n && (n = u), h > r && (r = h), l >
									a && (a = l), u > o && (o = u)
							}
							return this.min.set(e, i, n), this.max.set(r, a, o), this
						},
						setFromBufferAttribute: function (t) {
							for (var e = 1 / 0, i = 1 / 0, n = 1 / 0, r = -1 / 0, a = -1 / 0, o = -1 / 0, s =
									0, c = t.count; s < c; s++) {
								var h = t.getX(s),
									l = t.getY(s),
									u = t.getZ(s);
								h < e && (e = h), l < i && (i = l), u < n && (n = u), h > r && (r = h), l >
									a && (a = l), u > o && (o = u)
							}
							return this.min.set(e, i, n), this.max.set(r, a, o), this
						},
						setFromPoints: function (t) {
							this.makeEmpty();
							for (var e = 0, i = t.length; e < i; e++) this.expandByPoint(t[e]);
							return this
						},
						setFromCenterAndSize: function () {
							var t = new Ne;
							return function (e, i) {
								var n = t.copy(i).multiplyScalar(.5);
								return this.min.copy(e).sub(n), this.max.copy(e).add(n), this
							}
						}(),
						setFromObject: function (t) {
							return this.makeEmpty(), this.expandByObject(t)
						},
						clone: function () {
							return (new this.constructor).copy(this)
						},
						copy: function (t) {
							return this.min.copy(t.min), this.max.copy(t.max), this
						},
						makeEmpty: function () {
							return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y =
								this.max.z = -1 / 0, this
						},
						isEmpty: function () {
							return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min
								.z
						},
						getCenter: function (t) {
							return void 0 === t && (console.warn(
									"THREE.Box3: .getCenter() target is now required"), t = new Ne), this
								.isEmpty() ? t.set(0, 0, 0) : t.addVectors(this.min, this.max).multiplyScalar(
									.5)
						},
						getSize: function (t) {
							return void 0 === t && (console.warn(
									"THREE.Box3: .getSize() target is now required"), t = new Ne), this
								.isEmpty() ? t.set(0, 0, 0) : t.subVectors(this.max, this.min)
						},
						expandByPoint: function (t) {
							return this.min.min(t), this.max.max(t), this
						},
						expandByVector: function (t) {
							return this.min.sub(t), this.max.add(t), this
						},
						expandByScalar: function (t) {
							return this.min.addScalar(-t), this.max.addScalar(t), this
						},
						expandByObject: function () {
							var t, e, i, n = new Ne;

							function r(r) {
								var a = r.geometry;
								if (void 0 !== a)
									if (a.isGeometry) {
										var o = a.vertices;
										for (e = 0, i = o.length; e < i; e++) n.copy(o[e]), n.applyMatrix4(r
											.matrixWorld), t.expandByPoint(n)
									} else if (a.isBufferGeometry) {
									var s = a.attributes.position;
									if (void 0 !== s)
										for (e = 0, i = s.count; e < i; e++) n.fromBufferAttribute(s, e)
											.applyMatrix4(r.matrixWorld), t.expandByPoint(n)
								}
							}
							return function (e) {
								return t = this, e.updateMatrixWorld(!0), e.traverse(r), this
							}
						}(),
						containsPoint: function (t) {
							return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this
								.max.y || t.z < this.min.z || t.z > this.max.z)
						},
						containsBox: function (t) {
							return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y &&
								t.max.y <= this.max.y && this.min.z <= t.min.z && t.max.z <= this.max.z
						},
						getParameter: function (t, e) {
							return void 0 === e && (console.warn(
								"THREE.Box3: .getParameter() target is now required"), e = new Ne), e.set(
								(t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this
									.max.y - this.min.y), (t.z - this.min.z) / (this.max.z - this.min.z))
						},
						intersectsBox: function (t) {
							return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t
								.min.y > this.max.y || t.max.z < this.min.z || t.min.z > this.max.z)
						},
						intersectsSphere: (je = new Ne, function (t) {
							return this.clampPoint(t.center, je), je.distanceToSquared(t.center) <= t
								.radius * t.radius
						}),
						intersectsPlane: function (t) {
							var e, i;
							return t.normal.x > 0 ? (e = t.normal.x * this.min.x, i = t.normal.x * this.max
								.x) : (e = t.normal.x * this.max.x, i = t.normal.x * this.min.x), t.normal.y >
								0 ? (e += t.normal.y * this.min.y, i += t.normal.y * this.max.y) : (e += t
									.normal.y * this.max.y, i += t.normal.y * this.min.y), t.normal.z > 0 ? (
									e += t.normal.z * this.min.z, i += t.normal.z * this.max.z) : (e += t
									.normal.z * this.max.z, i += t.normal.z * this.min.z), e <= -t.constant &&
								i >= -t.constant
						},
						intersectsTriangle: function () {
							var t = new Ne,
								e = new Ne,
								i = new Ne,
								n = new Ne,
								r = new Ne,
								a = new Ne,
								o = new Ne,
								s = new Ne,
								c = new Ne,
								h = new Ne;

							function l(n) {
								var r, a;
								for (r = 0, a = n.length - 3; r <= a; r += 3) {
									o.fromArray(n, r);
									var s = c.x * Math.abs(o.x) + c.y * Math.abs(o.y) + c.z * Math.abs(o.z),
										h = t.dot(o),
										l = e.dot(o),
										u = i.dot(o);
									if (Math.max(-Math.max(h, l, u), Math.min(h, l, u)) > s) return !1
								}
								return !0
							}
							return function (o) {
								if (this.isEmpty()) return !1;
								this.getCenter(s), c.subVectors(this.max, s), t.subVectors(o.a, s), e
									.subVectors(o.b, s), i.subVectors(o.c, s), n.subVectors(e, t), r
									.subVectors(i, e), a.subVectors(t, i);
								var u = [0, -n.z, n.y, 0, -r.z, r.y, 0, -a.z, a.y, n.z, 0, -n.x, r.z, 0, -
									r.x, a.z, 0, -a.x, -n.y, n.x, 0, -r.y, r.x, 0, -a.y, a.x, 0
								];
								return !!l(u) && !!l(u = [1, 0, 0, 0, 1, 0, 0, 0, 1]) && (h.crossVectors(
									n, r), l(u = [h.x, h.y, h.z]))
							}
						}(),
						clampPoint: function (t, e) {
							return void 0 === e && (console.warn(
								"THREE.Box3: .clampPoint() target is now required"), e = new Ne), e.copy(
								t).clamp(this.min, this.max)
						},
						distanceToPoint: function () {
							var t = new Ne;
							return function (e) {
								var i = t.copy(e).clamp(this.min, this.max);
								return i.sub(e).length()
							}
						}(),
						getBoundingSphere: function () {
							var t = new Ne;
							return function (e) {
								return void 0 === e && (console.warn(
											"THREE.Box3: .getBoundingSphere() target is now required"),
										e = new Ke), this.getCenter(e.center), e.radius = .5 * this
									.getSize(t).length(), e
							}
						}(),
						intersect: function (t) {
							return this.min.max(t.min), this.max.min(t.max), this.isEmpty() && this
							.makeEmpty(), this
						},
						union: function (t) {
							return this.min.min(t.min), this.max.max(t.max), this
						},
						applyMatrix4: (ke = [new Ne, new Ne, new Ne, new Ne, new Ne, new Ne, new Ne, new Ne],
							function (t) {
								return this.isEmpty() ? this : (ke[0].set(this.min.x, this.min.y, this.min.z)
									.applyMatrix4(t), ke[1].set(this.min.x, this.min.y, this.max.z)
									.applyMatrix4(t), ke[2].set(this.min.x, this.max.y, this.min.z)
									.applyMatrix4(t), ke[3].set(this.min.x, this.max.y, this.max.z)
									.applyMatrix4(t), ke[4].set(this.max.x, this.min.y, this.min.z)
									.applyMatrix4(t), ke[5].set(this.max.x, this.min.y, this.max.z)
									.applyMatrix4(t), ke[6].set(this.max.x, this.max.y, this.min.z)
									.applyMatrix4(t), ke[7].set(this.max.x, this.max.y, this.max.z)
									.applyMatrix4(t), this.setFromPoints(ke), this)
							}),
						translate: function (t) {
							return this.min.add(t), this.max.add(t), this
						},
						equals: function (t) {
							return t.min.equals(this.min) && t.max.equals(this.max)
						}
					}), Object.assign(Ke.prototype, {
						set: function (t, e) {
							return this.center.copy(t), this.radius = e, this
						},
						setFromPoints: (He = new Qe, function (t, e) {
							var i = this.center;
							void 0 !== e ? i.copy(e) : He.setFromPoints(t).getCenter(i);
							for (var n = 0, r = 0, a = t.length; r < a; r++) n = Math.max(n, i
								.distanceToSquared(t[r]));
							return this.radius = Math.sqrt(n), this
						}),
						clone: function () {
							return (new this.constructor).copy(this)
						},
						copy: function (t) {
							return this.center.copy(t.center), this.radius = t.radius, this
						},
						empty: function () {
							return this.radius <= 0
						},
						containsPoint: function (t) {
							return t.distanceToSquared(this.center) <= this.radius * this.radius
						},
						distanceToPoint: function (t) {
							return t.distanceTo(this.center) - this.radius
						},
						intersectsSphere: function (t) {
							var e = this.radius + t.radius;
							return t.center.distanceToSquared(this.center) <= e * e
						},
						intersectsBox: function (t) {
							return t.intersectsSphere(this)
						},
						intersectsPlane: function (t) {
							return Math.abs(t.distanceToPoint(this.center)) <= this.radius
						},
						clampPoint: function (t, e) {
							var i = this.center.distanceToSquared(t);
							return void 0 === e && (console.warn(
									"THREE.Sphere: .clampPoint() target is now required"), e = new Ne), e
								.copy(t), i > this.radius * this.radius && (e.sub(this.center).normalize(), e
									.multiplyScalar(this.radius).add(this.center)), e
						},
						getBoundingBox: function (t) {
							return void 0 === t && (console.warn(
									"THREE.Sphere: .getBoundingBox() target is now required"), t = new Qe), t
								.set(this.center, this.center), t.expandByScalar(this.radius), t
						},
						applyMatrix4: function (t) {
							return this.center.applyMatrix4(t), this.radius = this.radius * t
								.getMaxScaleOnAxis(), this
						},
						translate: function (t) {
							return this.center.add(t), this
						},
						equals: function (t) {
							return t.center.equals(this.center) && t.radius === this.radius
						}
					}), Object.assign($e.prototype, {
						set: function (t, e) {
							return this.normal.copy(t), this.constant = e, this
						},
						setComponents: function (t, e, i, n) {
							return this.normal.set(t, e, i), this.constant = n, this
						},
						setFromNormalAndCoplanarPoint: function (t, e) {
							return this.normal.copy(t), this.constant = -e.dot(this.normal), this
						},
						setFromCoplanarPoints: function () {
							var t = new Ne,
								e = new Ne;
							return function (i, n, r) {
								var a = t.subVectors(r, n).cross(e.subVectors(i, n)).normalize();
								return this.setFromNormalAndCoplanarPoint(a, i), this
							}
						}(),
						clone: function () {
							return (new this.constructor).copy(this)
						},
						copy: function (t) {
							return this.normal.copy(t.normal), this.constant = t.constant, this
						},
						normalize: function () {
							var t = 1 / this.normal.length();
							return this.normal.multiplyScalar(t), this.constant *= t, this
						},
						negate: function () {
							return this.constant *= -1, this.normal.negate(), this
						},
						distanceToPoint: function (t) {
							return this.normal.dot(t) + this.constant
						},
						distanceToSphere: function (t) {
							return this.distanceToPoint(t.center) - t.radius
						},
						projectPoint: function (t, e) {
							return void 0 === e && (console.warn(
									"THREE.Plane: .projectPoint() target is now required"), e = new Ne), e
								.copy(this.normal).multiplyScalar(-this.distanceToPoint(t)).add(t)
						},
						intersectLine: function () {
							var t = new Ne;
							return function (e, i) {
								void 0 === i && (console.warn(
										"THREE.Plane: .intersectLine() target is now required"), i =
									new Ne);
								var n = e.delta(t),
									r = this.normal.dot(n);
								if (0 === r) return 0 === this.distanceToPoint(e.start) ? i.copy(e
									.start) : void 0;
								var a = -(e.start.dot(this.normal) + this.constant) / r;
								return a < 0 || a > 1 ? void 0 : i.copy(n).multiplyScalar(a).add(e.start)
							}
						}(),
						intersectsLine: function (t) {
							var e = this.distanceToPoint(t.start),
								i = this.distanceToPoint(t.end);
							return e < 0 && i > 0 || i < 0 && e > 0
						},
						intersectsBox: function (t) {
							return t.intersectsPlane(this)
						},
						intersectsSphere: function (t) {
							return t.intersectsPlane(this)
						},
						coplanarPoint: function (t) {
							return void 0 === t && (console.warn(
									"THREE.Plane: .coplanarPoint() target is now required"), t = new Ne), t
								.copy(this.normal).multiplyScalar(-this.constant)
						},
						applyMatrix4: function () {
							var t = new Ne,
								e = new Ue;
							return function (i, n) {
								var r = n || e.getNormalMatrix(i),
									a = this.coplanarPoint(t).applyMatrix4(i),
									o = this.normal.applyMatrix3(r).normalize();
								return this.constant = -a.dot(o), this
							}
						}(),
						translate: function (t) {
							return this.constant -= t.dot(this.normal), this
						},
						equals: function (t) {
							return t.normal.equals(this.normal) && t.constant === this.constant
						}
					}), Object.assign(ti.prototype, {
						set: function (t, e, i, n, r, a) {
							var o = this.planes;
							return o[0].copy(t), o[1].copy(e), o[2].copy(i), o[3].copy(n), o[4].copy(r), o[5]
								.copy(a), this
						},
						clone: function () {
							return (new this.constructor).copy(this)
						},
						copy: function (t) {
							for (var e = this.planes, i = 0; i < 6; i++) e[i].copy(t.planes[i]);
							return this
						},
						setFromMatrix: function (t) {
							var e = this.planes,
								i = t.elements,
								n = i[0],
								r = i[1],
								a = i[2],
								o = i[3],
								s = i[4],
								c = i[5],
								h = i[6],
								l = i[7],
								u = i[8],
								p = i[9],
								d = i[10],
								f = i[11],
								m = i[12],
								g = i[13],
								v = i[14],
								y = i[15];
							return e[0].setComponents(o - n, l - s, f - u, y - m).normalize(), e[1]
								.setComponents(o + n, l + s, f + u, y + m).normalize(), e[2].setComponents(o +
									r, l + c, f + p, y + g).normalize(), e[3].setComponents(o - r, l - c, f -
									p, y - g).normalize(), e[4].setComponents(o - a, l - h, f - d, y - v)
								.normalize(), e[5].setComponents(o + a, l + h, f + d, y + v).normalize(), this
						},
						intersectsObject: (Fe = new Ke, function (t) {
							var e = t.geometry;
							return null === e.boundingSphere && e.computeBoundingSphere(), Fe.copy(e
								.boundingSphere).applyMatrix4(t.matrixWorld), this.intersectsSphere(
								Fe)
						}),
						intersectsSprite: function () {
							var t = new Ke;
							return function (e) {
								return t.center.set(0, 0, 0), t.radius = .7071067811865476, t
									.applyMatrix4(e.matrixWorld), this.intersectsSphere(t)
							}
						}(),
						intersectsSphere: function (t) {
							for (var e = this.planes, i = t.center, n = -t.radius, r = 0; r < 6; r++) {
								var a = e[r].distanceToPoint(i);
								if (a < n) return !1
							}
							return !0
						},
						intersectsBox: (Ge = new Ne, function (t) {
							for (var e = this.planes, i = 0; i < 6; i++) {
								var n = e[i];
								if (Ge.x = n.normal.x > 0 ? t.max.x : t.min.x, Ge.y = n.normal.y > 0 ? t
									.max.y : t.min.y, Ge.z = n.normal.z > 0 ? t.max.z : t.min.z, n
									.distanceToPoint(Ge) < 0) return !1
							}
							return !0
						}),
						containsPoint: function (t) {
							for (var e = this.planes, i = 0; i < 6; i++)
								if (e[i].distanceToPoint(t) < 0) return !1;
							return !0
						}
					});
				var ei = {
					alphamap_fragment: "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif",
					alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
					alphatest_fragment: "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif",
					aomap_fragment: "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif",
					aomap_pars_fragment: "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
					begin_vertex: "vec3 transformed = vec3( position );",
					beginnormal_vertex: "vec3 objectNormal = vec3( normal );",
					bsdfs: "float punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n#else\n\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t}\n\treturn 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE  = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS  = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n\treturn specularColor * AB.x + AB.y;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}",
					bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tfDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",
					clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\tif ( clipped ) discard;\n\t#endif\n#endif",
					clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n\t#if ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )\n\t\tvarying vec3 vViewPosition;\n\t#endif\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",
					clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )\n\tvarying vec3 vViewPosition;\n#endif",
					clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif",
					color_fragment: "#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif",
					color_pars_fragment: "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif",
					color_pars_vertex: "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif",
					color_vertex: "#ifdef USE_COLOR\n\tvColor.xyz = color.xyz;\n#endif",
					common: "#define PI 3.14159265359\n#define PI2 6.28318530718\n#define PI_HALF 1.5707963267949\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}",
					cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_textureSize (1024.0)\nint getFaceFromDirection(vec3 direction) {\n\tvec3 absDirection = abs(direction);\n\tint face = -1;\n\tif( absDirection.x > absDirection.z ) {\n\t\tif(absDirection.x > absDirection.y )\n\t\t\tface = direction.x > 0.0 ? 0 : 3;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\telse {\n\t\tif(absDirection.z > absDirection.y )\n\t\t\tface = direction.z > 0.0 ? 2 : 5;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\treturn face;\n}\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\n\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\n\tfloat dxRoughness = dFdx(roughness);\n\tfloat dyRoughness = dFdy(roughness);\n\tvec3 dx = dFdx( vec * scale * dxRoughness );\n\tvec3 dy = dFdy( vec * scale * dyRoughness );\n\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\n\td = clamp(d, 1.0, cubeUV_rangeClamp);\n\tfloat mipLevel = 0.5 * log2(d);\n\treturn vec2(floor(mipLevel), fract(mipLevel));\n}\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\n\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\n\tfloat a = 16.0 * cubeUV_rcpTextureSize;\n\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\n\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\n\tfloat powScale = exp2_packed.x * exp2_packed.y;\n\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\n\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\n\tbool bRes = mipLevel == 0.0;\n\tscale =  bRes && (scale < a) ? a : scale;\n\tvec3 r;\n\tvec2 offset;\n\tint face = getFaceFromDirection(direction);\n\tfloat rcpPowScale = 1.0 / powScale;\n\tif( face == 0) {\n\t\tr = vec3(direction.x, -direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 1) {\n\t\tr = vec3(direction.y, direction.x, direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 2) {\n\t\tr = vec3(direction.z, direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 3) {\n\t\tr = vec3(direction.x, direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse if( face == 4) {\n\t\tr = vec3(direction.y, direction.x, -direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse {\n\t\tr = vec3(direction.z, -direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\tr = normalize(r);\n\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\n\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\n\tvec2 base = offset + vec2( texelOffset );\n\treturn base + s * ( scale - 2.0 * texelOffset );\n}\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\nvec4 textureCubeUV( sampler2D envMap, vec3 reflectedDirection, float roughness ) {\n\tfloat roughnessVal = roughness* cubeUV_maxLods3;\n\tfloat r1 = floor(roughnessVal);\n\tfloat r2 = r1 + 1.0;\n\tfloat t = fract(roughnessVal);\n\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\n\tfloat s = mipInfo.y;\n\tfloat level0 = mipInfo.x;\n\tfloat level1 = level0 + 1.0;\n\tlevel1 = level1 > 5.0 ? 5.0 : level1;\n\tlevel0 += min( floor( s + 0.5 ), 5.0 );\n\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\n\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\n\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\n\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\n\tvec4 result = mix(color10, color20, t);\n\treturn vec4(result.rgb, 1.0);\n}\n#endif",
					defaultnormal_vertex: "vec3 transformedNormal = normalMatrix * objectNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif",
					displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",
					displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\n#endif",
					emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",
					emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",
					encodings_fragment: "gl_FragColor = linearToOutputTexel( gl_FragColor );",
					encodings_pars_fragment: "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = min( floor( D ) / 255.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n\tvec3 Xp_Y_XYZp = value.rgb * cLogLuvM;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}",
					envmap_fragment: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\tvec2 sampleUV;\n\t\treflectVec = normalize( reflectVec );\n\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\treflectVec = normalize( reflectVec );\n\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\tenvColor = envMapTexelToLinear( envColor );\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",
					envmap_pars_fragment: "#if defined( USE_ENVMAP ) || defined( PHYSICAL )\n\tuniform float reflectivity;\n\tuniform float envMapIntensity;\n#endif\n#ifdef USE_ENVMAP\n\t#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\n\t\tvarying vec3 vWorldPosition;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",
					envmap_pars_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",
					envmap_physical_pars_fragment: "#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, queryVec, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent ));\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\t\tvec2 sampleUV;\n\t\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif",
					envmap_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",
					fog_vertex: "#ifdef USE_FOG\n\tfogDepth = -mvPosition.z;\n#endif",
					fog_pars_vertex: "#ifdef USE_FOG\n\tvarying float fogDepth;\n#endif",
					fog_fragment: "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 ) );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",
					fog_pars_fragment: "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",
					gradientmap_pars_fragment: "#ifdef TOON\n\tuniform sampler2D gradientMap;\n\tvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\t\tfloat dotNL = dot( normal, lightDirection );\n\t\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t\t#ifdef USE_GRADIENTMAP\n\t\t\treturn texture2D( gradientMap, coord ).rgb;\n\t\t#else\n\t\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t\t#endif\n\t}\n#endif",
					lightmap_fragment: "#ifdef USE_LIGHTMAP\n\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n#endif",
					lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
					lights_lambert_vertex: "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvLightFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n#endif",
					lights_pars_begin: "uniform vec3 ambientLightColor;\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t\tfloat shadowCameraNear;\n\t\tfloat shadowCameraFar;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif",
					lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",
					lights_phong_pars_fragment: "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifdef TOON\n\t\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#else\n\t\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\t\tvec3 irradiance = dotNL * directLight.color;\n\t#endif\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)",
					lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\n#ifdef STANDARD\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.clearCoat = saturate( clearCoat );\tmaterial.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\n#endif",
					lights_physical_pars_fragment: "struct PhysicalMaterial {\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n\t#ifndef STANDARD\n\t\tfloat clearCoat;\n\t\tfloat clearCoatRoughness;\n\t#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearCoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifndef STANDARD\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\n\treflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\t#ifndef STANDARD\n\t\treflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifndef STANDARD\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\tfloat dotNL = dotNV;\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.indirectSpecular += ( 1.0 - clearCoatDHR ) * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\n\t#ifndef STANDARD\n\t\treflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",
					lights_fragment_begin: "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = normalize( vViewPosition );\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearCoatRadiance = vec3( 0.0 );\n#endif",
					lights_fragment_maps: "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tirradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), maxMipLevel );\n\t#ifndef STANDARD\n\t\tclearCoatRadiance += getLightProbeIndirectRadiance( geometry, Material_ClearCoat_BlinnShininessExponent( material ), maxMipLevel );\n\t#endif\n#endif",
					lights_fragment_end: "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, clearCoatRadiance, geometry, material, reflectedLight );\n#endif",
					logdepthbuf_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",
					logdepthbuf_pars_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n#endif",
					logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif",
					logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t#else\n\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\tgl_Position.z *= gl_Position.w;\n\t#endif\n#endif",
					map_fragment: "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif",
					map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",
					map_particle_fragment: "#ifdef USE_MAP\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif",
					map_particle_pars_fragment: "#ifdef USE_MAP\n\tuniform mat3 uvTransform;\n\tuniform sampler2D map;\n#endif",
					metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",
					metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
					morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n#endif",
					morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n\t#ifndef USE_MORPHNORMALS\n\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif",
					morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\t#endif\n#endif",
					normal_fragment_begin: "#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n#endif",
					normal_fragment_maps: "#ifdef USE_NORMALMAP\n\t#ifdef OBJECTSPACE_NORMALMAP\n\t\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\t#ifdef FLIP_SIDED\n\t\t\tnormal = - normal;\n\t\t#endif\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#endif\n\t\tnormal = normalize( normalMatrix * normal );\n\t#else\n\t\tnormal = perturbNormal2Arb( -vViewPosition, normal );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif",
					normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n\t#ifdef OBJECTSPACE_NORMALMAP\n\t\tuniform mat3 normalMatrix;\n\t#else\n\t\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\t\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\t\tvec2 st0 = dFdx( vUv.st );\n\t\t\tvec2 st1 = dFdy( vUv.st );\n\t\t\tfloat scale = sign( st1.t * st0.s - st0.t * st1.s );\n\t\t\tvec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\n\t\t\tvec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\n\t\t\tvec3 N = normalize( surf_norm );\n\t\t\tmat3 tsn = mat3( S, T, N );\n\t\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\t\tmapN.xy *= normalScale;\n\t\t\tmapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t\treturn normalize( tsn * mapN );\n\t\t}\n\t#endif\n#endif",
					packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}",
					premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",
					project_vertex: "vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\ngl_Position = projectionMatrix * mvPosition;",
					dithering_fragment: "#if defined( DITHERING )\n  gl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",
					dithering_pars_fragment: "#if defined( DITHERING )\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",
					roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",
					roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
					shadowmap_pars_fragment: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n\t\tconst vec2 offset = vec2( 0.0, 1.0 );\n\t\tvec2 texelSize = vec2( 1.0 ) / size;\n\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\n\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n\t\tvec2 f = fract( uv * size + 0.5 );\n\t\tfloat a = mix( lb, lt, f.y );\n\t\tfloat b = mix( rb, rt, f.y );\n\t\tfloat c = mix( a, b, f.x );\n\t\treturn c;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif",
					shadowmap_pars_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n#endif",
					shadowmap_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n#endif",
					shadowmask_pars_fragment: "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tDirectionalLight directionalLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tshadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tSpotLight spotLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tshadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tPointLight pointLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tshadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#endif\n\t#endif\n\treturn shadow;\n}",
					skinbase_vertex: "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
					skinning_pars_vertex: "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif",
					skinning_vertex: "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",
					skinnormal_vertex: "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n#endif",
					specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
					specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
					tonemapping_fragment: "#if defined( TONE_MAPPING )\n  gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",
					tonemapping_pars_fragment: "#ifndef saturate\n\t#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( ( color * ( 2.51 * color + 0.03 ) ) / ( color * ( 2.43 * color + 0.59 ) + 0.14 ) );\n}",
					uv_pars_fragment: "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n#endif",
					uv_pars_vertex: "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n\tuniform mat3 uvTransform;\n#endif",
					uv_vertex: "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif",
					uv2_pars_fragment: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif",
					uv2_pars_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n#endif",
					uv2_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = uv2;\n#endif",
					worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n#endif",
					background_frag: "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
					background_vert: "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",
					cube_frag: "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldDirection;\nvoid main() {\n\tvec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
					cube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
					depth_frag: "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - gl_FragCoord.z ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\n\t#endif\n}",
					depth_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}",
					distanceRGBA_frag: "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",
					distanceRGBA_vert: "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",
					equirect_frag: "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV;\n\tsampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
					equirect_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",
					linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
					linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\tvLineDistance = scale * lineDistance;\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
					meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\treflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
					meshbasic_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",
					meshlambert_frag: "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
					meshlambert_vert: "#define LAMBERT\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
					meshmatcap_frag: "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
					meshmatcap_vert: "#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#ifndef FLAT_SHADED\n\t\tvNormal = normalize( transformedNormal );\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",
					meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
					meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
					meshphysical_frag: "#define PHYSICAL\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifndef STANDARD\n\tuniform float clearCoat;\n\tuniform float clearCoatRoughness;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
					meshphysical_vert: "#define PHYSICAL\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
					normal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\nvoid main() {\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}",
					normal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",
					points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
					points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",
					shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <fog_fragment>\n}",
					shadow_vert: "#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
					sprite_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
					sprite_vert: "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}"
				};

				function ii(t) {
					var e = {};
					for (var i in t)
						for (var n in e[i] = {}, t[i]) {
							var r = t[i][n];
							r && (r.isColor || r.isMatrix3 || r.isMatrix4 || r.isVector2 || r.isVector3 || r
									.isVector4 || r.isTexture) ? e[i][n] = r.clone() : Array.isArray(r) ? e[i][n] = r
								.slice() : e[i][n] = r
						}
					return e
				}

				function ni(t) {
					for (var e = {}, i = 0; i < t.length; i++) {
						var n = ii(t[i]);
						for (var r in n) e[r] = n[r]
					}
					return e
				}
				var ri, ai, oi, si = {
						clone: ii,
						merge: ni
					},
					ci = {
						aliceblue: 15792383,
						antiquewhite: 16444375,
						aqua: 65535,
						aquamarine: 8388564,
						azure: 15794175,
						beige: 16119260,
						bisque: 16770244,
						black: 0,
						blanchedalmond: 16772045,
						blue: 255,
						blueviolet: 9055202,
						brown: 10824234,
						burlywood: 14596231,
						cadetblue: 6266528,
						chartreuse: 8388352,
						chocolate: 13789470,
						coral: 16744272,
						cornflowerblue: 6591981,
						cornsilk: 16775388,
						crimson: 14423100,
						cyan: 65535,
						darkblue: 139,
						darkcyan: 35723,
						darkgoldenrod: 12092939,
						darkgray: 11119017,
						darkgreen: 25600,
						darkgrey: 11119017,
						darkkhaki: 12433259,
						darkmagenta: 9109643,
						darkolivegreen: 5597999,
						darkorange: 16747520,
						darkorchid: 10040012,
						darkred: 9109504,
						darksalmon: 15308410,
						darkseagreen: 9419919,
						darkslateblue: 4734347,
						darkslategray: 3100495,
						darkslategrey: 3100495,
						darkturquoise: 52945,
						darkviolet: 9699539,
						deeppink: 16716947,
						deepskyblue: 49151,
						dimgray: 6908265,
						dimgrey: 6908265,
						dodgerblue: 2003199,
						firebrick: 11674146,
						floralwhite: 16775920,
						forestgreen: 2263842,
						fuchsia: 16711935,
						gainsboro: 14474460,
						ghostwhite: 16316671,
						gold: 16766720,
						goldenrod: 14329120,
						gray: 8421504,
						green: 32768,
						greenyellow: 11403055,
						grey: 8421504,
						honeydew: 15794160,
						hotpink: 16738740,
						indianred: 13458524,
						indigo: 4915330,
						ivory: 16777200,
						khaki: 15787660,
						lavender: 15132410,
						lavenderblush: 16773365,
						lawngreen: 8190976,
						lemonchiffon: 16775885,
						lightblue: 11393254,
						lightcoral: 15761536,
						lightcyan: 14745599,
						lightgoldenrodyellow: 16448210,
						lightgray: 13882323,
						lightgreen: 9498256,
						lightgrey: 13882323,
						lightpink: 16758465,
						lightsalmon: 16752762,
						lightseagreen: 2142890,
						lightskyblue: 8900346,
						lightslategray: 7833753,
						lightslategrey: 7833753,
						lightsteelblue: 11584734,
						lightyellow: 16777184,
						lime: 65280,
						limegreen: 3329330,
						linen: 16445670,
						magenta: 16711935,
						maroon: 8388608,
						mediumaquamarine: 6737322,
						mediumblue: 205,
						mediumorchid: 12211667,
						mediumpurple: 9662683,
						mediumseagreen: 3978097,
						mediumslateblue: 8087790,
						mediumspringgreen: 64154,
						mediumturquoise: 4772300,
						mediumvioletred: 13047173,
						midnightblue: 1644912,
						mintcream: 16121850,
						mistyrose: 16770273,
						moccasin: 16770229,
						navajowhite: 16768685,
						navy: 128,
						oldlace: 16643558,
						olive: 8421376,
						olivedrab: 7048739,
						orange: 16753920,
						orangered: 16729344,
						orchid: 14315734,
						palegoldenrod: 15657130,
						palegreen: 10025880,
						paleturquoise: 11529966,
						palevioletred: 14381203,
						papayawhip: 16773077,
						peachpuff: 16767673,
						peru: 13468991,
						pink: 16761035,
						plum: 14524637,
						powderblue: 11591910,
						purple: 8388736,
						rebeccapurple: 6697881,
						red: 16711680,
						rosybrown: 12357519,
						royalblue: 4286945,
						saddlebrown: 9127187,
						salmon: 16416882,
						sandybrown: 16032864,
						seagreen: 3050327,
						seashell: 16774638,
						sienna: 10506797,
						silver: 12632256,
						skyblue: 8900331,
						slateblue: 6970061,
						slategray: 7372944,
						slategrey: 7372944,
						snow: 16775930,
						springgreen: 65407,
						steelblue: 4620980,
						tan: 13808780,
						teal: 32896,
						thistle: 14204888,
						tomato: 16737095,
						turquoise: 4251856,
						violet: 15631086,
						wheat: 16113331,
						white: 16777215,
						whitesmoke: 16119285,
						yellow: 16776960,
						yellowgreen: 10145074
					};

				function hi(t, e, i) {
					return void 0 === e && void 0 === i ? this.set(t) : this.setRGB(t, e, i)
				}
				Object.assign(hi.prototype, {
					isColor: !0,
					r: 1,
					g: 1,
					b: 1,
					set: function (t) {
						return t && t.isColor ? this.copy(t) : "number" == typeof t ? this.setHex(t) :
							"string" == typeof t && this.setStyle(t), this
					},
					setScalar: function (t) {
						return this.r = t, this.g = t, this.b = t, this
					},
					setHex: function (t) {
						return t = Math.floor(t), this.r = (t >> 16 & 255) / 255, this.g = (t >> 8 &
							255) / 255, this.b = (255 & t) / 255, this
					},
					setRGB: function (t, e, i) {
						return this.r = t, this.g = e, this.b = i, this
					},
					setHSL: function () {
						function t(t, e, i) {
							return i < 0 && (i += 1), i > 1 && (i -= 1), i < 1 / 6 ? t + 6 * (e - t) * i :
								i < .5 ? e : i < 2 / 3 ? t + 6 * (e - t) * (2 / 3 - i) : t
						}
						return function (e, i, n) {
							if (e = Ie.euclideanModulo(e, 1), i = Ie.clamp(i, 0, 1), n = Ie.clamp(n,
									0, 1), 0 === i) this.r = this.g = this.b = n;
							else {
								var r = n <= .5 ? n * (1 + i) : n + i - n * i,
									a = 2 * n - r;
								this.r = t(a, r, e + 1 / 3), this.g = t(a, r, e), this.b = t(a, r, e -
									1 / 3)
							}
							return this
						}
					}(),
					setStyle: function (t) {
						function e(e) {
							void 0 !== e && parseFloat(e) < 1 && console.warn(
								"THREE.Color: Alpha component of " + t + " will be ignored.")
						}
						var i;
						if (i = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(t)) {
							var n, r = i[1],
								a = i[2];
							switch (r) {
								case "rgb":
								case "rgba":
									if (n =
										/^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/
										.exec(a)) return this.r = Math.min(255, parseInt(n[1], 10)) / 255,
										this.g = Math.min(255, parseInt(n[2], 10)) / 255, this.b =
										Math.min(255, parseInt(n[3], 10)) / 255, e(n[5]), this;
									if (n =
										/^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/
										.exec(a)) return this.r = Math.min(100, parseInt(n[1], 10)) / 100,
										this.g = Math.min(100, parseInt(n[2], 10)) / 100, this.b =
										Math.min(100, parseInt(n[3], 10)) / 100, e(n[5]), this;
									break;
								case "hsl":
								case "hsla":
									if (n =
										/^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/
										.exec(a)) {
										var o = parseFloat(n[1]) / 360,
											s = parseInt(n[2], 10) / 100,
											c = parseInt(n[3], 10) / 100;
										return e(n[5]), this.setHSL(o, s, c)
									}
							}
						} else if (i = /^\#([A-Fa-f0-9]+)$/.exec(t)) {
							var h = i[1],
								l = h.length;
							if (3 === l) return this.r = parseInt(h.charAt(0) + h.charAt(0), 16) / 255,
								this.g = parseInt(h.charAt(1) + h.charAt(1), 16) / 255, this.b =
								parseInt(h.charAt(2) + h.charAt(2), 16) / 255, this;
							if (6 === l) return this.r = parseInt(h.charAt(0) + h.charAt(1), 16) / 255,
								this.g = parseInt(h.charAt(2) + h.charAt(3), 16) / 255, this.b =
								parseInt(h.charAt(4) + h.charAt(5), 16) / 255, this
						}
						if (t && t.length > 0) {
							var h = ci[t];
							void 0 !== h ? this.setHex(h) : console.warn("THREE.Color: Unknown color " +
								t)
						}
						return this
					},
					clone: function () {
						return new this.constructor(this.r, this.g, this.b)
					},
					copy: function (t) {
						return this.r = t.r, this.g = t.g, this.b = t.b, this
					},
					copyGammaToLinear: function (t, e) {
						return void 0 === e && (e = 2), this.r = Math.pow(t.r, e), this.g = Math.pow(t.g,
							e), this.b = Math.pow(t.b, e), this
					},
					copyLinearToGamma: function (t, e) {
						void 0 === e && (e = 2);
						var i = e > 0 ? 1 / e : 1;
						return this.r = Math.pow(t.r, i), this.g = Math.pow(t.g, i), this.b = Math.pow(t
							.b, i), this
					},
					convertGammaToLinear: function (t) {
						return this.copyGammaToLinear(this, t), this
					},
					convertLinearToGamma: function (t) {
						return this.copyLinearToGamma(this, t), this
					},
					copySRGBToLinear: function () {
						function t(t) {
							return t < .04045 ? .0773993808 * t : Math.pow(.9478672986 * t + .0521327014,
								2.4)
						}
						return function (e) {
							return this.r = t(e.r), this.g = t(e.g), this.b = t(e.b), this
						}
					}(),
					copyLinearToSRGB: function () {
						function t(t) {
							return t < .0031308 ? 12.92 * t : 1.055 * Math.pow(t, .41666) - .055
						}
						return function (e) {
							return this.r = t(e.r), this.g = t(e.g), this.b = t(e.b), this
						}
					}(),
					convertSRGBToLinear: function () {
						return this.copySRGBToLinear(this), this
					},
					convertLinearToSRGB: function () {
						return this.copyLinearToSRGB(this), this
					},
					getHex: function () {
						return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0
					},
					getHexString: function () {
						return ("000000" + this.getHex().toString(16)).slice(-6)
					},
					getHSL: function (t) {
						void 0 === t && (console.warn("THREE.Color: .getHSL() target is now required"),
							t = {
								h: 0,
								s: 0,
								l: 0
							});
						var e, i, n = this.r,
							r = this.g,
							a = this.b,
							o = Math.max(n, r, a),
							s = Math.min(n, r, a),
							c = (s + o) / 2;
						if (s === o) e = 0, i = 0;
						else {
							var h = o - s;
							switch (i = c <= .5 ? h / (o + s) : h / (2 - o - s), o) {
								case n:
									e = (r - a) / h + (r < a ? 6 : 0);
									break;
								case r:
									e = (a - n) / h + 2;
									break;
								case a:
									e = (n - r) / h + 4
							}
							e /= 6
						}
						return t.h = e, t.s = i, t.l = c, t
					},
					getStyle: function () {
						return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this
							.b | 0) + ")"
					},
					offsetHSL: (oi = {}, function (t, e, i) {
						return this.getHSL(oi), oi.h += t, oi.s += e, oi.l += i, this.setHSL(oi.h, oi
							.s, oi.l), this
					}),
					add: function (t) {
						return this.r += t.r, this.g += t.g, this.b += t.b, this
					},
					addColors: function (t, e) {
						return this.r = t.r + e.r, this.g = t.g + e.g, this.b = t.b + e.b, this
					},
					addScalar: function (t) {
						return this.r += t, this.g += t, this.b += t, this
					},
					sub: function (t) {
						return this.r = Math.max(0, this.r - t.r), this.g = Math.max(0, this.g - t.g),
							this.b = Math.max(0, this.b - t.b), this
					},
					multiply: function (t) {
						return this.r *= t.r, this.g *= t.g, this.b *= t.b, this
					},
					multiplyScalar: function (t) {
						return this.r *= t, this.g *= t, this.b *= t, this
					},
					lerp: function (t, e) {
						return this.r += (t.r - this.r) * e, this.g += (t.g - this.g) * e, this.b += (t
							.b - this.b) * e, this
					},
					lerpHSL: (ri = {
						h: 0,
						s: 0,
						l: 0
					}, ai = {
						h: 0,
						s: 0,
						l: 0
					}, function (t, e) {
						this.getHSL(ri), t.getHSL(ai);
						var i = Ie.lerp(ri.h, ai.h, e),
							n = Ie.lerp(ri.s, ai.s, e),
							r = Ie.lerp(ri.l, ai.l, e);
						return this.setHSL(i, n, r), this
					}),
					equals: function (t) {
						return t.r === this.r && t.g === this.g && t.b === this.b
					},
					fromArray: function (t, e) {
						return void 0 === e && (e = 0), this.r = t[e], this.g = t[e + 1], this.b = t[e +
							2], this
					},
					toArray: function (t, e) {
						return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this.r, t[e +
							1] = this.g, t[e + 2] = this.b, t
					},
					toJSON: function () {
						return this.getHex()
					}
				});
				var li, ui = {
						common: {
							diffuse: {
								value: new hi(15658734)
							},
							opacity: {
								value: 1
							},
							map: {
								value: null
							},
							uvTransform: {
								value: new Ue
							},
							alphaMap: {
								value: null
							}
						},
						specularmap: {
							specularMap: {
								value: null
							}
						},
						envmap: {
							envMap: {
								value: null
							},
							flipEnvMap: {
								value: -1
							},
							reflectivity: {
								value: 1
							},
							refractionRatio: {
								value: .98
							},
							maxMipLevel: {
								value: 0
							}
						},
						aomap: {
							aoMap: {
								value: null
							},
							aoMapIntensity: {
								value: 1
							}
						},
						lightmap: {
							lightMap: {
								value: null
							},
							lightMapIntensity: {
								value: 1
							}
						},
						emissivemap: {
							emissiveMap: {
								value: null
							}
						},
						bumpmap: {
							bumpMap: {
								value: null
							},
							bumpScale: {
								value: 1
							}
						},
						normalmap: {
							normalMap: {
								value: null
							},
							normalScale: {
								value: new De(1, 1)
							}
						},
						displacementmap: {
							displacementMap: {
								value: null
							},
							displacementScale: {
								value: 1
							},
							displacementBias: {
								value: 0
							}
						},
						roughnessmap: {
							roughnessMap: {
								value: null
							}
						},
						metalnessmap: {
							metalnessMap: {
								value: null
							}
						},
						gradientmap: {
							gradientMap: {
								value: null
							}
						},
						fog: {
							fogDensity: {
								value: 25e-5
							},
							fogNear: {
								value: 1
							},
							fogFar: {
								value: 2e3
							},
							fogColor: {
								value: new hi(16777215)
							}
						},
						lights: {
							ambientLightColor: {
								value: []
							},
							directionalLights: {
								value: [],
								properties: {
									direction: {},
									color: {},
									shadow: {},
									shadowBias: {},
									shadowRadius: {},
									shadowMapSize: {}
								}
							},
							directionalShadowMap: {
								value: []
							},
							directionalShadowMatrix: {
								value: []
							},
							spotLights: {
								value: [],
								properties: {
									color: {},
									position: {},
									direction: {},
									distance: {},
									coneCos: {},
									penumbraCos: {},
									decay: {},
									shadow: {},
									shadowBias: {},
									shadowRadius: {},
									shadowMapSize: {}
								}
							},
							spotShadowMap: {
								value: []
							},
							spotShadowMatrix: {
								value: []
							},
							pointLights: {
								value: [],
								properties: {
									color: {},
									position: {},
									decay: {},
									distance: {},
									shadow: {},
									shadowBias: {},
									shadowRadius: {},
									shadowMapSize: {},
									shadowCameraNear: {},
									shadowCameraFar: {}
								}
							},
							pointShadowMap: {
								value: []
							},
							pointShadowMatrix: {
								value: []
							},
							hemisphereLights: {
								value: [],
								properties: {
									direction: {},
									skyColor: {},
									groundColor: {}
								}
							},
							rectAreaLights: {
								value: [],
								properties: {
									color: {},
									position: {},
									width: {},
									height: {}
								}
							}
						},
						points: {
							diffuse: {
								value: new hi(15658734)
							},
							opacity: {
								value: 1
							},
							size: {
								value: 1
							},
							scale: {
								value: 1
							},
							map: {
								value: null
							},
							uvTransform: {
								value: new Ue
							}
						},
						sprite: {
							diffuse: {
								value: new hi(15658734)
							},
							opacity: {
								value: 1
							},
							center: {
								value: new De(.5, .5)
							},
							rotation: {
								value: 0
							},
							map: {
								value: null
							},
							uvTransform: {
								value: new Ue
							}
						}
					},
					pi = {
						basic: {
							uniforms: ni([ui.common, ui.specularmap, ui.envmap, ui.aomap, ui.lightmap, ui.fog]),
							vertexShader: ei.meshbasic_vert,
							fragmentShader: ei.meshbasic_frag
						},
						lambert: {
							uniforms: ni([ui.common, ui.specularmap, ui.envmap, ui.aomap, ui.lightmap, ui.emissivemap,
								ui.fog, ui.lights, {
									emissive: {
										value: new hi(0)
									}
								}
							]),
							vertexShader: ei.meshlambert_vert,
							fragmentShader: ei.meshlambert_frag
						},
						phong: {
							uniforms: ni([ui.common, ui.specularmap, ui.envmap, ui.aomap, ui.lightmap, ui.emissivemap,
								ui.bumpmap, ui.normalmap, ui.displacementmap, ui.gradientmap, ui.fog, ui
								.lights, {
									emissive: {
										value: new hi(0)
									},
									specular: {
										value: new hi(1118481)
									},
									shininess: {
										value: 30
									}
								}
							]),
							vertexShader: ei.meshphong_vert,
							fragmentShader: ei.meshphong_frag
						},
						standard: {
							uniforms: ni([ui.common, ui.envmap, ui.aomap, ui.lightmap, ui.emissivemap, ui.bumpmap, ui
								.normalmap, ui.displacementmap, ui.roughnessmap, ui.metalnessmap, ui.fog, ui
								.lights, {
									emissive: {
										value: new hi(0)
									},
									roughness: {
										value: .5
									},
									metalness: {
										value: .5
									},
									envMapIntensity: {
										value: 1
									}
								}
							]),
							vertexShader: ei.meshphysical_vert,
							fragmentShader: ei.meshphysical_frag
						},
						matcap: {
							uniforms: ni([ui.common, ui.bumpmap, ui.normalmap, ui.displacementmap, ui.fog, {
								matcap: {
									value: null
								}
							}]),
							vertexShader: ei.meshmatcap_vert,
							fragmentShader: ei.meshmatcap_frag
						},
						points: {
							uniforms: ni([ui.points, ui.fog]),
							vertexShader: ei.points_vert,
							fragmentShader: ei.points_frag
						},
						dashed: {
							uniforms: ni([ui.common, ui.fog, {
								scale: {
									value: 1
								},
								dashSize: {
									value: 1
								},
								totalSize: {
									value: 2
								}
							}]),
							vertexShader: ei.linedashed_vert,
							fragmentShader: ei.linedashed_frag
						},
						depth: {
							uniforms: ni([ui.common, ui.displacementmap]),
							vertexShader: ei.depth_vert,
							fragmentShader: ei.depth_frag
						},
						normal: {
							uniforms: ni([ui.common, ui.bumpmap, ui.normalmap, ui.displacementmap, {
								opacity: {
									value: 1
								}
							}]),
							vertexShader: ei.normal_vert,
							fragmentShader: ei.normal_frag
						},
						sprite: {
							uniforms: ni([ui.sprite, ui.fog]),
							vertexShader: ei.sprite_vert,
							fragmentShader: ei.sprite_frag
						},
						background: {
							uniforms: {
								uvTransform: {
									value: new Ue
								},
								t2D: {
									value: null
								}
							},
							vertexShader: ei.background_vert,
							fragmentShader: ei.background_frag
						},
						cube: {
							uniforms: {
								tCube: {
									value: null
								},
								tFlip: {
									value: -1
								},
								opacity: {
									value: 1
								}
							},
							vertexShader: ei.cube_vert,
							fragmentShader: ei.cube_frag
						},
						equirect: {
							uniforms: {
								tEquirect: {
									value: null
								}
							},
							vertexShader: ei.equirect_vert,
							fragmentShader: ei.equirect_frag
						},
						distanceRGBA: {
							uniforms: ni([ui.common, ui.displacementmap, {
								referencePosition: {
									value: new Ne
								},
								nearDistance: {
									value: 1
								},
								farDistance: {
									value: 1e3
								}
							}]),
							vertexShader: ei.distanceRGBA_vert,
							fragmentShader: ei.distanceRGBA_frag
						},
						shadow: {
							uniforms: ni([ui.lights, ui.fog, {
								color: {
									value: new hi(0)
								},
								opacity: {
									value: 1
								}
							}]),
							vertexShader: ei.shadow_vert,
							fragmentShader: ei.shadow_frag
						}
					};

				function di() {
					var t = null,
						e = !1,
						i = null;

					function n(r, a) {
						!1 !== e && (i(r, a), t.requestAnimationFrame(n))
					}
					return {
						start: function () {
							!0 !== e && null !== i && (t.requestAnimationFrame(n), e = !0)
						},
						stop: function () {
							e = !1
						},
						setAnimationLoop: function (t) {
							i = t
						},
						setContext: function (e) {
							t = e
						}
					}
				}

				function fi(t) {
					var e = new WeakMap;
					return {
						get: function (t) {
							return t.isInterleavedBufferAttribute && (t = t.data), e.get(t)
						},
						remove: function (i) {
							i.isInterleavedBufferAttribute && (i = i.data);
							var n = e.get(i);
							n && (t.deleteBuffer(n.buffer), e.delete(i))
						},
						update: function (i, n) {
							i.isInterleavedBufferAttribute && (i = i.data);
							var r = e.get(i);
							void 0 === r ? e.set(i, function (e, i) {
								var n = e.array,
									r = e.dynamic ? 35048 : 35044,
									a = t.createBuffer();
								t.bindBuffer(i, a), t.bufferData(i, n, r), e.onUploadCallback();
								var o = 5126;
								return n instanceof Float32Array ? o = 5126 : n instanceof Float64Array ?
									console.warn(
										"THREE.WebGLAttributes: Unsupported data buffer format: Float64Array."
										) : n instanceof Uint16Array ? o = 5123 :
									n instanceof Int16Array ? o = 5122 : n instanceof Uint32Array ? o =
									5125 : n instanceof Int32Array ? o = 5124 : n instanceof Int8Array ?
									o = 5120 : n instanceof Uint8Array && (o = 5121), {
										buffer: a,
										type: o,
										bytesPerElement: n.BYTES_PER_ELEMENT,
										version: e.version
									}
							}(i, n)) : r.version < i.version && (function (e, i, n) {
								var r = i.array,
									a = i.updateRange;
								t.bindBuffer(n, e), !1 === i.dynamic ? t.bufferData(n, r, 35044) : -1 ===
									a.count ? t.bufferSubData(n, 0, r) : 0 === a.count ? console.error(
										"THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually."
										) : (t.bufferSubData(n, a.offset * r.BYTES_PER_ELEMENT, r
										.subarray(a.offset, a.offset + a.count)), a.count = -1)
							}(r.buffer, i, n), r.version = i.version)
						}
					}
				}

				function mi(t, e, i, n, r, a) {
					this.a = t, this.b = e, this.c = i, this.normal = n && n.isVector3 ? n : new Ne, this
						.vertexNormals = Array.isArray(n) ? n : [], this.color = r && r.isColor ? r : new hi, this
						.vertexColors = Array.isArray(r) ? r : [], this.materialIndex = void 0 !== a ? a : 0
				}

				function gi(t, e, i, n) {
					this._x = t || 0, this._y = e || 0, this._z = i || 0, this._order = n || gi.DefaultOrder
				}

				function vi() {
					this.mask = 1
				}
				pi.physical = {
						uniforms: ni([pi.standard.uniforms, {
							clearCoat: {
								value: 0
							},
							clearCoatRoughness: {
								value: 0
							}
						}]),
						vertexShader: ei.meshphysical_vert,
						fragmentShader: ei.meshphysical_frag
					}, Object.assign(mi.prototype, {
						clone: function () {
							return (new this.constructor).copy(this)
						},
						copy: function (t) {
							this.a = t.a, this.b = t.b, this.c = t.c, this.normal.copy(t.normal), this.color
								.copy(t.color), this.materialIndex = t.materialIndex;
							for (var e = 0, i = t.vertexNormals.length; e < i; e++) this.vertexNormals[e] = t
								.vertexNormals[e].clone();
							for (var e = 0, i = t.vertexColors.length; e < i; e++) this.vertexColors[e] = t
								.vertexColors[e].clone();
							return this
						}
					}), gi.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"], gi.DefaultOrder = "XYZ",
					Object.defineProperties(gi.prototype, {
						x: {
							get: function () {
								return this._x
							},
							set: function (t) {
								this._x = t, this.onChangeCallback()
							}
						},
						y: {
							get: function () {
								return this._y
							},
							set: function (t) {
								this._y = t, this.onChangeCallback()
							}
						},
						z: {
							get: function () {
								return this._z
							},
							set: function (t) {
								this._z = t, this.onChangeCallback()
							}
						},
						order: {
							get: function () {
								return this._order
							},
							set: function (t) {
								this._order = t, this.onChangeCallback()
							}
						}
					}), Object.assign(gi.prototype, {
						isEuler: !0,
						set: function (t, e, i, n) {
							return this._x = t, this._y = e, this._z = i, this._order = n || this._order, this
								.onChangeCallback(), this
						},
						clone: function () {
							return new this.constructor(this._x, this._y, this._z, this._order)
						},
						copy: function (t) {
							return this._x = t._x, this._y = t._y, this._z = t._z, this._order = t._order,
								this.onChangeCallback(), this
						},
						setFromRotationMatrix: function (t, e, i) {
							var n = Ie.clamp,
								r = t.elements,
								a = r[0],
								o = r[4],
								s = r[8],
								c = r[1],
								h = r[5],
								l = r[9],
								u = r[2],
								p = r[6],
								d = r[10];
							return "XYZ" === (e = e || this._order) ? (this._y = Math.asin(n(s, -1, 1)), Math
									.abs(s) < .99999 ? (this._x = Math.atan2(-l, d), this._z = Math.atan2(-o,
										a)) : (this._x = Math.atan2(p, h), this._z = 0)) : "YXZ" === e ? (this
									._x = Math.asin(-n(l, -1, 1)), Math.abs(l) < .99999 ? (this._y = Math
										.atan2(s, d), this._z = Math.atan2(c, h)) : (this._y = Math.atan2(-u,
										a), this._z = 0)) : "ZXY" === e ? (this._x = Math.asin(n(p, -1, 1)),
									Math.abs(p) < .99999 ? (this._y = Math.atan2(-u, d), this._z = Math.atan2(
										-o, h)) : (this._y = 0, this._z = Math.atan2(c, a))) : "ZYX" === e ? (
									this._y = Math.asin(-n(u, -1, 1)), Math.abs(u) < .99999 ? (this._x = Math
										.atan2(p, d), this._z = Math.atan2(c, a)) : (this._x = 0, this._z =
										Math.atan2(-o, h))) : "YZX" === e ? (this._z = Math.asin(n(c, -1, 1)),
									Math.abs(c) < .99999 ? (this._x = Math.atan2(-l, h), this._y = Math.atan2(
										-u, a)) : (this._x = 0, this._y = Math.atan2(s, d))) : "XZY" === e ? (
									this._z = Math.asin(-n(o, -1, 1)), Math.abs(o) < .99999 ? (this._x = Math
										.atan2(p, h), this._y = Math.atan2(s, a)) : (this._x = Math.atan2(-l,
										d), this._y = 0)) : console.warn(
									"THREE.Euler: .setFromRotationMatrix() given unsupported order: " + e),
								this._order = e, !1 !== i && this.onChangeCallback(), this
						},
						setFromQuaternion: function () {
							var t = new Be;
							return function (e, i, n) {
								return t.makeRotationFromQuaternion(e), this.setFromRotationMatrix(t, i,
									n)
							}
						}(),
						setFromVector3: function (t, e) {
							return this.set(t.x, t.y, t.z, e || this._order)
						},
						reorder: (li = new ze, function (t) {
							return li.setFromEuler(this), this.setFromQuaternion(li, t)
						}),
						equals: function (t) {
							return t._x === this._x && t._y === this._y && t._z === this._z && t._order ===
								this._order
						},
						fromArray: function (t) {
							return this._x = t[0], this._y = t[1], this._z = t[2], void 0 !== t[3] && (this
								._order = t[3]), this.onChangeCallback(), this
						},
						toArray: function (t, e) {
							return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this._x, t[e +
								1] = this._y, t[e + 2] = this._z, t[e + 3] = this._order, t
						},
						toVector3: function (t) {
							return t ? t.set(this._x, this._y, this._z) : new Ne(this._x, this._y, this._z)
						},
						onChange: function (t) {
							return this.onChangeCallback = t, this
						},
						onChangeCallback: function () {}
					}), Object.assign(vi.prototype, {
						set: function (t) {
							this.mask = 1 << t | 0
						},
						enable: function (t) {
							this.mask |= 1 << t | 0
						},
						toggle: function (t) {
							this.mask ^= 1 << t | 0
						},
						disable: function (t) {
							this.mask &= ~(1 << t | 0)
						},
						test: function (t) {
							return 0 != (this.mask & t.mask)
						}
					});
				var yi, xi, bi, _i, wi = 0;

				function Mi() {
					Object.defineProperty(this, "id", {
							value: wi++
						}), this.uuid = Ie.generateUUID(), this.name = "", this.type = "Object3D", this.parent = null,
						this.children = [], this.up = Mi.DefaultUp.clone();
					var t = new Ne,
						e = new gi,
						i = new ze,
						n = new Ne(1, 1, 1);
					e.onChange(function () {
							i.setFromEuler(e, !1)
						}), i.onChange(function () {
							e.setFromQuaternion(i, void 0, !1)
						}), Object.defineProperties(this, {
							position: {
								configurable: !0,
								enumerable: !0,
								value: t
							},
							rotation: {
								configurable: !0,
								enumerable: !0,
								value: e
							},
							quaternion: {
								configurable: !0,
								enumerable: !0,
								value: i
							},
							scale: {
								configurable: !0,
								enumerable: !0,
								value: n
							},
							modelViewMatrix: {
								value: new Be
							},
							normalMatrix: {
								value: new Ue
							}
						}), this.matrix = new Be, this.matrixWorld = new Be, this.matrixAutoUpdate = Mi
						.DefaultMatrixAutoUpdate, this.matrixWorldNeedsUpdate = !1, this.layers = new vi, this
						.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this
						.renderOrder = 0, this.userData = {}
				}
				Mi.DefaultUp = new Ne(0, 1, 0), Mi.DefaultMatrixAutoUpdate = !0, Mi.prototype = Object.assign(Object
					.create(e.prototype), {
						constructor: Mi,
						isObject3D: !0,
						onBeforeRender: function () {},
						onAfterRender: function () {},
						applyMatrix: function (t) {
							this.matrix.multiplyMatrices(t, this.matrix), this.matrix.decompose(this.position,
								this.quaternion, this.scale)
						},
						applyQuaternion: function (t) {
							return this.quaternion.premultiply(t), this
						},
						setRotationFromAxisAngle: function (t, e) {
							this.quaternion.setFromAxisAngle(t, e)
						},
						setRotationFromEuler: function (t) {
							this.quaternion.setFromEuler(t, !0)
						},
						setRotationFromMatrix: function (t) {
							this.quaternion.setFromRotationMatrix(t)
						},
						setRotationFromQuaternion: function (t) {
							this.quaternion.copy(t)
						},
						rotateOnAxis: (_i = new ze, function (t, e) {
							return _i.setFromAxisAngle(t, e), this.quaternion.multiply(_i), this
						}),
						rotateOnWorldAxis: function () {
							var t = new ze;
							return function (e, i) {
								return t.setFromAxisAngle(e, i), this.quaternion.premultiply(t), this
							}
						}(),
						rotateX: function () {
							var t = new Ne(1, 0, 0);
							return function (e) {
								return this.rotateOnAxis(t, e)
							}
						}(),
						rotateY: function () {
							var t = new Ne(0, 1, 0);
							return function (e) {
								return this.rotateOnAxis(t, e)
							}
						}(),
						rotateZ: function () {
							var t = new Ne(0, 0, 1);
							return function (e) {
								return this.rotateOnAxis(t, e)
							}
						}(),
						translateOnAxis: function () {
							var t = new Ne;
							return function (e, i) {
								return t.copy(e).applyQuaternion(this.quaternion), this.position.add(t
									.multiplyScalar(i)), this
							}
						}(),
						translateX: function () {
							var t = new Ne(1, 0, 0);
							return function (e) {
								return this.translateOnAxis(t, e)
							}
						}(),
						translateY: function () {
							var t = new Ne(0, 1, 0);
							return function (e) {
								return this.translateOnAxis(t, e)
							}
						}(),
						translateZ: function () {
							var t = new Ne(0, 0, 1);
							return function (e) {
								return this.translateOnAxis(t, e)
							}
						}(),
						localToWorld: function (t) {
							return t.applyMatrix4(this.matrixWorld)
						},
						worldToLocal: (bi = new Be, function (t) {
							return t.applyMatrix4(bi.getInverse(this.matrixWorld))
						}),
						lookAt: function () {
							var t = new ze,
								e = new Be,
								i = new Ne,
								n = new Ne;
							return function (r, a, o) {
								r.isVector3 ? i.copy(r) : i.set(r, a, o);
								var s = this.parent;
								this.updateWorldMatrix(!0, !1), n.setFromMatrixPosition(this.matrixWorld),
									this.isCamera || this.isLight ? e.lookAt(n, i, this.up) : e.lookAt(i,
										n, this.up), this.quaternion.setFromRotationMatrix(e), s && (e
										.extractRotation(s.matrixWorld), t.setFromRotationMatrix(e), this
										.quaternion.premultiply(t.inverse()))
							}
						}(),
						add: function (t) {
							if (arguments.length > 1) {
								for (var e = 0; e < arguments.length; e++) this.add(arguments[e]);
								return this
							}
							return t === this ? (console.error(
									"THREE.Object3D.add: object can't be added as a child of itself.", t),
								this) : (t && t.isObject3D ? (null !== t.parent && t.parent.remove(t), t
									.parent = this, t.dispatchEvent({
										type: "added"
									}), this.children.push(t)) : console.error(
									"THREE.Object3D.add: object not an instance of THREE.Object3D.", t),
								this)
						},
						remove: function (t) {
							if (arguments.length > 1) {
								for (var e = 0; e < arguments.length; e++) this.remove(arguments[e]);
								return this
							}
							var i = this.children.indexOf(t);
							return -1 !== i && (t.parent = null, t.dispatchEvent({
								type: "removed"
							}), this.children.splice(i, 1)), this
						},
						getObjectById: function (t) {
							return this.getObjectByProperty("id", t)
						},
						getObjectByName: function (t) {
							return this.getObjectByProperty("name", t)
						},
						getObjectByProperty: function (t, e) {
							if (this[t] === e) return this;
							for (var i = 0, n = this.children.length; i < n; i++) {
								var r = this.children[i],
									a = r.getObjectByProperty(t, e);
								if (void 0 !== a) return a
							}
						},
						getWorldPosition: function (t) {
							return void 0 === t && (console.warn(
									"THREE.Object3D: .getWorldPosition() target is now required"), t =
								new Ne), this.updateMatrixWorld(!0), t.setFromMatrixPosition(this
								.matrixWorld)
						},
						getWorldQuaternion: (yi = new Ne, xi = new Ne, function (t) {
							return void 0 === t && (console.warn(
									"THREE.Object3D: .getWorldQuaternion() target is now required"),
								t = new ze), this.updateMatrixWorld(!0), this.matrixWorld.decompose(
								yi, t, xi), t
						}),
						getWorldScale: function () {
							var t = new Ne,
								e = new ze;
							return function (i) {
								return void 0 === i && (console.warn(
											"THREE.Object3D: .getWorldScale() target is now required"),
										i = new Ne), this.updateMatrixWorld(!0), this.matrixWorld
									.decompose(t, e, i), i
							}
						}(),
						getWorldDirection: function (t) {
							void 0 === t && (console.warn(
									"THREE.Object3D: .getWorldDirection() target is now required"), t =
								new Ne), this.updateMatrixWorld(!0);
							var e = this.matrixWorld.elements;
							return t.set(e[8], e[9], e[10]).normalize()
						},
						raycast: function () {},
						traverse: function (t) {
							t(this);
							for (var e = this.children, i = 0, n = e.length; i < n; i++) e[i].traverse(t)
						},
						traverseVisible: function (t) {
							if (!1 !== this.visible) {
								t(this);
								for (var e = this.children, i = 0, n = e.length; i < n; i++) e[i]
									.traverseVisible(t)
							}
						},
						traverseAncestors: function (t) {
							var e = this.parent;
							null !== e && (t(e), e.traverseAncestors(t))
						},
						updateMatrix: function () {
							this.matrix.compose(this.position, this.quaternion, this.scale), this
								.matrixWorldNeedsUpdate = !0
						},
						updateMatrixWorld: function (t) {
							this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate ||
								t) && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this
									.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this
									.matrixWorldNeedsUpdate = !1, t = !0);
							for (var e = this.children, i = 0, n = e.length; i < n; i++) e[i]
								.updateMatrixWorld(t)
						},
						updateWorldMatrix: function (t, e) {
							var i = this.parent;
							if (!0 === t && null !== i && i.updateWorldMatrix(!0, !1), this
								.matrixAutoUpdate && this.updateMatrix(), null === this.parent ? this
								.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent
									.matrixWorld, this.matrix), !0 === e)
								for (var n = this.children, r = 0, a = n.length; r < a; r++) n[r]
									.updateWorldMatrix(!1, !0)
						},
						toJSON: function (t) {
							var e = void 0 === t || "string" == typeof t,
								i = {};
							e && (t = {
								geometries: {},
								materials: {},
								textures: {},
								images: {},
								shapes: {}
							}, i.metadata = {
								version: 4.5,
								type: "Object",
								generator: "Object3D.toJSON"
							});
							var n = {};

							function r(e, i) {
								return void 0 === e[i.uuid] && (e[i.uuid] = i.toJSON(t)), i.uuid
							}
							if (n.uuid = this.uuid, n.type = this.type, "" !== this.name && (n.name = this
									.name), !0 === this.castShadow && (n.castShadow = !0), !0 === this
								.receiveShadow && (n.receiveShadow = !0), !1 === this.visible && (n
									.visible = !1), !1 === this.frustumCulled && (n.frustumCulled = !1), 0 !==
								this.renderOrder && (n.renderOrder = this.renderOrder), "{}" !== JSON
								.stringify(this.userData) && (n.userData = this.userData), n.layers = this
								.layers.mask, n.matrix = this.matrix.toArray(), !1 === this
								.matrixAutoUpdate && (n.matrixAutoUpdate = !1), this.isMesh || this.isLine ||
								this.isPoints) {
								n.geometry = r(t.geometries, this.geometry);
								var a = this.geometry.parameters;
								if (void 0 !== a && void 0 !== a.shapes) {
									var o = a.shapes;
									if (Array.isArray(o))
										for (var s = 0, c = o.length; s < c; s++) {
											var h = o[s];
											r(t.shapes, h)
										} else r(t.shapes, o)
								}
							}
							if (void 0 !== this.material)
								if (Array.isArray(this.material)) {
									for (var l = [], s = 0, c = this.material.length; s < c; s++) l.push(r(t
										.materials, this.material[s]));
									n.material = l
								} else n.material = r(t.materials, this.material);
							if (this.children.length > 0) {
								n.children = [];
								for (var s = 0; s < this.children.length; s++) n.children.push(this.children[
									s].toJSON(t).object)
							}
							if (e) {
								var u = m(t.geometries),
									p = m(t.materials),
									d = m(t.textures),
									f = m(t.images),
									o = m(t.shapes);
								u.length > 0 && (i.geometries = u), p.length > 0 && (i.materials = p), d
									.length > 0 && (i.textures = d), f.length > 0 && (i.images = f), o
									.length > 0 && (i.shapes = o)
							}
							return i.object = n, i;

							function m(t) {
								var e = [];
								for (var i in t) {
									var n = t[i];
									delete n.metadata, e.push(n)
								}
								return e
							}
						},
						clone: function (t) {
							return (new this.constructor).copy(this, t)
						},
						copy: function (t, e) {
							if (void 0 === e && (e = !0), this.name = t.name, this.up.copy(t.up), this
								.position.copy(t.position), this.quaternion.copy(t.quaternion), this.scale
								.copy(t.scale), this.matrix.copy(t.matrix), this.matrixWorld.copy(t
									.matrixWorld), this.matrixAutoUpdate = t.matrixAutoUpdate, this
								.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate, this.layers.mask = t
								.layers.mask, this.visible = t.visible, this.castShadow = t.castShadow, this
								.receiveShadow = t.receiveShadow, this.frustumCulled = t.frustumCulled, this
								.renderOrder = t.renderOrder, this.userData = JSON.parse(JSON.stringify(t
									.userData)), !0 === e)
								for (var i = 0; i < t.children.length; i++) {
									var n = t.children[i];
									this.add(n.clone())
								}
							return this
						}
					});
				var Si, Ei, Ti = 0;

				function Ai() {
					Object.defineProperty(this, "id", {
							value: Ti += 2
						}), this.uuid = Ie.generateUUID(), this.name = "", this.type = "Geometry", this.vertices = [],
						this.colors = [], this.faces = [], this.faceVertexUvs = [
							[]
						], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this
						.skinIndices = [], this.lineDistances = [], this.boundingBox = null, this.boundingSphere =
						null, this.elementsNeedUpdate = !1, this.verticesNeedUpdate = !1, this.uvsNeedUpdate = !1,
						this.normalsNeedUpdate = !1, this.colorsNeedUpdate = !1, this.lineDistancesNeedUpdate = !1,
						this.groupsNeedUpdate = !1
				}

				function Li(t, e, i) {
					if (Array.isArray(t)) throw new TypeError(
					"THREE.BufferAttribute: array should be a Typed Array.");
					this.name = "", this.array = t, this.itemSize = e, this.count = void 0 !== t ? t.length / e : 0,
						this.normalized = !0 === i, this.dynamic = !1, this.updateRange = {
							offset: 0,
							count: -1
						}, this.version = 0
				}

				function Pi(t, e, i) {
					Li.call(this, new Int8Array(t), e, i)
				}

				function Ci(t, e, i) {
					Li.call(this, new Uint8Array(t), e, i)
				}

				function Ri(t, e, i) {
					Li.call(this, new Uint8ClampedArray(t), e, i)
				}

				function Oi(t, e, i) {
					Li.call(this, new Int16Array(t), e, i)
				}

				function Ii(t, e, i) {
					Li.call(this, new Uint16Array(t), e, i)
				}

				function Di(t, e, i) {
					Li.call(this, new Int32Array(t), e, i)
				}

				function Bi(t, e, i) {
					Li.call(this, new Uint32Array(t), e, i)
				}

				function zi(t, e, i) {
					Li.call(this, new Float32Array(t), e, i)
				}

				function Ni(t, e, i) {
					Li.call(this, new Float64Array(t), e, i)
				}

				function Ui() {
					this.vertices = [], this.normals = [], this.colors = [], this.uvs = [], this.uvs2 = [], this
						.groups = [], this.morphTargets = {}, this.skinWeights = [], this.skinIndices = [], this
						.boundingBox = null, this.boundingSphere = null, this.verticesNeedUpdate = !1, this
						.normalsNeedUpdate = !1, this.colorsNeedUpdate = !1, this.uvsNeedUpdate = !1, this
						.groupsNeedUpdate = !1
				}

				function Gi(t) {
					if (0 === t.length) return -1 / 0;
					for (var e = t[0], i = 1, n = t.length; i < n; ++i) t[i] > e && (e = t[i]);
					return e
				}
				Ai.prototype = Object.assign(Object.create(e.prototype), {
						constructor: Ai,
						isGeometry: !0,
						applyMatrix: function (t) {
							for (var e = (new Ue).getNormalMatrix(t), i = 0, n = this.vertices.length; i <
								n; i++) {
								var r = this.vertices[i];
								r.applyMatrix4(t)
							}
							for (var i = 0, n = this.faces.length; i < n; i++) {
								var a = this.faces[i];
								a.normal.applyMatrix3(e).normalize();
								for (var o = 0, s = a.vertexNormals.length; o < s; o++) a.vertexNormals[o]
									.applyMatrix3(e).normalize()
							}
							return null !== this.boundingBox && this.computeBoundingBox(), null !== this
								.boundingSphere && this.computeBoundingSphere(), this.verticesNeedUpdate = !0,
								this.normalsNeedUpdate = !0, this
						},
						rotateX: function () {
							var t = new Be;
							return function (e) {
								return t.makeRotationX(e), this.applyMatrix(t), this
							}
						}(),
						rotateY: function () {
							var t = new Be;
							return function (e) {
								return t.makeRotationY(e), this.applyMatrix(t), this
							}
						}(),
						rotateZ: function () {
							var t = new Be;
							return function (e) {
								return t.makeRotationZ(e), this.applyMatrix(t), this
							}
						}(),
						translate: function () {
							var t = new Be;
							return function (e, i, n) {
								return t.makeTranslation(e, i, n), this.applyMatrix(t), this
							}
						}(),
						scale: function () {
							var t = new Be;
							return function (e, i, n) {
								return t.makeScale(e, i, n), this.applyMatrix(t), this
							}
						}(),
						lookAt: (Ei = new Mi, function (t) {
							Ei.lookAt(t), Ei.updateMatrix(), this.applyMatrix(Ei.matrix)
						}),
						fromBufferGeometry: function (t) {
							var e = this,
								i = null !== t.index ? t.index.array : void 0,
								n = t.attributes,
								r = n.position.array,
								a = void 0 !== n.normal ? n.normal.array : void 0,
								o = void 0 !== n.color ? n.color.array : void 0,
								s = void 0 !== n.uv ? n.uv.array : void 0,
								c = void 0 !== n.uv2 ? n.uv2.array : void 0;
							void 0 !== c && (this.faceVertexUvs[1] = []);
							for (var h = 0, l = 0; h < r.length; h += 3, l += 2) e.vertices.push((new Ne)
								.fromArray(r, h)), void 0 !== o && e.colors.push((new hi).fromArray(o, h));

							function u(t, i, n, r) {
								var h = void 0 === o ? [] : [e.colors[t].clone(), e.colors[i].clone(), e
										.colors[n].clone()
									],
									l = void 0 === a ? [] : [(new Ne).fromArray(a, 3 * t), (new Ne).fromArray(
										a, 3 * i), (new Ne).fromArray(a, 3 * n)],
									u = new mi(t, i, n, l, h, r);
								e.faces.push(u), void 0 !== s && e.faceVertexUvs[0].push([(new De).fromArray(
									s, 2 * t), (new De).fromArray(s, 2 * i), (new De).fromArray(s,
									2 * n)]), void 0 !== c && e.faceVertexUvs[1].push([(new De).fromArray(
									c, 2 * t), (new De).fromArray(c, 2 * i), (new De).fromArray(c,
									2 * n)])
							}
							var p = t.groups;
							if (p.length > 0)
								for (var h = 0; h < p.length; h++)
									for (var d = p[h], f = d.start, m = d.count, l = f, g = f + m; l < g; l +=
										3) void 0 !== i ? u(i[l], i[l + 1], i[l + 2], d.materialIndex) : u(l,
										l + 1, l + 2, d.materialIndex);
							else if (void 0 !== i)
								for (var h = 0; h < i.length; h += 3) u(i[h], i[h + 1], i[h + 2]);
							else
								for (var h = 0; h < r.length / 3; h += 3) u(h, h + 1, h + 2);
							return this.computeFaceNormals(), null !== t.boundingBox && (this.boundingBox = t
								.boundingBox.clone()), null !== t.boundingSphere && (this.boundingSphere =
								t.boundingSphere.clone()), this
						},
						center: (Si = new Ne, function () {
							return this.computeBoundingBox(), this.boundingBox.getCenter(Si).negate(),
								this.translate(Si.x, Si.y, Si.z), this
						}),
						normalize: function () {
							this.computeBoundingSphere();
							var t = this.boundingSphere.center,
								e = this.boundingSphere.radius,
								i = 0 === e ? 1 : 1 / e,
								n = new Be;
							return n.set(i, 0, 0, -i * t.x, 0, i, 0, -i * t.y, 0, 0, i, -i * t.z, 0, 0, 0, 1),
								this.applyMatrix(n), this
						},
						computeFaceNormals: function () {
							for (var t = new Ne, e = new Ne, i = 0, n = this.faces.length; i < n; i++) {
								var r = this.faces[i],
									a = this.vertices[r.a],
									o = this.vertices[r.b],
									s = this.vertices[r.c];
								t.subVectors(s, o), e.subVectors(a, o), t.cross(e), t.normalize(), r.normal
									.copy(t)
							}
						},
						computeVertexNormals: function (t) {
							var e, i, n, r, a, o;
							for (void 0 === t && (t = !0), o = new Array(this.vertices.length), e = 0, i =
								this.vertices.length; e < i; e++) o[e] = new Ne;
							if (t) {
								var s, c, h, l = new Ne,
									u = new Ne;
								for (n = 0, r = this.faces.length; n < r; n++) a = this.faces[n], s = this
									.vertices[a.a], c = this.vertices[a.b], h = this.vertices[a.c], l
									.subVectors(h, c), u.subVectors(s, c), l.cross(u), o[a.a].add(l), o[a.b]
									.add(l), o[a.c].add(l)
							} else
								for (this.computeFaceNormals(), n = 0, r = this.faces.length; n < r; n++) a =
									this.faces[n], o[a.a].add(a.normal), o[a.b].add(a.normal), o[a.c].add(a
										.normal);
							for (e = 0, i = this.vertices.length; e < i; e++) o[e].normalize();
							for (n = 0, r = this.faces.length; n < r; n++) {
								var p = (a = this.faces[n]).vertexNormals;
								3 === p.length ? (p[0].copy(o[a.a]), p[1].copy(o[a.b]), p[2].copy(o[a.c])) : (
									p[0] = o[a.a].clone(), p[1] = o[a.b].clone(), p[2] = o[a.c].clone())
							}
							this.faces.length > 0 && (this.normalsNeedUpdate = !0)
						},
						computeFlatVertexNormals: function () {
							var t, e, i;
							for (this.computeFaceNormals(), t = 0, e = this.faces.length; t < e; t++) {
								var n = (i = this.faces[t]).vertexNormals;
								3 === n.length ? (n[0].copy(i.normal), n[1].copy(i.normal), n[2].copy(i
									.normal)) : (n[0] = i.normal.clone(), n[1] = i.normal.clone(), n[2] =
									i.normal.clone())
							}
							this.faces.length > 0 && (this.normalsNeedUpdate = !0)
						},
						computeMorphNormals: function () {
							var t, e, i, n, r;
							for (i = 0, n = this.faces.length; i < n; i++)
								for ((r = this.faces[i]).__originalFaceNormal ? r.__originalFaceNormal.copy(r
										.normal) : r.__originalFaceNormal = r.normal.clone(), r
									.__originalVertexNormals || (r.__originalVertexNormals = []), t = 0, e = r
									.vertexNormals.length; t < e; t++) r.__originalVertexNormals[t] ? r
									.__originalVertexNormals[t].copy(r.vertexNormals[t]) : r
									.__originalVertexNormals[t] = r.vertexNormals[t].clone();
							var a = new Ai;
							for (a.faces = this.faces, t = 0, e = this.morphTargets.length; t < e; t++) {
								if (!this.morphNormals[t]) {
									this.morphNormals[t] = {}, this.morphNormals[t].faceNormals = [], this
										.morphNormals[t].vertexNormals = [];
									var o = this.morphNormals[t].faceNormals,
										s = this.morphNormals[t].vertexNormals;
									for (i = 0, n = this.faces.length; i < n; i++) c = new Ne, h = {
										a: new Ne,
										b: new Ne,
										c: new Ne
									}, o.push(c), s.push(h)
								}
								var c, h, l = this.morphNormals[t];
								for (a.vertices = this.morphTargets[t].vertices, a.computeFaceNormals(), a
									.computeVertexNormals(), i = 0, n = this.faces.length; i < n; i++) r =
									this.faces[i], c = l.faceNormals[i], h = l.vertexNormals[i], c.copy(r
										.normal), h.a.copy(r.vertexNormals[0]), h.b.copy(r.vertexNormals[1]),
									h.c.copy(r.vertexNormals[2])
							}
							for (i = 0, n = this.faces.length; i < n; i++)(r = this.faces[i]).normal = r
								.__originalFaceNormal, r.vertexNormals = r.__originalVertexNormals
						},
						computeBoundingBox: function () {
							null === this.boundingBox && (this.boundingBox = new Qe), this.boundingBox
								.setFromPoints(this.vertices)
						},
						computeBoundingSphere: function () {
							null === this.boundingSphere && (this.boundingSphere = new Ke), this
								.boundingSphere.setFromPoints(this.vertices)
						},
						merge: function (t, e, i) {
							if (t && t.isGeometry) {
								var n, r = this.vertices.length,
									a = this.vertices,
									o = t.vertices,
									s = this.faces,
									c = t.faces,
									h = this.faceVertexUvs[0],
									l = t.faceVertexUvs[0],
									u = this.colors,
									p = t.colors;
								void 0 === i && (i = 0), void 0 !== e && (n = (new Ue).getNormalMatrix(e));
								for (var d = 0, f = o.length; d < f; d++) {
									var m = o[d],
										g = m.clone();
									void 0 !== e && g.applyMatrix4(e), a.push(g)
								}
								for (var d = 0, f = p.length; d < f; d++) u.push(p[d].clone());
								for (d = 0, f = c.length; d < f; d++) {
									var v, y, x, b = c[d],
										_ = b.vertexNormals,
										w = b.vertexColors;
									(v = new mi(b.a + r, b.b + r, b.c + r)).normal.copy(b.normal), void 0 !==
										n && v.normal.applyMatrix3(n).normalize();
									for (var M = 0, S = _.length; M < S; M++) y = _[M].clone(), void 0 !==
										n && y.applyMatrix3(n).normalize(), v.vertexNormals.push(y);
									v.color.copy(b.color);
									for (var M = 0, S = w.length; M < S; M++) x = w[M], v.vertexColors.push(x
										.clone());
									v.materialIndex = b.materialIndex + i, s.push(v)
								}
								for (d = 0, f = l.length; d < f; d++) {
									var E = l[d],
										T = [];
									if (void 0 !== E) {
										for (var M = 0, S = E.length; M < S; M++) T.push(E[M].clone());
										h.push(T)
									}
								}
							} else console.error(
								"THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.", t)
						},
						mergeMesh: function (t) {
							t && t.isMesh ? (t.matrixAutoUpdate && t.updateMatrix(), this.merge(t.geometry, t
								.matrix)) : console.error(
								"THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.", t)
						},
						mergeVertices: function () {
							var t, e, i, n, r, a, o, s, c = {},
								h = [],
								l = [],
								u = Math.pow(10, 4);
							for (i = 0, n = this.vertices.length; i < n; i++) t = this.vertices[i], e = Math
								.round(t.x * u) + "_" + Math.round(t.y * u) + "_" + Math.round(t.z * u),
								void 0 === c[e] ? (c[e] = i, h.push(this.vertices[i]), l[i] = h.length - 1) :
								l[i] = l[c[e]];
							var p = [];
							for (i = 0, n = this.faces.length; i < n; i++) {
								(r = this.faces[i]).a = l[r.a], r.b = l[r.b], r.c = l[r.c], a = [r.a, r.b, r
									.c];
								for (var d = 0; d < 3; d++)
									if (a[d] === a[(d + 1) % 3]) {
										p.push(i);
										break
									}
							}
							for (i = p.length - 1; i >= 0; i--) {
								var f = p[i];
								for (this.faces.splice(f, 1), o = 0, s = this.faceVertexUvs.length; o <
									s; o++) this.faceVertexUvs[o].splice(f, 1)
							}
							var m = this.vertices.length - h.length;
							return this.vertices = h, m
						},
						setFromPoints: function (t) {
							this.vertices = [];
							for (var e = 0, i = t.length; e < i; e++) {
								var n = t[e];
								this.vertices.push(new Ne(n.x, n.y, n.z || 0))
							}
							return this
						},
						sortFacesByMaterialIndex: function () {
							for (var t = this.faces, e = t.length, i = 0; i < e; i++) t[i]._id = i;
							t.sort(function (t, e) {
								return t.materialIndex - e.materialIndex
							});
							var n, r, a = this.faceVertexUvs[0],
								o = this.faceVertexUvs[1];
							a && a.length === e && (n = []), o && o.length === e && (r = []);
							for (var i = 0; i < e; i++) {
								var s = t[i]._id;
								n && n.push(a[s]), r && r.push(o[s])
							}
							n && (this.faceVertexUvs[0] = n), r && (this.faceVertexUvs[1] = r)
						},
						toJSON: function () {
							var t = {
								metadata: {
									version: 4.5,
									type: "Geometry",
									generator: "Geometry.toJSON"
								}
							};
							if (t.uuid = this.uuid, t.type = this.type, "" !== this.name && (t.name = this
									.name), void 0 !== this.parameters) {
								var e = this.parameters;
								for (var i in e) void 0 !== e[i] && (t[i] = e[i]);
								return t
							}
							for (var n = [], r = 0; r < this.vertices.length; r++) {
								var a = this.vertices[r];
								n.push(a.x, a.y, a.z)
							}
							for (var o = [], s = [], c = {}, h = [], l = {}, u = [], p = {}, r = 0; r < this
								.faces.length; r++) {
								var d = this.faces[r],
									f = void 0 !== this.faceVertexUvs[0][r],
									m = d.normal.length() > 0,
									g = d.vertexNormals.length > 0,
									v = 1 !== d.color.r || 1 !== d.color.g || 1 !== d.color.b,
									y = d.vertexColors.length > 0,
									x = 0;
								if (x = M(x = M(x = M(x = M(x = M(x = M(x = M(x = M(x, 0, 0), 1, !0), 2, !1),
										3, f), 4, m), 5, g), 6, v), 7, y), o.push(x), o.push(d.a, d.b, d.c), o
									.push(d.materialIndex), f) {
									var b = this.faceVertexUvs[0][r];
									o.push(T(b[0]), T(b[1]), T(b[2]))
								}
								if (m && o.push(S(d.normal)), g) {
									var _ = d.vertexNormals;
									o.push(S(_[0]), S(_[1]), S(_[2]))
								}
								if (v && o.push(E(d.color)), y) {
									var w = d.vertexColors;
									o.push(E(w[0]), E(w[1]), E(w[2]))
								}
							}

							function M(t, e, i) {
								return i ? t | 1 << e : t & ~(1 << e)
							}

							function S(t) {
								var e = t.x.toString() + t.y.toString() + t.z.toString();
								return void 0 !== c[e] ? c[e] : (c[e] = s.length / 3, s.push(t.x, t.y, t.z),
									c[e])
							}

							function E(t) {
								var e = t.r.toString() + t.g.toString() + t.b.toString();
								return void 0 !== l[e] ? l[e] : (l[e] = h.length, h.push(t.getHex()), l[e])
							}

							function T(t) {
								var e = t.x.toString() + t.y.toString();
								return void 0 !== p[e] ? p[e] : (p[e] = u.length / 2, u.push(t.x, t.y), p[e])
							}
							return t.data = {}, t.data.vertices = n, t.data.normals = s, h.length > 0 && (t
								.data.colors = h), u.length > 0 && (t.data.uvs = [u]), t.data.faces = o, t
						},
						clone: function () {
							return (new Ai).copy(this)
						},
						copy: function (t) {
							var e, i, n, r, a, o;
							this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [
									[]
								], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this
								.skinIndices = [], this.lineDistances = [], this.boundingBox = null, this
								.boundingSphere = null, this.name = t.name;
							var s = t.vertices;
							for (e = 0, i = s.length; e < i; e++) this.vertices.push(s[e].clone());
							var c = t.colors;
							for (e = 0, i = c.length; e < i; e++) this.colors.push(c[e].clone());
							var h = t.faces;
							for (e = 0, i = h.length; e < i; e++) this.faces.push(h[e].clone());
							for (e = 0, i = t.faceVertexUvs.length; e < i; e++) {
								var l = t.faceVertexUvs[e];
								for (void 0 === this.faceVertexUvs[e] && (this.faceVertexUvs[e] = []), n = 0,
									r = l.length; n < r; n++) {
									var u = l[n],
										p = [];
									for (a = 0, o = u.length; a < o; a++) {
										var d = u[a];
										p.push(d.clone())
									}
									this.faceVertexUvs[e].push(p)
								}
							}
							var f = t.morphTargets;
							for (e = 0, i = f.length; e < i; e++) {
								var m = {};
								if (m.name = f[e].name, void 0 !== f[e].vertices)
									for (m.vertices = [], n = 0, r = f[e].vertices.length; n < r; n++) m
										.vertices.push(f[e].vertices[n].clone());
								if (void 0 !== f[e].normals)
									for (m.normals = [], n = 0, r = f[e].normals.length; n < r; n++) m.normals
										.push(f[e].normals[n].clone());
								this.morphTargets.push(m)
							}
							var g = t.morphNormals;
							for (e = 0, i = g.length; e < i; e++) {
								var v = {};
								if (void 0 !== g[e].vertexNormals)
									for (v.vertexNormals = [], n = 0, r = g[e].vertexNormals.length; n <
										r; n++) {
										var y = g[e].vertexNormals[n],
											x = {};
										x.a = y.a.clone(), x.b = y.b.clone(), x.c = y.c.clone(), v
											.vertexNormals.push(x)
									}
								if (void 0 !== g[e].faceNormals)
									for (v.faceNormals = [], n = 0, r = g[e].faceNormals.length; n < r; n++) v
										.faceNormals.push(g[e].faceNormals[n].clone());
								this.morphNormals.push(v)
							}
							var b = t.skinWeights;
							for (e = 0, i = b.length; e < i; e++) this.skinWeights.push(b[e].clone());
							var _ = t.skinIndices;
							for (e = 0, i = _.length; e < i; e++) this.skinIndices.push(_[e].clone());
							var w = t.lineDistances;
							for (e = 0, i = w.length; e < i; e++) this.lineDistances.push(w[e]);
							var M = t.boundingBox;
							null !== M && (this.boundingBox = M.clone());
							var S = t.boundingSphere;
							return null !== S && (this.boundingSphere = S.clone()), this.elementsNeedUpdate =
								t.elementsNeedUpdate, this.verticesNeedUpdate = t.verticesNeedUpdate, this
								.uvsNeedUpdate = t.uvsNeedUpdate, this.normalsNeedUpdate = t
								.normalsNeedUpdate, this.colorsNeedUpdate = t.colorsNeedUpdate, this
								.lineDistancesNeedUpdate = t.lineDistancesNeedUpdate, this.groupsNeedUpdate =
								t.groupsNeedUpdate, this
						},
						dispose: function () {
							this.dispatchEvent({
								type: "dispose"
							})
						}
					}), Object.defineProperty(Li.prototype, "needsUpdate", {
						set: function (t) {
							!0 === t && this.version++
						}
					}), Object.assign(Li.prototype, {
						isBufferAttribute: !0,
						onUploadCallback: function () {},
						setArray: function (t) {
							if (Array.isArray(t)) throw new TypeError(
								"THREE.BufferAttribute: array should be a Typed Array.");
							return this.count = void 0 !== t ? t.length / this.itemSize : 0, this.array = t,
								this
						},
						setDynamic: function (t) {
							return this.dynamic = t, this
						},
						copy: function (t) {
							return this.name = t.name, this.array = new t.array.constructor(t.array), this
								.itemSize = t.itemSize, this.count = t.count, this.normalized = t.normalized,
								this.dynamic = t.dynamic, this
						},
						copyAt: function (t, e, i) {
							t *= this.itemSize, i *= e.itemSize;
							for (var n = 0, r = this.itemSize; n < r; n++) this.array[t + n] = e.array[i + n];
							return this
						},
						copyArray: function (t) {
							return this.array.set(t), this
						},
						copyColorsArray: function (t) {
							for (var e = this.array, i = 0, n = 0, r = t.length; n < r; n++) {
								var a = t[n];
								void 0 === a && (console.warn(
										"THREE.BufferAttribute.copyColorsArray(): color is undefined", n),
									a = new hi), e[i++] = a.r, e[i++] = a.g, e[i++] = a.b
							}
							return this
						},
						copyVector2sArray: function (t) {
							for (var e = this.array, i = 0, n = 0, r = t.length; n < r; n++) {
								var a = t[n];
								void 0 === a && (console.warn(
									"THREE.BufferAttribute.copyVector2sArray(): vector is undefined",
									n), a = new De), e[i++] = a.x, e[i++] = a.y
							}
							return this
						},
						copyVector3sArray: function (t) {
							for (var e = this.array, i = 0, n = 0, r = t.length; n < r; n++) {
								var a = t[n];
								void 0 === a && (console.warn(
									"THREE.BufferAttribute.copyVector3sArray(): vector is undefined",
									n), a = new Ne), e[i++] = a.x, e[i++] = a.y, e[i++] = a.z
							}
							return this
						},
						copyVector4sArray: function (t) {
							for (var e = this.array, i = 0, n = 0, r = t.length; n < r; n++) {
								var a = t[n];
								void 0 === a && (console.warn(
										"THREE.BufferAttribute.copyVector4sArray(): vector is undefined",
										n), a = new Xe), e[i++] = a.x, e[i++] = a.y, e[i++] = a.z, e[i++] = a
									.w
							}
							return this
						},
						set: function (t, e) {
							return void 0 === e && (e = 0), this.array.set(t, e), this
						},
						getX: function (t) {
							return this.array[t * this.itemSize]
						},
						setX: function (t, e) {
							return this.array[t * this.itemSize] = e, this
						},
						getY: function (t) {
							return this.array[t * this.itemSize + 1]
						},
						setY: function (t, e) {
							return this.array[t * this.itemSize + 1] = e, this
						},
						getZ: function (t) {
							return this.array[t * this.itemSize + 2]
						},
						setZ: function (t, e) {
							return this.array[t * this.itemSize + 2] = e, this
						},
						getW: function (t) {
							return this.array[t * this.itemSize + 3]
						},
						setW: function (t, e) {
							return this.array[t * this.itemSize + 3] = e, this
						},
						setXY: function (t, e, i) {
							return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = i, this
						},
						setXYZ: function (t, e, i, n) {
							return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = i, this
								.array[t + 2] = n, this
						},
						setXYZW: function (t, e, i, n, r) {
							return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = i, this
								.array[t + 2] = n, this.array[t + 3] = r, this
						},
						onUpload: function (t) {
							return this.onUploadCallback = t, this
						},
						clone: function () {
							return new this.constructor(this.array, this.itemSize).copy(this)
						}
					}), Pi.prototype = Object.create(Li.prototype), Pi.prototype.constructor = Pi, Ci.prototype =
					Object.create(Li.prototype), Ci.prototype.constructor = Ci, Ri.prototype = Object.create(Li
						.prototype), Ri.prototype.constructor = Ri, Oi.prototype = Object.create(Li.prototype), Oi
					.prototype.constructor = Oi, Ii.prototype = Object.create(Li.prototype), Ii.prototype
					.constructor = Ii, Di.prototype = Object.create(Li.prototype), Di.prototype.constructor = Di, Bi
					.prototype = Object.create(Li.prototype), Bi.prototype.constructor = Bi, zi.prototype = Object
					.create(Li.prototype), zi.prototype.constructor = zi, Ni.prototype = Object.create(Li.prototype),
					Ni.prototype.constructor = Ni, Object.assign(Ui.prototype, {
						computeGroups: function (t) {
							for (var e, i = [], n = void 0, r = t.faces, a = 0; a < r.length; a++) {
								var o = r[a];
								o.materialIndex !== n && (n = o.materialIndex, void 0 !== e && (e.count = 3 *
									a - e.start, i.push(e)), e = {
									start: 3 * a,
									materialIndex: n
								})
							}
							void 0 !== e && (e.count = 3 * a - e.start, i.push(e)), this.groups = i
						},
						fromGeometry: function (t) {
							var e, i = t.faces,
								n = t.vertices,
								r = t.faceVertexUvs,
								a = r[0] && r[0].length > 0,
								o = r[1] && r[1].length > 0,
								s = t.morphTargets,
								c = s.length;
							if (c > 0) {
								e = [];
								for (var h = 0; h < c; h++) e[h] = {
									name: s[h].name,
									data: []
								};
								this.morphTargets.position = e
							}
							var l, u = t.morphNormals,
								p = u.length;
							if (p > 0) {
								l = [];
								for (var h = 0; h < p; h++) l[h] = {
									name: u[h].name,
									data: []
								};
								this.morphTargets.normal = l
							}
							var d = t.skinIndices,
								f = t.skinWeights,
								m = d.length === n.length,
								g = f.length === n.length;
							n.length > 0 && 0 === i.length && console.error(
								"THREE.DirectGeometry: Faceless geometries are not supported.");
							for (var h = 0; h < i.length; h++) {
								var v = i[h];
								this.vertices.push(n[v.a], n[v.b], n[v.c]);
								var y = v.vertexNormals;
								if (3 === y.length) this.normals.push(y[0], y[1], y[2]);
								else {
									var x = v.normal;
									this.normals.push(x, x, x)
								}
								var b = v.vertexColors;
								if (3 === b.length) this.colors.push(b[0], b[1], b[2]);
								else {
									var _ = v.color;
									this.colors.push(_, _, _)
								}
								if (!0 === a) {
									var w = r[0][h];
									void 0 !== w ? this.uvs.push(w[0], w[1], w[2]) : (console.warn(
											"THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ", h
											), this.uvs.push(new De, new De, new De))
								}
								if (!0 === o) {
									var w = r[1][h];
									void 0 !== w ? this.uvs2.push(w[0], w[1], w[2]) : (console.warn(
										"THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ", h
										), this.uvs2.push(new De, new De, new De))
								}
								for (var M = 0; M < c; M++) {
									var S = s[M].vertices;
									e[M].data.push(S[v.a], S[v.b], S[v.c])
								}
								for (var M = 0; M < p; M++) {
									var E = u[M].vertexNormals[h];
									l[M].data.push(E.a, E.b, E.c)
								}
								m && this.skinIndices.push(d[v.a], d[v.b], d[v.c]), g && this.skinWeights
									.push(f[v.a], f[v.b], f[v.c])
							}
							return this.computeGroups(t), this.verticesNeedUpdate = t.verticesNeedUpdate, this
								.normalsNeedUpdate = t.normalsNeedUpdate, this.colorsNeedUpdate = t
								.colorsNeedUpdate, this.uvsNeedUpdate = t.uvsNeedUpdate, this
								.groupsNeedUpdate = t.groupsNeedUpdate, this
						}
					});
				var Fi = 1;

				function Hi() {
					Object.defineProperty(this, "id", {
							value: Fi += 2
						}), this.uuid = Ie.generateUUID(), this.name = "", this.type = "BufferGeometry", this.index =
						null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox =
						null, this.boundingSphere = null, this.drawRange = {
							start: 0,
							count: 1 / 0
						}, this.userData = {}
				}

				function ki(t, e, i, n, r, a) {
					Ai.call(this), this.type = "BoxGeometry", this.parameters = {
						width: t,
						height: e,
						depth: i,
						widthSegments: n,
						heightSegments: r,
						depthSegments: a
					}, this.fromBufferGeometry(new ji(t, e, i, n, r, a)), this.mergeVertices()
				}

				function ji(t, e, i, n, r, a) {
					Hi.call(this), this.type = "BoxBufferGeometry", this.parameters = {
						width: t,
						height: e,
						depth: i,
						widthSegments: n,
						heightSegments: r,
						depthSegments: a
					};
					var o = this;
					t = t || 1, e = e || 1, i = i || 1, n = Math.floor(n) || 1, r = Math.floor(r) || 1, a = Math
						.floor(a) || 1;
					var s = [],
						c = [],
						h = [],
						l = [],
						u = 0,
						p = 0;

					function d(t, e, i, n, r, a, d, f, m, g, v) {
						var y, x, b = a / m,
							_ = d / g,
							w = a / 2,
							M = d / 2,
							S = f / 2,
							E = m + 1,
							T = g + 1,
							A = 0,
							L = 0,
							P = new Ne;
						for (x = 0; x < T; x++) {
							var C = x * _ - M;
							for (y = 0; y < E; y++) {
								var R = y * b - w;
								P[t] = R * n, P[e] = C * r, P[i] = S, c.push(P.x, P.y, P.z), P[t] = 0, P[e] = 0, P[
									i] = f > 0 ? 1 : -1, h.push(P.x, P.y, P.z), l.push(y / m), l.push(1 - x / g), A +=
									1
							}
						}
						for (x = 0; x < g; x++)
							for (y = 0; y < m; y++) {
								var O = u + y + E * x,
									I = u + y + E * (x + 1),
									D = u + (y + 1) + E * (x + 1),
									B = u + (y + 1) + E * x;
								s.push(O, I, B), s.push(I, D, B), L += 6
							}
						o.addGroup(p, L, v), p += L, u += A
					}
					d("z", "y", "x", -1, -1, i, e, t, a, r, 0), d("z", "y", "x", 1, -1, i, e, -t, a, r, 1), d("x",
							"z", "y", 1, 1, t, i, e, n, a, 2), d("x", "z", "y", 1, -1, t, i, -e, n, a, 3), d("x", "y",
							"z", 1, -1, t, e, i, n, r, 4), d("x", "y", "z", -1, -1, t, e, -i, n, r, 5), this.setIndex(
							s), this.addAttribute("position", new zi(c, 3)), this.addAttribute("normal", new zi(h,
						3)), this.addAttribute("uv", new zi(l, 2))
				}

				function Vi(t, e, i, n) {
					Ai.call(this), this.type = "PlaneGeometry", this.parameters = {
						width: t,
						height: e,
						widthSegments: i,
						heightSegments: n
					}, this.fromBufferGeometry(new Wi(t, e, i, n)), this.mergeVertices()
				}

				function Wi(t, e, i, n) {
					Hi.call(this), this.type = "PlaneBufferGeometry", this.parameters = {
						width: t,
						height: e,
						widthSegments: i,
						heightSegments: n
					};
					var r, a, o = (t = t || 1) / 2,
						s = (e = e || 1) / 2,
						c = Math.floor(i) || 1,
						h = Math.floor(n) || 1,
						l = c + 1,
						u = h + 1,
						p = t / c,
						d = e / h,
						f = [],
						m = [],
						g = [],
						v = [];
					for (a = 0; a < u; a++) {
						var y = a * d - s;
						for (r = 0; r < l; r++) {
							var x = r * p - o;
							m.push(x, -y, 0), g.push(0, 0, 1), v.push(r / c), v.push(1 - a / h)
						}
					}
					for (a = 0; a < h; a++)
						for (r = 0; r < c; r++) {
							var b = r + l * a,
								_ = r + l * (a + 1),
								w = r + 1 + l * (a + 1),
								M = r + 1 + l * a;
							f.push(b, _, M), f.push(_, w, M)
						}
					this.setIndex(f), this.addAttribute("position", new zi(m, 3)), this.addAttribute("normal", new zi(
						g, 3)), this.addAttribute("uv", new zi(v, 2))
				}
				Hi.prototype = Object.assign(Object.create(e.prototype), {
						constructor: Hi,
						isBufferGeometry: !0,
						getIndex: function () {
							return this.index
						},
						setIndex: function (t) {
							Array.isArray(t) ? this.index = new(Gi(t) > 65535 ? Bi : Ii)(t, 1) : this.index =
								t
						},
						addAttribute: function (t, e) {
							return e && e.isBufferAttribute || e && e.isInterleavedBufferAttribute ?
								"index" === t ? (console.warn(
									"THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."
									), this.setIndex(e), this) : (this.attributes[t] = e, this) : (console
									.warn(
										"THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."
										), this.addAttribute(t, new Li(arguments[1], arguments[2])))
						},
						getAttribute: function (t) {
							return this.attributes[t]
						},
						removeAttribute: function (t) {
							return delete this.attributes[t], this
						},
						addGroup: function (t, e, i) {
							this.groups.push({
								start: t,
								count: e,
								materialIndex: void 0 !== i ? i : 0
							})
						},
						clearGroups: function () {
							this.groups = []
						},
						setDrawRange: function (t, e) {
							this.drawRange.start = t, this.drawRange.count = e
						},
						applyMatrix: function (t) {
							var e = this.attributes.position;
							void 0 !== e && (t.applyToBufferAttribute(e), e.needsUpdate = !0);
							var i = this.attributes.normal;
							if (void 0 !== i) {
								var n = (new Ue).getNormalMatrix(t);
								n.applyToBufferAttribute(i), i.needsUpdate = !0
							}
							return null !== this.boundingBox && this.computeBoundingBox(), null !== this
								.boundingSphere && this.computeBoundingSphere(), this
						},
						rotateX: function () {
							var t = new Be;
							return function (e) {
								return t.makeRotationX(e), this.applyMatrix(t), this
							}
						}(),
						rotateY: function () {
							var t = new Be;
							return function (e) {
								return t.makeRotationY(e), this.applyMatrix(t), this
							}
						}(),
						rotateZ: function () {
							var t = new Be;
							return function (e) {
								return t.makeRotationZ(e), this.applyMatrix(t), this
							}
						}(),
						translate: function () {
							var t = new Be;
							return function (e, i, n) {
								return t.makeTranslation(e, i, n), this.applyMatrix(t), this
							}
						}(),
						scale: function () {
							var t = new Be;
							return function (e, i, n) {
								return t.makeScale(e, i, n), this.applyMatrix(t), this
							}
						}(),
						lookAt: function () {
							var t = new Mi;
							return function (e) {
								t.lookAt(e), t.updateMatrix(), this.applyMatrix(t.matrix)
							}
						}(),
						center: function () {
							var t = new Ne;
							return function () {
								return this.computeBoundingBox(), this.boundingBox.getCenter(t).negate(),
									this.translate(t.x, t.y, t.z), this
							}
						}(),
						setFromObject: function (t) {
							var e = t.geometry;
							if (t.isPoints || t.isLine) {
								var i = new zi(3 * e.vertices.length, 3),
									n = new zi(3 * e.colors.length, 3);
								if (this.addAttribute("position", i.copyVector3sArray(e.vertices)), this
									.addAttribute("color", n.copyColorsArray(e.colors)), e.lineDistances && e
									.lineDistances.length === e.vertices.length) {
									var r = new zi(e.lineDistances.length, 1);
									this.addAttribute("lineDistance", r.copyArray(e.lineDistances))
								}
								null !== e.boundingSphere && (this.boundingSphere = e.boundingSphere.clone()),
									null !== e.boundingBox && (this.boundingBox = e.boundingBox.clone())
							} else t.isMesh && e && e.isGeometry && this.fromGeometry(e);
							return this
						},
						setFromPoints: function (t) {
							for (var e = [], i = 0, n = t.length; i < n; i++) {
								var r = t[i];
								e.push(r.x, r.y, r.z || 0)
							}
							return this.addAttribute("position", new zi(e, 3)), this
						},
						updateFromObject: function (t) {
							var e, i = t.geometry;
							if (t.isMesh) {
								var n = i.__directGeometry;
								if (!0 === i.elementsNeedUpdate && (n = void 0, i.elementsNeedUpdate = !1),
									void 0 === n) return this.fromGeometry(i);
								n.verticesNeedUpdate = i.verticesNeedUpdate, n.normalsNeedUpdate = i
									.normalsNeedUpdate, n.colorsNeedUpdate = i.colorsNeedUpdate, n
									.uvsNeedUpdate = i.uvsNeedUpdate, n.groupsNeedUpdate = i.groupsNeedUpdate,
									i.verticesNeedUpdate = !1, i.normalsNeedUpdate = !1, i
									.colorsNeedUpdate = !1, i.uvsNeedUpdate = !1, i.groupsNeedUpdate = !1, i =
									n
							}
							return !0 === i.verticesNeedUpdate && (void 0 !== (e = this.attributes
									.position) && (e.copyVector3sArray(i.vertices), e.needsUpdate = !0), i
									.verticesNeedUpdate = !1), !0 === i.normalsNeedUpdate && (void 0 !== (e =
									this.attributes.normal) && (e.copyVector3sArray(i.normals), e
									.needsUpdate = !0), i.normalsNeedUpdate = !1), !0 === i
								.colorsNeedUpdate && (void 0 !== (e = this.attributes.color) && (e
										.copyColorsArray(i.colors), e.needsUpdate = !0), i
									.colorsNeedUpdate = !1), i.uvsNeedUpdate && (void 0 !== (e = this
										.attributes.uv) && (e.copyVector2sArray(i.uvs), e.needsUpdate = !0), i
									.uvsNeedUpdate = !1), i.lineDistancesNeedUpdate && (void 0 !== (e = this
									.attributes.lineDistance) && (e.copyArray(i.lineDistances), e
									.needsUpdate = !0), i.lineDistancesNeedUpdate = !1), i.groupsNeedUpdate &&
								(i.computeGroups(t.geometry), this.groups = i.groups, i.groupsNeedUpdate = !
								1), this
						},
						fromGeometry: function (t) {
							return t.__directGeometry = (new Ui).fromGeometry(t), this.fromDirectGeometry(t
								.__directGeometry)
						},
						fromDirectGeometry: function (t) {
							var e = new Float32Array(3 * t.vertices.length);
							if (this.addAttribute("position", new Li(e, 3).copyVector3sArray(t.vertices)), t
								.normals.length > 0) {
								var i = new Float32Array(3 * t.normals.length);
								this.addAttribute("normal", new Li(i, 3).copyVector3sArray(t.normals))
							}
							if (t.colors.length > 0) {
								var n = new Float32Array(3 * t.colors.length);
								this.addAttribute("color", new Li(n, 3).copyColorsArray(t.colors))
							}
							if (t.uvs.length > 0) {
								var r = new Float32Array(2 * t.uvs.length);
								this.addAttribute("uv", new Li(r, 2).copyVector2sArray(t.uvs))
							}
							if (t.uvs2.length > 0) {
								var a = new Float32Array(2 * t.uvs2.length);
								this.addAttribute("uv2", new Li(a, 2).copyVector2sArray(t.uvs2))
							}
							for (var o in this.groups = t.groups, t.morphTargets) {
								for (var s = [], c = t.morphTargets[o], h = 0, l = c.length; h < l; h++) {
									var u = c[h],
										p = new zi(3 * u.data.length, 3);
									p.name = u.name, s.push(p.copyVector3sArray(u.data))
								}
								this.morphAttributes[o] = s
							}
							if (t.skinIndices.length > 0) {
								var d = new zi(4 * t.skinIndices.length, 4);
								this.addAttribute("skinIndex", d.copyVector4sArray(t.skinIndices))
							}
							if (t.skinWeights.length > 0) {
								var f = new zi(4 * t.skinWeights.length, 4);
								this.addAttribute("skinWeight", f.copyVector4sArray(t.skinWeights))
							}
							return null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere
							.clone()), null !== t.boundingBox && (this.boundingBox = t.boundingBox
							.clone()), this
						},
						computeBoundingBox: function () {
							null === this.boundingBox && (this.boundingBox = new Qe);
							var t = this.attributes.position;
							void 0 !== t ? this.boundingBox.setFromBufferAttribute(t) : this.boundingBox
								.makeEmpty(), (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min
									.y) || isNaN(this.boundingBox.min.z)) && console.error(
									'THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',
									this)
						},
						computeBoundingSphere: function () {
							var t = new Qe,
								e = new Ne;
							return function () {
								null === this.boundingSphere && (this.boundingSphere = new Ke);
								var i = this.attributes.position;
								if (i) {
									var n = this.boundingSphere.center;
									t.setFromBufferAttribute(i), t.getCenter(n);
									for (var r = 0, a = 0, o = i.count; a < o; a++) e.x = i.getX(a), e.y =
										i.getY(a), e.z = i.getZ(a), r = Math.max(r, n.distanceToSquared(
											e));
									this.boundingSphere.radius = Math.sqrt(r), isNaN(this.boundingSphere
										.radius) && console.error(
										'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',
										this)
								}
							}
						}(),
						computeFaceNormals: function () {},
						computeVertexNormals: function () {
							var t = this.index,
								e = this.attributes;
							if (e.position) {
								var i = e.position.array;
								if (void 0 === e.normal) this.addAttribute("normal", new Li(new Float32Array(i
									.length), 3));
								else
									for (var n = e.normal.array, r = 0, a = n.length; r < a; r++) n[r] = 0;
								var o, s, c, h = e.normal.array,
									l = new Ne,
									u = new Ne,
									p = new Ne,
									d = new Ne,
									f = new Ne;
								if (t)
									for (var m = t.array, r = 0, a = t.count; r < a; r += 3) o = 3 * m[r + 0],
										s = 3 * m[r + 1], c = 3 * m[r + 2], l.fromArray(i, o), u.fromArray(i,
											s), p.fromArray(i, c), d.subVectors(p, u), f.subVectors(l, u), d
										.cross(f), h[o] += d.x, h[o + 1] += d.y, h[o + 2] += d.z, h[s] += d.x,
										h[s + 1] += d.y, h[s + 2] += d.z, h[c] += d.x, h[c + 1] += d.y, h[c +
											2] += d.z;
								else
									for (var r = 0, a = i.length; r < a; r += 9) l.fromArray(i, r), u
										.fromArray(i, r + 3), p.fromArray(i, r + 6), d.subVectors(p, u), f
										.subVectors(l, u), d.cross(f), h[r] = d.x, h[r + 1] = d.y, h[r + 2] =
										d.z, h[r + 3] = d.x, h[r + 4] = d.y, h[r + 5] = d.z, h[r + 6] = d.x,
										h[r + 7] = d.y, h[r + 8] = d.z;
								this.normalizeNormals(), e.normal.needsUpdate = !0
							}
						},
						merge: function (t, e) {
							if (t && t.isBufferGeometry) {
								void 0 === e && (e = 0, console.warn(
									"THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."
									));
								var i = this.attributes;
								for (var n in i)
									if (void 0 !== t.attributes[n])
										for (var r = i[n], a = r.array, o = t.attributes[n], s = o.array, c =
												o.itemSize, h = 0, l = c * e; h < s.length; h++, l++) a[l] =
											s[h];
								return this
							}
							console.error(
								"THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.",
								t)
						},
						normalizeNormals: function () {
							var t = new Ne;
							return function () {
								for (var e = this.attributes.normal, i = 0, n = e.count; i < n; i++) t.x =
									e.getX(i), t.y = e.getY(i), t.z = e.getZ(i), t.normalize(), e.setXYZ(
										i, t.x, t.y, t.z)
							}
						}(),
						toNonIndexed: function () {
							if (null === this.index) return console.warn(
								"THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed."
								), this;
							var t = new Hi,
								e = this.index.array,
								i = this.attributes;
							for (var n in i) {
								for (var r = i[n], a = r.array, o = r.itemSize, s = new a.constructor(e
										.length * o), c = 0, h = 0, l = 0, u = e.length; l < u; l++) {
									c = e[l] * o;
									for (var p = 0; p < o; p++) s[h++] = a[c++]
								}
								t.addAttribute(n, new Li(s, o))
							}
							for (var d = this.groups, l = 0, u = d.length; l < u; l++) {
								var f = d[l];
								t.addGroup(f.start, f.count, f.materialIndex)
							}
							return t
						},
						toJSON: function () {
							var t = {
								metadata: {
									version: 4.5,
									type: "BufferGeometry",
									generator: "BufferGeometry.toJSON"
								}
							};
							if (t.uuid = this.uuid, t.type = this.type, "" !== this.name && (t.name = this
									.name), Object.keys(this.userData).length > 0 && (t.userData = this
									.userData), void 0 !== this.parameters) {
								var e = this.parameters;
								for (var i in e) void 0 !== e[i] && (t[i] = e[i]);
								return t
							}
							t.data = {
								attributes: {}
							};
							var n = this.index;
							if (null !== n) {
								var r = Array.prototype.slice.call(n.array);
								t.data.index = {
									type: n.array.constructor.name,
									array: r
								}
							}
							var a = this.attributes;
							for (var i in a) {
								var o = a[i],
									r = Array.prototype.slice.call(o.array);
								t.data.attributes[i] = {
									itemSize: o.itemSize,
									type: o.array.constructor.name,
									array: r,
									normalized: o.normalized
								}
							}
							var s = this.groups;
							s.length > 0 && (t.data.groups = JSON.parse(JSON.stringify(s)));
							var c = this.boundingSphere;
							return null !== c && (t.data.boundingSphere = {
								center: c.center.toArray(),
								radius: c.radius
							}), t
						},
						clone: function () {
							return (new Hi).copy(this)
						},
						copy: function (t) {
							var e, i, n;
							this.index = null, this.attributes = {}, this.morphAttributes = {}, this
								.groups = [], this.boundingBox = null, this.boundingSphere = null, this.name =
								t.name;
							var r = t.index;
							null !== r && this.setIndex(r.clone());
							var a = t.attributes;
							for (e in a) {
								var o = a[e];
								this.addAttribute(e, o.clone())
							}
							var s = t.morphAttributes;
							for (e in s) {
								var c = [],
									h = s[e];
								for (i = 0, n = h.length; i < n; i++) c.push(h[i].clone());
								this.morphAttributes[e] = c
							}
							var l = t.groups;
							for (i = 0, n = l.length; i < n; i++) {
								var u = l[i];
								this.addGroup(u.start, u.count, u.materialIndex)
							}
							var p = t.boundingBox;
							null !== p && (this.boundingBox = p.clone());
							var d = t.boundingSphere;
							return null !== d && (this.boundingSphere = d.clone()), this.drawRange.start = t
								.drawRange.start, this.drawRange.count = t.drawRange.count, this.userData = t
								.userData, this
						},
						dispose: function () {
							this.dispatchEvent({
								type: "dispose"
							})
						}
					}), ki.prototype = Object.create(Ai.prototype), ki.prototype.constructor = ki, ji.prototype =
					Object.create(Hi.prototype), ji.prototype.constructor = ji, Vi.prototype = Object.create(Ai
						.prototype), Vi.prototype.constructor = Vi, Wi.prototype = Object.create(Hi.prototype), Wi
					.prototype.constructor = Wi;
				var qi, Xi, Yi, Ji, Zi, Qi, Ki, $i, tn, en, nn, rn, an = 0;

				function on() {
					Object.defineProperty(this, "id", {
							value: an++
						}), this.uuid = Ie.generateUUID(), this.name = "", this.type = "Material", this.fog = !0, this
						.lights = !0, this.blending = A, this.side = b, this.flatShading = !1, this.vertexColors = M,
						this.opacity = 1, this.transparent = !1, this.blendSrc = H, this.blendDst = k, this
						.blendEquation = O, this.blendSrcAlpha = null, this.blendDstAlpha = null, this
						.blendEquationAlpha = null, this.depthFunc = Q, this.depthTest = !0, this.depthWrite = !0,
						this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this
						.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this
						.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaTest =
						0, this.premultipliedAlpha = !1, this.visible = !0, this.userData = {}, this.needsUpdate = !0
				}

				function sn(t) {
					on.call(this), this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this
						.vertexShader =
						"void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",
						this.fragmentShader = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}", this
						.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this
						.lights = !1, this.clipping = !1, this.skinning = !1, this.morphTargets = !1, this
						.morphNormals = !1, this.extensions = {
							derivatives: !1,
							fragDepth: !1,
							drawBuffers: !1,
							shaderTextureLOD: !1
						}, this.defaultAttributeValues = {
							color: [1, 1, 1],
							uv: [0, 0],
							uv2: [0, 0]
						}, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, void 0 !== t && (
							void 0 !== t.attributes && console.error(
								"THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."
								), this.setValues(t))
				}

				function cn(t, e) {
					this.origin = void 0 !== t ? t : new Ne, this.direction = void 0 !== e ? e : new Ne
				}

				function hn(t, e, i) {
					this.a = void 0 !== t ? t : new Ne, this.b = void 0 !== e ? e : new Ne, this.c = void 0 !== i ?
						i : new Ne
				}

				function ln(t) {
					on.call(this), this.type = "MeshBasicMaterial", this.color = new hi(16777215), this.map = null,
						this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1,
						this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = it, this
						.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth =
						1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this
						.morphTargets = !1, this.lights = !1, this.setValues(t)
				}

				function un(t, e) {
					Mi.call(this), this.type = "Mesh", this.geometry = void 0 !== t ? t : new Hi, this.material =
						void 0 !== e ? e : new ln({
							color: 16777215 * Math.random()
						}), this.drawMode = xe, this.updateMorphTargets()
				}

				function pn(t, e) {
					return Math.abs(e[1]) - Math.abs(t[1])
				}

				function dn(t, e, i, n, r, a, o, s, c, h) {
					t = void 0 !== t ? t : [], e = void 0 !== e ? e : ut, qe.call(this, t, e, i, n, r, a, o, s, c, h),
						this.flipY = !1
				}

				function fn(t, e, i, n) {
					qe.call(this, null), this.image = {
						data: t,
						width: e,
						height: i,
						depth: n
					}, this.magFilter = _t, this.minFilter = _t, this.generateMipmaps = !1, this.flipY = !1
				}
				on.prototype = Object.assign(Object.create(e.prototype), {
						constructor: on,
						isMaterial: !0,
						onBeforeCompile: function () {},
						setValues: function (t) {
							if (void 0 !== t)
								for (var e in t) {
									var i = t[e];
									if (void 0 !== i)
										if ("shading" !== e) {
											var n = this[e];
											void 0 !== n ? n && n.isColor ? n.set(i) : n && n.isVector3 &&
												i && i.isVector3 ? n.copy(i) : this[e] = i : console.warn(
													"THREE." + this.type + ": '" + e +
													"' is not a property of this material.")
										} else console.warn("THREE." + this.type +
											": .shading has been removed. Use the boolean .flatShading instead."
											), this.flatShading = 1 === i;
									else console.warn("THREE.Material: '" + e + "' parameter is undefined.")
								}
						},
						toJSON: function (t) {
							var e = void 0 === t || "string" == typeof t;
							e && (t = {
								textures: {},
								images: {}
							});
							var i = {
								metadata: {
									version: 4.5,
									type: "Material",
									generator: "Material.toJSON"
								}
							};

							function n(t) {
								var e = [];
								for (var i in t) {
									var n = t[i];
									delete n.metadata, e.push(n)
								}
								return e
							}
							if (i.uuid = this.uuid, i.type = this.type, "" !== this.name && (i.name = this
									.name), this.color && this.color.isColor && (i.color = this.color
								.getHex()), void 0 !== this.roughness && (i.roughness = this.roughness),
								void 0 !== this.metalness && (i.metalness = this.metalness), this.emissive &&
								this.emissive.isColor && (i.emissive = this.emissive.getHex()), 1 !== this
								.emissiveIntensity && (i.emissiveIntensity = this.emissiveIntensity), this
								.specular && this.specular.isColor && (i.specular = this.specular.getHex()),
								void 0 !== this.shininess && (i.shininess = this.shininess), void 0 !== this
								.clearCoat && (i.clearCoat = this.clearCoat), void 0 !== this
								.clearCoatRoughness && (i.clearCoatRoughness = this.clearCoatRoughness), this
								.map && this.map.isTexture && (i.map = this.map.toJSON(t).uuid), this
								.alphaMap && this.alphaMap.isTexture && (i.alphaMap = this.alphaMap.toJSON(t)
									.uuid), this.lightMap && this.lightMap.isTexture && (i.lightMap = this
									.lightMap.toJSON(t).uuid), this.aoMap && this.aoMap.isTexture && (i
									.aoMap = this.aoMap.toJSON(t).uuid, i.aoMapIntensity = this.aoMapIntensity
									), this.bumpMap && this.bumpMap.isTexture && (i.bumpMap = this.bumpMap
									.toJSON(t).uuid, i.bumpScale = this.bumpScale), this.normalMap && this
								.normalMap.isTexture && (i.normalMap = this.normalMap.toJSON(t).uuid, i
									.normalMapType = this.normalMapType, i.normalScale = this.normalScale
									.toArray()), this.displacementMap && this.displacementMap.isTexture && (i
									.displacementMap = this.displacementMap.toJSON(t).uuid, i
									.displacementScale = this.displacementScale, i.displacementBias = this
									.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (i
									.roughnessMap = this.roughnessMap.toJSON(t).uuid), this.metalnessMap &&
								this.metalnessMap.isTexture && (i.metalnessMap = this.metalnessMap.toJSON(t)
									.uuid), this.emissiveMap && this.emissiveMap.isTexture && (i.emissiveMap =
									this.emissiveMap.toJSON(t).uuid), this.specularMap && this.specularMap
								.isTexture && (i.specularMap = this.specularMap.toJSON(t).uuid), this
								.envMap && this.envMap.isTexture && (i.envMap = this.envMap.toJSON(t).uuid, i
									.reflectivity = this.reflectivity, void 0 !== this.combine && (i.combine =
										this.combine), void 0 !== this.envMapIntensity && (i.envMapIntensity =
										this.envMapIntensity)), this.gradientMap && this.gradientMap
								.isTexture && (i.gradientMap = this.gradientMap.toJSON(t).uuid), void 0 !==
								this.size && (i.size = this.size), void 0 !== this.sizeAttenuation && (i
									.sizeAttenuation = this.sizeAttenuation), this.blending !== A && (i
									.blending = this.blending), !0 === this.flatShading && (i.flatShading =
									this.flatShading), this.side !== b && (i.side = this.side), this
								.vertexColors !== M && (i.vertexColors = this.vertexColors), this.opacity <
								1 && (i.opacity = this.opacity), !0 === this.transparent && (i.transparent =
									this.transparent), i.depthFunc = this.depthFunc, i.depthTest = this
								.depthTest, i.depthWrite = this.depthWrite, 0 !== this.rotation && (i
									.rotation = this.rotation), !0 === this.polygonOffset && (i
									.polygonOffset = !0), 0 !== this.polygonOffsetFactor && (i
									.polygonOffsetFactor = this.polygonOffsetFactor), 0 !== this
								.polygonOffsetUnits && (i.polygonOffsetUnits = this.polygonOffsetUnits), 1 !==
								this.linewidth && (i.linewidth = this.linewidth), void 0 !== this.dashSize &&
								(i.dashSize = this.dashSize), void 0 !== this.gapSize && (i.gapSize = this
									.gapSize), void 0 !== this.scale && (i.scale = this.scale), !0 === this
								.dithering && (i.dithering = !0), this.alphaTest > 0 && (i.alphaTest = this
									.alphaTest), !0 === this.premultipliedAlpha && (i.premultipliedAlpha =
									this.premultipliedAlpha), !0 === this.wireframe && (i.wireframe = this
									.wireframe), this.wireframeLinewidth > 1 && (i.wireframeLinewidth = this
									.wireframeLinewidth), "round" !== this.wireframeLinecap && (i
									.wireframeLinecap = this.wireframeLinecap), "round" !== this
								.wireframeLinejoin && (i.wireframeLinejoin = this.wireframeLinejoin), !0 ===
								this.morphTargets && (i.morphTargets = !0), !0 === this.skinning && (i
									.skinning = !0), !1 === this.visible && (i.visible = !1), "{}" !== JSON
								.stringify(this.userData) && (i.userData = this.userData), e) {
								var r = n(t.textures),
									a = n(t.images);
								r.length > 0 && (i.textures = r), a.length > 0 && (i.images = a)
							}
							return i
						},
						clone: function () {
							return (new this.constructor).copy(this)
						},
						copy: function (t) {
							this.name = t.name, this.fog = t.fog, this.lights = t.lights, this.blending = t
								.blending, this.side = t.side, this.flatShading = t.flatShading, this
								.vertexColors = t.vertexColors, this.opacity = t.opacity, this.transparent = t
								.transparent, this.blendSrc = t.blendSrc, this.blendDst = t.blendDst, this
								.blendEquation = t.blendEquation, this.blendSrcAlpha = t.blendSrcAlpha, this
								.blendDstAlpha = t.blendDstAlpha, this.blendEquationAlpha = t
								.blendEquationAlpha, this.depthFunc = t.depthFunc, this.depthTest = t
								.depthTest, this.depthWrite = t.depthWrite, this.colorWrite = t.colorWrite,
								this.precision = t.precision, this.polygonOffset = t.polygonOffset, this
								.polygonOffsetFactor = t.polygonOffsetFactor, this.polygonOffsetUnits = t
								.polygonOffsetUnits, this.dithering = t.dithering, this.alphaTest = t
								.alphaTest, this.premultipliedAlpha = t.premultipliedAlpha, this.visible = t
								.visible, this.userData = JSON.parse(JSON.stringify(t.userData)), this
								.clipShadows = t.clipShadows, this.clipIntersection = t.clipIntersection;
							var e = t.clippingPlanes,
								i = null;
							if (null !== e) {
								var n = e.length;
								i = new Array(n);
								for (var r = 0; r !== n; ++r) i[r] = e[r].clone()
							}
							return this.clippingPlanes = i, this.shadowSide = t.shadowSide, this
						},
						dispose: function () {
							this.dispatchEvent({
								type: "dispose"
							})
						}
					}), sn.prototype = Object.create(on.prototype), sn.prototype.constructor = sn, sn.prototype
					.isShaderMaterial = !0, sn.prototype.copy = function (t) {
						return on.prototype.copy.call(this, t), this.fragmentShader = t.fragmentShader, this
							.vertexShader = t.vertexShader, this.uniforms = ii(t.uniforms), this.defines = Object
							.assign({}, t.defines), this.wireframe = t.wireframe, this.wireframeLinewidth = t
							.wireframeLinewidth, this.lights = t.lights, this.clipping = t.clipping, this.skinning = t
							.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this
							.extensions = t.extensions, this
					}, sn.prototype.toJSON = function (t) {
						var e = on.prototype.toJSON.call(this, t);
						for (var i in e.uniforms = {}, this.uniforms) {
							var n = this.uniforms[i],
								r = n.value;
							r && r.isTexture ? e.uniforms[i] = {
								type: "t",
								value: r.toJSON(t).uuid
							} : r && r.isColor ? e.uniforms[i] = {
								type: "c",
								value: r.getHex()
							} : r && r.isVector2 ? e.uniforms[i] = {
								type: "v2",
								value: r.toArray()
							} : r && r.isVector3 ? e.uniforms[i] = {
								type: "v3",
								value: r.toArray()
							} : r && r.isVector4 ? e.uniforms[i] = {
								type: "v4",
								value: r.toArray()
							} : r && r.isMatrix4 ? e.uniforms[i] = {
								type: "m4",
								value: r.toArray()
							} : e.uniforms[i] = {
								value: r
							}
						}
						Object.keys(this.defines).length > 0 && (e.defines = this.defines), e.vertexShader = this
							.vertexShader, e.fragmentShader = this.fragmentShader;
						var a = {};
						for (var o in this.extensions) !0 === this.extensions[o] && (a[o] = !0);
						return Object.keys(a).length > 0 && (e.extensions = a), e
					}, Object.assign(cn.prototype, {
						set: function (t, e) {
							return this.origin.copy(t), this.direction.copy(e), this
						},
						clone: function () {
							return (new this.constructor).copy(this)
						},
						copy: function (t) {
							return this.origin.copy(t.origin), this.direction.copy(t.direction), this
						},
						at: function (t, e) {
							return void 0 === e && (console.warn("THREE.Ray: .at() target is now required"),
								e = new Ne), e.copy(this.direction).multiplyScalar(t).add(this.origin)
						},
						lookAt: function (t) {
							return this.direction.copy(t).sub(this.origin).normalize(), this
						},
						recast: function () {
							var t = new Ne;
							return function (e) {
								return this.origin.copy(this.at(e, t)), this
							}
						}(),
						closestPointToPoint: function (t, e) {
							void 0 === e && (console.warn(
									"THREE.Ray: .closestPointToPoint() target is now required"), e =
								new Ne), e.subVectors(t, this.origin);
							var i = e.dot(this.direction);
							return i < 0 ? e.copy(this.origin) : e.copy(this.direction).multiplyScalar(i).add(
								this.origin)
						},
						distanceToPoint: function (t) {
							return Math.sqrt(this.distanceSqToPoint(t))
						},
						distanceSqToPoint: function () {
							var t = new Ne;
							return function (e) {
								var i = t.subVectors(e, this.origin).dot(this.direction);
								return i < 0 ? this.origin.distanceToSquared(e) : (t.copy(this.direction)
									.multiplyScalar(i).add(this.origin), t.distanceToSquared(e))
							}
						}(),
						distanceSqToSegment: (en = new Ne, nn = new Ne, rn = new Ne, function (t, e, i, n) {
							en.copy(t).add(e).multiplyScalar(.5), nn.copy(e).sub(t).normalize(), rn.copy(
								this.origin).sub(en);
							var r, a, o, s, c = .5 * t.distanceTo(e),
								h = -this.direction.dot(nn),
								l = rn.dot(this.direction),
								u = -rn.dot(nn),
								p = rn.lengthSq(),
								d = Math.abs(1 - h * h);
							if (d > 0)
								if (a = h * l - u, s = c * d, (r = h * u - l) >= 0)
									if (a >= -s)
										if (a <= s) {
											var f = 1 / d;
											o = (r *= f) * (r + h * (a *= f) + 2 * l) + a * (h * r + a +
												2 * u) + p
										} else a = c, r = Math.max(0, -(h * a + l)), o = -r * r + a * (a +
											2 * u) + p;
							else a = -c, r = Math.max(0, -(h * a + l)), o = -r * r + a * (a + 2 * u) + p;
							else a <= -s ? (r = Math.max(0, -(-h * c + l)), a = r > 0 ? -c : Math.min(Math
								.max(-c, -u), c), o = -r * r + a * (a + 2 * u) + p) : a <= s ? (r = 0,
								a = Math.min(Math.max(-c, -u), c), o = a * (a + 2 * u) + p) : (r =
								Math.max(0, -(h * c + l)), a = r > 0 ? c : Math.min(Math.max(-c, -u),
									c), o = -r * r + a * (a + 2 * u) + p);
							else a = h > 0 ? -c : c, r = Math.max(0, -(h * a + l)), o = -r * r + a * (a +
								2 * u) + p;
							return i && i.copy(this.direction).multiplyScalar(r).add(this.origin), n && n
								.copy(nn).multiplyScalar(a).add(en), o
						}),
						intersectSphere: function () {
							var t = new Ne;
							return function (e, i) {
								t.subVectors(e.center, this.origin);
								var n = t.dot(this.direction),
									r = t.dot(t) - n * n,
									a = e.radius * e.radius;
								if (r > a) return null;
								var o = Math.sqrt(a - r),
									s = n - o,
									c = n + o;
								return s < 0 && c < 0 ? null : s < 0 ? this.at(c, i) : this.at(s, i)
							}
						}(),
						intersectsSphere: function (t) {
							return this.distanceSqToPoint(t.center) <= t.radius * t.radius
						},
						distanceToPlane: function (t) {
							var e = t.normal.dot(this.direction);
							if (0 === e) return 0 === t.distanceToPoint(this.origin) ? 0 : null;
							var i = -(this.origin.dot(t.normal) + t.constant) / e;
							return i >= 0 ? i : null
						},
						intersectPlane: function (t, e) {
							var i = this.distanceToPlane(t);
							return null === i ? null : this.at(i, e)
						},
						intersectsPlane: function (t) {
							var e = t.distanceToPoint(this.origin);
							if (0 === e) return !0;
							var i = t.normal.dot(this.direction);
							return i * e < 0
						},
						intersectBox: function (t, e) {
							var i, n, r, a, o, s, c = 1 / this.direction.x,
								h = 1 / this.direction.y,
								l = 1 / this.direction.z,
								u = this.origin;
							return c >= 0 ? (i = (t.min.x - u.x) * c, n = (t.max.x - u.x) * c) : (i = (t.max
								.x - u.x) * c, n = (t.min.x - u.x) * c), h >= 0 ? (r = (t.min.y - u.y) *
								h, a = (t.max.y - u.y) * h) : (r = (t.max.y - u.y) * h, a = (t.min.y - u
								.y) * h), i > a || r > n ? null : ((r > i || i != i) && (i = r), (a < n ||
									n != n) && (n = a), l >= 0 ? (o = (t.min.z - u.z) * l, s = (t.max.z -
									u.z) * l) : (o = (t.max.z - u.z) * l, s = (t.min.z - u.z) * l), i >
								s || o > n ? null : ((o > i || i != i) && (i = o), (s < n || n != n) && (
									n = s), n < 0 ? null : this.at(i >= 0 ? i : n, e)))
						},
						intersectsBox: (tn = new Ne, function (t) {
							return null !== this.intersectBox(t, tn)
						}),
						intersectTriangle: function () {
							var t = new Ne,
								e = new Ne,
								i = new Ne,
								n = new Ne;
							return function (r, a, o, s, c) {
								e.subVectors(a, r), i.subVectors(o, r), n.crossVectors(e, i);
								var h, l = this.direction.dot(n);
								if (l > 0) {
									if (s) return null;
									h = 1
								} else {
									if (!(l < 0)) return null;
									h = -1, l = -l
								}
								t.subVectors(this.origin, r);
								var u = h * this.direction.dot(i.crossVectors(t, i));
								if (u < 0) return null;
								var p = h * this.direction.dot(e.cross(t));
								if (p < 0) return null;
								if (u + p > l) return null;
								var d = -h * t.dot(n);
								return d < 0 ? null : this.at(d / l, c)
							}
						}(),
						applyMatrix4: function (t) {
							return this.origin.applyMatrix4(t), this.direction.transformDirection(t), this
						},
						equals: function (t) {
							return t.origin.equals(this.origin) && t.direction.equals(this.direction)
						}
					}), Object.assign(hn, {
						getNormal: ($i = new Ne, function (t, e, i, n) {
							void 0 === n && (console.warn(
									"THREE.Triangle: .getNormal() target is now required"), n =
								new Ne), n.subVectors(i, e), $i.subVectors(t, e), n.cross($i);
							var r = n.lengthSq();
							return r > 0 ? n.multiplyScalar(1 / Math.sqrt(r)) : n.set(0, 0, 0)
						}),
						getBarycoord: function () {
							var t = new Ne,
								e = new Ne,
								i = new Ne;
							return function (n, r, a, o, s) {
								t.subVectors(o, r), e.subVectors(a, r), i.subVectors(n, r);
								var c = t.dot(t),
									h = t.dot(e),
									l = t.dot(i),
									u = e.dot(e),
									p = e.dot(i),
									d = c * u - h * h;
								if (void 0 === s && (console.warn(
											"THREE.Triangle: .getBarycoord() target is now required"), s =
										new Ne), 0 === d) return s.set(-2, -1, -1);
								var f = 1 / d,
									m = (u * l - h * p) * f,
									g = (c * p - h * l) * f;
								return s.set(1 - m - g, g, m)
							}
						}(),
						containsPoint: function () {
							var t = new Ne;
							return function (e, i, n, r) {
								return hn.getBarycoord(e, i, n, r, t), t.x >= 0 && t.y >= 0 && t.x + t
									.y <= 1
							}
						}(),
						getUV: (Ki = new Ne, function (t, e, i, n, r, a, o, s) {
							return this.getBarycoord(t, e, i, n, Ki), s.set(0, 0), s.addScaledVector(r, Ki
								.x), s.addScaledVector(a, Ki.y), s.addScaledVector(o, Ki.z), s
						})
					}), Object.assign(hn.prototype, {
						set: function (t, e, i) {
							return this.a.copy(t), this.b.copy(e), this.c.copy(i), this
						},
						setFromPointsAndIndices: function (t, e, i, n) {
							return this.a.copy(t[e]), this.b.copy(t[i]), this.c.copy(t[n]), this
						},
						clone: function () {
							return (new this.constructor).copy(this)
						},
						copy: function (t) {
							return this.a.copy(t.a), this.b.copy(t.b), this.c.copy(t.c), this
						},
						getArea: function () {
							var t = new Ne,
								e = new Ne;
							return function () {
								return t.subVectors(this.c, this.b), e.subVectors(this.a, this.b), .5 * t
									.cross(e).length()
							}
						}(),
						getMidpoint: function (t) {
							return void 0 === t && (console.warn(
									"THREE.Triangle: .getMidpoint() target is now required"), t = new Ne), t
								.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
						},
						getNormal: function (t) {
							return hn.getNormal(this.a, this.b, this.c, t)
						},
						getPlane: function (t) {
							return void 0 === t && (console.warn(
									"THREE.Triangle: .getPlane() target is now required"), t = new Ne), t
								.setFromCoplanarPoints(this.a, this.b, this.c)
						},
						getBarycoord: function (t, e) {
							return hn.getBarycoord(t, this.a, this.b, this.c, e)
						},
						containsPoint: function (t) {
							return hn.containsPoint(t, this.a, this.b, this.c)
						},
						getUV: function (t, e, i, n, r) {
							return hn.getUV(t, this.a, this.b, this.c, e, i, n, r)
						},
						intersectsBox: function (t) {
							return t.intersectsTriangle(this)
						},
						closestPointToPoint: (qi = new Ne, Xi = new Ne, Yi = new Ne, Ji = new Ne, Zi = new Ne,
							Qi = new Ne,
							function (t, e) {
								void 0 === e && (console.warn(
										"THREE.Triangle: .closestPointToPoint() target is now required"),
									e = new Ne);
								var i, n, r = this.a,
									a = this.b,
									o = this.c;
								qi.subVectors(a, r), Xi.subVectors(o, r), Ji.subVectors(t, r);
								var s = qi.dot(Ji),
									c = Xi.dot(Ji);
								if (s <= 0 && c <= 0) return e.copy(r);
								Zi.subVectors(t, a);
								var h = qi.dot(Zi),
									l = Xi.dot(Zi);
								if (h >= 0 && l <= h) return e.copy(a);
								var u = s * l - h * c;
								if (u <= 0 && s >= 0 && h <= 0) return i = s / (s - h), e.copy(r)
									.addScaledVector(qi, i);
								Qi.subVectors(t, o);
								var p = qi.dot(Qi),
									d = Xi.dot(Qi);
								if (d >= 0 && p <= d) return e.copy(o);
								var f = p * c - s * d;
								if (f <= 0 && c >= 0 && d <= 0) return n = c / (c - d), e.copy(r)
									.addScaledVector(Xi, n);
								var m = h * d - p * l;
								if (m <= 0 && l - h >= 0 && p - d >= 0) return Yi.subVectors(o, a), n = (l -
									h) / (l - h + (p - d)), e.copy(a).addScaledVector(Yi, n);
								var g = 1 / (m + f + u);
								return i = f * g, n = u * g, e.copy(r).addScaledVector(qi, i).addScaledVector(
									Xi, n)
							}),
						equals: function (t) {
							return t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c)
						}
					}), ln.prototype = Object.create(on.prototype), ln.prototype.constructor = ln, ln.prototype
					.isMeshBasicMaterial = !0, ln.prototype.copy = function (t) {
						return on.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this
							.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t
							.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.specularMap = t.specularMap, this
							.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this
							.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe =
							t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t
							.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t
							.skinning, this.morphTargets = t.morphTargets, this
					}, un.prototype = Object.assign(Object.create(Mi.prototype), {
						constructor: un,
						isMesh: !0,
						setDrawMode: function (t) {
							this.drawMode = t
						},
						copy: function (t) {
							return Mi.prototype.copy.call(this, t), this.drawMode = t.drawMode, void 0 !== t
								.morphTargetInfluences && (this.morphTargetInfluences = t
									.morphTargetInfluences.slice()), void 0 !== t.morphTargetDictionary && (
									this.morphTargetDictionary = Object.assign({}, t.morphTargetDictionary)),
								this
						},
						updateMorphTargets: function () {
							var t, e, i, n = this.geometry;
							if (n.isBufferGeometry) {
								var r = n.morphAttributes,
									a = Object.keys(r);
								if (a.length > 0) {
									var o = r[a[0]];
									if (void 0 !== o)
										for (this.morphTargetInfluences = [], this.morphTargetDictionary = {},
											t = 0, e = o.length; t < e; t++) i = o[t].name || String(t), this
											.morphTargetInfluences.push(0), this.morphTargetDictionary[i] = t
								}
							} else {
								var s = n.morphTargets;
								void 0 !== s && s.length > 0 && console.error(
									"THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
									)
							}
						},
						raycast: function () {
							var t = new Be,
								e = new cn,
								i = new Ke,
								n = new Ne,
								r = new Ne,
								a = new Ne,
								o = new Ne,
								s = new Ne,
								c = new Ne,
								h = new De,
								l = new De,
								u = new De,
								p = new Ne,
								d = new Ne;

							function f(t, e, i, n, r, a, o, s) {
								if (null === (e.side === _ ? n.intersectTriangle(o, a, r, !0, s) : n
										.intersectTriangle(r, a, o, e.side !== w, s))) return null;
								d.copy(s), d.applyMatrix4(t.matrixWorld);
								var c = i.ray.origin.distanceTo(d);
								return c < i.near || c > i.far ? null : {
									distance: c,
									point: d.clone(),
									object: t
								}
							}

							function m(t, e, i, o, s, c, d, m, g) {
								n.fromBufferAttribute(s, d), r.fromBufferAttribute(s, m), a
									.fromBufferAttribute(s, g);
								var v = f(t, e, i, o, n, r, a, p);
								if (v) {
									c && (h.fromBufferAttribute(c, d), l.fromBufferAttribute(c, m), u
										.fromBufferAttribute(c, g), v.uv = hn.getUV(p, n, r, a, h, l, u,
											new De));
									var y = new mi(d, m, g);
									hn.getNormal(n, r, a, y.normal), v.face = y
								}
								return v
							}
							return function (d, g) {
								var v, y = this.geometry,
									x = this.material,
									b = this.matrixWorld;
								if (void 0 !== x && (null === y.boundingSphere && y
										.computeBoundingSphere(), i.copy(y.boundingSphere), i
										.applyMatrix4(b), !1 !== d.ray.intersectsSphere(i) && (t
											.getInverse(b), e.copy(d.ray).applyMatrix4(t), null === y
											.boundingBox || !1 !== e.intersectsBox(y.boundingBox))))
									if (y.isBufferGeometry) {
										var _, w, M, S, E, T, A, L, P, C, R, O = y.index,
											I = y.attributes.position,
											D = y.attributes.uv,
											B = y.groups,
											z = y.drawRange;
										if (null !== O)
											if (Array.isArray(x))
												for (S = 0, T = B.length; S < T; S++)
													for (L = B[S], P = x[L.materialIndex], C = Math.max(L
															.start, z.start), R = Math.min(L.start + L
															.count, z.start + z.count), E = C, A = R; E <
														A; E += 3) _ = O.getX(E), w = O.getX(E + 1), M = O
														.getX(E + 2), (v = m(this, P, d, e, I, D, _, w,
															M)) && (v.faceIndex = Math.floor(E / 3), g
															.push(v));
											else
												for (C = Math.max(0, z.start), R = Math.min(O.count, z
														.start + z.count), S = C, T = R; S < T; S += 3)
													_ = O.getX(S), w = O.getX(S + 1), M = O.getX(S + 2), (
														v = m(this, x, d, e, I, D, _, w, M)) && (v
														.faceIndex = Math.floor(S / 3), g.push(v));
										else if (void 0 !== I)
											if (Array.isArray(x))
												for (S = 0, T = B.length; S < T; S++)
													for (L = B[S], P = x[L.materialIndex], C = Math.max(L
															.start, z.start), R = Math.min(L.start + L
															.count, z.start + z.count), E = C, A = R; E <
														A; E += 3)(v = m(this, P, d, e, I, D, _ = E, w =
														E + 1, M = E + 2)) && (v.faceIndex = Math
														.floor(E / 3), g.push(v));
											else
												for (C = Math.max(0, z.start), R = Math.min(I.count, z
														.start + z.count), S = C, T = R; S < T; S += 3)(
													v = m(this, x, d, e, I, D, _ = S, w = S + 1, M =
														S + 2)) && (v.faceIndex = Math.floor(S / 3), g
													.push(v))
									} else if (y.isGeometry) {
									var N, U, G, F, H = Array.isArray(x),
										k = y.vertices,
										j = y.faces,
										V = y.faceVertexUvs[0];
									V.length > 0 && (F = V);
									for (var W = 0, q = j.length; W < q; W++) {
										var X = j[W],
											Y = H ? x[X.materialIndex] : x;
										if (void 0 !== Y) {
											if (N = k[X.a], U = k[X.b], G = k[X.c], !0 === Y
												.morphTargets) {
												var J = y.morphTargets,
													Z = this.morphTargetInfluences;
												n.set(0, 0, 0), r.set(0, 0, 0), a.set(0, 0, 0);
												for (var Q = 0, K = J.length; Q < K; Q++) {
													var $ = Z[Q];
													if (0 !== $) {
														var tt = J[Q].vertices;
														n.addScaledVector(o.subVectors(tt[X.a], N), $), r
															.addScaledVector(s.subVectors(tt[X.b], U), $),
															a.addScaledVector(c.subVectors(tt[X.c], G), $)
													}
												}
												n.add(N), r.add(U), a.add(G), N = n, U = r, G = a
											}
											if (v = f(this, Y, d, e, N, U, G, p)) {
												if (F && F[W]) {
													var et = F[W];
													h.copy(et[0]), l.copy(et[1]), u.copy(et[2]), v.uv = hn
														.getUV(p, N, U, G, h, l, u, new De)
												}
												v.face = X, v.faceIndex = W, g.push(v)
											}
										}
									}
								}
							}
						}(),
						clone: function () {
							return new this.constructor(this.geometry, this.material).copy(this)
						}
					}), dn.prototype = Object.create(qe.prototype), dn.prototype.constructor = dn, dn.prototype
					.isCubeTexture = !0, Object.defineProperty(dn.prototype, "images", {
						get: function () {
							return this.image
						},
						set: function (t) {
							this.image = t
						}
					}), fn.prototype = Object.create(qe.prototype), fn.prototype.constructor = fn, fn.prototype
					.isDataTexture3D = !0;
				var mn = new qe,
					gn = new fn,
					vn = new dn;

				function yn() {
					this.seq = [], this.map = {}
				}
				var xn = [],
					bn = [],
					_n = new Float32Array(16),
					wn = new Float32Array(9),
					Mn = new Float32Array(4);

				function Sn(t, e, i) {
					var n = t[0];
					if (n <= 0 || n > 0) return t;
					var r = e * i,
						a = xn[r];
					if (void 0 === a && (a = new Float32Array(r), xn[r] = a), 0 !== e) {
						n.toArray(a, 0);
						for (var o = 1, s = 0; o !== e; ++o) s += i, t[o].toArray(a, s)
					}
					return a
				}

				function En(t, e) {
					if (t.length !== e.length) return !1;
					for (var i = 0, n = t.length; i < n; i++)
						if (t[i] !== e[i]) return !1;
					return !0
				}

				function Tn(t, e) {
					for (var i = 0, n = e.length; i < n; i++) t[i] = e[i]
				}

				function An(t, e) {
					var i = bn[e];
					void 0 === i && (i = new Int32Array(e), bn[e] = i);
					for (var n = 0; n !== e; ++n) i[n] = t.allocTextureUnit();
					return i
				}

				function Ln(t, e) {
					var i = this.cache;
					i[0] !== e && (t.uniform1f(this.addr, e), i[0] = e)
				}

				function Pn(t, e) {
					var i = this.cache;
					i[0] !== e && (t.uniform1i(this.addr, e), i[0] = e)
				}

				function Cn(t, e) {
					var i = this.cache;
					if (void 0 !== e.x) i[0] === e.x && i[1] === e.y || (t.uniform2f(this.addr, e.x, e.y), i[0] = e.x,
						i[1] = e.y);
					else {
						if (En(i, e)) return;
						t.uniform2fv(this.addr, e), Tn(i, e)
					}
				}

				function Rn(t, e) {
					var i = this.cache;
					if (void 0 !== e.x) i[0] === e.x && i[1] === e.y && i[2] === e.z || (t.uniform3f(this.addr, e.x, e
						.y, e.z), i[0] = e.x, i[1] = e.y, i[2] = e.z);
					else if (void 0 !== e.r) i[0] === e.r && i[1] === e.g && i[2] === e.b || (t.uniform3f(this.addr, e
						.r, e.g, e.b), i[0] = e.r, i[1] = e.g, i[2] = e.b);
					else {
						if (En(i, e)) return;
						t.uniform3fv(this.addr, e), Tn(i, e)
					}
				}

				function On(t, e) {
					var i = this.cache;
					if (void 0 !== e.x) i[0] === e.x && i[1] === e.y && i[2] === e.z && i[3] === e.w || (t.uniform4f(
						this.addr, e.x, e.y, e.z, e.w), i[0] = e.x, i[1] = e.y, i[2] = e.z, i[3] = e.w);
					else {
						if (En(i, e)) return;
						t.uniform4fv(this.addr, e), Tn(i, e)
					}
				}

				function In(t, e) {
					var i = this.cache,
						n = e.elements;
					if (void 0 === n) {
						if (En(i, e)) return;
						t.uniformMatrix2fv(this.addr, !1, e), Tn(i, e)
					} else {
						if (En(i, n)) return;
						Mn.set(n), t.uniformMatrix2fv(this.addr, !1, Mn), Tn(i, n)
					}
				}

				function Dn(t, e) {
					var i = this.cache,
						n = e.elements;
					if (void 0 === n) {
						if (En(i, e)) return;
						t.uniformMatrix3fv(this.addr, !1, e), Tn(i, e)
					} else {
						if (En(i, n)) return;
						wn.set(n), t.uniformMatrix3fv(this.addr, !1, wn), Tn(i, n)
					}
				}

				function Bn(t, e) {
					var i = this.cache,
						n = e.elements;
					if (void 0 === n) {
						if (En(i, e)) return;
						t.uniformMatrix4fv(this.addr, !1, e), Tn(i, e)
					} else {
						if (En(i, n)) return;
						_n.set(n), t.uniformMatrix4fv(this.addr, !1, _n), Tn(i, n)
					}
				}

				function zn(t, e, i) {
					var n = this.cache,
						r = i.allocTextureUnit();
					n[0] !== r && (t.uniform1i(this.addr, r), n[0] = r), i.setTexture2D(e || mn, r)
				}

				function Nn(t, e, i) {
					var n = this.cache,
						r = i.allocTextureUnit();
					n[0] !== r && (t.uniform1i(this.addr, r), n[0] = r), i.setTexture3D(e || gn, r)
				}

				function Un(t, e, i) {
					var n = this.cache,
						r = i.allocTextureUnit();
					n[0] !== r && (t.uniform1i(this.addr, r), n[0] = r), i.setTextureCube(e || vn, r)
				}

				function Gn(t, e) {
					var i = this.cache;
					En(i, e) || (t.uniform2iv(this.addr, e), Tn(i, e))
				}

				function Fn(t, e) {
					var i = this.cache;
					En(i, e) || (t.uniform3iv(this.addr, e), Tn(i, e))
				}

				function Hn(t, e) {
					var i = this.cache;
					En(i, e) || (t.uniform4iv(this.addr, e), Tn(i, e))
				}

				function kn(t, e) {
					var i = this.cache;
					En(i, e) || (t.uniform1fv(this.addr, e), Tn(i, e))
				}

				function jn(t, e) {
					var i = this.cache;
					En(i, e) || (t.uniform1iv(this.addr, e), Tn(i, e))
				}

				function Vn(t, e) {
					var i = this.cache,
						n = Sn(e, this.size, 2);
					En(i, n) || (t.uniform2fv(this.addr, n), this.updateCache(n))
				}

				function Wn(t, e) {
					var i = this.cache,
						n = Sn(e, this.size, 3);
					En(i, n) || (t.uniform3fv(this.addr, n), this.updateCache(n))
				}

				function qn(t, e) {
					var i = this.cache,
						n = Sn(e, this.size, 4);
					En(i, n) || (t.uniform4fv(this.addr, n), this.updateCache(n))
				}

				function Xn(t, e) {
					var i = this.cache,
						n = Sn(e, this.size, 4);
					En(i, n) || (t.uniformMatrix2fv(this.addr, !1, n), this.updateCache(n))
				}

				function Yn(t, e) {
					var i = this.cache,
						n = Sn(e, this.size, 9);
					En(i, n) || (t.uniformMatrix3fv(this.addr, !1, n), this.updateCache(n))
				}

				function Jn(t, e) {
					var i = this.cache,
						n = Sn(e, this.size, 16);
					En(i, n) || (t.uniformMatrix4fv(this.addr, !1, n), this.updateCache(n))
				}

				function Zn(t, e, i) {
					var n = this.cache,
						r = e.length,
						a = An(i, r);
					!1 === En(n, a) && (t.uniform1iv(this.addr, a), Tn(n, a));
					for (var o = 0; o !== r; ++o) i.setTexture2D(e[o] || mn, a[o])
				}

				function Qn(t, e, i) {
					var n = this.cache,
						r = e.length,
						a = An(i, r);
					!1 === En(n, a) && (t.uniform1iv(this.addr, a), Tn(n, a));
					for (var o = 0; o !== r; ++o) i.setTextureCube(e[o] || vn, a[o])
				}

				function Kn(t, e, i) {
					this.id = t, this.addr = i, this.cache = [], this.setValue = function (t) {
						switch (t) {
							case 5126:
								return Ln;
							case 35664:
								return Cn;
							case 35665:
								return Rn;
							case 35666:
								return On;
							case 35674:
								return In;
							case 35675:
								return Dn;
							case 35676:
								return Bn;
							case 35678:
							case 36198:
								return zn;
							case 35679:
								return Nn;
							case 35680:
								return Un;
							case 5124:
							case 35670:
								return Pn;
							case 35667:
							case 35671:
								return Gn;
							case 35668:
							case 35672:
								return Fn;
							case 35669:
							case 35673:
								return Hn
						}
					}(e.type)
				}

				function $n(t, e, i) {
					this.id = t, this.addr = i, this.cache = [], this.size = e.size, this.setValue = function (t) {
						switch (t) {
							case 5126:
								return kn;
							case 35664:
								return Vn;
							case 35665:
								return Wn;
							case 35666:
								return qn;
							case 35674:
								return Xn;
							case 35675:
								return Yn;
							case 35676:
								return Jn;
							case 35678:
								return Zn;
							case 35680:
								return Qn;
							case 5124:
							case 35670:
								return jn;
							case 35667:
							case 35671:
								return Gn;
							case 35668:
							case 35672:
								return Fn;
							case 35669:
							case 35673:
								return Hn
						}
					}(e.type)
				}

				function tr(t) {
					this.id = t, yn.call(this)
				}
				$n.prototype.updateCache = function (t) {
					var e = this.cache;
					t instanceof Float32Array && e.length !== t.length && (this.cache = new Float32Array(t
						.length)), Tn(e, t)
				}, tr.prototype.setValue = function (t, e, i) {
					for (var n = this.seq, r = 0, a = n.length; r !== a; ++r) {
						var o = n[r];
						o.setValue(t, e[o.id], i)
					}
				};
				var er = /([\w\d_]+)(\])?(\[|\.)?/g;

				function ir(t, e) {
					t.seq.push(e), t.map[e.id] = e
				}

				function nr(t, e, i) {
					var n = t.name,
						r = n.length;
					for (er.lastIndex = 0;;) {
						var a = er.exec(n),
							o = er.lastIndex,
							s = a[1],
							c = "]" === a[2],
							h = a[3];
						if (c && (s |= 0), void 0 === h || "[" === h && o + 2 === r) {
							ir(i, void 0 === h ? new Kn(s, t, e) : new $n(s, t, e));
							break
						}
						var l = i.map,
							u = l[s];
						void 0 === u && (u = new tr(s), ir(i, u)), i = u
					}
				}

				function rr(t, e, i) {
					yn.call(this), this.renderer = i;
					for (var n = t.getProgramParameter(e, 35718), r = 0; r < n; ++r) {
						var a = t.getActiveUniform(e, r),
							o = t.getUniformLocation(e, a.name);
						nr(a, o, this)
					}
				}

				function ar(t, e, i) {
					var n = t.createShader(e);
					return t.shaderSource(n, i), t.compileShader(n), !1 === t.getShaderParameter(n, 35713) && console
						.error("THREE.WebGLShader: Shader couldn't compile."), "" !== t.getShaderInfoLog(n) && console
						.warn("THREE.WebGLShader: gl.getShaderInfoLog()", 35633 === e ? "vertex" : "fragment", t
							.getShaderInfoLog(n),
							function (t) {
								for (var e = t.split("\n"), i = 0; i < e.length; i++) e[i] = i + 1 + ": " + e[i];
								return e.join("\n")
							}(i)), n
				}
				rr.prototype.setValue = function (t, e, i) {
					var n = this.map[e];
					void 0 !== n && n.setValue(t, i, this.renderer)
				}, rr.prototype.setOptional = function (t, e, i) {
					var n = e[i];
					void 0 !== n && this.setValue(t, i, n)
				}, rr.upload = function (t, e, i, n) {
					for (var r = 0, a = e.length; r !== a; ++r) {
						var o = e[r],
							s = i[o.id];
						!1 !== s.needsUpdate && o.setValue(t, s.value, n)
					}
				}, rr.seqWithValue = function (t, e) {
					for (var i = [], n = 0, r = t.length; n !== r; ++n) {
						var a = t[n];
						a.id in e && i.push(a)
					}
					return i
				};
				var or = 0;

				function sr(t) {
					switch (t) {
						case we:
							return ["Linear", "( value )"];
						case Me:
							return ["sRGB", "( value )"];
						case Ee:
							return ["RGBE", "( value )"];
						case Te:
							return ["RGBM", "( value, 7.0 )"];
						case Ae:
							return ["RGBM", "( value, 16.0 )"];
						case Le:
							return ["RGBD", "( value, 256.0 )"];
						case Se:
							return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
						default:
							throw new Error("unsupported encoding: " + t)
					}
				}

				function cr(t, e) {
					var i = sr(e);
					return "vec4 " + t + "( vec4 value ) { return " + i[0] + "ToLinear" + i[1] + "; }"
				}

				function hr(t) {
					return "" !== t
				}

				function lr(t, e) {
					return t.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights)
						.replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e
							.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights)
				}

				function ur(t, e) {
					return t.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e
						.numClippingPlanes - e.numClipIntersection)
				}

				function pr(t) {
					return t.replace(/^[ \t]*#include +<([\w\d./]+)>/gm, function (t, e) {
						var i = ei[e];
						if (void 0 === i) throw new Error("Can not resolve #include <" + e + ">");
						return pr(i)
					})
				}

				function dr(t) {
					return t.replace(
						/#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,
						function (t, e, i, n) {
							for (var r = "", a = parseInt(e); a < parseInt(i); a++) r += n.replace(/\[ i \]/g,
								"[ " + a + " ]");
							return r
						})
				}

				function fr(t, e, i, n, r, a, o) {
					var s = t.context,
						c = n.defines,
						h = r.vertexShader,
						l = r.fragmentShader,
						u = "SHADOWMAP_TYPE_BASIC";
					a.shadowMapType === y ? u = "SHADOWMAP_TYPE_PCF" : a.shadowMapType === x && (u =
						"SHADOWMAP_TYPE_PCF_SOFT");
					var p = "ENVMAP_TYPE_CUBE",
						d = "ENVMAP_MODE_REFLECTION",
						f = "ENVMAP_BLENDING_MULTIPLY";
					if (a.envMap) {
						switch (n.envMap.mapping) {
							case ut:
							case pt:
								p = "ENVMAP_TYPE_CUBE";
								break;
							case gt:
							case vt:
								p = "ENVMAP_TYPE_CUBE_UV";
								break;
							case dt:
							case ft:
								p = "ENVMAP_TYPE_EQUIREC";
								break;
							case mt:
								p = "ENVMAP_TYPE_SPHERE"
						}
						switch (n.envMap.mapping) {
							case pt:
							case ft:
								d = "ENVMAP_MODE_REFRACTION"
						}
						switch (n.combine) {
							case it:
								f = "ENVMAP_BLENDING_MULTIPLY";
								break;
							case nt:
								f = "ENVMAP_BLENDING_MIX";
								break;
							case rt:
								f = "ENVMAP_BLENDING_ADD"
						}
					}
					var m, g, v, b, _, w = t.gammaFactor > 0 ? t.gammaFactor : 1,
						M = o.isWebGL2 ? "" : function (t, e, i) {
							return [(t = t || {}).derivatives || e.envMapCubeUV || e.bumpMap || e.normalMap && !e
								.objectSpaceNormalMap || e.flatShading ?
								"#extension GL_OES_standard_derivatives : enable" : "", (t.fragDepth || e
									.logarithmicDepthBuffer) && i.get("EXT_frag_depth") ?
								"#extension GL_EXT_frag_depth : enable" : "", t.drawBuffers && i.get(
									"WEBGL_draw_buffers") ? "#extension GL_EXT_draw_buffers : require" : "", (t
									.shaderTextureLOD || e.envMap) && i.get("EXT_shader_texture_lod") ?
								"#extension GL_EXT_shader_texture_lod : enable" : ""
							].filter(hr).join("\n")
						}(n.extensions, a, e),
						S = function (t) {
							var e = [];
							for (var i in t) {
								var n = t[i];
								!1 !== n && e.push("#define " + i + " " + n)
							}
							return e.join("\n")
						}(c),
						E = s.createProgram();
					if (n.isRawShaderMaterial ? ((m = [S].filter(hr).join("\n")).length > 0 && (m += "\n"), (g = [M,
							S].filter(hr).join("\n")).length > 0 && (g += "\n")) : (m = ["precision " + a.precision +
							" float;", "precision " + a.precision + " int;", "#define SHADER_NAME " + r.name, S, a
							.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define GAMMA_FACTOR " + w,
							"#define MAX_BONES " + a.maxBones, a.useFog && a.fog ? "#define USE_FOG" : "", a
							.useFog && a.fogExp ? "#define FOG_EXP2" : "", a.map ? "#define USE_MAP" : "", a
							.envMap ? "#define USE_ENVMAP" : "", a.envMap ? "#define " + d : "", a.lightMap ?
							"#define USE_LIGHTMAP" : "", a.aoMap ? "#define USE_AOMAP" : "", a.emissiveMap ?
							"#define USE_EMISSIVEMAP" : "", a.bumpMap ? "#define USE_BUMPMAP" : "", a.normalMap ?
							"#define USE_NORMALMAP" : "", a.normalMap && a.objectSpaceNormalMap ?
							"#define OBJECTSPACE_NORMALMAP" : "", a.displacementMap && a.supportsVertexTextures ?
							"#define USE_DISPLACEMENTMAP" : "", a.specularMap ? "#define USE_SPECULARMAP" : "", a
							.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", a.metalnessMap ?
							"#define USE_METALNESSMAP" : "", a.alphaMap ? "#define USE_ALPHAMAP" : "", a
							.vertexColors ? "#define USE_COLOR" : "", a.flatShading ? "#define FLAT_SHADED" : "",
							a.skinning ? "#define USE_SKINNING" : "", a.useVertexTexture ?
							"#define BONE_TEXTURE" : "", a.morphTargets ? "#define USE_MORPHTARGETS" : "", a
							.morphNormals && !1 === a.flatShading ? "#define USE_MORPHNORMALS" : "", a
							.doubleSided ? "#define DOUBLE_SIDED" : "", a.flipSided ? "#define FLIP_SIDED" : "", a
							.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", a.shadowMapEnabled ? "#define " +
							u : "", a.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", a
							.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", a.logarithmicDepthBuffer &&
							(o.isWebGL2 || e.get("EXT_frag_depth")) ? "#define USE_LOGDEPTHBUF_EXT" : "",
							"uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;",
							"uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;",
							"uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;",
							"attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;",
							"#ifdef USE_COLOR", "\tattribute vec3 color;", "#endif", "#ifdef USE_MORPHTARGETS",
							"\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;",
							"\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;",
							"\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;",
							"\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;",
							"\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;",
							"\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;",
							"\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif", "#ifdef USE_SKINNING",
							"\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"
						].filter(hr).join("\n"), g = [M, "precision " + a.precision + " float;", "precision " + a
							.precision + " int;", "#define SHADER_NAME " + r.name, S, a.alphaTest ?
							"#define ALPHATEST " + a.alphaTest + (a.alphaTest % 1 ? "" : ".0") : "",
							"#define GAMMA_FACTOR " + w, a.useFog && a.fog ? "#define USE_FOG" : "", a.useFog && a
							.fogExp ? "#define FOG_EXP2" : "", a.map ? "#define USE_MAP" : "", a.matcap ?
							"#define USE_MATCAP" : "", a.envMap ? "#define USE_ENVMAP" : "", a.envMap ?
							"#define " + p : "", a.envMap ? "#define " + d : "", a.envMap ? "#define " + f : "", a
							.lightMap ? "#define USE_LIGHTMAP" : "", a.aoMap ? "#define USE_AOMAP" : "", a
							.emissiveMap ? "#define USE_EMISSIVEMAP" : "", a.bumpMap ? "#define USE_BUMPMAP" : "",
							a.normalMap ? "#define USE_NORMALMAP" : "", a.normalMap && a.objectSpaceNormalMap ?
							"#define OBJECTSPACE_NORMALMAP" : "", a.specularMap ? "#define USE_SPECULARMAP" : "",
							a.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", a.metalnessMap ?
							"#define USE_METALNESSMAP" : "", a.alphaMap ? "#define USE_ALPHAMAP" : "", a
							.vertexColors ? "#define USE_COLOR" : "", a.gradientMap ? "#define USE_GRADIENTMAP" :
							"", a.flatShading ? "#define FLAT_SHADED" : "", a.doubleSided ?
							"#define DOUBLE_SIDED" : "", a.flipSided ? "#define FLIP_SIDED" : "", a
							.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", a.shadowMapEnabled ? "#define " +
							u : "", a.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", a
							.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", a
							.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", a.logarithmicDepthBuffer &&
							(o.isWebGL2 || e.get("EXT_frag_depth")) ? "#define USE_LOGDEPTHBUF_EXT" : "", a
							.envMap && (o.isWebGL2 || e.get("EXT_shader_texture_lod")) ?
							"#define TEXTURE_LOD_EXT" : "", "uniform mat4 viewMatrix;",
							"uniform vec3 cameraPosition;", a.toneMapping !== at ? "#define TONE_MAPPING" : "", a
							.toneMapping !== at ? ei.tonemapping_pars_fragment : "", a.toneMapping !== at ?
							function (t, e) {
								var i;
								switch (e) {
									case ot:
										i = "Linear";
										break;
									case st:
										i = "Reinhard";
										break;
									case ct:
										i = "Uncharted2";
										break;
									case ht:
										i = "OptimizedCineon";
										break;
									case lt:
										i = "ACESFilmic";
										break;
									default:
										throw new Error("unsupported toneMapping: " + e)
								}
								return "vec3 " + t + "( vec3 color ) { return " + i + "ToneMapping( color ); }"
							}("toneMapping", a.toneMapping) : "", a.dithering ? "#define DITHERING" : "", a
							.outputEncoding || a.mapEncoding || a.matcapEncoding || a.envMapEncoding || a
							.emissiveMapEncoding ? ei.encodings_pars_fragment : "", a.mapEncoding ? cr(
								"mapTexelToLinear", a.mapEncoding) : "", a.matcapEncoding ? cr(
								"matcapTexelToLinear", a.matcapEncoding) : "", a.envMapEncoding ? cr(
								"envMapTexelToLinear", a.envMapEncoding) : "", a.emissiveMapEncoding ? cr(
								"emissiveMapTexelToLinear", a.emissiveMapEncoding) : "", a.outputEncoding ? (v =
								"linearToOutputTexel", b = a.outputEncoding, _ = sr(b), "vec4 " + v +
								"( vec4 value ) { return LinearTo" + _[0] + _[1] + "; }") : "", a.depthPacking ?
							"#define DEPTH_PACKING " + n.depthPacking : "", "\n"
						].filter(hr).join("\n")), h = ur(h = lr(h = pr(h), a), a), l = ur(l = lr(l = pr(l), a), a),
						h = dr(h), l = dr(l), o.isWebGL2 && !n.isRawShaderMaterial) {
						var T = !1,
							A = /^\s*#version\s+300\s+es\s*\n/;
						n.isShaderMaterial && null !== h.match(A) && null !== l.match(A) && (T = !0, h = h.replace(A,
							""), l = l.replace(A, "")), m = ["#version 300 es\n", "#define attribute in",
							"#define varying out", "#define texture2D texture"
						].join("\n") + "\n" + m, g = ["#version 300 es\n", "#define varying in", T ? "" :
							"out highp vec4 pc_fragColor;", T ? "" : "#define gl_FragColor pc_fragColor",
							"#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture",
							"#define textureCube texture", "#define texture2DProj textureProj",
							"#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod",
							"#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad",
							"#define texture2DProjGradEXT textureProjGrad",
							"#define textureCubeGradEXT textureGrad"
						].join("\n") + "\n" + g
					}
					var L = m + h,
						P = g + l,
						C = ar(s, 35633, L),
						R = ar(s, 35632, P);
					s.attachShader(E, C), s.attachShader(E, R), void 0 !== n.index0AttributeName ? s
						.bindAttribLocation(E, 0, n.index0AttributeName) : !0 === a.morphTargets && s
						.bindAttribLocation(E, 0, "position"), s.linkProgram(E);
					var O, I, D = s.getProgramInfoLog(E).trim(),
						B = s.getShaderInfoLog(C).trim(),
						z = s.getShaderInfoLog(R).trim(),
						N = !0,
						U = !0;
					return !1 === s.getProgramParameter(E, 35714) ? (N = !1, console.error(
							"THREE.WebGLProgram: shader error: ", s.getError(), "35715", s.getProgramParameter(E,
								35715), "gl.getProgramInfoLog", D, B, z)) : "" !== D ? console.warn(
							"THREE.WebGLProgram: gl.getProgramInfoLog()", D) : "" !== B && "" !== z || (U = !1), U &&
						(this.diagnostics = {
							runnable: N,
							material: n,
							programLog: D,
							vertexShader: {
								log: B,
								prefix: m
							},
							fragmentShader: {
								log: z,
								prefix: g
							}
						}), s.deleteShader(C), s.deleteShader(R), this.getUniforms = function () {
							return void 0 === O && (O = new rr(s, E, t)), O
						}, this.getAttributes = function () {
							return void 0 === I && (I = function (t, e) {
								for (var i = {}, n = t.getProgramParameter(e, 35721), r = 0; r < n; r++) {
									var a = t.getActiveAttrib(e, r),
										o = a.name;
									i[o] = t.getAttribLocation(e, o)
								}
								return i
							}(s, E)), I
						}, this.destroy = function () {
							s.deleteProgram(E), this.program = void 0
						}, Object.defineProperties(this, {
							uniforms: {
								get: function () {
									return console.warn(
											"THREE.WebGLProgram: .uniforms is now .getUniforms()."), this
										.getUniforms()
								}
							},
							attributes: {
								get: function () {
									return console.warn(
											"THREE.WebGLProgram: .attributes is now .getAttributes()."), this
										.getAttributes()
								}
							}
						}), this.name = r.name, this.id = or++, this.code = i, this.usedTimes = 1, this.program = E,
						this.vertexShader = C, this.fragmentShader = R, this
				}

				function mr(t, e, i) {
					var n = [],
						r = {
							MeshDepthMaterial: "depth",
							MeshDistanceMaterial: "distanceRGBA",
							MeshNormalMaterial: "normal",
							MeshBasicMaterial: "basic",
							MeshLambertMaterial: "lambert",
							MeshPhongMaterial: "phong",
							MeshToonMaterial: "phong",
							MeshStandardMaterial: "physical",
							MeshPhysicalMaterial: "physical",
							MeshMatcapMaterial: "matcap",
							LineBasicMaterial: "basic",
							LineDashedMaterial: "dashed",
							PointsMaterial: "points",
							ShadowMaterial: "shadow",
							SpriteMaterial: "sprite"
						},
						a = ["precision", "supportsVertexTextures", "map", "mapEncoding", "matcap", "matcapEncoding",
							"envMap", "envMapMode", "envMapEncoding", "lightMap", "aoMap", "emissiveMap",
							"emissiveMapEncoding", "bumpMap", "normalMap", "objectSpaceNormalMap", "displacementMap",
							"specularMap", "roughnessMap", "metalnessMap", "gradientMap", "alphaMap", "combine",
							"vertexColors", "fog", "useFog", "fogExp", "flatShading", "sizeAttenuation",
							"logarithmicDepthBuffer", "skinning", "maxBones", "useVertexTexture", "morphTargets",
							"morphNormals", "maxMorphTargets", "maxMorphNormals", "premultipliedAlpha",
							"numDirLights", "numPointLights", "numSpotLights", "numHemiLights", "numRectAreaLights",
							"shadowMapEnabled", "shadowMapType", "toneMapping", "physicallyCorrectLights",
							"alphaTest", "doubleSided", "flipSided", "numClippingPlanes", "numClipIntersection",
							"depthPacking", "dithering"
						];

					function o(t, e) {
						var i;
						return t ? t.isTexture ? i = t.encoding : t.isWebGLRenderTarget && (console.warn(
							"THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."
							), i = t.texture.encoding) : i = we, i === we && e && (i = Se), i
					}
					this.getParameters = function (e, n, a, s, c, h, l) {
						var u = r[e.type],
							p = l.isSkinnedMesh ? function (t) {
								var e = t.skeleton.bones;
								if (i.floatVertexTextures) return 1024;
								var n = i.maxVertexUniforms,
									r = Math.floor((n - 20) / 4),
									a = Math.min(r, e.length);
								return a < e.length ? (console.warn("THREE.WebGLRenderer: Skeleton has " + e
									.length + " bones. This GPU supports " + a + "."), 0) : a
							}(l) : 0,
							d = i.precision;
						null !== e.precision && (d = i.getMaxPrecision(e.precision)) !== e.precision && console
							.warn("THREE.WebGLProgram.getParameters:", e.precision, "not supported, using", d,
								"instead.");
						var f = t.getRenderTarget(),
							m = {
								shaderID: u,
								precision: d,
								supportsVertexTextures: i.vertexTextures,
								outputEncoding: o(f ? f.texture : null, t.gammaOutput),
								map: !!e.map,
								mapEncoding: o(e.map, t.gammaInput),
								matcap: !!e.matcap,
								matcapEncoding: o(e.matcap, t.gammaInput),
								envMap: !!e.envMap,
								envMapMode: e.envMap && e.envMap.mapping,
								envMapEncoding: o(e.envMap, t.gammaInput),
								envMapCubeUV: !!e.envMap && (e.envMap.mapping === gt || e.envMap.mapping === vt),
								lightMap: !!e.lightMap,
								aoMap: !!e.aoMap,
								emissiveMap: !!e.emissiveMap,
								emissiveMapEncoding: o(e.emissiveMap, t.gammaInput),
								bumpMap: !!e.bumpMap,
								normalMap: !!e.normalMap,
								objectSpaceNormalMap: e.normalMapType === Oe,
								displacementMap: !!e.displacementMap,
								roughnessMap: !!e.roughnessMap,
								metalnessMap: !!e.metalnessMap,
								specularMap: !!e.specularMap,
								alphaMap: !!e.alphaMap,
								gradientMap: !!e.gradientMap,
								combine: e.combine,
								vertexColors: e.vertexColors,
								fog: !!s,
								useFog: e.fog,
								fogExp: s && s.isFogExp2,
								flatShading: e.flatShading,
								sizeAttenuation: e.sizeAttenuation,
								logarithmicDepthBuffer: i.logarithmicDepthBuffer,
								skinning: e.skinning && p > 0,
								maxBones: p,
								useVertexTexture: i.floatVertexTextures,
								morphTargets: e.morphTargets,
								morphNormals: e.morphNormals,
								maxMorphTargets: t.maxMorphTargets,
								maxMorphNormals: t.maxMorphNormals,
								numDirLights: n.directional.length,
								numPointLights: n.point.length,
								numSpotLights: n.spot.length,
								numRectAreaLights: n.rectArea.length,
								numHemiLights: n.hemi.length,
								numClippingPlanes: c,
								numClipIntersection: h,
								dithering: e.dithering,
								shadowMapEnabled: t.shadowMap.enabled && l.receiveShadow && a.length > 0,
								shadowMapType: t.shadowMap.type,
								toneMapping: t.toneMapping,
								physicallyCorrectLights: t.physicallyCorrectLights,
								premultipliedAlpha: e.premultipliedAlpha,
								alphaTest: e.alphaTest,
								doubleSided: e.side === w,
								flipSided: e.side === _,
								depthPacking: void 0 !== e.depthPacking && e.depthPacking
							};
						return m
					}, this.getProgramCode = function (e, i) {
						var n = [];
						if (i.shaderID ? n.push(i.shaderID) : (n.push(e.fragmentShader), n.push(e.vertexShader)),
							void 0 !== e.defines)
							for (var r in e.defines) n.push(r), n.push(e.defines[r]);
						for (var o = 0; o < a.length; o++) n.push(i[a[o]]);
						return n.push(e.onBeforeCompile.toString()), n.push(t.gammaOutput), n.push(t.gammaFactor),
							n.join()
					}, this.acquireProgram = function (r, a, o, s) {
						for (var c, h = 0, l = n.length; h < l; h++) {
							var u = n[h];
							if (u.code === s) {
								++(c = u).usedTimes;
								break
							}
						}
						return void 0 === c && (c = new fr(t, e, s, r, a, o, i), n.push(c)), c
					}, this.releaseProgram = function (t) {
						if (0 == --t.usedTimes) {
							var e = n.indexOf(t);
							n[e] = n[n.length - 1], n.pop(), t.destroy()
						}
					}, this.programs = n
				}

				function gr(t, e) {
					return t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.program && e.program &&
						t.program !== e.program ? t.program.id - e.program.id : t.material.id !== e.material.id ? t
						.material.id - e.material.id : t.z !== e.z ? t.z - e.z : t.id - e.id
				}

				function vr(t, e) {
					return t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.z !== e.z ? e.z - t.z :
						t.id - e.id
				}

				function yr() {
					var t = [],
						e = 0,
						i = [],
						n = [];

					function r(i, n, r, a, o) {
						var s = t[e];
						return void 0 === s ? (s = {
							id: i.id,
							object: i,
							geometry: n,
							material: r,
							program: r.program,
							renderOrder: i.renderOrder,
							z: a,
							group: o
						}, t[e] = s) : (s.id = i.id, s.object = i, s.geometry = n, s.material = r, s.program = r
							.program, s.renderOrder = i.renderOrder, s.z = a, s.group = o), e++, s
					}
					return {
						opaque: i,
						transparent: n,
						init: function () {
							e = 0, i.length = 0, n.length = 0
						},
						push: function (t, e, a, o, s) {
							var c = r(t, e, a, o, s);
							(!0 === a.transparent ? n : i).push(c)
						},
						unshift: function (t, e, a, o, s) {
							var c = r(t, e, a, o, s);
							(!0 === a.transparent ? n : i).unshift(c)
						},
						sort: function () {
							i.length > 1 && i.sort(gr), n.length > 1 && n.sort(vr)
						}
					}
				}
				var xr = 0;

				function br() {
					var t = new function () {
							var t = {};
							return {
								get: function (e) {
									if (void 0 !== t[e.id]) return t[e.id];
									var i;
									switch (e.type) {
										case "DirectionalLight":
											i = {
												direction: new Ne,
												color: new hi,
												shadow: !1,
												shadowBias: 0,
												shadowRadius: 1,
												shadowMapSize: new De
											};
											break;
										case "SpotLight":
											i = {
												position: new Ne,
												direction: new Ne,
												color: new hi,
												distance: 0,
												coneCos: 0,
												penumbraCos: 0,
												decay: 0,
												shadow: !1,
												shadowBias: 0,
												shadowRadius: 1,
												shadowMapSize: new De
											};
											break;
										case "PointLight":
											i = {
												position: new Ne,
												color: new hi,
												distance: 0,
												decay: 0,
												shadow: !1,
												shadowBias: 0,
												shadowRadius: 1,
												shadowMapSize: new De,
												shadowCameraNear: 1,
												shadowCameraFar: 1e3
											};
											break;
										case "HemisphereLight":
											i = {
												direction: new Ne,
												skyColor: new hi,
												groundColor: new hi
											};
											break;
										case "RectAreaLight":
											i = {
												color: new hi,
												position: new Ne,
												halfWidth: new Ne,
												halfHeight: new Ne
											}
									}
									return t[e.id] = i, i
								}
							}
						},
						e = {
							id: xr++,
							hash: {
								stateID: -1,
								directionalLength: -1,
								pointLength: -1,
								spotLength: -1,
								rectAreaLength: -1,
								hemiLength: -1,
								shadowsLength: -1
							},
							ambient: [0, 0, 0],
							directional: [],
							directionalShadowMap: [],
							directionalShadowMatrix: [],
							spot: [],
							spotShadowMap: [],
							spotShadowMatrix: [],
							rectArea: [],
							point: [],
							pointShadowMap: [],
							pointShadowMatrix: [],
							hemi: []
						},
						i = new Ne,
						n = new Be,
						r = new Be;
					return {
						setup: function (a, o, s) {
							for (var c = 0, h = 0, l = 0, u = 0, p = 0, d = 0, f = 0, m = 0, g = s
									.matrixWorldInverse, v = 0, y = a.length; v < y; v++) {
								var x = a[v],
									b = x.color,
									_ = x.intensity,
									w = x.distance,
									M = x.shadow && x.shadow.map ? x.shadow.map.texture : null;
								if (x.isAmbientLight) c += b.r * _, h += b.g * _, l += b.b * _;
								else if (x.isDirectionalLight) {
									var S = t.get(x);
									if (S.color.copy(x.color).multiplyScalar(x.intensity), S.direction
										.setFromMatrixPosition(x.matrixWorld), i.setFromMatrixPosition(x.target
											.matrixWorld), S.direction.sub(i), S.direction.transformDirection(g),
										S.shadow = x.castShadow, x.castShadow) {
										var E = x.shadow;
										S.shadowBias = E.bias, S.shadowRadius = E.radius, S.shadowMapSize = E
											.mapSize
									}
									e.directionalShadowMap[u] = M, e.directionalShadowMatrix[u] = x.shadow.matrix,
										e.directional[u] = S, u++
								} else if (x.isSpotLight) {
									var S = t.get(x);
									if (S.position.setFromMatrixPosition(x.matrixWorld), S.position.applyMatrix4(
											g), S.color.copy(b).multiplyScalar(_), S.distance = w, S.direction
										.setFromMatrixPosition(x.matrixWorld), i.setFromMatrixPosition(x.target
											.matrixWorld), S.direction.sub(i), S.direction.transformDirection(g),
										S.coneCos = Math.cos(x.angle), S.penumbraCos = Math.cos(x.angle * (1 - x
											.penumbra)), S.decay = x.decay, S.shadow = x.castShadow, x.castShadow
										) {
										var E = x.shadow;
										S.shadowBias = E.bias, S.shadowRadius = E.radius, S.shadowMapSize = E
											.mapSize
									}
									e.spotShadowMap[d] = M, e.spotShadowMatrix[d] = x.shadow.matrix, e.spot[d] =
										S, d++
								} else if (x.isRectAreaLight) {
									var S = t.get(x);
									S.color.copy(b).multiplyScalar(_), S.position.setFromMatrixPosition(x
											.matrixWorld), S.position.applyMatrix4(g), r.identity(), n.copy(x
											.matrixWorld), n.premultiply(g), r.extractRotation(n), S.halfWidth
										.set(.5 * x.width, 0, 0), S.halfHeight.set(0, .5 * x.height, 0), S
										.halfWidth.applyMatrix4(r), S.halfHeight.applyMatrix4(r), e.rectArea[f] =
										S, f++
								} else if (x.isPointLight) {
									var S = t.get(x);
									if (S.position.setFromMatrixPosition(x.matrixWorld), S.position.applyMatrix4(
											g), S.color.copy(x.color).multiplyScalar(x.intensity), S.distance = x
										.distance, S.decay = x.decay, S.shadow = x.castShadow, x.castShadow) {
										var E = x.shadow;
										S.shadowBias = E.bias, S.shadowRadius = E.radius, S.shadowMapSize = E
											.mapSize, S.shadowCameraNear = E.camera.near, S.shadowCameraFar = E
											.camera.far
									}
									e.pointShadowMap[p] = M, e.pointShadowMatrix[p] = x.shadow.matrix, e.point[
										p] = S, p++
								} else if (x.isHemisphereLight) {
									var S = t.get(x);
									S.direction.setFromMatrixPosition(x.matrixWorld), S.direction
										.transformDirection(g), S.direction.normalize(), S.skyColor.copy(x.color)
										.multiplyScalar(_), S.groundColor.copy(x.groundColor).multiplyScalar(_), e
										.hemi[m] = S, m++
								}
							}
							e.ambient[0] = c, e.ambient[1] = h, e.ambient[2] = l, e.directional.length = u, e.spot
								.length = d, e.rectArea.length = f, e.point.length = p, e.hemi.length = m, e.hash
								.stateID = e.id, e.hash.directionalLength = u, e.hash.pointLength = p, e.hash
								.spotLength = d, e.hash.rectAreaLength = f, e.hash.hemiLength = m, e.hash
								.shadowsLength = o.length
						},
						state: e
					}
				}

				function _r() {
					var t = new br,
						e = [],
						i = [],
						n = {
							lightsArray: e,
							shadowsArray: i,
							lights: t
						};
					return {
						init: function () {
							e.length = 0, i.length = 0
						},
						state: n,
						setupLights: function (n) {
							t.setup(e, i, n)
						},
						pushLight: function (t) {
							e.push(t)
						},
						pushShadow: function (t) {
							i.push(t)
						}
					}
				}

				function wr(t) {
					on.call(this), this.type = "MeshDepthMaterial", this.depthPacking = Pe, this.skinning = !1, this
						.morphTargets = !1, this.map = null, this.alphaMap = null, this.displacementMap = null, this
						.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this
						.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.setValues(t)
				}

				function Mr(t) {
					on.call(this), this.type = "MeshDistanceMaterial", this.referencePosition = new Ne, this
						.nearDistance = 1, this.farDistance = 1e3, this.skinning = !1, this.morphTargets = !1, this
						.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1,
						this.displacementBias = 0, this.fog = !1, this.lights = !1, this.setValues(t)
				}

				function Sr(t, e, i) {
					for (var n = new ti, r = new Be, a = new De, o = new De(i, i), s = new Ne, c = new Ne, h = 1, l =
							2, u = 1 + (h | l), p = new Array(u), d = new Array(u), f = {}, m = {
								0: _,
								1: b,
								2: w
							}, g = [new Ne(1, 0, 0), new Ne(-1, 0, 0), new Ne(0, 0, 1), new Ne(0, 0, -1), new Ne(0, 1,
								0), new Ne(0, -1, 0)], v = [new Ne(0, 1, 0), new Ne(0, 1, 0), new Ne(0, 1, 0), new Ne(
								0, 1, 0), new Ne(0, 0, 1), new Ne(0, 0, -1)], x = [new Xe, new Xe, new Xe, new Xe,
								new Xe, new Xe
							], M = 0; M !== u; ++M) {
						var S = 0 != (M & h),
							E = 0 != (M & l),
							T = new wr({
								depthPacking: Ce,
								morphTargets: S,
								skinning: E
							});
						p[M] = T;
						var A = new Mr({
							morphTargets: S,
							skinning: E
						});
						d[M] = A
					}
					var L = this;

					function P(e, i, n, r, a, o) {
						var s = e.geometry,
							c = null,
							u = p,
							g = e.customDepthMaterial;
						if (n && (u = d, g = e.customDistanceMaterial), g) c = g;
						else {
							var v = !1;
							i.morphTargets && (s && s.isBufferGeometry ? v = s.morphAttributes && s.morphAttributes
									.position && s.morphAttributes.position.length > 0 : s && s.isGeometry && (v = s
										.morphTargets && s.morphTargets.length > 0)), e.isSkinnedMesh && !1 === i
								.skinning && console.warn(
									"THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:", e
									);
							var y = e.isSkinnedMesh && i.skinning,
								x = 0;
							v && (x |= h), y && (x |= l), c = u[x]
						}
						if (t.localClippingEnabled && !0 === i.clipShadows && 0 !== i.clippingPlanes.length) {
							var b = c.uuid,
								_ = i.uuid,
								w = f[b];
							void 0 === w && (w = {}, f[b] = w);
							var M = w[_];
							void 0 === M && (M = c.clone(), w[_] = M), c = M
						}
						return c.visible = i.visible, c.wireframe = i.wireframe, c.side = null != i.shadowSide ? i
							.shadowSide : m[i.side], c.clipShadows = i.clipShadows, c.clippingPlanes = i
							.clippingPlanes, c.clipIntersection = i.clipIntersection, c.wireframeLinewidth = i
							.wireframeLinewidth, c.linewidth = i.linewidth, n && c.isMeshDistanceMaterial && (c
								.referencePosition.copy(r), c.nearDistance = a, c.farDistance = o), c
					}

					function C(i, r, a, o) {
						if (!1 !== i.visible) {
							var s = i.layers.test(r.layers);
							if (s && (i.isMesh || i.isLine || i.isPoints) && i.castShadow && (!i.frustumCulled || n
									.intersectsObject(i))) {
								i.modelViewMatrix.multiplyMatrices(a.matrixWorldInverse, i.matrixWorld);
								var h = e.update(i),
									l = i.material;
								if (Array.isArray(l))
									for (var u = h.groups, p = 0, d = u.length; p < d; p++) {
										var f = u[p],
											m = l[f.materialIndex];
										if (m && m.visible) {
											var g = P(i, m, o, c, a.near, a.far);
											t.renderBufferDirect(a, null, h, g, i, f)
										}
									} else if (l.visible) {
										var g = P(i, l, o, c, a.near, a.far);
										t.renderBufferDirect(a, null, h, g, i, null)
									}
							}
							for (var v = i.children, y = 0, x = v.length; y < x; y++) C(v[y], r, a, o)
						}
					}
					this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = y, this.render =
						function (e, i, h) {
							if (!1 !== L.enabled && (!1 !== L.autoUpdate || !1 !== L.needsUpdate) && 0 !== e.length) {
								t.context;
								var l, u = t.state;
								u.disable(3042), u.buffers.color.setClear(1, 1, 1, 1), u.buffers.depth.setTest(!0), u
									.setScissorTest(!1);
								for (var p = 0, d = e.length; p < d; p++) {
									var f = e[p],
										m = f.shadow,
										y = f && f.isPointLight;
									if (void 0 !== m) {
										var b = m.camera;
										if (a.copy(m.mapSize), a.min(o), y) {
											var _ = a.x,
												w = a.y;
											x[0].set(2 * _, w, _, w), x[1].set(0, w, _, w), x[2].set(3 * _, w, _, w),
												x[3].set(_, w, _, w), x[4].set(3 * _, 0, _, w), x[5].set(_, 0, _, w),
												a.x *= 4, a.y *= 2
										}
										if (null === m.map) {
											var M = {
												minFilter: _t,
												magFilter: _t,
												format: Ht
											};
											m.map = new Ye(a.x, a.y, M), m.map.texture.name = f.name + ".shadowMap", b
												.updateProjectionMatrix()
										}
										m.isSpotLightShadow && m.update(f);
										var S = m.map,
											E = m.matrix;
										c.setFromMatrixPosition(f.matrixWorld), b.position.copy(c), y ? (l = 6, E
												.makeTranslation(-c.x, -c.y, -c.z)) : (l = 1, s.setFromMatrixPosition(
												f.target.matrixWorld), b.lookAt(s), b.updateMatrixWorld(), E.set(
												.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), E.multiply(
												b.projectionMatrix), E.multiply(b.matrixWorldInverse)), t
											.setRenderTarget(S), t.clear();
										for (var T = 0; T < l; T++) {
											if (y) {
												s.copy(b.position), s.add(g[T]), b.up.copy(v[T]), b.lookAt(s), b
													.updateMatrixWorld();
												var A = x[T];
												u.viewport(A)
											}
											r.multiplyMatrices(b.projectionMatrix, b.matrixWorldInverse), n
												.setFromMatrix(r), C(i, h, b, y)
										}
									} else console.warn("THREE.WebGLShadowMap:", f, "has no shadow.")
								}
								L.needsUpdate = !1
							}
						}
				}

				function Er(t, e, i, n, r, a, o) {
					var s, c = {};

					function h(t, e) {
						if (t.width > e || t.height > e) {
							if ("data" in t) return void console.warn(
								"THREE.WebGLRenderer: image in DataTexture is too big (" + t.width + "x" + t
								.height + ").");
							var i = e / Math.max(t.width, t.height),
								n = document.createElement("canvas");
							n.width = Math.floor(t.width * i), n.height = Math.floor(t.height * i);
							var r = n.getContext("2d");
							return r.drawImage(t, 0, 0, t.width, t.height, 0, 0, n.width, n.height), console.warn(
								"THREE.WebGLRenderer: image is too big (" + t.width + "x" + t.height +
								"). Resized to " + n.width + "x" + n.height), n
						}
						return t
					}

					function l(t) {
						return Ie.isPowerOfTwo(t.width) && Ie.isPowerOfTwo(t.height)
					}

					function u(t, e) {
						return t.generateMipmaps && e && t.minFilter !== _t && t.minFilter !== St
					}

					function p(e, i, r, a) {
						t.generateMipmap(e);
						var o = n.get(i);
						o.__maxMipLevel = Math.log(Math.max(r, a)) * Math.LOG2E
					}

					function d(t, e) {
						if (!r.isWebGL2) return t;
						if (6403 === t) {
							if (5126 === e) return 33326;
							if (5131 === e) return 33325;
							if (5121 === e) return 33321
						}
						if (6407 === t) {
							if (5126 === e) return 34837;
							if (5131 === e) return 34843;
							if (5121 === e) return 32849
						}
						if (6408 === t) {
							if (5126 === e) return 34836;
							if (5131 === e) return 34842;
							if (5121 === e) return 32856
						}
						return t
					}

					function f(t) {
						return t === _t || t === wt || t === Mt ? 9728 : 9729
					}

					function m(e) {
						var i = e.target;
						i.removeEventListener("dispose", m),
							function (e) {
								var i = n.get(e);
								if (e.image && i.__image__webglTextureCube) t.deleteTexture(i
									.__image__webglTextureCube);
								else {
									if (void 0 === i.__webglInit) return;
									t.deleteTexture(i.__webglTexture)
								}
								n.remove(e)
							}(i), i.isVideoTexture && delete c[i.id], o.memory.textures--
					}

					function g(e) {
						var i = e.target;
						i.removeEventListener("dispose", g),
							function (e) {
								var i = n.get(e),
									r = n.get(e.texture);
								if (e) {
									if (void 0 !== r.__webglTexture && t.deleteTexture(r.__webglTexture), e
										.depthTexture && e.depthTexture.dispose(), e.isWebGLRenderTargetCube)
										for (var a = 0; a < 6; a++) t.deleteFramebuffer(i.__webglFramebuffer[a]), i
											.__webglDepthbuffer && t.deleteRenderbuffer(i.__webglDepthbuffer[a]);
									else t.deleteFramebuffer(i.__webglFramebuffer), i.__webglDepthbuffer && t
										.deleteRenderbuffer(i.__webglDepthbuffer);
									n.remove(e.texture), n.remove(e)
								}
							}(i), o.memory.textures--
					}

					function v(t, e) {
						var r = n.get(t);
						if (t.isVideoTexture && function (t) {
								var e = t.id,
									i = o.render.frame;
								c[e] !== i && (c[e] = i, t.update())
							}(t), t.version > 0 && r.__version !== t.version) {
							var a = t.image;
							if (void 0 === a) console.warn(
								"THREE.WebGLRenderer: Texture marked for update but image is undefined");
							else {
								if (!1 !== a.complete) return void x(r, t, e);
								console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete")
							}
						}
						i.activeTexture(33984 + e), i.bindTexture(3553, r.__webglTexture)
					}

					function y(i, o, s) {
						var c;
						if (s ? (t.texParameteri(i, 10242, a.convert(o.wrapS)), t.texParameteri(i, 10243, a.convert(o
								.wrapT)), t.texParameteri(i, 10240, a.convert(o.magFilter)), t.texParameteri(i,
								10241, a.convert(o.minFilter))) : (t.texParameteri(i, 10242, 33071), t.texParameteri(
								i, 10243, 33071), o.wrapS === xt && o.wrapT === xt || console.warn(
								"THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."
								), t.texParameteri(i, 10240, f(o.magFilter)), t.texParameteri(i, 10241, f(o
								.minFilter)), o.minFilter !== _t && o.minFilter !== St && console.warn(
								"THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter."
								)), c = e.get("EXT_texture_filter_anisotropic")) {
							if (o.type === It && null === e.get("OES_texture_float_linear")) return;
							if (o.type === Dt && null === (r.isWebGL2 || e.get("OES_texture_half_float_linear")))
								return;
							(o.anisotropy > 1 || n.get(o).__currentAnisotropy) && (t.texParameterf(i, c
								.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(o.anisotropy, r.getMaxAnisotropy())), n.get(
								o).__currentAnisotropy = o.anisotropy)
						}
					}

					function x(e, n, c) {
						var f;
						f = n.isDataTexture3D ? 32879 : 3553, void 0 === e.__webglInit && (e.__webglInit = !0, n
								.addEventListener("dispose", m), e.__webglTexture = t.createTexture(), o.memory
								.textures++), i.activeTexture(33984 + c), i.bindTexture(f, e.__webglTexture), t
							.pixelStorei(37440, n.flipY), t.pixelStorei(37441, n.premultiplyAlpha), t.pixelStorei(
								3317, n.unpackAlignment);
						var g = h(n.image, r.maxTextureSize);
						(function (t) {
							return !r.isWebGL2 && (t.wrapS !== xt || t.wrapT !== xt || t.minFilter !== _t && t
								.minFilter !== St)
						})(n) && !1 === l(g) && (g = function (t) {
							if (t instanceof HTMLImageElement || t instanceof HTMLCanvasElement ||
								t instanceof ImageBitmap) {
								void 0 === s && (s = document.createElement("canvas")), s.width = Ie
									.floorPowerOfTwo(t.width), s.height = Ie.floorPowerOfTwo(t.height);
								var e = s.getContext("2d");
								return e.drawImage(t, 0, 0, s.width, s.height), console.warn(
									"THREE.WebGLRenderer: image is not power of two (" + t.width + "x" + t
									.height + "). Resized to " + s.width + "x" + s.height), s
							}
							return t
						}(g));
						var v = l(g),
							x = a.convert(n.format),
							b = a.convert(n.type),
							_ = d(x, b);
						y(f, n, v);
						var w, M = n.mipmaps;
						if (n.isDepthTexture) {
							if (_ = 6402, n.type === It) {
								if (!r.isWebGL2) throw new Error("Float Depth Texture only supported in WebGL2.0");
								_ = 36012
							} else r.isWebGL2 && (_ = 33189);
							n.format === Wt && 6402 === _ && n.type !== Ct && n.type !== Ot && (console.warn(
								"THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."
								), n.type = Ct, b = a.convert(n.type)), n.format === qt && (_ = 34041, n.type !==
								Ut && (console.warn(
									"THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."
									), n.type = Ut, b = a.convert(n.type))), i.texImage2D(3553, 0, _, g.width, g
								.height, 0, x, b, null)
						} else if (n.isDataTexture)
							if (M.length > 0 && v) {
								for (var S = 0, E = M.length; S < E; S++) w = M[S], i.texImage2D(3553, S, _, w.width,
									w.height, 0, x, b, w.data);
								n.generateMipmaps = !1, e.__maxMipLevel = M.length - 1
							} else i.texImage2D(3553, 0, _, g.width, g.height, 0, x, b, g.data), e.__maxMipLevel = 0;
						else if (n.isCompressedTexture) {
							for (var S = 0, E = M.length; S < E; S++) w = M[S], n.format !== Ht && n.format !== Ft ? i
								.getCompressedTextureFormats().indexOf(x) > -1 ? i.compressedTexImage2D(3553, S, _, w
									.width, w.height, 0, w.data) : console.warn(
									"THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"
									) : i.texImage2D(3553, S, _, w.width, w.height, 0, x, b, w.data);
							e.__maxMipLevel = M.length - 1
						} else if (n.isDataTexture3D) i.texImage3D(32879, 0, _, g.width, g.height, g.depth, 0, x, b, g
							.data), e.__maxMipLevel = 0;
						else if (M.length > 0 && v) {
							for (var S = 0, E = M.length; S < E; S++) w = M[S], i.texImage2D(3553, S, _, x, b, w);
							n.generateMipmaps = !1, e.__maxMipLevel = M.length - 1
						} else i.texImage2D(3553, 0, _, x, b, g), e.__maxMipLevel = 0;
						u(n, v) && p(3553, n, g.width, g.height), e.__version = n.version, n.onUpdate && n.onUpdate(n)
					}

					function b(e, r, o, s) {
						var c = a.convert(r.texture.format),
							h = a.convert(r.texture.type),
							l = d(c, h);
						i.texImage2D(s, 0, l, r.width, r.height, 0, c, h, null), t.bindFramebuffer(36160, e), t
							.framebufferTexture2D(36160, o, s, n.get(r.texture).__webglTexture, 0), t.bindFramebuffer(
								36160, null)
					}

					function _(e, i) {
						t.bindRenderbuffer(36161, e), i.depthBuffer && !i.stencilBuffer ? (t.renderbufferStorage(
							36161, 33189, i.width, i.height), t.framebufferRenderbuffer(36160, 36096, 36161,
							e)) : i.depthBuffer && i.stencilBuffer ? (t.renderbufferStorage(36161, 34041, i.width,
							i.height), t.framebufferRenderbuffer(36160, 33306, 36161, e)) : t.renderbufferStorage(
							36161, 32854, i.width, i.height), t.bindRenderbuffer(36161, null)
					}

					function w(e) {
						var i = n.get(e),
							r = !0 === e.isWebGLRenderTargetCube;
						if (e.depthTexture) {
							if (r) throw new Error("target.depthTexture not supported in Cube render targets");
							! function (e, i) {
								if (i && i.isWebGLRenderTargetCube) throw new Error(
									"Depth Texture with cube render targets is not supported");
								if (t.bindFramebuffer(36160, e), !i.depthTexture || !i.depthTexture.isDepthTexture)
									throw new Error(
										"renderTarget.depthTexture must be an instance of THREE.DepthTexture");
								n.get(i.depthTexture).__webglTexture && i.depthTexture.image.width === i.width && i
									.depthTexture.image.height === i.height || (i.depthTexture.image.width = i.width,
										i.depthTexture.image.height = i.height, i.depthTexture.needsUpdate = !0), v(i
										.depthTexture, 0);
								var r = n.get(i.depthTexture).__webglTexture;
								if (i.depthTexture.format === Wt) t.framebufferTexture2D(36160, 36096, 3553, r, 0);
								else {
									if (i.depthTexture.format !== qt) throw new Error("Unknown depthTexture format");
									t.framebufferTexture2D(36160, 33306, 3553, r, 0)
								}
							}(i.__webglFramebuffer, e)
						} else if (r) {
							i.__webglDepthbuffer = [];
							for (var a = 0; a < 6; a++) t.bindFramebuffer(36160, i.__webglFramebuffer[a]), i
								.__webglDepthbuffer[a] = t.createRenderbuffer(), _(i.__webglDepthbuffer[a], e)
						} else t.bindFramebuffer(36160, i.__webglFramebuffer), i.__webglDepthbuffer = t
							.createRenderbuffer(), _(i.__webglDepthbuffer, e);
						t.bindFramebuffer(36160, null)
					}
					this.setTexture2D = v, this.setTexture3D = function (t, e) {
						var r = n.get(t);
						t.version > 0 && r.__version !== t.version ? x(r, t, e) : (i.activeTexture(33984 + e), i
							.bindTexture(32879, r.__webglTexture))
					}, this.setTextureCube = function (e, s) {
						var c = n.get(e);
						if (6 === e.image.length)
							if (e.version > 0 && c.__version !== e.version) {
								c.__image__webglTextureCube || (e.addEventListener("dispose", m), c
										.__image__webglTextureCube = t.createTexture(), o.memory.textures++), i
									.activeTexture(33984 + s), i.bindTexture(34067, c.__image__webglTextureCube),
									t.pixelStorei(37440, e.flipY);
								for (var f = e && e.isCompressedTexture, g = e.image[0] && e.image[0]
										.isDataTexture, v = [], x = 0; x < 6; x++) v[x] = f || g ? g ? e.image[x]
									.image : e.image[x] : h(e.image[x], r.maxCubemapSize);
								var b = v[0],
									_ = l(b),
									w = a.convert(e.format),
									M = a.convert(e.type),
									S = d(w, M);
								y(34067, e, _);
								for (var x = 0; x < 6; x++)
									if (f)
										for (var E, T = v[x].mipmaps, A = 0, L = T.length; A < L; A++) E = T[A], e
											.format !== Ht && e.format !== Ft ? i.getCompressedTextureFormats()
											.indexOf(w) > -1 ? i.compressedTexImage2D(34069 + x, A, S, E.width, E
												.height, 0, E.data) : console.warn(
												"THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"
												) : i.texImage2D(34069 + x, A, S, E.width, E.height, 0, w, M, E
												.data);
									else g ? i.texImage2D(34069 + x, 0, S, v[x].width, v[x].height, 0, w, M, v[x]
										.data) : i.texImage2D(34069 + x, 0, S, w, M, v[x]);
								c.__maxMipLevel = f ? T.length - 1 : 0, u(e, _) && p(34067, e, b.width, b.height),
									c.__version = e.version, e.onUpdate && e.onUpdate(e)
							} else i.activeTexture(33984 + s), i.bindTexture(34067, c.__image__webglTextureCube)
					}, this.setTextureCubeDynamic = function (t, e) {
						i.activeTexture(33984 + e), i.bindTexture(34067, n.get(t).__webglTexture)
					}, this.setupRenderTarget = function (e) {
						var r = n.get(e),
							a = n.get(e.texture);
						e.addEventListener("dispose", g), a.__webglTexture = t.createTexture(), o.memory
							.textures++;
						var s = !0 === e.isWebGLRenderTargetCube,
							c = l(e);
						if (s) {
							r.__webglFramebuffer = [];
							for (var h = 0; h < 6; h++) r.__webglFramebuffer[h] = t.createFramebuffer()
						} else r.__webglFramebuffer = t.createFramebuffer();
						if (s) {
							i.bindTexture(34067, a.__webglTexture), y(34067, e.texture, c);
							for (var h = 0; h < 6; h++) b(r.__webglFramebuffer[h], e, 36064, 34069 + h);
							u(e.texture, c) && p(34067, e.texture, e.width, e.height), i.bindTexture(34067, null)
						} else i.bindTexture(3553, a.__webglTexture), y(3553, e.texture, c), b(r
							.__webglFramebuffer, e, 36064, 3553), u(e.texture, c) && p(3553, e.texture, e
							.width, e.height), i.bindTexture(3553, null);
						e.depthBuffer && w(e)
					}, this.updateRenderTargetMipmap = function (t) {
						var e = t.texture,
							r = l(t);
						if (u(e, r)) {
							var a = t.isWebGLRenderTargetCube ? 34067 : 3553,
								o = n.get(e).__webglTexture;
							i.bindTexture(a, o), p(a, e, t.width, t.height), i.bindTexture(a, null)
						}
					}
				}

				function Tr(t, e, i) {
					return {
						convert: function (t) {
							var n;
							if (t === yt) return 10497;
							if (t === xt) return 33071;
							if (t === bt) return 33648;
							if (t === _t) return 9728;
							if (t === wt) return 9984;
							if (t === Mt) return 9986;
							if (t === St) return 9729;
							if (t === Et) return 9985;
							if (t === Tt) return 9987;
							if (t === At) return 5121;
							if (t === Bt) return 32819;
							if (t === zt) return 32820;
							if (t === Nt) return 33635;
							if (t === Lt) return 5120;
							if (t === Pt) return 5122;
							if (t === Ct) return 5123;
							if (t === Rt) return 5124;
							if (t === Ot) return 5125;
							if (t === It) return 5126;
							if (t === Dt) {
								if (i.isWebGL2) return 5131;
								if (null !== (n = e.get("OES_texture_half_float"))) return n.HALF_FLOAT_OES
							}
							if (t === Gt) return 6406;
							if (t === Ft) return 6407;
							if (t === Ht) return 6408;
							if (t === kt) return 6409;
							if (t === jt) return 6410;
							if (t === Wt) return 6402;
							if (t === qt) return 34041;
							if (t === Xt) return 6403;
							if (t === O) return 32774;
							if (t === I) return 32778;
							if (t === D) return 32779;
							if (t === N) return 0;
							if (t === U) return 1;
							if (t === G) return 768;
							if (t === F) return 769;
							if (t === H) return 770;
							if (t === k) return 771;
							if (t === j) return 772;
							if (t === V) return 773;
							if (t === W) return 774;
							if (t === q) return 775;
							if (t === X) return 776;
							if ((t === Yt || t === Jt || t === Zt || t === Qt) && null !== (n = e.get(
									"WEBGL_compressed_texture_s3tc"))) {
								if (t === Yt) return n.COMPRESSED_RGB_S3TC_DXT1_EXT;
								if (t === Jt) return n.COMPRESSED_RGBA_S3TC_DXT1_EXT;
								if (t === Zt) return n.COMPRESSED_RGBA_S3TC_DXT3_EXT;
								if (t === Qt) return n.COMPRESSED_RGBA_S3TC_DXT5_EXT
							}
							if ((t === Kt || t === $t || t === te || t === ee) && null !== (n = e.get(
									"WEBGL_compressed_texture_pvrtc"))) {
								if (t === Kt) return n.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
								if (t === $t) return n.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
								if (t === te) return n.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
								if (t === ee) return n.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
							}
							if (t === ie && null !== (n = e.get("WEBGL_compressed_texture_etc1"))) return n
								.COMPRESSED_RGB_ETC1_WEBGL;
							if ((t === ne || t === re || t === ae || t === oe || t === se || t === ce || t ===
									he || t === le || t === ue || t === pe || t === de || t === fe || t === me ||
									t === ge) && null !== (n = e.get("WEBGL_compressed_texture_astc"))) return t;
							if (t === B || t === z) {
								if (i.isWebGL2) {
									if (t === B) return 32775;
									if (t === z) return 32776
								}
								if (null !== (n = e.get("EXT_blend_minmax"))) {
									if (t === B) return n.MIN_EXT;
									if (t === z) return n.MAX_EXT
								}
							}
							if (t === Ut) {
								if (i.isWebGL2) return 34042;
								if (null !== (n = e.get("WEBGL_depth_texture"))) return n.UNSIGNED_INT_24_8_WEBGL
							}
							return 0
						}
					}
				}

				function Ar() {
					Mi.call(this), this.type = "Group"
				}

				function Lr() {
					Mi.call(this), this.type = "Camera", this.matrixWorldInverse = new Be, this.projectionMatrix =
						new Be, this.projectionMatrixInverse = new Be
				}

				function Pr(t, e, i, n) {
					Lr.call(this), this.type = "PerspectiveCamera", this.fov = void 0 !== t ? t : 50, this.zoom = 1,
						this.near = void 0 !== i ? i : .1, this.far = void 0 !== n ? n : 2e3, this.focus = 10, this
						.aspect = void 0 !== e ? e : 1, this.view = null, this.filmGauge = 35, this.filmOffset = 0,
						this.updateProjectionMatrix()
				}

				function Cr(t) {
					Pr.call(this), this.cameras = t || []
				}
				wr.prototype = Object.create(on.prototype), wr.prototype.constructor = wr, wr.prototype
					.isMeshDepthMaterial = !0, wr.prototype.copy = function (t) {
						return on.prototype.copy.call(this, t), this.depthPacking = t.depthPacking, this.skinning = t
							.skinning, this.morphTargets = t.morphTargets, this.map = t.map, this.alphaMap = t
							.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t
							.displacementScale, this.displacementBias = t.displacementBias, this.wireframe = t
							.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this
					}, Mr.prototype = Object.create(on.prototype), Mr.prototype.constructor = Mr, Mr.prototype
					.isMeshDistanceMaterial = !0, Mr.prototype.copy = function (t) {
						return on.prototype.copy.call(this, t), this.referencePosition.copy(t.referencePosition), this
							.nearDistance = t.nearDistance, this.farDistance = t.farDistance, this.skinning = t
							.skinning, this.morphTargets = t.morphTargets, this.map = t.map, this.alphaMap = t
							.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t
							.displacementScale, this.displacementBias = t.displacementBias, this
					}, Ar.prototype = Object.assign(Object.create(Mi.prototype), {
						constructor: Ar,
						isGroup: !0
					}), Lr.prototype = Object.assign(Object.create(Mi.prototype), {
						constructor: Lr,
						isCamera: !0,
						copy: function (t, e) {
							return Mi.prototype.copy.call(this, t, e), this.matrixWorldInverse.copy(t
									.matrixWorldInverse), this.projectionMatrix.copy(t.projectionMatrix), this
								.projectionMatrixInverse.copy(t.projectionMatrixInverse), this
						},
						getWorldDirection: function (t) {
							void 0 === t && (console.warn(
									"THREE.Camera: .getWorldDirection() target is now required"), t =
								new Ne), this.updateMatrixWorld(!0);
							var e = this.matrixWorld.elements;
							return t.set(-e[8], -e[9], -e[10]).normalize()
						},
						updateMatrixWorld: function (t) {
							Mi.prototype.updateMatrixWorld.call(this, t), this.matrixWorldInverse.getInverse(
								this.matrixWorld)
						},
						clone: function () {
							return (new this.constructor).copy(this)
						}
					}), Pr.prototype = Object.assign(Object.create(Lr.prototype), {
						constructor: Pr,
						isPerspectiveCamera: !0,
						copy: function (t, e) {
							return Lr.prototype.copy.call(this, t, e), this.fov = t.fov, this.zoom = t.zoom,
								this.near = t.near, this.far = t.far, this.focus = t.focus, this.aspect = t
								.aspect, this.view = null === t.view ? null : Object.assign({}, t.view), this
								.filmGauge = t.filmGauge, this.filmOffset = t.filmOffset, this
						},
						setFocalLength: function (t) {
							var e = .5 * this.getFilmHeight() / t;
							this.fov = 2 * Ie.RAD2DEG * Math.atan(e), this.updateProjectionMatrix()
						},
						getFocalLength: function () {
							var t = Math.tan(.5 * Ie.DEG2RAD * this.fov);
							return .5 * this.getFilmHeight() / t
						},
						getEffectiveFOV: function () {
							return 2 * Ie.RAD2DEG * Math.atan(Math.tan(.5 * Ie.DEG2RAD * this.fov) / this
								.zoom)
						},
						getFilmWidth: function () {
							return this.filmGauge * Math.min(this.aspect, 1)
						},
						getFilmHeight: function () {
							return this.filmGauge / Math.max(this.aspect, 1)
						},
						setViewOffset: function (t, e, i, n, r, a) {
							this.aspect = t / e, null === this.view && (this.view = {
									enabled: !0,
									fullWidth: 1,
									fullHeight: 1,
									offsetX: 0,
									offsetY: 0,
									width: 1,
									height: 1
								}), this.view.enabled = !0, this.view.fullWidth = t, this.view.fullHeight = e,
								this.view.offsetX = i, this.view.offsetY = n, this.view.width = r, this.view
								.height = a, this.updateProjectionMatrix()
						},
						clearViewOffset: function () {
							null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
						},
						updateProjectionMatrix: function () {
							var t = this.near,
								e = t * Math.tan(.5 * Ie.DEG2RAD * this.fov) / this.zoom,
								i = 2 * e,
								n = this.aspect * i,
								r = -.5 * n,
								a = this.view;
							if (null !== this.view && this.view.enabled) {
								var o = a.fullWidth,
									s = a.fullHeight;
								r += a.offsetX * n / o, e -= a.offsetY * i / s, n *= a.width / o, i *= a
									.height / s
							}
							var c = this.filmOffset;
							0 !== c && (r += t * c / this.getFilmWidth()), this.projectionMatrix
								.makePerspective(r, r + n, e, e - i, t, this.far), this
								.projectionMatrixInverse.getInverse(this.projectionMatrix)
						},
						toJSON: function (t) {
							var e = Mi.prototype.toJSON.call(this, t);
							return e.object.fov = this.fov, e.object.zoom = this.zoom, e.object.near = this
								.near, e.object.far = this.far, e.object.focus = this.focus, e.object.aspect =
								this.aspect, null !== this.view && (e.object.view = Object.assign({}, this
									.view)), e.object.filmGauge = this.filmGauge, e.object.filmOffset = this
								.filmOffset, e
						}
					}), Cr.prototype = Object.assign(Object.create(Pr.prototype), {
						constructor: Cr,
						isArrayCamera: !0
					});
				var Rr, Or, Ir, Dr, Br, zr, Nr = new Ne,
					Ur = new Ne;

				function Gr(t, e, i) {
					Nr.setFromMatrixPosition(e.matrixWorld), Ur.setFromMatrixPosition(i.matrixWorld);
					var n = Nr.distanceTo(Ur),
						r = e.projectionMatrix.elements,
						a = i.projectionMatrix.elements,
						o = r[14] / (r[10] - 1),
						s = r[14] / (r[10] + 1),
						c = (r[9] + 1) / r[5],
						h = (r[9] - 1) / r[5],
						l = (r[8] - 1) / r[0],
						u = (a[8] + 1) / a[0],
						p = o * l,
						d = o * u,
						f = n / (-l + u),
						m = f * -l;
					e.matrixWorld.decompose(t.position, t.quaternion, t.scale), t.translateX(m), t.translateZ(f), t
						.matrixWorld.compose(t.position, t.quaternion, t.scale), t.matrixWorldInverse.getInverse(t
							.matrixWorld);
					var g = o + f,
						v = s + f,
						y = p - m,
						x = d + (n - m),
						b = c * s / v * g,
						_ = h * s / v * g;
					t.projectionMatrix.makePerspective(y, x, b, _, g, v)
				}

				function Fr(t) {
					var e = this,
						i = null,
						n = null,
						r = null,
						a = [],
						o = new Be,
						s = new Be,
						c = 1,
						h = "stage";
					"undefined" != typeof window && "VRFrameData" in window && (n = new window.VRFrameData, window
						.addEventListener("vrdisplaypresentchange", x, !1));
					var l = new Be,
						u = new ze,
						p = new Ne,
						d = new Pr;
					d.bounds = new Xe(0, 0, .5, 1), d.layers.enable(1);
					var f = new Pr;
					f.bounds = new Xe(.5, 0, .5, 1), f.layers.enable(2);
					var m, g, v = new Cr([d, f]);

					function y() {
						return null !== i && !0 === i.isPresenting
					}

					function x() {
						if (y()) {
							var n = i.getEyeParameters("left"),
								r = n.renderWidth * c,
								a = n.renderHeight * c;
							g = t.getPixelRatio(), m = t.getSize(), t.setDrawingBufferSize(2 * r, a, 1), w.start()
						} else e.enabled && t.setDrawingBufferSize(m.width, m.height, g), w.stop()
					}
					v.layers.enable(1), v.layers.enable(2);
					var b = [];

					function _(t) {
						for (var e = navigator.getGamepads && navigator.getGamepads(), i = 0, n = 0, r = e.length; i <
							r; i++) {
							var a = e[i];
							if (a && ("Daydream Controller" === a.id || "Gear VR Controller" === a.id ||
									"Oculus Go Controller" === a.id || "OpenVR Gamepad" === a.id || a.id.startsWith(
										"Oculus Touch") || a.id.startsWith("Spatial Controller"))) {
								if (n === t) return a;
								n++
							}
						}
					}
					this.enabled = !1, this.getController = function (t) {
						var e = a[t];
						return void 0 === e && ((e = new Ar).matrixAutoUpdate = !1, e.visible = !1, a[t] = e), e
					}, this.getDevice = function () {
						return i
					}, this.setDevice = function (t) {
						void 0 !== t && (i = t), w.setContext(t)
					}, this.setFramebufferScaleFactor = function (t) {
						c = t
					}, this.setFrameOfReferenceType = function (t) {
						h = t
					}, this.setPoseTarget = function (t) {
						void 0 !== t && (r = t)
					}, this.getCamera = function (t) {
						var e = "stage" === h ? 1.6 : 0;
						if (null === i) return t.position.set(0, e, 0), t;
						if (i.depthNear = t.near, i.depthFar = t.far, i.getFrameData(n), "stage" === h) {
							var c = i.stageParameters;
							c ? o.fromArray(c.sittingToStandingTransform) : o.makeTranslation(0, e, 0)
						}
						var m = n.pose,
							g = null !== r ? r : t;
						if (g.matrix.copy(o), g.matrix.decompose(g.position, g.quaternion, g.scale), null !== m
							.orientation && (u.fromArray(m.orientation), g.quaternion.multiply(u)), null !== m
							.position && (u.setFromRotationMatrix(o), p.fromArray(m.position), p.applyQuaternion(
								u), g.position.add(p)), g.updateMatrixWorld(), !1 === i.isPresenting) return t;
						d.near = t.near, f.near = t.near, d.far = t.far, f.far = t.far, d.matrixWorldInverse
							.fromArray(n.leftViewMatrix), f.matrixWorldInverse.fromArray(n.rightViewMatrix), s
							.getInverse(o), "stage" === h && (d.matrixWorldInverse.multiply(s), f
								.matrixWorldInverse.multiply(s));
						var y = g.parent;
						null !== y && (l.getInverse(y.matrixWorld), d.matrixWorldInverse.multiply(l), f
								.matrixWorldInverse.multiply(l)), d.matrixWorld.getInverse(d.matrixWorldInverse),
							f.matrixWorld.getInverse(f.matrixWorldInverse), d.projectionMatrix.fromArray(n
								.leftProjectionMatrix), f.projectionMatrix.fromArray(n.rightProjectionMatrix), Gr(
								v, d, f);
						var x = i.getLayers();
						if (x.length) {
							var w = x[0];
							null !== w.leftBounds && 4 === w.leftBounds.length && d.bounds.fromArray(w
								.leftBounds), null !== w.rightBounds && 4 === w.rightBounds.length && f.bounds
								.fromArray(w.rightBounds)
						}
						return function () {
							for (var t = 0; t < a.length; t++) {
								var e = a[t],
									i = _(t);
								if (void 0 !== i && void 0 !== i.pose) {
									if (null === i.pose) return;
									var n = i.pose;
									!1 === n.hasPosition && e.position.set(.2, -.6, -.05), null !== n
										.position && e.position.fromArray(n.position), null !== n
										.orientation && e.quaternion.fromArray(n.orientation), e.matrix
										.compose(e.position, e.quaternion, e.scale), e.matrix.premultiply(o),
										e.matrix.decompose(e.position, e.quaternion, e.scale), e
										.matrixWorldNeedsUpdate = !0, e.visible = !0;
									var r = "Daydream Controller" === i.id ? 0 : 1;
									b[t] !== i.buttons[r].pressed && (b[t] = i.buttons[r].pressed, !0 === b[
										t] ? e.dispatchEvent({
											type: "selectstart"
										}) : (e.dispatchEvent({
											type: "selectend"
										}), e.dispatchEvent({
											type: "select"
										})))
								} else e.visible = !1
							}
						}(), v
					}, this.getStandingMatrix = function () {
						return o
					}, this.isPresenting = y;
					var w = new di;
					this.setAnimationLoop = function (t) {
						w.setAnimationLoop(t)
					}, this.submitFrame = function () {
						y() && i.submitFrame()
					}, this.dispose = function () {
						"undefined" != typeof window && window.removeEventListener("vrdisplaypresentchange", x)
					}
				}

				function Hr(t) {
					console.log("THREE.WebGLRenderer", f);
					var e = void 0 !== (t = t || {}).canvas ? t.canvas : document.createElement("canvas"),
						i = void 0 !== t.context ? t.context : null,
						n = void 0 !== t.alpha && t.alpha,
						r = void 0 === t.depth || t.depth,
						a = void 0 === t.stencil || t.stencil,
						o = void 0 !== t.antialias && t.antialias,
						s = void 0 === t.premultipliedAlpha || t.premultipliedAlpha,
						c = void 0 !== t.preserveDrawingBuffer && t.preserveDrawingBuffer,
						h = void 0 !== t.powerPreference ? t.powerPreference : "default",
						l = null,
						u = null;
					this.domElement = e, this.context = null, this.autoClear = !0, this.autoClearColor = !0, this
						.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this
						.clippingPlanes = [], this.localClippingEnabled = !1, this.gammaFactor = 2, this
						.gammaInput = !1, this.gammaOutput = !1, this.physicallyCorrectLights = !1, this.toneMapping =
						ot, this.toneMappingExposure = 1, this.toneMappingWhitePoint = 1, this.maxMorphTargets = 8,
						this.maxMorphNormals = 4;
					var p, d, y, x, M, S, E, I, D, B, z, N, U, G, F, H, k, j, V = this,
						W = !1,
						q = null,
						X = null,
						it = null,
						nt = -1,
						rt = {
							geometry: null,
							program: null,
							wireframe: !1
						},
						at = null,
						st = null,
						ct = new Xe,
						ht = new Xe,
						lt = null,
						ut = 0,
						pt = e.width,
						dt = e.height,
						ft = 1,
						mt = new Xe(0, 0, pt, dt),
						gt = new Xe(0, 0, pt, dt),
						vt = !1,
						yt = new ti,
						xt = new function () {
							var t = this,
								e = null,
								i = 0,
								n = !1,
								r = !1,
								a = new $e,
								o = new Ue,
								s = {
									value: null,
									needsUpdate: !1
								};

							function c() {
								s.value !== e && (s.value = e, s.needsUpdate = i > 0), t.numPlanes = i, t
									.numIntersection = 0
							}

							function h(e, i, n, r) {
								var c = null !== e ? e.length : 0,
									h = null;
								if (0 !== c) {
									if (h = s.value, !0 !== r || null === h) {
										var l = n + 4 * c,
											u = i.matrixWorldInverse;
										o.getNormalMatrix(u), (null === h || h.length < l) && (h = new Float32Array(
											l));
										for (var p = 0, d = n; p !== c; ++p, d += 4) a.copy(e[p]).applyMatrix4(u, o),
											a.normal.toArray(h, d), h[d + 3] = a.constant
									}
									s.value = h, s.needsUpdate = !0
								}
								return t.numPlanes = c, h
							}
							this.uniform = s, this.numPlanes = 0, this.numIntersection = 0, this.init = function (t,
								r, a) {
								var o = 0 !== t.length || r || 0 !== i || n;
								return n = r, e = h(t, a, 0), i = t.length, o
							}, this.beginShadows = function () {
								r = !0, h(null)
							}, this.endShadows = function () {
								r = !1, c()
							}, this.setState = function (t, a, o, l, u, p) {
								if (!n || null === t || 0 === t.length || r && !o) r ? h(null) : c();
								else {
									var d = r ? 0 : i,
										f = 4 * d,
										m = u.clippingState || null;
									s.value = m, m = h(t, l, f, p);
									for (var g = 0; g !== f; ++g) m[g] = e[g];
									u.clippingState = m, this.numIntersection = a ? this.numPlanes : 0, this
										.numPlanes += d
								}
							}
						},
						bt = !1,
						_t = !1,
						wt = new Be,
						Mt = new Ne;

					function St() {
						return null === X ? ft : 1
					}
					try {
						var Et = {
							alpha: n,
							depth: r,
							stencil: a,
							antialias: o,
							premultipliedAlpha: s,
							preserveDrawingBuffer: c,
							powerPreference: h
						};
						if (e.addEventListener("webglcontextlost", Ct, !1), e.addEventListener("webglcontextrestored",
								Rt, !1), null === (p = i || e.getContext("webgl", Et) || e.getContext(
								"experimental-webgl", Et))) throw null !== e.getContext("webgl") ? new Error(
							"Error creating WebGL context with your selected attributes.") : new Error(
							"Error creating WebGL context.");
						void 0 === p.getShaderPrecisionFormat && (p.getShaderPrecisionFormat = function () {
							return {
								rangeMin: 1,
								rangeMax: 1,
								precision: 1
							}
						})
					} catch (t) {
						console.error("THREE.WebGLRenderer: " + t.message)
					}

					function Tt() {
						d = new function (t) {
								var e = {};
								return {
									get: function (i) {
										if (void 0 !== e[i]) return e[i];
										var n;
										switch (i) {
											case "WEBGL_depth_texture":
												n = t.getExtension("WEBGL_depth_texture") || t.getExtension(
													"MOZ_WEBGL_depth_texture") || t.getExtension(
													"WEBKIT_WEBGL_depth_texture");
												break;
											case "EXT_texture_filter_anisotropic":
												n = t.getExtension("EXT_texture_filter_anisotropic") || t
													.getExtension("MOZ_EXT_texture_filter_anisotropic") || t
													.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
												break;
											case "WEBGL_compressed_texture_s3tc":
												n = t.getExtension("WEBGL_compressed_texture_s3tc") || t
													.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || t
													.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
												break;
											case "WEBGL_compressed_texture_pvrtc":
												n = t.getExtension("WEBGL_compressed_texture_pvrtc") || t
													.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
												break;
											default:
												n = t.getExtension(i)
										}
										return null === n && console.warn("THREE.WebGLRenderer: " + i +
											" extension not supported."), e[i] = n, n
									}
								}
							}(p), (y = new function (t, e, i) {
								var n;

								function r(e) {
									if ("highp" === e) {
										if (t.getShaderPrecisionFormat(35633, 36338).precision > 0 && t
											.getShaderPrecisionFormat(35632, 36338).precision > 0) return "highp";
										e = "mediump"
									}
									return "mediump" === e && t.getShaderPrecisionFormat(35633, 36337).precision >
										0 && t.getShaderPrecisionFormat(35632, 36337).precision > 0 ? "mediump" :
										"lowp"
								}
								var a = "undefined" != typeof WebGL2RenderingContext &&
									t instanceof WebGL2RenderingContext,
									o = void 0 !== i.precision ? i.precision : "highp",
									s = r(o);
								s !== o && (console.warn("THREE.WebGLRenderer:", o, "not supported, using", s,
									"instead."), o = s);
								var c = !0 === i.logarithmicDepthBuffer,
									h = t.getParameter(34930),
									l = t.getParameter(35660),
									u = t.getParameter(3379),
									p = t.getParameter(34076),
									d = t.getParameter(34921),
									f = t.getParameter(36347),
									m = t.getParameter(36348),
									g = t.getParameter(36349),
									v = l > 0,
									y = a || !!e.get("OES_texture_float");
								return {
									isWebGL2: a,
									getMaxAnisotropy: function () {
										if (void 0 !== n) return n;
										var i = e.get("EXT_texture_filter_anisotropic");
										return n = null !== i ? t.getParameter(i
											.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0
									},
									getMaxPrecision: r,
									precision: o,
									logarithmicDepthBuffer: c,
									maxTextures: h,
									maxVertexTextures: l,
									maxTextureSize: u,
									maxCubemapSize: p,
									maxAttributes: d,
									maxVertexUniforms: f,
									maxVaryings: m,
									maxFragmentUniforms: g,
									vertexTextures: v,
									floatFragmentTextures: y,
									floatVertexTextures: v && y
								}
							}(p, d, t)).isWebGL2 || (d.get("WEBGL_depth_texture"), d.get("OES_texture_float"), d.get(
								"OES_texture_half_float"), d.get("OES_texture_half_float_linear"), d.get(
								"OES_standard_derivatives"), d.get("OES_element_index_uint"), d.get(
								"ANGLE_instanced_arrays")), d.get("OES_texture_float_linear"), j = new Tr(p, d, y), (
								x = new function (t, e, i, n) {
									var r = new function () {
											var e = !1,
												i = new Xe,
												n = null,
												r = new Xe(0, 0, 0, 0);
											return {
												setMask: function (i) {
													n === i || e || (t.colorMask(i, i, i, i), n = i)
												},
												setLocked: function (t) {
													e = t
												},
												setClear: function (e, n, a, o, s) {
													!0 === s && (e *= o, n *= o, a *= o), i.set(e, n, a, o), !
														1 === r.equals(i) && (t.clearColor(e, n, a, o), r.copy(i))
												},
												reset: function () {
													e = !1, n = null, r.set(-1, 0, 0, 0)
												}
											}
										},
										a = new function () {
											var e = !1,
												i = null,
												n = null,
												r = null;
											return {
												setTest: function (t) {
													t ? at(2929) : ot(2929)
												},
												setMask: function (n) {
													i === n || e || (t.depthMask(n), i = n)
												},
												setFunc: function (e) {
													if (n !== e) {
														if (e) switch (e) {
															case Y:
																t.depthFunc(512);
																break;
															case J:
																t.depthFunc(519);
																break;
															case Z:
																t.depthFunc(513);
																break;
															case Q:
																t.depthFunc(515);
																break;
															case K:
																t.depthFunc(514);
																break;
															case $:
																t.depthFunc(518);
																break;
															case tt:
																t.depthFunc(516);
																break;
															case et:
																t.depthFunc(517);
																break;
															default:
																t.depthFunc(515)
														} else t.depthFunc(515);
														n = e
													}
												},
												setLocked: function (t) {
													e = t
												},
												setClear: function (e) {
													r !== e && (t.clearDepth(e), r = e)
												},
												reset: function () {
													e = !1, i = null, n = null, r = null
												}
											}
										},
										o = new function () {
											var e = !1,
												i = null,
												n = null,
												r = null,
												a = null,
												o = null,
												s = null,
												c = null,
												h = null;
											return {
												setTest: function (t) {
													t ? at(2960) : ot(2960)
												},
												setMask: function (n) {
													i === n || e || (t.stencilMask(n), i = n)
												},
												setFunc: function (e, i, o) {
													n === e && r === i && a === o || (t.stencilFunc(e, i, o), n =
														e, r = i, a = o)
												},
												setOp: function (e, i, n) {
													o === e && s === i && c === n || (t.stencilOp(e, i, n), o = e,
														s = i, c = n)
												},
												setLocked: function (t) {
													e = t
												},
												setClear: function (e) {
													h !== e && (t.clearStencil(e), h = e)
												},
												reset: function () {
													e = !1, i = null, n = null, r = null, a = null, o = null, s =
														null, c = null, h = null
												}
											}
										},
										s = t.getParameter(34921),
										c = new Uint8Array(s),
										h = new Uint8Array(s),
										l = new Uint8Array(s),
										u = {},
										p = null,
										d = null,
										f = null,
										y = null,
										x = null,
										b = null,
										M = null,
										S = null,
										E = null,
										I = null,
										D = !1,
										B = null,
										z = null,
										N = null,
										U = null,
										G = null,
										F = t.getParameter(35661),
										H = !1,
										k = 0,
										j = t.getParameter(7938); - 1 !== j.indexOf("WebGL") ? (k = parseFloat(
											/^WebGL\ ([0-9])/.exec(j)[1]), H = k >= 1) : -1 !== j.indexOf(
										"OpenGL ES") && (k = parseFloat(/^OpenGL\ ES\ ([0-9])/.exec(j)[1]), H = k >=
											2);
									var V = null,
										W = {},
										q = new Xe,
										X = new Xe;

									function it(e, i, n) {
										var r = new Uint8Array(4),
											a = t.createTexture();
										t.bindTexture(e, a), t.texParameteri(e, 10241, 9728), t.texParameteri(e,
											10240, 9728);
										for (var o = 0; o < n; o++) t.texImage2D(i + o, 0, 6408, 1, 1, 0, 6408, 5121,
											r);
										return a
									}
									var nt = {};

									function rt(i, r) {
										if (c[i] = 1, 0 === h[i] && (t.enableVertexAttribArray(i), h[i] = 1), l[i] !==
											r) {
											var a = n.isWebGL2 ? t : e.get("ANGLE_instanced_arrays");
											a[n.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](i, r),
												l[i] = r
										}
									}

									function at(e) {
										!0 !== u[e] && (t.enable(e), u[e] = !0)
									}

									function ot(e) {
										!1 !== u[e] && (t.disable(e), u[e] = !1)
									}

									function st(e, n, r, a, o, s, c, h) {
										if (e !== T) {
											if (f || (at(3042), f = !0), e === R) o = o || n, s = s || r, c = c || a,
												n === x && o === S || (t.blendEquationSeparate(i.convert(n), i
													.convert(o)), x = n, S = o), r === b && a === M && s === E &&
												c === I || (t.blendFuncSeparate(i.convert(r), i.convert(a), i.convert(
													s), i.convert(c)), b = r, M = a, E = s, I = c), y = e, D = null;
											else if (e !== y || h !== D) {
												if (x === O && S === O || (t.blendEquation(32774), x = O, S = O), h)
													switch (e) {
														case A:
															t.blendFuncSeparate(1, 771, 1, 771);
															break;
														case L:
															t.blendFunc(1, 1);
															break;
														case P:
															t.blendFuncSeparate(0, 0, 769, 771);
															break;
														case C:
															t.blendFuncSeparate(0, 768, 0, 770);
															break;
														default:
															console.error("THREE.WebGLState: Invalid blending: ", e)
													} else switch (e) {
														case A:
															t.blendFuncSeparate(770, 771, 1, 771);
															break;
														case L:
															t.blendFunc(770, 1);
															break;
														case P:
															t.blendFunc(0, 769);
															break;
														case C:
															t.blendFunc(0, 768);
															break;
														default:
															console.error("THREE.WebGLState: Invalid blending: ",
																e)
													}
												b = null, M = null, E = null, I = null, y = e, D = h
											}
										} else f && (ot(3042), f = !1)
									}

									function ct(e) {
										B !== e && (e ? t.frontFace(2304) : t.frontFace(2305), B = e)
									}

									function ht(e) {
										e !== m ? (at(2884), e !== z && (e === g ? t.cullFace(1029) : e === v ? t
											.cullFace(1028) : t.cullFace(1032))) : ot(2884), z = e
									}

									function lt(e, i, n) {
										e ? (at(32823), U === i && G === n || (t.polygonOffset(i, n), U = i, G = n)) :
											ot(32823)
									}

									function ut(e) {
										void 0 === e && (e = 33984 + F - 1), V !== e && (t.activeTexture(e), V = e)
									}
									return nt[3553] = it(3553, 3553, 1), nt[34067] = it(34067, 34069, 6), r.setClear(
											0, 0, 0, 1), a.setClear(1), o.setClear(0), at(2929), a.setFunc(Q), ct(!1),
										ht(g), at(2884), st(T), {
											buffers: {
												color: r,
												depth: a,
												stencil: o
											},
											initAttributes: function () {
												for (var t = 0, e = c.length; t < e; t++) c[t] = 0
											},
											enableAttribute: function (t) {
												rt(t, 0)
											},
											enableAttributeAndDivisor: rt,
											disableUnusedAttributes: function () {
												for (var e = 0, i = h.length; e !== i; ++e) h[e] !== c[e] && (t
													.disableVertexAttribArray(e), h[e] = 0)
											},
											enable: at,
											disable: ot,
											getCompressedTextureFormats: function () {
												if (null === p && (p = [], e.get(
														"WEBGL_compressed_texture_pvrtc") || e.get(
															"WEBGL_compressed_texture_s3tc") || e.get(
															"WEBGL_compressed_texture_etc1") || e.get(
															"WEBGL_compressed_texture_astc")))
													for (var i = t.getParameter(34467), n = 0; n < i.length; n++)
														p.push(i[n]);
												return p
											},
											useProgram: function (e) {
												return d !== e && (t.useProgram(e), d = e, !0)
											},
											setBlending: st,
											setMaterial: function (t, e) {
												t.side === w ? ot(2884) : at(2884);
												var i = t.side === _;
												e && (i = !i), ct(i), t.blending === A && !1 === t.transparent ?
													st(T) : st(t.blending, t.blendEquation, t.blendSrc, t
														.blendDst, t.blendEquationAlpha, t.blendSrcAlpha, t
														.blendDstAlpha, t.premultipliedAlpha), a.setFunc(t
														.depthFunc), a.setTest(t.depthTest), a.setMask(t
														.depthWrite), r.setMask(t.colorWrite), lt(t.polygonOffset,
														t.polygonOffsetFactor, t.polygonOffsetUnits)
											},
											setFlipSided: ct,
											setCullFace: ht,
											setLineWidth: function (e) {
												e !== N && (H && t.lineWidth(e), N = e)
											},
											setPolygonOffset: lt,
											setScissorTest: function (t) {
												t ? at(3089) : ot(3089)
											},
											activeTexture: ut,
											bindTexture: function (e, i) {
												null === V && ut();
												var n = W[V];
												void 0 === n && (n = {
													type: void 0,
													texture: void 0
												}, W[V] = n), n.type === e && n.texture === i || (t
													.bindTexture(e, i || nt[e]), n.type = e, n.texture = i)
											},
											compressedTexImage2D: function () {
												try {
													t.compressedTexImage2D.apply(t, arguments)
												} catch (t) {
													console.error("THREE.WebGLState:", t)
												}
											},
											texImage2D: function () {
												try {
													t.texImage2D.apply(t, arguments)
												} catch (t) {
													console.error("THREE.WebGLState:", t)
												}
											},
											texImage3D: function () {
												try {
													t.texImage3D.apply(t, arguments)
												} catch (t) {
													console.error("THREE.WebGLState:", t)
												}
											},
											scissor: function (e) {
												!1 === q.equals(e) && (t.scissor(e.x, e.y, e.z, e.w), q.copy(e))
											},
											viewport: function (e) {
												!1 === X.equals(e) && (t.viewport(e.x, e.y, e.z, e.w), X.copy(e))
											},
											reset: function () {
												for (var e = 0; e < h.length; e++) 1 === h[e] && (t
													.disableVertexAttribArray(e), h[e] = 0);
												u = {}, p = null, V = null, W = {}, d = null, y = null, B = null,
													z = null, r.reset(), a.reset(), o.reset()
											}
										}
								}(p, d, j, y)).scissor(ht.copy(gt).multiplyScalar(ft)), x.viewport(ct.copy(mt)
								.multiplyScalar(ft)), M = new function (t) {
								var e = {
									frame: 0,
									calls: 0,
									triangles: 0,
									points: 0,
									lines: 0
								};
								return {
									memory: {
										geometries: 0,
										textures: 0
									},
									render: e,
									programs: null,
									autoReset: !0,
									reset: function () {
										e.frame++, e.calls = 0, e.triangles = 0, e.points = 0, e.lines = 0
									},
									update: function (t, i, n) {
										switch (n = n || 1, e.calls++, i) {
											case 4:
												e.triangles += n * (t / 3);
												break;
											case 5:
											case 6:
												e.triangles += n * (t - 2);
												break;
											case 1:
												e.lines += n * (t / 2);
												break;
											case 3:
												e.lines += n * (t - 1);
												break;
											case 2:
												e.lines += n * t;
												break;
											case 0:
												e.points += n * t;
												break;
											default:
												console.error("THREE.WebGLInfo: Unknown draw mode:", i)
										}
									}
								}
							}(p), S = new function () {
								var t = new WeakMap;
								return {
									get: function (e) {
										var i = t.get(e);
										return void 0 === i && (i = {}, t.set(e, i)), i
									},
									remove: function (e) {
										t.delete(e)
									},
									update: function (e, i, n) {
										t.get(e)[i] = n
									},
									dispose: function () {
										t = new WeakMap
									}
								}
							}, E = new Er(p, d, x, S, y, j, M), I = new fi(p), D = new function (t, e, i) {
								var n = {},
									r = {};

								function a(t) {
									var o = t.target,
										s = n[o.id];
									for (var c in null !== s.index && e.remove(s.index), s.attributes) e.remove(s
										.attributes[c]);
									o.removeEventListener("dispose", a), delete n[o.id];
									var h = r[s.id];
									h && (e.remove(h), delete r[s.id]), i.memory.geometries--
								}
								return {
									get: function (t, e) {
										var r = n[e.id];
										return r || (e.addEventListener("dispose", a), e.isBufferGeometry ? r =
											e : e.isGeometry && (void 0 === e._bufferGeometry && (e
													._bufferGeometry = (new Hi).setFromObject(t)), r = e
												._bufferGeometry), n[e.id] = r, i.memory.geometries++, r)
									},
									update: function (t) {
										var i = t.index,
											n = t.attributes;
										for (var r in null !== i && e.update(i, 34963), n) e.update(n[r], 34962);
										var a = t.morphAttributes;
										for (var r in a)
											for (var o = a[r], s = 0, c = o.length; s < c; s++) e.update(o[s],
												34962)
									},
									getWireframeAttribute: function (t) {
										var i = r[t.id];
										if (i) return i;
										var n = [],
											a = t.index,
											o = t.attributes;
										if (null !== a)
											for (var s = a.array, c = 0, h = s.length; c < h; c += 3) {
												var l = s[c + 0],
													u = s[c + 1],
													p = s[c + 2];
												n.push(l, u, u, p, p, l)
											} else
												for (var s = o.position.array, c = 0, h = s.length / 3 - 1; c <
													h; c += 3) {
													var l = c + 0,
														u = c + 1,
														p = c + 2;
													n.push(l, u, u, p, p, l)
												}
										return i = new(Gi(n) > 65535 ? Bi : Ii)(n, 1), e.update(i, 34963), r[t
											.id] = i, i
									}
								}
							}(p, I, M), B = new function (t, e) {
								var i = {};
								return {
									update: function (n) {
										var r = e.render.frame,
											a = n.geometry,
											o = t.get(n, a);
										return i[o.id] !== r && (a.isGeometry && o.updateFromObject(n), t.update(
											o), i[o.id] = r), o
									},
									dispose: function () {
										i = {}
									}
								}
							}(D, M), F = new function (t) {
								var e = {},
									i = new Float32Array(8);
								return {
									update: function (n, r, a, o) {
										var s = n.morphTargetInfluences,
											c = s.length,
											h = e[r.id];
										if (void 0 === h) {
											h = [];
											for (var l = 0; l < c; l++) h[l] = [l, 0];
											e[r.id] = h
										}
										for (var u = a.morphTargets && r.morphAttributes.position, p = a
												.morphNormals && r.morphAttributes.normal, l = 0; l < c; l++) {
											var d = h[l];
											0 !== d[1] && (u && r.removeAttribute("morphTarget" + l), p && r
												.removeAttribute("morphNormal" + l))
										}
										for (var l = 0; l < c; l++) {
											var d = h[l];
											d[0] = l, d[1] = s[l]
										}
										h.sort(pn);
										for (var l = 0; l < 8; l++) {
											var d = h[l];
											if (d) {
												var f = d[0],
													m = d[1];
												if (m) {
													u && r.addAttribute("morphTarget" + l, u[f]), p && r
														.addAttribute("morphNormal" + l, p[f]), i[l] = m;
													continue
												}
											}
											i[l] = 0
										}
										o.getUniforms().setValue(t, "morphTargetInfluences", i)
									}
								}
							}(p), z = new mr(V, d, y), N = new function () {
								var t = {};
								return {
									get: function (e, i) {
										var n, r = t[e.id];
										return void 0 === r ? (n = new yr, t[e.id] = {}, t[e.id][i.id] = n) :
											void 0 === (n = r[i.id]) && (n = new yr, r[i.id] = n), n
									},
									dispose: function () {
										t = {}
									}
								}
							}, U = new function () {
								var t = {};
								return {
									get: function (e, i) {
										var n;
										return void 0 === t[e.id] ? (n = new _r, t[e.id] = {}, t[e.id][i.id] =
											n) : void 0 === t[e.id][i.id] ? (n = new _r, t[e.id][i.id] = n) : n =
											t[e.id][i.id], n
									},
									dispose: function () {
										t = {}
									}
								}
							}, G = new function (t, e, i, n) {
								var r, a, o = new hi(0),
									s = 0,
									c = null,
									h = 0;

								function l(t, i) {
									e.buffers.color.setClear(t.r, t.g, t.b, i, n)
								}
								return {
									getClearColor: function () {
										return o
									},
									setClearColor: function (t, e) {
										o.set(t), l(o, s = void 0 !== e ? e : 1)
									},
									getClearAlpha: function () {
										return s
									},
									setClearAlpha: function (t) {
										l(o, s = t)
									},
									render: function (e, n, u, p) {
										var d = n.background;
										if (null === d ? (l(o, s), c = null, h = 0) : d && d.isColor && (l(d, 1),
												p = !0, c = null, h = 0), (t.autoClear || p) && t.clear(t
												.autoClearColor, t.autoClearDepth, t.autoClearStencil), d && (d
												.isCubeTexture || d.isWebGLRenderTargetCube)) {
											void 0 === a && ((a = new un(new ji(1, 1, 1), new sn({
													type: "BackgroundCubeMaterial",
													uniforms: ii(pi.cube.uniforms),
													vertexShader: pi.cube.vertexShader,
													fragmentShader: pi.cube.fragmentShader,
													side: _,
													depthTest: !0,
													depthWrite: !1,
													fog: !1
												}))).geometry.removeAttribute("normal"), a.geometry
												.removeAttribute("uv"), a.onBeforeRender = function (t, e,
												i) {
													this.matrixWorld.copyPosition(i.matrixWorld)
												}, Object.defineProperty(a.material, "map", {
													get: function () {
														return this.uniforms.tCube.value
													}
												}), i.update(a));
											var f = d.isWebGLRenderTargetCube ? d.texture : d;
											a.material.uniforms.tCube.value = f, a.material.uniforms.tFlip.value =
												d.isWebGLRenderTargetCube ? 1 : -1, c === d && h === f.version ||
												(a.material.needsUpdate = !0, c = d, h = f.version), e.unshift(a,
													a.geometry, a.material, 0, null)
										} else d && d.isTexture && (void 0 === r && ((r = new un(new Wi(2, 2),
													new sn({
														type: "BackgroundMaterial",
														uniforms: ii(pi.background.uniforms),
														vertexShader: pi.background.vertexShader,
														fragmentShader: pi.background.fragmentShader,
														side: b,
														depthTest: !1,
														depthWrite: !1,
														fog: !1
													}))).geometry.removeAttribute("normal"), Object
												.defineProperty(r.material, "map", {
													get: function () {
														return this.uniforms.t2D.value
													}
												}), i.update(r)), r.material.uniforms.t2D.value = d, !0 === d
											.matrixAutoUpdate && d.updateMatrix(), r.material.uniforms
											.uvTransform.value.copy(d.matrix), c === d && h === d.version || (
												r.material.needsUpdate = !0, c = d, h = d.version), e.unshift(
												r, r.geometry, r.material, 0, null))
									}
								}
							}(V, x, B, s), H = new function (t, e, i, n) {
								var r;
								this.setMode = function (t) {
									r = t
								}, this.render = function (e, n) {
									t.drawArrays(r, e, n), i.update(n, r)
								}, this.renderInstances = function (a, o, s) {
									var c;
									if (n.isWebGL2) c = t;
									else if (null === (c = e.get("ANGLE_instanced_arrays"))) return void console
										.error(
											"THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
											);
									c[n.isWebGL2 ? "drawArraysInstanced" : "drawArraysInstancedANGLE"](r, o, s, a
										.maxInstancedCount), i.update(s, r, a.maxInstancedCount)
								}
							}(p, d, M, y), k = new function (t, e, i, n) {
								var r, a, o;
								this.setMode = function (t) {
									r = t
								}, this.setIndex = function (t) {
									a = t.type, o = t.bytesPerElement
								}, this.render = function (e, n) {
									t.drawElements(r, n, a, e * o), i.update(n, r)
								}, this.renderInstances = function (s, c, h) {
									if (n.isWebGL2) l = t;
									else {
										var l = e.get("ANGLE_instanced_arrays");
										if (null === l) return void console.error(
											"THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
											)
									}
									l[n.isWebGL2 ? "drawElementsInstanced" : "drawElementsInstancedANGLE"](r, h,
										a, c * o, s.maxInstancedCount), i.update(h, r, s.maxInstancedCount)
								}
							}(p, d, M, y), M.programs = z.programs, V.context = p, V.capabilities = y, V.extensions =
							d, V.properties = S, V.renderLists = N, V.state = x, V.info = M
					}
					Tt();
					var Lt = null;
					"undefined" != typeof navigator && (Lt = "xr" in navigator ? new function (t) {
						var e = t.context,
							i = null,
							n = null,
							r = 1,
							a = null,
							o = "stage",
							s = null,
							c = [],
							h = [];

						function l() {
							return null !== n && null !== a
						}
						var u = new Pr;
						u.layers.enable(1), u.viewport = new Xe;
						var p = new Pr;
						p.layers.enable(2), p.viewport = new Xe;
						var d = new Cr([u, p]);

						function f(t) {
							var e = c[h.indexOf(t.inputSource)];
							e && e.dispatchEvent({
								type: t.type
							})
						}

						function m() {
							t.setFramebuffer(null), y.stop()
						}

						function g(t, e) {
							null === e ? t.matrixWorld.copy(t.matrix) : t.matrixWorld.multiplyMatrices(e
								.matrixWorld, t.matrix), t.matrixWorldInverse.getInverse(t.matrixWorld)
						}
						d.layers.enable(1), d.layers.enable(2), this.enabled = !1, this.getController =
							function (t) {
								var e = c[t];
								return void 0 === e && ((e = new Ar).matrixAutoUpdate = !1, e.visible = !1, c[
									t] = e), e
							}, this.getDevice = function () {
								return i
							}, this.setDevice = function (t) {
								void 0 !== t && (i = t), t instanceof XRDevice && e.setCompatibleXRDevice(t)
							}, this.setFramebufferScaleFactor = function (t) {
								r = t
							}, this.setFrameOfReferenceType = function (t) {
								o = t
							}, this.setSession = function (i) {
								null !== (n = i) && (n.addEventListener("select", f), n.addEventListener(
										"selectstart", f), n.addEventListener("selectend", f), n
									.addEventListener("end", m), n.baseLayer = new XRWebGLLayer(n, e, {
										framebufferScaleFactor: r
									}), n.requestFrameOfReference(o).then(function (e) {
										a = e, t.setFramebuffer(n.baseLayer.framebuffer), y
											.setContext(n), y.start()
									}), h = n.getInputSources(), n.addEventListener("inputsourceschange",
										function () {
											h = n.getInputSources(), console.log(h);
											for (var t = 0; t < c.length; t++) {
												var e = c[t];
												e.userData.inputSource = h[t]
											}
										}))
							}, this.getCamera = function (t) {
								if (l()) {
									var e = t.parent,
										i = d.cameras;
									g(d, e);
									for (var n = 0; n < i.length; n++) g(i[n], e);
									t.matrixWorld.copy(d.matrixWorld);
									for (var r = t.children, n = 0, a = r.length; n < a; n++) r[n]
										.updateMatrixWorld(!0);
									return Gr(d, u, p), d
								}
								return t
							}, this.isPresenting = l;
						var v = null,
							y = new di;
						y.setAnimationLoop(function (t, e) {
							if (null !== (s = e.getDevicePose(a)))
								for (var i = n.baseLayer, r = e.views, o = 0; o < r.length; o++) {
									var l = r[o],
										u = i.getViewport(l),
										p = s.getViewMatrix(l),
										f = d.cameras[o];
									f.matrix.fromArray(p).getInverse(f.matrix), f.projectionMatrix
										.fromArray(l.projectionMatrix), f.viewport.set(u.x, u.y, u
											.width, u.height), 0 === o && d.matrix.copy(f.matrix)
								}
							for (var o = 0; o < c.length; o++) {
								var m = c[o],
									g = h[o];
								if (g) {
									var y = e.getInputPose(g, a);
									if (null !== y) {
										"targetRay" in y ? m.matrix.elements = y.targetRay
											.transformMatrix : "pointerMatrix" in y && (m.matrix
												.elements = y.pointerMatrix), m.matrix.decompose(m
												.position, m.rotation, m.scale), m.visible = !0;
										continue
									}
								}
								m.visible = !1
							}
							v && v(t)
						}), this.setAnimationLoop = function (t) {
							v = t
						}, this.dispose = function () {}, this.getStandingMatrix = function () {
							return console.warn(
									"THREE.WebXRManager: getStandingMatrix() is no longer needed."),
								new THREE.Matrix4
						}, this.submitFrame = function () {}
					}(V) : new Fr(V)), this.vr = Lt;
					var Pt = new Sr(V, B, y.maxTextureSize);

					function Ct(t) {
						t.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), W = !0
					}

					function Rt() {
						console.log("THREE.WebGLRenderer: Context Restored."), W = !1, Tt()
					}

					function Ot(t) {
						var e = t.target;
						e.removeEventListener("dispose", Ot),
							function (t) {
								Bt(t), S.remove(t)
							}(e)
					}

					function Bt(t) {
						var e = S.get(t).program;
						t.program = void 0, void 0 !== e && z.releaseProgram(e)
					}
					this.shadowMap = Pt, this.getContext = function () {
						return p
					}, this.getContextAttributes = function () {
						return p.getContextAttributes()
					}, this.forceContextLoss = function () {
						var t = d.get("WEBGL_lose_context");
						t && t.loseContext()
					}, this.forceContextRestore = function () {
						var t = d.get("WEBGL_lose_context");
						t && t.restoreContext()
					}, this.getPixelRatio = function () {
						return ft
					}, this.setPixelRatio = function (t) {
						void 0 !== t && (ft = t, this.setSize(pt, dt, !1))
					}, this.getSize = function () {
						return {
							width: pt,
							height: dt
						}
					}, this.setSize = function (t, i, n) {
						Lt.isPresenting() ? console.warn(
							"THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (pt =
							t, dt = i, e.width = t * ft, e.height = i * ft, !1 !== n && (e.style.width = t +
								"px", e.style.height = i + "px"), this.setViewport(0, 0, t, i))
					}, this.getDrawingBufferSize = function () {
						return {
							width: pt * ft,
							height: dt * ft
						}
					}, this.setDrawingBufferSize = function (t, i, n) {
						pt = t, dt = i, ft = n, e.width = t * n, e.height = i * n, this.setViewport(0, 0, t, i)
					}, this.getCurrentViewport = function () {
						return ct
					}, this.setViewport = function (t, e, i, n) {
						mt.set(t, dt - e - n, i, n), x.viewport(ct.copy(mt).multiplyScalar(ft))
					}, this.setScissor = function (t, e, i, n) {
						gt.set(t, dt - e - n, i, n), x.scissor(ht.copy(gt).multiplyScalar(ft))
					}, this.setScissorTest = function (t) {
						x.setScissorTest(vt = t)
					}, this.getClearColor = function () {
						return G.getClearColor()
					}, this.setClearColor = function () {
						G.setClearColor.apply(G, arguments)
					}, this.getClearAlpha = function () {
						return G.getClearAlpha()
					}, this.setClearAlpha = function () {
						G.setClearAlpha.apply(G, arguments)
					}, this.clear = function (t, e, i) {
						var n = 0;
						(void 0 === t || t) && (n |= 16384), (void 0 === e || e) && (n |= 256), (void 0 === i ||
							i) && (n |= 1024), p.clear(n)
					}, this.clearColor = function () {
						this.clear(!0, !1, !1)
					}, this.clearDepth = function () {
						this.clear(!1, !0, !1)
					}, this.clearStencil = function () {
						this.clear(!1, !1, !0)
					}, this.dispose = function () {
						e.removeEventListener("webglcontextlost", Ct, !1), e.removeEventListener(
							"webglcontextrestored", Rt, !1), N.dispose(), U.dispose(), S.dispose(), B
						.dispose(), Lt.dispose(), Ut.stop()
					}, this.renderBufferImmediate = function (t, e) {
						x.initAttributes();
						var i = S.get(t);
						t.hasPositions && !i.position && (i.position = p.createBuffer()), t.hasNormals && !i
							.normal && (i.normal = p.createBuffer()), t.hasUvs && !i.uv && (i.uv = p
							.createBuffer()), t.hasColors && !i.color && (i.color = p.createBuffer());
						var n = e.getAttributes();
						t.hasPositions && (p.bindBuffer(34962, i.position), p.bufferData(34962, t.positionArray,
								35048), x.enableAttribute(n.position), p.vertexAttribPointer(n.position, 3,
								5126, !1, 0, 0)), t.hasNormals && (p.bindBuffer(34962, i.normal), p.bufferData(
									34962, t.normalArray, 35048), x.enableAttribute(n.normal), p
								.vertexAttribPointer(n.normal, 3, 5126, !1, 0, 0)), t.hasUvs && (p.bindBuffer(
									34962, i.uv), p.bufferData(34962, t.uvArray, 35048), x.enableAttribute(n.uv),
								p.vertexAttribPointer(n.uv, 2, 5126, !1, 0, 0)), t.hasColors && (p.bindBuffer(
								34962, i.color), p.bufferData(34962, t.colorArray, 35048), x.enableAttribute(n
								.color), p.vertexAttribPointer(n.color, 3, 5126, !1, 0, 0)), x
							.disableUnusedAttributes(), p.drawArrays(4, 0, t.count), t.count = 0
					}, this.renderBufferDirect = function (t, e, i, n, r, a) {
						var o = r.isMesh && r.normalMatrix.determinant() < 0;
						x.setMaterial(n, o);
						var s = jt(t, e, n, r),
							c = !1;
						rt.geometry === i.id && rt.program === s.id && rt.wireframe === (!0 === n.wireframe) || (
								rt.geometry = i.id, rt.program = s.id, rt.wireframe = !0 === n.wireframe, c = !0),
							r.morphTargetInfluences && (F.update(r, i, n, s), c = !0);
						var h, l = i.index,
							u = i.attributes.position,
							f = 1;
						!0 === n.wireframe && (l = D.getWireframeAttribute(i), f = 2);
						var m = H;
						null !== l && (h = I.get(l), (m = k).setIndex(h)), c && (function (t, e, i) {
							if (i && i.isInstancedBufferGeometry & !y.isWebGL2 && null === d.get(
									"ANGLE_instanced_arrays")) console.error(
								"THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
								);
							else {
								x.initAttributes();
								var n = i.attributes,
									r = e.getAttributes(),
									a = t.defaultAttributeValues;
								for (var o in r) {
									var s = r[o];
									if (s >= 0) {
										var c = n[o];
										if (void 0 !== c) {
											var h = c.normalized,
												l = c.itemSize,
												u = I.get(c);
											if (void 0 === u) continue;
											var f = u.buffer,
												m = u.type,
												g = u.bytesPerElement;
											if (c.isInterleavedBufferAttribute) {
												var v = c.data,
													b = v.stride,
													_ = c.offset;
												v && v.isInstancedInterleavedBuffer ? (x
													.enableAttributeAndDivisor(s, v.meshPerAttribute),
													void 0 === i.maxInstancedCount && (i
														.maxInstancedCount = v.meshPerAttribute * v
														.count)) : x.enableAttribute(s), p.bindBuffer(
													34962, f), p.vertexAttribPointer(s, l, m, h, b *
													g, _ * g)
											} else c.isInstancedBufferAttribute ? (x
													.enableAttributeAndDivisor(s, c.meshPerAttribute),
													void 0 === i.maxInstancedCount && (i
														.maxInstancedCount = c.meshPerAttribute * c.count)
													) : x.enableAttribute(s), p.bindBuffer(34962, f), p
												.vertexAttribPointer(s, l, m, h, 0, 0)
										} else if (void 0 !== a) {
											var w = a[o];
											if (void 0 !== w) switch (w.length) {
												case 2:
													p.vertexAttrib2fv(s, w);
													break;
												case 3:
													p.vertexAttrib3fv(s, w);
													break;
												case 4:
													p.vertexAttrib4fv(s, w);
													break;
												default:
													p.vertexAttrib1fv(s, w)
											}
										}
									}
								}
								x.disableUnusedAttributes()
							}
						}(n, s, i), null !== l && p.bindBuffer(34963, h.buffer));
						var g = 1 / 0;
						null !== l ? g = l.count : void 0 !== u && (g = u.count);
						var v = i.drawRange.start * f,
							b = i.drawRange.count * f,
							_ = null !== a ? a.start * f : 0,
							w = null !== a ? a.count * f : 1 / 0,
							M = Math.max(v, _),
							S = Math.min(g, v + b, _ + w) - 1,
							E = Math.max(0, S - M + 1);
						if (0 !== E) {
							if (r.isMesh)
								if (!0 === n.wireframe) x.setLineWidth(n.wireframeLinewidth * St()), m.setMode(1);
								else switch (r.drawMode) {
									case xe:
										m.setMode(4);
										break;
									case be:
										m.setMode(5);
										break;
									case _e:
										m.setMode(6)
								} else if (r.isLine) {
									var T = n.linewidth;
									void 0 === T && (T = 1), x.setLineWidth(T * St()), r.isLineSegments ? m
										.setMode(1) : r.isLineLoop ? m.setMode(2) : m.setMode(3)
								} else r.isPoints ? m.setMode(0) : r.isSprite && m.setMode(4);
							i && i.isInstancedBufferGeometry ? i.maxInstancedCount > 0 && m.renderInstances(i, M,
								E) : m.render(M, E)
						}
					}, this.compile = function (t, e) {
						(u = U.get(t, e)).init(), t.traverse(function (t) {
							t.isLight && (u.pushLight(t), t.castShadow && u.pushShadow(t))
						}), u.setupLights(e), t.traverse(function (e) {
							if (e.material)
								if (Array.isArray(e.material))
									for (var i = 0; i < e.material.length; i++) kt(e.material[i], t.fog,
										e);
								else kt(e.material, t.fog, e)
						})
					};
					var zt, Nt = null,
						Ut = new di;

					function Gt(t, e, i, n) {
						for (var r = 0, a = t.length; r < a; r++) {
							var o = t[r],
								s = o.object,
								c = o.geometry,
								h = void 0 === n ? o.material : n,
								l = o.group;
							if (i.isArrayCamera) {
								st = i;
								for (var p = i.cameras, d = 0, f = p.length; d < f; d++) {
									var m = p[d];
									if (s.layers.test(m.layers)) {
										if ("viewport" in m) x.viewport(ct.copy(m.viewport));
										else {
											var g = m.bounds,
												v = g.x * pt,
												y = g.y * dt,
												b = g.z * pt,
												_ = g.w * dt;
											x.viewport(ct.set(v, y, b, _).multiplyScalar(ft))
										}
										u.setupLights(m), Ft(s, e, m, c, h, l)
									}
								}
							} else st = null, Ft(s, e, i, c, h, l)
						}
					}

					function Ft(t, e, i, n, r, a) {
						if (t.onBeforeRender(V, e, i, n, r, a), u = U.get(e, st || i), t.modelViewMatrix
							.multiplyMatrices(i.matrixWorldInverse, t.matrixWorld), t.normalMatrix.getNormalMatrix(t
								.modelViewMatrix), t.isImmediateRenderObject) {
							x.setMaterial(r);
							var o = jt(i, e.fog, r, t);
							rt.geometry = null, rt.program = null, rt.wireframe = !1,
								function (t, e) {
									t.render(function (t) {
										V.renderBufferImmediate(t, e)
									})
								}(t, o)
						} else V.renderBufferDirect(i, e.fog, n, r, t, a);
						t.onAfterRender(V, e, i, n, r, a), u = U.get(e, st || i)
					}

					function kt(t, e, i) {
						var n = S.get(t),
							r = u.state.lights,
							a = u.state.shadowsArray,
							o = n.lightsHash,
							s = r.state.hash,
							c = z.getParameters(t, r.state, a, e, xt.numPlanes, xt.numIntersection, i),
							h = z.getProgramCode(t, c),
							l = n.program,
							p = !0;
						if (void 0 === l) t.addEventListener("dispose", Ot);
						else if (l.code !== h) Bt(t);
						else if (o.stateID !== s.stateID || o.directionalLength !== s.directionalLength || o
							.pointLength !== s.pointLength || o.spotLength !== s.spotLength || o.rectAreaLength !== s
							.rectAreaLength || o.hemiLength !== s.hemiLength || o.shadowsLength !== s.shadowsLength) o
							.stateID = s.stateID, o.directionalLength = s.directionalLength, o.pointLength = s
							.pointLength, o.spotLength = s.spotLength, o.rectAreaLength = s.rectAreaLength, o
							.hemiLength = s.hemiLength, o.shadowsLength = s.shadowsLength, p = !1;
						else {
							if (void 0 !== c.shaderID) return;
							p = !1
						}
						if (p) {
							if (c.shaderID) {
								var d = pi[c.shaderID];
								n.shader = {
									name: t.type,
									uniforms: ii(d.uniforms),
									vertexShader: d.vertexShader,
									fragmentShader: d.fragmentShader
								}
							} else n.shader = {
								name: t.type,
								uniforms: t.uniforms,
								vertexShader: t.vertexShader,
								fragmentShader: t.fragmentShader
							};
							t.onBeforeCompile(n.shader, V), h = z.getProgramCode(t, c), l = z.acquireProgram(t, n
								.shader, c, h), n.program = l, t.program = l
						}
						var f = l.getAttributes();
						if (t.morphTargets) {
							t.numSupportedMorphTargets = 0;
							for (var m = 0; m < V.maxMorphTargets; m++) f["morphTarget" + m] >= 0 && t
								.numSupportedMorphTargets++
						}
						if (t.morphNormals) {
							t.numSupportedMorphNormals = 0;
							for (var m = 0; m < V.maxMorphNormals; m++) f["morphNormal" + m] >= 0 && t
								.numSupportedMorphNormals++
						}
						var g = n.shader.uniforms;
						(t.isShaderMaterial || t.isRawShaderMaterial) && !0 !== t.clipping || (n.numClippingPlanes =
								xt.numPlanes, n.numIntersection = xt.numIntersection, g.clippingPlanes = xt.uniform),
							n.fog = e, void 0 === o && (n.lightsHash = o = {}), o.stateID = s.stateID, o
							.directionalLength = s.directionalLength, o.pointLength = s.pointLength, o.spotLength = s
							.spotLength, o.rectAreaLength = s.rectAreaLength, o.hemiLength = s.hemiLength, o
							.shadowsLength = s.shadowsLength, t.lights && (g.ambientLightColor.value = r.state
								.ambient, g.directionalLights.value = r.state.directional, g.spotLights.value = r
								.state.spot, g.rectAreaLights.value = r.state.rectArea, g.pointLights.value = r.state
								.point, g.hemisphereLights.value = r.state.hemi, g.directionalShadowMap.value = r
								.state.directionalShadowMap, g.directionalShadowMatrix.value = r.state
								.directionalShadowMatrix, g.spotShadowMap.value = r.state.spotShadowMap, g
								.spotShadowMatrix.value = r.state.spotShadowMatrix, g.pointShadowMap.value = r.state
								.pointShadowMap, g.pointShadowMatrix.value = r.state.pointShadowMatrix);
						var v = n.program.getUniforms(),
							y = rr.seqWithValue(v.seq, g);
						n.uniformsList = y
					}

					function jt(t, e, i, n) {
						ut = 0;
						var r = S.get(i),
							a = u.state.lights,
							o = r.lightsHash,
							s = a.state.hash;
						if (bt && (_t || t !== at)) {
							var c = t === at && i.id === nt;
							xt.setState(i.clippingPlanes, i.clipIntersection, i.clipShadows, t, r, c)
						}!1 === i.needsUpdate && (void 0 === r.program ? i.needsUpdate = !0 : i.fog && r.fog !== e ? i
								.needsUpdate = !0 : (!i.lights || o.stateID === s.stateID && o.directionalLength === s
									.directionalLength && o.pointLength === s.pointLength && o.spotLength === s
									.spotLength && o.rectAreaLength === s.rectAreaLength && o.hemiLength === s
									.hemiLength && o.shadowsLength === s.shadowsLength) && (void 0 === r
									.numClippingPlanes || r.numClippingPlanes === xt.numPlanes && r
									.numIntersection === xt.numIntersection) || (i.needsUpdate = !0)), i
							.needsUpdate && (kt(i, e, n), i.needsUpdate = !1);
						var h, l, d = !1,
							f = !1,
							m = !1,
							g = r.program,
							v = g.getUniforms(),
							b = r.shader.uniforms;
						if (x.useProgram(g.program) && (d = !0, f = !0, m = !0), i.id !== nt && (nt = i.id, f = !0),
							d || at !== t) {
							if (v.setValue(p, "projectionMatrix", t.projectionMatrix), y.logarithmicDepthBuffer && v
								.setValue(p, "logDepthBufFC", 2 / (Math.log(t.far + 1) / Math.LN2)), at !== t && (at =
									t, f = !0, m = !0), i.isShaderMaterial || i.isMeshPhongMaterial || i
								.isMeshStandardMaterial || i.envMap) {
								var w = v.map.cameraPosition;
								void 0 !== w && w.setValue(p, Mt.setFromMatrixPosition(t.matrixWorld))
							}(i.isMeshPhongMaterial || i.isMeshLambertMaterial || i.isMeshBasicMaterial || i
								.isMeshStandardMaterial || i.isShaderMaterial || i.skinning) && v.setValue(p,
								"viewMatrix", t.matrixWorldInverse)
						}
						if (i.skinning) {
							v.setOptional(p, n, "bindMatrix"), v.setOptional(p, n, "bindMatrixInverse");
							var M = n.skeleton;
							if (M) {
								var E = M.bones;
								if (y.floatVertexTextures) {
									if (void 0 === M.boneTexture) {
										var T = Math.sqrt(4 * E.length);
										T = Ie.ceilPowerOfTwo(T), T = Math.max(T, 4);
										var A = new Float32Array(T * T * 4);
										A.set(M.boneMatrices);
										var L = new Ze(A, T, T, Ht, It);
										L.needsUpdate = !0, M.boneMatrices = A, M.boneTexture = L, M.boneTextureSize =
											T
									}
									v.setValue(p, "boneTexture", M.boneTexture), v.setValue(p, "boneTextureSize", M
										.boneTextureSize)
								} else v.setOptional(p, M, "boneMatrices")
							}
						}
						return f && (v.setValue(p, "toneMappingExposure", V.toneMappingExposure), v.setValue(p,
									"toneMappingWhitePoint", V.toneMappingWhitePoint), i.lights && (l = m, (h = b)
									.ambientLightColor.needsUpdate = l, h.directionalLights.needsUpdate = l, h
									.pointLights.needsUpdate = l, h.spotLights.needsUpdate = l, h.rectAreaLights
									.needsUpdate = l, h.hemisphereLights.needsUpdate = l), e && i.fog && function (t,
									e) {
									t.fogColor.value = e.color, e.isFog ? (t.fogNear.value = e.near, t.fogFar.value =
										e.far) : e.isFogExp2 && (t.fogDensity.value = e.density)
								}(b, e), i.isMeshBasicMaterial ? Vt(b, i) : i.isMeshLambertMaterial ? (Vt(b, i),
									function (t, e) {
										e.emissiveMap && (t.emissiveMap.value = e.emissiveMap)
									}(b, i)) : i.isMeshPhongMaterial ? (Vt(b, i), i.isMeshToonMaterial ? function (t,
									e) {
									Wt(t, e), e.gradientMap && (t.gradientMap.value = e.gradientMap)
								}(b, i) : Wt(b, i)) : i.isMeshStandardMaterial ? (Vt(b, i), i.isMeshPhysicalMaterial ?
									function (t, e) {
										qt(t, e), t.reflectivity.value = e.reflectivity, t.clearCoat.value = e
											.clearCoat, t.clearCoatRoughness.value = e.clearCoatRoughness
									}(b, i) : qt(b, i)) : i.isMeshMatcapMaterial ? (Vt(b, i), function (t, e) {
									e.matcap && (t.matcap.value = e.matcap), e.bumpMap && (t.bumpMap.value = e
										.bumpMap, t.bumpScale.value = e.bumpScale, e.side === _ && (t
											.bumpScale.value *= -1)), e.normalMap && (t.normalMap.value = e
										.normalMap, t.normalScale.value.copy(e.normalScale), e.side === _ && t
										.normalScale.value.negate()), e.displacementMap && (t.displacementMap
										.value = e.displacementMap, t.displacementScale.value = e
										.displacementScale, t.displacementBias.value = e.displacementBias)
								}(b, i)) : i.isMeshDepthMaterial ? (Vt(b, i), function (t, e) {
									e.displacementMap && (t.displacementMap.value = e.displacementMap, t
										.displacementScale.value = e.displacementScale, t.displacementBias
										.value = e.displacementBias)
								}(b, i)) : i.isMeshDistanceMaterial ? (Vt(b, i), function (t, e) {
									e.displacementMap && (t.displacementMap.value = e.displacementMap, t
											.displacementScale.value = e.displacementScale, t.displacementBias
											.value = e.displacementBias), t.referencePosition.value.copy(e
											.referencePosition), t.nearDistance.value = e.nearDistance, t
										.farDistance.value = e.farDistance
								}(b, i)) : i.isMeshNormalMaterial ? (Vt(b, i), function (t, e) {
									e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, e
										.side === _ && (t.bumpScale.value *= -1)), e.normalMap && (t.normalMap
										.value = e.normalMap, t.normalScale.value.copy(e.normalScale), e
										.side === _ && t.normalScale.value.negate()), e.displacementMap && (t
										.displacementMap.value = e.displacementMap, t.displacementScale
										.value = e.displacementScale, t.displacementBias.value = e
										.displacementBias)
								}(b, i)) : i.isLineBasicMaterial ? (function (t, e) {
									t.diffuse.value = e.color, t.opacity.value = e.opacity
								}(b, i), i.isLineDashedMaterial && function (t, e) {
									t.dashSize.value = e.dashSize, t.totalSize.value = e.dashSize + e.gapSize, t
										.scale.value = e.scale
								}(b, i)) : i.isPointsMaterial ? function (t, e) {
									t.diffuse.value = e.color, t.opacity.value = e.opacity, t.size.value = e.size *
										ft, t.scale.value = .5 * dt, t.map.value = e.map, null !== e.map && (!0 === e
											.map.matrixAutoUpdate && e.map.updateMatrix(), t.uvTransform.value.copy(e
												.map.matrix))
								}(b, i) : i.isSpriteMaterial ? function (t, e) {
									t.diffuse.value = e.color, t.opacity.value = e.opacity, t.rotation.value = e
										.rotation, t.map.value = e.map, null !== e.map && (!0 === e.map
											.matrixAutoUpdate && e.map.updateMatrix(), t.uvTransform.value.copy(e.map
												.matrix))
								}(b, i) : i.isShadowMaterial && (b.color.value = i.color, b.opacity.value = i
								.opacity), void 0 !== b.ltc_1 && (b.ltc_1.value = ui.LTC_1), void 0 !== b.ltc_2 && (b
									.ltc_2.value = ui.LTC_2), rr.upload(p, r.uniformsList, b, V)), i
							.isShaderMaterial && !0 === i.uniformsNeedUpdate && (rr.upload(p, r.uniformsList, b, V), i
								.uniformsNeedUpdate = !1), i.isSpriteMaterial && v.setValue(p, "center", n.center), v
							.setValue(p, "modelViewMatrix", n.modelViewMatrix), v.setValue(p, "normalMatrix", n
								.normalMatrix), v.setValue(p, "modelMatrix", n.matrixWorld), g
					}

					function Vt(t, e) {
						var i;
						t.opacity.value = e.opacity, e.color && (t.diffuse.value = e.color), e.emissive && t.emissive
							.value.copy(e.emissive).multiplyScalar(e.emissiveIntensity), e.map && (t.map.value = e
								.map), e.alphaMap && (t.alphaMap.value = e.alphaMap), e.specularMap && (t.specularMap
								.value = e.specularMap), e.envMap && (t.envMap.value = e.envMap, t.flipEnvMap.value =
								e.envMap.isCubeTexture ? -1 : 1, t.reflectivity.value = e.reflectivity, t
								.refractionRatio.value = e.refractionRatio, t.maxMipLevel.value = S.get(e.envMap)
								.__maxMipLevel), e.lightMap && (t.lightMap.value = e.lightMap, t.lightMapIntensity
								.value = e.lightMapIntensity), e.aoMap && (t.aoMap.value = e.aoMap, t.aoMapIntensity
								.value = e.aoMapIntensity), e.map ? i = e.map : e.specularMap ? i = e.specularMap : e
							.displacementMap ? i = e.displacementMap : e.normalMap ? i = e.normalMap : e.bumpMap ? i =
							e.bumpMap : e.roughnessMap ? i = e.roughnessMap : e.metalnessMap ? i = e.metalnessMap : e
							.alphaMap ? i = e.alphaMap : e.emissiveMap && (i = e.emissiveMap), void 0 !== i && (i
								.isWebGLRenderTarget && (i = i.texture), !0 === i.matrixAutoUpdate && i
							.updateMatrix(), t.uvTransform.value.copy(i.matrix))
					}

					function Wt(t, e) {
						t.specular.value = e.specular, t.shininess.value = Math.max(e.shininess, 1e-4), e
							.emissiveMap && (t.emissiveMap.value = e.emissiveMap), e.bumpMap && (t.bumpMap.value = e
								.bumpMap, t.bumpScale.value = e.bumpScale, e.side === _ && (t.bumpScale.value *= -1)),
							e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale),
								e.side === _ && t.normalScale.value.negate()), e.displacementMap && (t.displacementMap
								.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t
								.displacementBias.value = e.displacementBias)
					}

					function qt(t, e) {
						t.roughness.value = e.roughness, t.metalness.value = e.metalness, e.roughnessMap && (t
								.roughnessMap.value = e.roughnessMap), e.metalnessMap && (t.metalnessMap.value = e
								.metalnessMap), e.emissiveMap && (t.emissiveMap.value = e.emissiveMap), e.bumpMap && (
								t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, e.side === _ && (t
									.bumpScale.value *= -1)), e.normalMap && (t.normalMap.value = e.normalMap, t
								.normalScale.value.copy(e.normalScale), e.side === _ && t.normalScale.value.negate()),
							e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale
								.value = e.displacementScale, t.displacementBias.value = e.displacementBias), e
							.envMap && (t.envMapIntensity.value = e.envMapIntensity)
					}
					Ut.setAnimationLoop(function (t) {
						Lt.isPresenting() || Nt && Nt(t)
					}), "undefined" != typeof window && Ut.setContext(window), this.setAnimationLoop = function (
						t) {
						Nt = t, Lt.setAnimationLoop(t), Ut.start()
					}, this.render = function (t, e, i, n) {
						if (e && e.isCamera) {
							if (!W) {
								rt.geometry = null, rt.program = null, rt.wireframe = !1, nt = -1, at = null, !
									0 === t.autoUpdate && t.updateMatrixWorld(), null === e.parent && e
									.updateMatrixWorld(), Lt.enabled && (e = Lt.getCamera(e)), (u = U.get(t, e))
									.init(), t.onBeforeRender(V, t, e, i), wt.multiplyMatrices(e.projectionMatrix,
										e.matrixWorldInverse), yt.setFromMatrix(wt), _t = this
									.localClippingEnabled, bt = xt.init(this.clippingPlanes, _t, e), (l = N.get(t,
										e)).init(),
									function t(e, i, n) {
										if (!1 !== e.visible) {
											var r = e.layers.test(i.layers);
											if (r)
												if (e.isLight) u.pushLight(e), e.castShadow && u.pushShadow(e);
												else if (e.isSprite) {
												if (!e.frustumCulled || yt.intersectsSprite(e)) {
													n && Mt.setFromMatrixPosition(e.matrixWorld).applyMatrix4(wt);
													var a = B.update(e),
														o = e.material;
													l.push(e, a, o, Mt.z, null)
												}
											} else if (e.isImmediateRenderObject) n && Mt.setFromMatrixPosition(e
												.matrixWorld).applyMatrix4(wt), l.push(e, null, e.material, Mt
												.z, null);
											else if ((e.isMesh || e.isLine || e.isPoints) && (e.isSkinnedMesh && e
													.skeleton.update(), !e.frustumCulled || yt.intersectsObject(e)
													)) {
												n && Mt.setFromMatrixPosition(e.matrixWorld).applyMatrix4(wt);
												var a = B.update(e),
													o = e.material;
												if (Array.isArray(o))
													for (var s = a.groups, c = 0, h = s.length; c < h; c++) {
														var p = s[c],
															d = o[p.materialIndex];
														d && d.visible && l.push(e, a, d, Mt.z, p)
													} else o.visible && l.push(e, a, o, Mt.z, null)
											}
											for (var f = e.children, c = 0, h = f.length; c < h; c++) t(f[c], i,
												n)
										}
									}(t, e, V.sortObjects), !0 === V.sortObjects && l.sort(), bt && xt
									.beginShadows();
								var r = u.state.shadowsArray;
								Pt.render(r, t, e), u.setupLights(e), bt && xt.endShadows(), this.info
									.autoReset && this.info.reset(), void 0 === i && (i = null), this
									.setRenderTarget(i), G.render(l, t, e, n);
								var a = l.opaque,
									o = l.transparent;
								if (t.overrideMaterial) {
									var s = t.overrideMaterial;
									a.length && Gt(a, t, e, s), o.length && Gt(o, t, e, s)
								} else a.length && Gt(a, t, e), o.length && Gt(o, t, e);
								i && E.updateRenderTargetMipmap(i), x.buffers.depth.setTest(!0), x.buffers.depth
									.setMask(!0), x.buffers.color.setMask(!0), x.setPolygonOffset(!1), t
									.onAfterRender(V, t, e), Lt.enabled && Lt.submitFrame(), l = null, u = null
							}
						} else console.error(
							"THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.")
					}, this.allocTextureUnit = function () {
						var t = ut;
						return t >= y.maxTextures && console.warn("THREE.WebGLRenderer: Trying to use " + t +
							" texture units while this GPU supports only " + y.maxTextures), ut += 1, t
					}, this.setTexture2D = (zt = !1, function (t, e) {
						t && t.isWebGLRenderTarget && (zt || (console.warn(
							"THREE.WebGLRenderer.setTexture2D: don't use render targets as textures. Use their .texture property instead."
							), zt = !0), t = t.texture), E.setTexture2D(t, e)
					}), this.setTexture3D = function (t, e) {
						E.setTexture3D(t, e)
					}, this.setTexture = function () {
						var t = !1;
						return function (e, i) {
							t || (console.warn(
								"THREE.WebGLRenderer: .setTexture is deprecated, use setTexture2D instead."
								), t = !0), E.setTexture2D(e, i)
						}
					}(), this.setTextureCube = function () {
						var t = !1;
						return function (e, i) {
							e && e.isWebGLRenderTargetCube && (t || (console.warn(
									"THREE.WebGLRenderer.setTextureCube: don't use cube render targets as textures. Use their .texture property instead."
									), t = !0), e = e.texture), e && e.isCubeTexture || Array.isArray(e
								.image) && 6 === e.image.length ? E.setTextureCube(e, i) : E
								.setTextureCubeDynamic(e, i)
						}
					}(), this.setFramebuffer = function (t) {
						q = t
					}, this.getRenderTarget = function () {
						return X
					}, this.setRenderTarget = function (t) {
						X = t, t && void 0 === S.get(t).__webglFramebuffer && E.setupRenderTarget(t);
						var e = q,
							i = !1;
						if (t) {
							var n = S.get(t).__webglFramebuffer;
							t.isWebGLRenderTargetCube ? (e = n[t.activeCubeFace], i = !0) : e = n, ct.copy(t
								.viewport), ht.copy(t.scissor), lt = t.scissorTest
						} else ct.copy(mt).multiplyScalar(ft), ht.copy(gt).multiplyScalar(ft), lt = vt;
						if (it !== e && (p.bindFramebuffer(36160, e), it = e), x.viewport(ct), x.scissor(ht), x
							.setScissorTest(lt), i) {
							var r = S.get(t.texture);
							p.framebufferTexture2D(36160, 36064, 34069 + t.activeCubeFace, r.__webglTexture, t
								.activeMipMapLevel)
						}
					}, this.readRenderTargetPixels = function (t, e, i, n, r, a) {
						if (t && t.isWebGLRenderTarget) {
							var o = S.get(t).__webglFramebuffer;
							if (o) {
								var s = !1;
								o !== it && (p.bindFramebuffer(36160, o), s = !0);
								try {
									var c = t.texture,
										h = c.format,
										l = c.type;
									if (h !== Ht && j.convert(h) !== p.getParameter(35739)) return void console
										.error(
											"THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format."
											);
									if (!(l === At || j.convert(l) === p.getParameter(35738) || l === It && (y
											.isWebGL2 || d.get("OES_texture_float") || d.get(
												"WEBGL_color_buffer_float")) || l === Dt && (y.isWebGL2 ? d
											.get("EXT_color_buffer_float") : d.get(
												"EXT_color_buffer_half_float")))) return void console.error(
										"THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type."
										);
									36053 === p.checkFramebufferStatus(36160) ? e >= 0 && e <= t.width - n && i >=
										0 && i <= t.height - r && p.readPixels(e, i, n, r, j.convert(h), j
											.convert(l), a) : console.error(
											"THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete."
											)
								} finally {
									s && p.bindFramebuffer(36160, it)
								}
							}
						} else console.error(
							"THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget."
							)
					}, this.copyFramebufferToTexture = function (t, e, i) {
						var n = e.image.width,
							r = e.image.height,
							a = j.convert(e.format);
						this.setTexture2D(e, 0), p.copyTexImage2D(3553, i || 0, a, t.x, t.y, n, r, 0)
					}, this.copyTextureToTexture = function (t, e, i, n) {
						var r = e.image.width,
							a = e.image.height,
							o = j.convert(i.format),
							s = j.convert(i.type);
						this.setTexture2D(i, 0), e.isDataTexture ? p.texSubImage2D(3553, n || 0, t.x, t.y, r, a,
							o, s, e.image.data) : p.texSubImage2D(3553, n || 0, t.x, t.y, o, s, e.image)
					}
				}

				function kr(t, e) {
					this.name = "", this.color = new hi(t), this.density = void 0 !== e ? e : 25e-5
				}

				function jr(t, e, i) {
					this.name = "", this.color = new hi(t), this.near = void 0 !== e ? e : 1, this.far = void 0 !==
						i ? i : 1e3
				}

				function Vr() {
					Mi.call(this), this.type = "Scene", this.background = null, this.fog = null, this
						.overrideMaterial = null, this.autoUpdate = !0
				}

				function Wr(t, e) {
					this.array = t, this.stride = e, this.count = void 0 !== t ? t.length / e : 0, this.dynamic = !1,
						this.updateRange = {
							offset: 0,
							count: -1
						}, this.version = 0
				}

				function qr(t, e, i, n) {
					this.data = t, this.itemSize = e, this.offset = i, this.normalized = !0 === n
				}

				function Xr(t) {
					on.call(this), this.type = "SpriteMaterial", this.color = new hi(16777215), this.map = null, this
						.rotation = 0, this.sizeAttenuation = !0, this.lights = !1, this.transparent = !0, this
						.setValues(t)
				}

				function Yr(t) {
					if (Mi.call(this), this.type = "Sprite", void 0 === Rr) {
						Rr = new Hi;
						var e = new Float32Array([-.5, -.5, 0, 0, 0, .5, -.5, 0, 1, 0, .5, .5, 0, 1, 1, -.5, .5, 0, 0,
								1
							]),
							i = new Wr(e, 5);
						Rr.setIndex([0, 1, 2, 0, 2, 3]), Rr.addAttribute("position", new qr(i, 3, 0, !1)), Rr
							.addAttribute("uv", new qr(i, 2, 3, !1))
					}
					this.geometry = Rr, this.material = void 0 !== t ? t : new Xr, this.center = new De(.5, .5)
				}

				function Jr() {
					Mi.call(this), this.type = "LOD", Object.defineProperties(this, {
						levels: {
							enumerable: !0,
							value: []
						}
					})
				}

				function Zr(t, e) {
					t && t.isGeometry && console.error(
							"THREE.SkinnedMesh no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."),
						un.call(this, t, e), this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix =
						new Be, this.bindMatrixInverse = new Be
				}

				function Qr(t, e) {
					if (t = t || [], this.bones = t.slice(0), this.boneMatrices = new Float32Array(16 * this.bones
							.length), void 0 === e) this.calculateInverses();
					else if (this.bones.length === e.length) this.boneInverses = e.slice(0);
					else {
						console.warn("THREE.Skeleton boneInverses is the wrong length."), this.boneInverses = [];
						for (var i = 0, n = this.bones.length; i < n; i++) this.boneInverses.push(new Be)
					}
				}

				function Kr() {
					Mi.call(this), this.type = "Bone"
				}

				function $r(t) {
					on.call(this), this.type = "LineBasicMaterial", this.color = new hi(16777215), this.linewidth = 1,
						this.linecap = "round", this.linejoin = "round", this.lights = !1, this.setValues(t)
				}

				function ta(t, e, i) {
					1 === i && console.error(
							"THREE.Line: parameter THREE.LinePieces no longer supported. Use THREE.LineSegments instead."
							), Mi.call(this), this.type = "Line", this.geometry = void 0 !== t ? t : new Hi, this
						.material = void 0 !== e ? e : new $r({
							color: 16777215 * Math.random()
						})
				}

				function ea(t, e) {
					ta.call(this, t, e), this.type = "LineSegments"
				}

				function ia(t, e) {
					ta.call(this, t, e), this.type = "LineLoop"
				}

				function na(t) {
					on.call(this), this.type = "PointsMaterial", this.color = new hi(16777215), this.map = null, this
						.size = 1, this.sizeAttenuation = !0, this.morphTargets = !1, this.lights = !1, this
						.setValues(t)
				}

				function ra(t, e) {
					Mi.call(this), this.type = "Points", this.geometry = void 0 !== t ? t : new Hi, this.material =
						void 0 !== e ? e : new na({
							color: 16777215 * Math.random()
						})
				}

				function aa(t, e, i, n, r, a, o, s, c) {
					qe.call(this, t, e, i, n, r, a, o, s, c), this.format = void 0 !== o ? o : Ft, this.minFilter =
						void 0 !== a ? a : St, this.magFilter = void 0 !== r ? r : St, this.generateMipmaps = !1
				}

				function oa(t, e, i, n, r, a, o, s, c, h, l, u) {
					qe.call(this, null, a, o, s, c, h, n, r, l, u), this.image = {
						width: e,
						height: i
					}, this.mipmaps = t, this.flipY = !1, this.generateMipmaps = !1
				}

				function sa(t, e, i, n, r, a, o, s, c) {
					qe.call(this, t, e, i, n, r, a, o, s, c), this.needsUpdate = !0
				}

				function ca(t, e, i, n, r, a, o, s, c, h) {
					if ((h = void 0 !== h ? h : Wt) !== Wt && h !== qt) throw new Error(
						"DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
					void 0 === i && h === Wt && (i = Ct), void 0 === i && h === qt && (i = Ut), qe.call(this, null, n,
							r, a, o, s, h, i, c), this.image = {
							width: t,
							height: e
						}, this.magFilter = void 0 !== o ? o : _t, this.minFilter = void 0 !== s ? s : _t, this
						.flipY = !1, this.generateMipmaps = !1
				}

				function ha(t) {
					Hi.call(this), this.type = "WireframeGeometry";
					var e, i, n, r, a, o, s, c, h, l, u = [],
						p = [0, 0],
						d = {},
						f = ["a", "b", "c"];
					if (t && t.isGeometry) {
						var m = t.faces;
						for (e = 0, n = m.length; e < n; e++) {
							var g = m[e];
							for (i = 0; i < 3; i++) s = g[f[i]], c = g[f[(i + 1) % 3]], p[0] = Math.min(s, c), p[1] =
								Math.max(s, c), h = p[0] + "," + p[1], void 0 === d[h] && (d[h] = {
									index1: p[0],
									index2: p[1]
								})
						}
						for (h in d) o = d[h], l = t.vertices[o.index1], u.push(l.x, l.y, l.z), l = t.vertices[o
							.index2], u.push(l.x, l.y, l.z)
					} else if (t && t.isBufferGeometry) {
						var v, y, x, b, _, w, M, S;
						if (l = new Ne, null !== t.index) {
							for (v = t.attributes.position, y = t.index, 0 === (x = t.groups).length && (x = [{
									start: 0,
									count: y.count,
									materialIndex: 0
								}]), r = 0, a = x.length; r < a; ++r)
								for (b = x[r], _ = b.start, w = b.count, e = _, n = _ + w; e < n; e += 3)
									for (i = 0; i < 3; i++) s = y.getX(e + i), c = y.getX(e + (i + 1) % 3), p[0] =
										Math.min(s, c), p[1] = Math.max(s, c), h = p[0] + "," + p[1], void 0 === d[
										h] && (d[h] = {
											index1: p[0],
											index2: p[1]
										});
							for (h in d) o = d[h], l.fromBufferAttribute(v, o.index1), u.push(l.x, l.y, l.z), l
								.fromBufferAttribute(v, o.index2), u.push(l.x, l.y, l.z)
						} else
							for (v = t.attributes.position, e = 0, n = v.count / 3; e < n; e++)
								for (i = 0; i < 3; i++) M = 3 * e + i, l.fromBufferAttribute(v, M), u.push(l.x, l.y, l
									.z), S = 3 * e + (i + 1) % 3, l.fromBufferAttribute(v, S), u.push(l.x, l.y, l
									.z)
					}
					this.addAttribute("position", new zi(u, 3))
				}

				function la(t, e, i) {
					Ai.call(this), this.type = "ParametricGeometry", this.parameters = {
						func: t,
						slices: e,
						stacks: i
					}, this.fromBufferGeometry(new ua(t, e, i)), this.mergeVertices()
				}

				function ua(t, e, i) {
					Hi.call(this), this.type = "ParametricBufferGeometry", this.parameters = {
						func: t,
						slices: e,
						stacks: i
					};
					var n, r, a = [],
						o = [],
						s = [],
						c = [],
						h = new Ne,
						l = new Ne,
						u = new Ne,
						p = new Ne,
						d = new Ne;
					t.length < 3 && console.error(
						"THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.");
					var f = e + 1;
					for (n = 0; n <= i; n++) {
						var m = n / i;
						for (r = 0; r <= e; r++) {
							var g = r / e;
							t(g, m, l), o.push(l.x, l.y, l.z), g - 1e-5 >= 0 ? (t(g - 1e-5, m, u), p.subVectors(l,
								u)) : (t(g + 1e-5, m, u), p.subVectors(u, l)), m - 1e-5 >= 0 ? (t(g, m - 1e-5, u), d
									.subVectors(l, u)) : (t(g, m + 1e-5, u), d.subVectors(u, l)), h.crossVectors(p, d)
								.normalize(), s.push(h.x, h.y, h.z), c.push(g, m)
						}
					}
					for (n = 0; n < i; n++)
						for (r = 0; r < e; r++) {
							var v = n * f + r,
								y = n * f + r + 1,
								x = (n + 1) * f + r + 1,
								b = (n + 1) * f + r;
							a.push(v, y, b), a.push(y, x, b)
						}
					this.setIndex(a), this.addAttribute("position", new zi(o, 3)), this.addAttribute("normal", new zi(
						s, 3)), this.addAttribute("uv", new zi(c, 2))
				}

				function pa(t, e, i, n) {
					Ai.call(this), this.type = "PolyhedronGeometry", this.parameters = {
						vertices: t,
						indices: e,
						radius: i,
						detail: n
					}, this.fromBufferGeometry(new da(t, e, i, n)), this.mergeVertices()
				}

				function da(t, e, i, n) {
					Hi.call(this), this.type = "PolyhedronBufferGeometry", this.parameters = {
						vertices: t,
						indices: e,
						radius: i,
						detail: n
					}, i = i || 1;
					var r = [],
						a = [];

					function o(t, e, i, n) {
						var r, a, o = Math.pow(2, n),
							c = [];
						for (r = 0; r <= o; r++) {
							c[r] = [];
							var h = t.clone().lerp(i, r / o),
								l = e.clone().lerp(i, r / o),
								u = o - r;
							for (a = 0; a <= u; a++) c[r][a] = 0 === a && r === o ? h : h.clone().lerp(l, a / u)
						}
						for (r = 0; r < o; r++)
							for (a = 0; a < 2 * (o - r) - 1; a++) {
								var p = Math.floor(a / 2);
								a % 2 == 0 ? (s(c[r][p + 1]), s(c[r + 1][p]), s(c[r][p])) : (s(c[r][p + 1]), s(c[r +
									1][p + 1]), s(c[r + 1][p]))
							}
					}

					function s(t) {
						r.push(t.x, t.y, t.z)
					}

					function c(e, i) {
						var n = 3 * e;
						i.x = t[n + 0], i.y = t[n + 1], i.z = t[n + 2]
					}

					function h(t, e, i, n) {
						n < 0 && 1 === t.x && (a[e] = t.x - 1), 0 === i.x && 0 === i.z && (a[e] = n / 2 / Math.PI +
							.5)
					}

					function l(t) {
						return Math.atan2(t.z, -t.x)
					}! function (t) {
						for (var i = new Ne, n = new Ne, r = new Ne, a = 0; a < e.length; a += 3) c(e[a + 0], i), c(e[
							a + 1], n), c(e[a + 2], r), o(i, n, r, t)
					}(n = n || 0),
					function (t) {
						for (var e = new Ne, i = 0; i < r.length; i += 3) e.x = r[i + 0], e.y = r[i + 1], e.z = r[i +
							2], e.normalize().multiplyScalar(t), r[i + 0] = e.x, r[i + 1] = e.y, r[i + 2] = e.z
					}(i),
					function () {
						for (var t = new Ne, e = 0; e < r.length; e += 3) {
							t.x = r[e + 0], t.y = r[e + 1], t.z = r[e + 2];
							var i = l(t) / 2 / Math.PI + .5,
								n = (o = t, Math.atan2(-o.y, Math.sqrt(o.x * o.x + o.z * o.z)) / Math.PI + .5);
							a.push(i, 1 - n)
						}
						var o;
						(function () {
							for (var t = new Ne, e = new Ne, i = new Ne, n = new Ne, o = new De, s = new De, c =
									new De, u = 0, p = 0; u < r.length; u += 9, p += 6) {
								t.set(r[u + 0], r[u + 1], r[u + 2]), e.set(r[u + 3], r[u + 4], r[u + 5]), i.set(r[
									u + 6], r[u + 7], r[u + 8]), o.set(a[p + 0], a[p + 1]), s.set(a[p + 2], a[
									p + 3]), c.set(a[p + 4], a[p + 5]), n.copy(t).add(e).add(i).divideScalar(
									3);
								var d = l(n);
								h(o, p + 0, t, d), h(s, p + 2, e, d), h(c, p + 4, i, d)
							}
						})(),
						function () {
							for (var t = 0; t < a.length; t += 6) {
								var e = a[t + 0],
									i = a[t + 2],
									n = a[t + 4],
									r = Math.max(e, i, n),
									o = Math.min(e, i, n);
								r > .9 && o < .1 && (e < .2 && (a[t + 0] += 1), i < .2 && (a[t + 2] += 1), n < .2 && (
									a[t + 4] += 1))
							}
						}()
					}(), this.addAttribute("position", new zi(r, 3)), this.addAttribute("normal", new zi(r.slice(),
							3)), this.addAttribute("uv", new zi(a, 2)), 0 === n ? this.computeVertexNormals() : this
						.normalizeNormals()
				}

				function fa(t, e) {
					Ai.call(this), this.type = "TetrahedronGeometry", this.parameters = {
						radius: t,
						detail: e
					}, this.fromBufferGeometry(new ma(t, e)), this.mergeVertices()
				}

				function ma(t, e) {
					da.call(this, [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1], [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1], t,
						e), this.type = "TetrahedronBufferGeometry", this.parameters = {
						radius: t,
						detail: e
					}
				}

				function ga(t, e) {
					Ai.call(this), this.type = "OctahedronGeometry", this.parameters = {
						radius: t,
						detail: e
					}, this.fromBufferGeometry(new va(t, e)), this.mergeVertices()
				}

				function va(t, e) {
					da.call(this, [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1], [0, 2, 4, 0, 4, 3, 0, 3,
						5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2
					], t, e), this.type = "OctahedronBufferGeometry", this.parameters = {
						radius: t,
						detail: e
					}
				}

				function ya(t, e) {
					Ai.call(this), this.type = "IcosahedronGeometry", this.parameters = {
						radius: t,
						detail: e
					}, this.fromBufferGeometry(new xa(t, e)), this.mergeVertices()
				}

				function xa(t, e) {
					var i = (1 + Math.sqrt(5)) / 2,
						n = [-1, i, 0, 1, i, 0, -1, -i, 0, 1, -i, 0, 0, -1, i, 0, 1, i, 0, -1, -i, 0, 1, -i, i, 0, -1,
							i, 0, 1, -i, 0, -1, -i, 0, 1
						];
					da.call(this, n, [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2,
						10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6,
						2, 10, 8, 6, 7, 9, 8, 1
					], t, e), this.type = "IcosahedronBufferGeometry", this.parameters = {
						radius: t,
						detail: e
					}
				}

				function ba(t, e) {
					Ai.call(this), this.type = "DodecahedronGeometry", this.parameters = {
						radius: t,
						detail: e
					}, this.fromBufferGeometry(new _a(t, e)), this.mergeVertices()
				}

				function _a(t, e) {
					var i = (1 + Math.sqrt(5)) / 2,
						n = 1 / i,
						r = [-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -
							n, -i, 0, -n, i, 0, n, -i, 0, n, i, -n, -i, 0, -n, i, 0, n, -i, 0, n, i, 0, -i, 0, -n, i,
							0, -n, -i, 0, n, i, 0, n
						];
					da.call(this, r, [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8,
						10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2,
						6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4,
						14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19,
						4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9
					], t, e), this.type = "DodecahedronBufferGeometry", this.parameters = {
						radius: t,
						detail: e
					}
				}

				function wa(t, e, i, n, r, a) {
					Ai.call(this), this.type = "TubeGeometry", this.parameters = {
						path: t,
						tubularSegments: e,
						radius: i,
						radialSegments: n,
						closed: r
					}, void 0 !== a && console.warn("THREE.TubeGeometry: taper has been removed.");
					var o = new Ma(t, e, i, n, r);
					this.tangents = o.tangents, this.normals = o.normals, this.binormals = o.binormals, this
						.fromBufferGeometry(o), this.mergeVertices()
				}

				function Ma(t, e, i, n, r) {
					Hi.call(this), this.type = "TubeBufferGeometry", this.parameters = {
						path: t,
						tubularSegments: e,
						radius: i,
						radialSegments: n,
						closed: r
					}, e = e || 64, i = i || 1, n = n || 8, r = r || !1;
					var a = t.computeFrenetFrames(e, r);
					this.tangents = a.tangents, this.normals = a.normals, this.binormals = a.binormals;
					var o, s, c = new Ne,
						h = new Ne,
						l = new De,
						u = new Ne,
						p = [],
						d = [],
						f = [],
						m = [];

					function g(r) {
						u = t.getPointAt(r / e, u);
						var o = a.normals[r],
							l = a.binormals[r];
						for (s = 0; s <= n; s++) {
							var f = s / n * Math.PI * 2,
								m = Math.sin(f),
								g = -Math.cos(f);
							h.x = g * o.x + m * l.x, h.y = g * o.y + m * l.y, h.z = g * o.z + m * l.z, h.normalize(),
								d.push(h.x, h.y, h.z), c.x = u.x + i * h.x, c.y = u.y + i * h.y, c.z = u.z + i * h.z,
								p.push(c.x, c.y, c.z)
						}
					}! function () {
						for (o = 0; o < e; o++) g(o);
						g(!1 === r ? e : 0),
							function () {
								for (o = 0; o <= e; o++)
									for (s = 0; s <= n; s++) l.x = o / e, l.y = s / n, f.push(l.x, l.y)
							}(),
							function () {
								for (s = 1; s <= e; s++)
									for (o = 1; o <= n; o++) {
										var t = (n + 1) * (s - 1) + (o - 1),
											i = (n + 1) * s + (o - 1),
											r = (n + 1) * s + o,
											a = (n + 1) * (s - 1) + o;
										m.push(t, i, a), m.push(i, r, a)
									}
							}()
					}(), this.setIndex(m), this.addAttribute("position", new zi(p, 3)), this.addAttribute("normal",
						new zi(d, 3)), this.addAttribute("uv", new zi(f, 2))
				}

				function Sa(t, e, i, n, r, a, o) {
					Ai.call(this), this.type = "TorusKnotGeometry", this.parameters = {
						radius: t,
						tube: e,
						tubularSegments: i,
						radialSegments: n,
						p: r,
						q: a
					}, void 0 !== o && console.warn(
						"THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead."
						), this.fromBufferGeometry(new Ea(t, e, i, n, r, a)), this.mergeVertices()
				}

				function Ea(t, e, i, n, r, a) {
					Hi.call(this), this.type = "TorusKnotBufferGeometry", this.parameters = {
							radius: t,
							tube: e,
							tubularSegments: i,
							radialSegments: n,
							p: r,
							q: a
						}, t = t || 1, e = e || .4, i = Math.floor(i) || 64, n = Math.floor(n) || 8, r = r || 2, a =
						a || 3;
					var o, s, c = [],
						h = [],
						l = [],
						u = [],
						p = new Ne,
						d = new Ne,
						f = new Ne,
						m = new Ne,
						g = new Ne,
						v = new Ne,
						y = new Ne;
					for (o = 0; o <= i; ++o) {
						var x = o / i * r * Math.PI * 2;
						for (A(x, r, a, t, f), A(x + .01, r, a, t, m), v.subVectors(m, f), y.addVectors(m, f), g
							.crossVectors(v, y), y.crossVectors(g, v), g.normalize(), y.normalize(), s = 0; s <= n; ++
							s) {
							var b = s / n * Math.PI * 2,
								_ = -e * Math.cos(b),
								w = e * Math.sin(b);
							p.x = f.x + (_ * y.x + w * g.x), p.y = f.y + (_ * y.y + w * g.y), p.z = f.z + (_ * y.z +
								w * g.z), h.push(p.x, p.y, p.z), d.subVectors(p, f).normalize(), l.push(d.x, d.y,
								d.z), u.push(o / i), u.push(s / n)
						}
					}
					for (s = 1; s <= i; s++)
						for (o = 1; o <= n; o++) {
							var M = (n + 1) * (s - 1) + (o - 1),
								S = (n + 1) * s + (o - 1),
								E = (n + 1) * s + o,
								T = (n + 1) * (s - 1) + o;
							c.push(M, S, T), c.push(S, E, T)
						}

					function A(t, e, i, n, r) {
						var a = Math.cos(t),
							o = Math.sin(t),
							s = i / e * t,
							c = Math.cos(s);
						r.x = n * (2 + c) * .5 * a, r.y = n * (2 + c) * o * .5, r.z = n * Math.sin(s) * .5
					}
					this.setIndex(c), this.addAttribute("position", new zi(h, 3)), this.addAttribute("normal", new zi(
						l, 3)), this.addAttribute("uv", new zi(u, 2))
				}

				function Ta(t, e, i, n, r) {
					Ai.call(this), this.type = "TorusGeometry", this.parameters = {
						radius: t,
						tube: e,
						radialSegments: i,
						tubularSegments: n,
						arc: r
					}, this.fromBufferGeometry(new Aa(t, e, i, n, r)), this.mergeVertices()
				}

				function Aa(t, e, i, n, r) {
					Hi.call(this), this.type = "TorusBufferGeometry", this.parameters = {
							radius: t,
							tube: e,
							radialSegments: i,
							tubularSegments: n,
							arc: r
						}, t = t || 1, e = e || .4, i = Math.floor(i) || 8, n = Math.floor(n) || 6, r = r || 2 * Math
						.PI;
					var a, o, s = [],
						c = [],
						h = [],
						l = [],
						u = new Ne,
						p = new Ne,
						d = new Ne;
					for (a = 0; a <= i; a++)
						for (o = 0; o <= n; o++) {
							var f = o / n * r,
								m = a / i * Math.PI * 2;
							p.x = (t + e * Math.cos(m)) * Math.cos(f), p.y = (t + e * Math.cos(m)) * Math.sin(f), p
								.z = e * Math.sin(m), c.push(p.x, p.y, p.z), u.x = t * Math.cos(f), u.y = t * Math
								.sin(f), d.subVectors(p, u).normalize(), h.push(d.x, d.y, d.z), l.push(o / n), l.push(
									a / i)
						}
					for (a = 1; a <= i; a++)
						for (o = 1; o <= n; o++) {
							var g = (n + 1) * a + o - 1,
								v = (n + 1) * (a - 1) + o - 1,
								y = (n + 1) * (a - 1) + o,
								x = (n + 1) * a + o;
							s.push(g, v, x), s.push(v, y, x)
						}
					this.setIndex(s), this.addAttribute("position", new zi(c, 3)), this.addAttribute("normal", new zi(
						h, 3)), this.addAttribute("uv", new zi(l, 2))
				}
				kr.prototype.isFogExp2 = !0, kr.prototype.clone = function () {
						return new kr(this.color, this.density)
					}, kr.prototype.toJSON = function () {
						return {
							type: "FogExp2",
							color: this.color.getHex(),
							density: this.density
						}
					}, jr.prototype.isFog = !0, jr.prototype.clone = function () {
						return new jr(this.color, this.near, this.far)
					}, jr.prototype.toJSON = function () {
						return {
							type: "Fog",
							color: this.color.getHex(),
							near: this.near,
							far: this.far
						}
					}, Vr.prototype = Object.assign(Object.create(Mi.prototype), {
						constructor: Vr,
						copy: function (t, e) {
							return Mi.prototype.copy.call(this, t, e), null !== t.background && (this
									.background = t.background.clone()), null !== t.fog && (this.fog = t.fog
									.clone()), null !== t.overrideMaterial && (this.overrideMaterial = t
									.overrideMaterial.clone()), this.autoUpdate = t.autoUpdate, this
								.matrixAutoUpdate = t.matrixAutoUpdate, this
						},
						toJSON: function (t) {
							var e = Mi.prototype.toJSON.call(this, t);
							return null !== this.background && (e.object.background = this.background.toJSON(
								t)), null !== this.fog && (e.object.fog = this.fog.toJSON()), e
						}
					}), Object.defineProperty(Wr.prototype, "needsUpdate", {
						set: function (t) {
							!0 === t && this.version++
						}
					}), Object.assign(Wr.prototype, {
						isInterleavedBuffer: !0,
						onUploadCallback: function () {},
						setArray: function (t) {
							if (Array.isArray(t)) throw new TypeError(
								"THREE.BufferAttribute: array should be a Typed Array.");
							return this.count = void 0 !== t ? t.length / this.stride : 0, this.array = t,
								this
						},
						setDynamic: function (t) {
							return this.dynamic = t, this
						},
						copy: function (t) {
							return this.array = new t.array.constructor(t.array), this.count = t.count, this
								.stride = t.stride, this.dynamic = t.dynamic, this
						},
						copyAt: function (t, e, i) {
							t *= this.stride, i *= e.stride;
							for (var n = 0, r = this.stride; n < r; n++) this.array[t + n] = e.array[i + n];
							return this
						},
						set: function (t, e) {
							return void 0 === e && (e = 0), this.array.set(t, e), this
						},
						clone: function () {
							return (new this.constructor).copy(this)
						},
						onUpload: function (t) {
							return this.onUploadCallback = t, this
						}
					}), Object.defineProperties(qr.prototype, {
						count: {
							get: function () {
								return this.data.count
							}
						},
						array: {
							get: function () {
								return this.data.array
							}
						}
					}), Object.assign(qr.prototype, {
						isInterleavedBufferAttribute: !0,
						setX: function (t, e) {
							return this.data.array[t * this.data.stride + this.offset] = e, this
						},
						setY: function (t, e) {
							return this.data.array[t * this.data.stride + this.offset + 1] = e, this
						},
						setZ: function (t, e) {
							return this.data.array[t * this.data.stride + this.offset + 2] = e, this
						},
						setW: function (t, e) {
							return this.data.array[t * this.data.stride + this.offset + 3] = e, this
						},
						getX: function (t) {
							return this.data.array[t * this.data.stride + this.offset]
						},
						getY: function (t) {
							return this.data.array[t * this.data.stride + this.offset + 1]
						},
						getZ: function (t) {
							return this.data.array[t * this.data.stride + this.offset + 2]
						},
						getW: function (t) {
							return this.data.array[t * this.data.stride + this.offset + 3]
						},
						setXY: function (t, e, i) {
							return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this
								.data.array[t + 1] = i, this
						},
						setXYZ: function (t, e, i, n) {
							return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this
								.data.array[t + 1] = i, this.data.array[t + 2] = n, this
						},
						setXYZW: function (t, e, i, n, r) {
							return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this
								.data.array[t + 1] = i, this.data.array[t + 2] = n, this.data.array[t + 3] =
								r, this
						}
					}), Xr.prototype = Object.create(on.prototype), Xr.prototype.constructor = Xr, Xr.prototype
					.isSpriteMaterial = !0, Xr.prototype.copy = function (t) {
						return on.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this
							.rotation = t.rotation, this.sizeAttenuation = t.sizeAttenuation, this
					}, Yr.prototype = Object.assign(Object.create(Mi.prototype), {
						constructor: Yr,
						isSprite: !0,
						raycast: function () {
							var t = new Ne,
								e = new Ne,
								i = new Ne,
								n = new De,
								r = new De,
								a = new Be,
								o = new Ne,
								s = new Ne,
								c = new Ne,
								h = new De,
								l = new De,
								u = new De;

							function p(t, e, i, o, s, c) {
								n.subVectors(t, i).addScalar(.5).multiply(o), void 0 !== s ? (r.x = c * n.x -
										s * n.y, r.y = s * n.x + c * n.y) : r.copy(n), t.copy(e), t.x += r.x,
									t.y += r.y, t.applyMatrix4(a)
							}
							return function (n, r) {
								e.setFromMatrixScale(this.matrixWorld), a.getInverse(this.modelViewMatrix)
									.premultiply(this.matrixWorld), i.setFromMatrixPosition(this
										.modelViewMatrix);
								var d, f, m = this.material.rotation;
								0 !== m && (f = Math.cos(m), d = Math.sin(m));
								var g = this.center;
								p(o.set(-.5, -.5, 0), i, g, e, d, f), p(s.set(.5, -.5, 0), i, g, e, d, f),
									p(c.set(.5, .5, 0), i, g, e, d, f), h.set(0, 0), l.set(1, 0), u.set(1,
										1);
								var v = n.ray.intersectTriangle(o, s, c, !1, t);
								if (null !== v || (p(s.set(-.5, .5, 0), i, g, e, d, f), l.set(0, 1),
										null !== (v = n.ray.intersectTriangle(o, c, s, !1, t)))) {
									var y = n.ray.origin.distanceTo(t);
									y < n.near || y > n.far || r.push({
										distance: y,
										point: t.clone(),
										uv: hn.getUV(t, o, s, c, h, l, u, new De),
										face: null,
										object: this
									})
								}
							}
						}(),
						clone: function () {
							return new this.constructor(this.material).copy(this)
						},
						copy: function (t) {
							return Mi.prototype.copy.call(this, t), void 0 !== t.center && this.center.copy(t
								.center), this
						}
					}), Jr.prototype = Object.assign(Object.create(Mi.prototype), {
						constructor: Jr,
						copy: function (t) {
							Mi.prototype.copy.call(this, t, !1);
							for (var e = t.levels, i = 0, n = e.length; i < n; i++) {
								var r = e[i];
								this.addLevel(r.object.clone(), r.distance)
							}
							return this
						},
						addLevel: function (t, e) {
							void 0 === e && (e = 0), e = Math.abs(e);
							for (var i = this.levels, n = 0; n < i.length && !(e < i[n].distance); n++);
							i.splice(n, 0, {
								distance: e,
								object: t
							}), this.add(t)
						},
						getObjectForDistance: function (t) {
							for (var e = this.levels, i = 1, n = e.length; i < n && !(t < e[i].distance); i++)
							;
							return e[i - 1].object
						},
						raycast: (zr = new Ne, function (t, e) {
							zr.setFromMatrixPosition(this.matrixWorld);
							var i = t.ray.origin.distanceTo(zr);
							this.getObjectForDistance(i).raycast(t, e)
						}),
						update: function () {
							var t = new Ne,
								e = new Ne;
							return function (i) {
								var n = this.levels;
								if (n.length > 1) {
									t.setFromMatrixPosition(i.matrixWorld), e.setFromMatrixPosition(this
										.matrixWorld);
									var r = t.distanceTo(e);
									n[0].object.visible = !0;
									for (var a = 1, o = n.length; a < o && r >= n[a].distance; a++) n[a -
										1].object.visible = !1, n[a].object.visible = !0;
									for (; a < o; a++) n[a].object.visible = !1
								}
							}
						}(),
						toJSON: function (t) {
							var e = Mi.prototype.toJSON.call(this, t);
							e.object.levels = [];
							for (var i = this.levels, n = 0, r = i.length; n < r; n++) {
								var a = i[n];
								e.object.levels.push({
									object: a.object.uuid,
									distance: a.distance
								})
							}
							return e
						}
					}), Zr.prototype = Object.assign(Object.create(un.prototype), {
						constructor: Zr,
						isSkinnedMesh: !0,
						bind: function (t, e) {
							this.skeleton = t, void 0 === e && (this.updateMatrixWorld(!0), this.skeleton
									.calculateInverses(), e = this.matrixWorld), this.bindMatrix.copy(e), this
								.bindMatrixInverse.getInverse(e)
						},
						pose: function () {
							this.skeleton.pose()
						},
						normalizeSkinWeights: function () {
							for (var t = new Xe, e = this.geometry.attributes.skinWeight, i = 0, n = e
								.count; i < n; i++) {
								t.x = e.getX(i), t.y = e.getY(i), t.z = e.getZ(i), t.w = e.getW(i);
								var r = 1 / t.manhattanLength();
								r !== 1 / 0 ? t.multiplyScalar(r) : t.set(1, 0, 0, 0), e.setXYZW(i, t.x, t.y,
									t.z, t.w)
							}
						},
						updateMatrixWorld: function (t) {
							un.prototype.updateMatrixWorld.call(this, t), "attached" === this.bindMode ? this
								.bindMatrixInverse.getInverse(this.matrixWorld) : "detached" === this
								.bindMode ? this.bindMatrixInverse.getInverse(this.bindMatrix) : console.warn(
									"THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode)
						},
						clone: function () {
							return new this.constructor(this.geometry, this.material).copy(this)
						}
					}), Object.assign(Qr.prototype, {
						calculateInverses: function () {
							this.boneInverses = [];
							for (var t = 0, e = this.bones.length; t < e; t++) {
								var i = new Be;
								this.bones[t] && i.getInverse(this.bones[t].matrixWorld), this.boneInverses
									.push(i)
							}
						},
						pose: function () {
							var t, e, i;
							for (e = 0, i = this.bones.length; e < i; e++)(t = this.bones[e]) && t.matrixWorld
								.getInverse(this.boneInverses[e]);
							for (e = 0, i = this.bones.length; e < i; e++)(t = this.bones[e]) && (t.parent &&
								t.parent.isBone ? (t.matrix.getInverse(t.parent.matrixWorld), t.matrix
									.multiply(t.matrixWorld)) : t.matrix.copy(t.matrixWorld), t.matrix
								.decompose(t.position, t.quaternion, t.scale))
						},
						update: (Dr = new Be, Br = new Be, function () {
							for (var t = this.bones, e = this.boneInverses, i = this.boneMatrices, n =
									this.boneTexture, r = 0, a = t.length; r < a; r++) {
								var o = t[r] ? t[r].matrixWorld : Br;
								Dr.multiplyMatrices(o, e[r]), Dr.toArray(i, 16 * r)
							}
							void 0 !== n && (n.needsUpdate = !0)
						}),
						clone: function () {
							return new Qr(this.bones, this.boneInverses)
						},
						getBoneByName: function (t) {
							for (var e = 0, i = this.bones.length; e < i; e++) {
								var n = this.bones[e];
								if (n.name === t) return n
							}
						}
					}), Kr.prototype = Object.assign(Object.create(Mi.prototype), {
						constructor: Kr,
						isBone: !0
					}), $r.prototype = Object.create(on.prototype), $r.prototype.constructor = $r, $r.prototype
					.isLineBasicMaterial = !0, $r.prototype.copy = function (t) {
						return on.prototype.copy.call(this, t), this.color.copy(t.color), this.linewidth = t
							.linewidth, this.linecap = t.linecap, this.linejoin = t.linejoin, this
					}, ta.prototype = Object.assign(Object.create(Mi.prototype), {
						constructor: ta,
						isLine: !0,
						computeLineDistances: (Or = new Ne, Ir = new Ne, function () {
							var t = this.geometry;
							if (t.isBufferGeometry)
								if (null === t.index) {
									for (var e = t.attributes.position, i = [0], n = 1, r = e.count; n <
										r; n++) Or.fromBufferAttribute(e, n - 1), Ir.fromBufferAttribute(
										e, n), i[n] = i[n - 1], i[n] += Or.distanceTo(Ir);
									t.addAttribute("lineDistance", new zi(i, 1))
								} else console.warn(
									"THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
									);
							else if (t.isGeometry) {
								var a = t.vertices,
									i = t.lineDistances;
								i[0] = 0;
								for (var n = 1, r = a.length; n < r; n++) i[n] = i[n - 1], i[n] += a[n -
									1].distanceTo(a[n])
							}
							return this
						}),
						raycast: function () {
							var t = new Be,
								e = new cn,
								i = new Ke;
							return function (n, r) {
								var a = n.linePrecision,
									o = this.geometry,
									s = this.matrixWorld;
								if (null === o.boundingSphere && o.computeBoundingSphere(), i.copy(o
										.boundingSphere), i.applyMatrix4(s), i.radius += a, !1 !== n.ray
									.intersectsSphere(i)) {
									t.getInverse(s), e.copy(n.ray).applyMatrix4(t);
									var c = a / ((this.scale.x + this.scale.y + this.scale.z) / 3),
										h = c * c,
										l = new Ne,
										u = new Ne,
										p = new Ne,
										d = new Ne,
										f = this && this.isLineSegments ? 2 : 1;
									if (o.isBufferGeometry) {
										var m = o.index,
											g = o.attributes,
											v = g.position.array;
										if (null !== m)
											for (var y = m.array, x = 0, b = y.length - 1; x < b; x +=
												f) {
												var _ = y[x],
													w = y[x + 1];
												l.fromArray(v, 3 * _), u.fromArray(v, 3 * w);
												var M = e.distanceSqToSegment(l, u, d, p);
												if (!(M > h)) {
													d.applyMatrix4(this.matrixWorld);
													var S = n.ray.origin.distanceTo(d);
													S < n.near || S > n.far || r.push({
														distance: S,
														point: p.clone().applyMatrix4(this
															.matrixWorld),
														index: x,
														face: null,
														faceIndex: null,
														object: this
													})
												}
											} else
												for (var x = 0, b = v.length / 3 - 1; x < b; x += f) {
													l.fromArray(v, 3 * x), u.fromArray(v, 3 * x + 3);
													var M = e.distanceSqToSegment(l, u, d, p);
													if (!(M > h)) {
														d.applyMatrix4(this.matrixWorld);
														var S = n.ray.origin.distanceTo(d);
														S < n.near || S > n.far || r.push({
															distance: S,
															point: p.clone().applyMatrix4(this
																.matrixWorld),
															index: x,
															face: null,
															faceIndex: null,
															object: this
														})
													}
												}
									} else if (o.isGeometry)
										for (var E = o.vertices, T = E.length, x = 0; x < T - 1; x += f) {
											var M = e.distanceSqToSegment(E[x], E[x + 1], d, p);
											if (!(M > h)) {
												d.applyMatrix4(this.matrixWorld);
												var S = n.ray.origin.distanceTo(d);
												S < n.near || S > n.far || r.push({
													distance: S,
													point: p.clone().applyMatrix4(this
														.matrixWorld),
													index: x,
													face: null,
													faceIndex: null,
													object: this
												})
											}
										}
								}
							}
						}(),
						copy: function (t) {
							return Mi.prototype.copy.call(this, t), this.geometry.copy(t.geometry), this
								.material.copy(t.material), this
						},
						clone: function () {
							return (new this.constructor).copy(this)
						}
					}), ea.prototype = Object.assign(Object.create(ta.prototype), {
						constructor: ea,
						isLineSegments: !0,
						computeLineDistances: function () {
							var t = new Ne,
								e = new Ne;
							return function () {
								var i = this.geometry;
								if (i.isBufferGeometry)
									if (null === i.index) {
										for (var n = i.attributes.position, r = [], a = 0, o = n
											.count; a < o; a += 2) t.fromBufferAttribute(n, a), e
											.fromBufferAttribute(n, a + 1), r[a] = 0 === a ? 0 : r[a - 1],
											r[a + 1] = r[a] + t.distanceTo(e);
										i.addAttribute("lineDistance", new zi(r, 1))
									} else console.warn(
										"THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
										);
								else if (i.isGeometry)
									for (var s = i.vertices, r = i.lineDistances, a = 0, o = s.length; a <
										o; a += 2) t.copy(s[a]), e.copy(s[a + 1]), r[a] = 0 === a ? 0 : r[
										a - 1], r[a + 1] = r[a] + t.distanceTo(e);
								return this
							}
						}()
					}), ia.prototype = Object.assign(Object.create(ta.prototype), {
						constructor: ia,
						isLineLoop: !0
					}), na.prototype = Object.create(on.prototype), na.prototype.constructor = na, na.prototype
					.isPointsMaterial = !0, na.prototype.copy = function (t) {
						return on.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this
							.size = t.size, this.sizeAttenuation = t.sizeAttenuation, this.morphTargets = t
							.morphTargets, this
					}, ra.prototype = Object.assign(Object.create(Mi.prototype), {
						constructor: ra,
						isPoints: !0,
						raycast: function () {
							var t = new Be,
								e = new cn,
								i = new Ke;
							return function (n, r) {
								var a = this,
									o = this.geometry,
									s = this.matrixWorld,
									c = n.params.Points.threshold;
								if (null === o.boundingSphere && o.computeBoundingSphere(), i.copy(o
										.boundingSphere), i.applyMatrix4(s), i.radius += c, !1 !== n.ray
									.intersectsSphere(i)) {
									t.getInverse(s), e.copy(n.ray).applyMatrix4(t);
									var h = c / ((this.scale.x + this.scale.y + this.scale.z) / 3),
										l = h * h,
										u = new Ne,
										p = new Ne;
									if (o.isBufferGeometry) {
										var d = o.index,
											f = o.attributes,
											m = f.position.array;
										if (null !== d)
											for (var g = d.array, v = 0, y = g.length; v < y; v++) {
												var x = g[v];
												u.fromArray(m, 3 * x), w(u, x)
											} else
												for (var v = 0, b = m.length / 3; v < b; v++) u.fromArray(
													m, 3 * v), w(u, v)
									} else
										for (var _ = o.vertices, v = 0, b = _.length; v < b; v++) w(_[v],
											v)
								}

								function w(t, i) {
									var o = e.distanceSqToPoint(t);
									if (o < l) {
										e.closestPointToPoint(t, p), p.applyMatrix4(s);
										var c = n.ray.origin.distanceTo(p);
										if (c < n.near || c > n.far) return;
										r.push({
											distance: c,
											distanceToRay: Math.sqrt(o),
											point: p.clone(),
											index: i,
											face: null,
											object: a
										})
									}
								}
							}
						}(),
						clone: function () {
							return new this.constructor(this.geometry, this.material).copy(this)
						}
					}), aa.prototype = Object.assign(Object.create(qe.prototype), {
						constructor: aa,
						isVideoTexture: !0,
						update: function () {
							var t = this.image;
							t.readyState >= t.HAVE_CURRENT_DATA && (this.needsUpdate = !0)
						}
					}), oa.prototype = Object.create(qe.prototype), oa.prototype.constructor = oa, oa.prototype
					.isCompressedTexture = !0, sa.prototype = Object.create(qe.prototype), sa.prototype.constructor =
					sa, sa.prototype.isCanvasTexture = !0, ca.prototype = Object.create(qe.prototype), ca.prototype
					.constructor = ca, ca.prototype.isDepthTexture = !0, ha.prototype = Object.create(Hi.prototype),
					ha.prototype.constructor = ha, la.prototype = Object.create(Ai.prototype), la.prototype
					.constructor = la, ua.prototype = Object.create(Hi.prototype), ua.prototype.constructor = ua, pa
					.prototype = Object.create(Ai.prototype), pa.prototype.constructor = pa, da.prototype = Object
					.create(Hi.prototype), da.prototype.constructor = da, fa.prototype = Object.create(Ai.prototype),
					fa.prototype.constructor = fa, ma.prototype = Object.create(da.prototype), ma.prototype
					.constructor = ma, ga.prototype = Object.create(Ai.prototype), ga.prototype.constructor = ga, va
					.prototype = Object.create(da.prototype), va.prototype.constructor = va, ya.prototype = Object
					.create(Ai.prototype), ya.prototype.constructor = ya, xa.prototype = Object.create(da.prototype),
					xa.prototype.constructor = xa, ba.prototype = Object.create(Ai.prototype), ba.prototype
					.constructor = ba, _a.prototype = Object.create(da.prototype), _a.prototype.constructor = _a, wa
					.prototype = Object.create(Ai.prototype), wa.prototype.constructor = wa, Ma.prototype = Object
					.create(Hi.prototype), Ma.prototype.constructor = Ma, Sa.prototype = Object.create(Ai.prototype),
					Sa.prototype.constructor = Sa, Ea.prototype = Object.create(Hi.prototype), Ea.prototype
					.constructor = Ea, Ta.prototype = Object.create(Ai.prototype), Ta.prototype.constructor = Ta, Aa
					.prototype = Object.create(Hi.prototype), Aa.prototype.constructor = Aa;
				var La = {
					triangulate: function (t, e, i) {
						i = i || 2;
						var n, r, a, o, s, c, h, l = e && e.length,
							u = l ? e[0] * i : t.length,
							p = Pa(t, 0, u, i, !0),
							d = [];
						if (!p) return d;
						if (l && (p = function (t, e, i, n) {
								var r, a, o, s, c, h = [];
								for (r = 0, a = e.length; r < a; r++) o = e[r] * n, s = r < a - 1 ? e[r +
									1] * n : t.length, (c = Pa(t, o, s, n, !1)) === c.next && (c
									.steiner = !0), h.push(Ga(c));
								for (h.sort(za), r = 0; r < h.length; r++) Na(h[r], i), i = Ca(i, i.next);
								return i
							}(t, e, p, i)), t.length > 80 * i) {
							n = a = t[0], r = o = t[1];
							for (var f = i; f < u; f += i) s = t[f], c = t[f + 1], s < n && (n = s), c < r &&
								(r = c), s > a && (a = s), c > o && (o = c);
							h = 0 !== (h = Math.max(a - n, o - r)) ? 1 / h : 0
						}
						return Ra(p, d, i, n, r, h), d
					}
				};

				function Pa(t, e, i, n, r) {
					var a, o;
					if (r === function (t, e, i, n) {
							for (var r = 0, a = e, o = i - n; a < i; a += n) r += (t[o] - t[a]) * (t[a + 1] + t[o +
								1]), o = a;
							return r
						}(t, e, i, n) > 0)
						for (a = e; a < i; a += n) o = Xa(a, t[a], t[a + 1], o);
					else
						for (a = i - n; a >= e; a -= n) o = Xa(a, t[a], t[a + 1], o);
					return o && ja(o, o.next) && (Ya(o), o = o.next), o
				}

				function Ca(t, e) {
					if (!t) return t;
					e || (e = t);
					var i, n = t;
					do {
						if (i = !1, n.steiner || !ja(n, n.next) && 0 !== ka(n.prev, n, n.next)) n = n.next;
						else {
							if (Ya(n), (n = e = n.prev) === n.next) break;
							i = !0
						}
					} while (i || n !== e);
					return e
				}

				function Ra(t, e, i, n, r, a, o) {
					if (t) {
						!o && a && function (t, e, i, n) {
							var r = t;
							do {
								null === r.z && (r.z = Ua(r.x, r.y, e, i, n)), r.prevZ = r.prev, r.nextZ = r.next,
									r = r.next
							} while (r !== t);
							r.prevZ.nextZ = null, r.prevZ = null,
								function (t) {
									var e, i, n, r, a, o, s, c, h = 1;
									do {
										for (i = t, t = null, a = null, o = 0; i;) {
											for (o++, n = i, s = 0, e = 0; e < h && (s++, n = n.nextZ); e++);
											for (c = h; s > 0 || c > 0 && n;) 0 !== s && (0 === c || !n || i.z <=
													n.z) ? (r = i, i = i.nextZ, s--) : (r = n, n = n.nextZ, c--),
												a ? a.nextZ = r : t = r, r.prevZ = a, a = r;
											i = n
										}
										a.nextZ = null, h *= 2
									} while (o > 1)
								}(r)
						}(t, n, r, a);
						for (var s, c, h = t; t.prev !== t.next;)
							if (s = t.prev, c = t.next, a ? Ia(t, n, r, a) : Oa(t)) e.push(s.i / i), e.push(t.i / i),
								e.push(c.i / i), Ya(t), t = c.next, h = c.next;
							else if ((t = c) === h) {
							o ? 1 === o ? Ra(t = Da(t, e, i), e, i, n, r, a, 2) : 2 === o && Ba(t, e, i, n, r, a) :
								Ra(Ca(t), e, i, n, r, a, 1);
							break
						}
					}
				}

				function Oa(t) {
					var e = t.prev,
						i = t,
						n = t.next;
					if (ka(e, i, n) >= 0) return !1;
					for (var r = t.next.next; r !== t.prev;) {
						if (Fa(e.x, e.y, i.x, i.y, n.x, n.y, r.x, r.y) && ka(r.prev, r, r.next) >= 0) return !1;
						r = r.next
					}
					return !0
				}

				function Ia(t, e, i, n) {
					var r = t.prev,
						a = t,
						o = t.next;
					if (ka(r, a, o) >= 0) return !1;
					for (var s = r.x < a.x ? r.x < o.x ? r.x : o.x : a.x < o.x ? a.x : o.x, c = r.y < a.y ? r.y < o
							.y ? r.y : o.y : a.y < o.y ? a.y : o.y, h = r.x > a.x ? r.x > o.x ? r.x : o.x : a.x > o
							.x ? a.x : o.x, l = r.y > a.y ? r.y > o.y ? r.y : o.y : a.y > o.y ? a.y : o.y, u = Ua(s,
								c, e, i, n), p = Ua(h, l, e, i, n), d = t.nextZ; d && d.z <= p;) {
						if (d !== t.prev && d !== t.next && Fa(r.x, r.y, a.x, a.y, o.x, o.y, d.x, d.y) && ka(d.prev,
								d, d.next) >= 0) return !1;
						d = d.nextZ
					}
					for (d = t.prevZ; d && d.z >= u;) {
						if (d !== t.prev && d !== t.next && Fa(r.x, r.y, a.x, a.y, o.x, o.y, d.x, d.y) && ka(d.prev,
								d, d.next) >= 0) return !1;
						d = d.prevZ
					}
					return !0
				}

				function Da(t, e, i) {
					var n = t;
					do {
						var r = n.prev,
							a = n.next.next;
						!ja(r, a) && Va(r, n, n.next, a) && Wa(r, a) && Wa(a, r) && (e.push(r.i / i), e.push(n.i / i),
							e.push(a.i / i), Ya(n), Ya(n.next), n = t = a), n = n.next
					} while (n !== t);
					return n
				}

				function Ba(t, e, i, n, r, a) {
					var o = t;
					do {
						for (var s = o.next.next; s !== o.prev;) {
							if (o.i !== s.i && Ha(o, s)) {
								var c = qa(o, s);
								return o = Ca(o, o.next), c = Ca(c, c.next), Ra(o, e, i, n, r, a), void Ra(c, e, i, n,
									r, a)
							}
							s = s.next
						}
						o = o.next
					} while (o !== t)
				}

				function za(t, e) {
					return t.x - e.x
				}

				function Na(t, e) {
					if (e = function (t, e) {
							var i, n = e,
								r = t.x,
								a = t.y,
								o = -1 / 0;
							do {
								if (a <= n.y && a >= n.next.y && n.next.y !== n.y) {
									var s = n.x + (a - n.y) * (n.next.x - n.x) / (n.next.y - n.y);
									if (s <= r && s > o) {
										if (o = s, s === r) {
											if (a === n.y) return n;
											if (a === n.next.y) return n.next
										}
										i = n.x < n.next.x ? n : n.next
									}
								}
								n = n.next
							} while (n !== e);
							if (!i) return null;
							if (r === o) return i.prev;
							var c, h = i,
								l = i.x,
								u = i.y,
								p = 1 / 0;
							for (n = i.next; n !== h;) r >= n.x && n.x >= l && r !== n.x && Fa(a < u ? r : o, a, l, u,
								a < u ? o : r, a, n.x, n.y) && ((c = Math.abs(a - n.y) / (r - n.x)) < p || c ===
								p && n.x > i.x) && Wa(n, t) && (i = n, p = c), n = n.next;
							return i
						}(t, e)) {
						var i = qa(e, t);
						Ca(i, i.next)
					}
				}

				function Ua(t, e, i, n, r) {
					return (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = 32767 * (t -
						i) * r) | t << 8)) | t << 4)) | t << 2)) | t << 1)) | (e = 1431655765 & ((e = 858993459 &
						((e = 252645135 & ((e = 16711935 & ((e = 32767 * (e - n) * r) | e << 8)) | e <<
							4)) | e << 2)) | e << 1)) << 1
				}

				function Ga(t) {
					var e = t,
						i = t;
					do {
						e.x < i.x && (i = e), e = e.next
					} while (e !== t);
					return i
				}

				function Fa(t, e, i, n, r, a, o, s) {
					return (r - o) * (e - s) - (t - o) * (a - s) >= 0 && (t - o) * (n - s) - (i - o) * (e - s) >= 0 &&
						(i - o) * (a - s) - (r - o) * (n - s) >= 0
				}

				function Ha(t, e) {
					return t.next.i !== e.i && t.prev.i !== e.i && ! function (t, e) {
						var i = t;
						do {
							if (i.i !== t.i && i.next.i !== t.i && i.i !== e.i && i.next.i !== e.i && Va(i, i
									.next, t, e)) return !0;
							i = i.next
						} while (i !== t);
						return !1
					}(t, e) && Wa(t, e) && Wa(e, t) && function (t, e) {
						var i = t,
							n = !1,
							r = (t.x + e.x) / 2,
							a = (t.y + e.y) / 2;
						do {
							i.y > a != i.next.y > a && i.next.y !== i.y && r < (i.next.x - i.x) * (a - i.y) / (i
								.next.y - i.y) + i.x && (n = !n), i = i.next
						} while (i !== t);
						return n
					}(t, e)
				}

				function ka(t, e, i) {
					return (e.y - t.y) * (i.x - e.x) - (e.x - t.x) * (i.y - e.y)
				}

				function ja(t, e) {
					return t.x === e.x && t.y === e.y
				}

				function Va(t, e, i, n) {
					return !!(ja(t, e) && ja(i, n) || ja(t, n) && ja(i, e)) || ka(t, e, i) > 0 != ka(t, e, n) > 0 &&
						ka(i, n, t) > 0 != ka(i, n, e) > 0
				}

				function Wa(t, e) {
					return ka(t.prev, t, t.next) < 0 ? ka(t, e, t.next) >= 0 && ka(t, t.prev, e) >= 0 : ka(t, e, t
						.prev) < 0 || ka(t, t.next, e) < 0
				}

				function qa(t, e) {
					var i = new Ja(t.i, t.x, t.y),
						n = new Ja(e.i, e.x, e.y),
						r = t.next,
						a = e.prev;
					return t.next = e, e.prev = t, i.next = r, r.prev = i, n.next = i, i.prev = n, a.next = n, n
						.prev = a, n
				}

				function Xa(t, e, i, n) {
					var r = new Ja(t, e, i);
					return n ? (r.next = n.next, r.prev = n, n.next.prev = r, n.next = r) : (r.prev = r, r.next = r),
						r
				}

				function Ya(t) {
					t.next.prev = t.prev, t.prev.next = t.next, t.prevZ && (t.prevZ.nextZ = t.nextZ), t.nextZ && (t
						.nextZ.prevZ = t.prevZ)
				}

				function Ja(t, e, i) {
					this.i = t, this.x = e, this.y = i, this.prev = null, this.next = null, this.z = null, this
						.prevZ = null, this.nextZ = null, this.steiner = !1
				}
				var Za = {
					area: function (t) {
						for (var e = t.length, i = 0, n = e - 1, r = 0; r < e; n = r++) i += t[n].x * t[r].y -
							t[r].x * t[n].y;
						return .5 * i
					},
					isClockWise: function (t) {
						return Za.area(t) < 0
					},
					triangulateShape: function (t, e) {
						var i = [],
							n = [],
							r = [];
						Qa(t), Ka(i, t);
						var a = t.length;
						e.forEach(Qa);
						for (var o = 0; o < e.length; o++) n.push(a), a += e[o].length, Ka(i, e[o]);
						for (var s = La.triangulate(i, n), o = 0; o < s.length; o += 3) r.push(s.slice(o, o +
							3));
						return r
					}
				};

				function Qa(t) {
					var e = t.length;
					e > 2 && t[e - 1].equals(t[0]) && t.pop()
				}

				function Ka(t, e) {
					for (var i = 0; i < e.length; i++) t.push(e[i].x), t.push(e[i].y)
				}

				function $a(t, e) {
					Ai.call(this), this.type = "ExtrudeGeometry", this.parameters = {
						shapes: t,
						options: e
					}, this.fromBufferGeometry(new to(t, e)), this.mergeVertices()
				}

				function to(t, e) {
					Hi.call(this), this.type = "ExtrudeBufferGeometry", this.parameters = {
						shapes: t,
						options: e
					}, t = Array.isArray(t) ? t : [t];
					for (var i = this, n = [], r = [], a = 0, o = t.length; a < o; a++) {
						var s = t[a];
						c(s)
					}

					function c(t) {
						var a = [],
							o = void 0 !== e.curveSegments ? e.curveSegments : 12,
							s = void 0 !== e.steps ? e.steps : 1,
							c = void 0 !== e.depth ? e.depth : 100,
							h = void 0 === e.bevelEnabled || e.bevelEnabled,
							l = void 0 !== e.bevelThickness ? e.bevelThickness : 6,
							u = void 0 !== e.bevelSize ? e.bevelSize : l - 2,
							p = void 0 !== e.bevelSegments ? e.bevelSegments : 3,
							d = e.extrudePath,
							f = void 0 !== e.UVGenerator ? e.UVGenerator : eo;
						void 0 !== e.amount && (console.warn(
							"THREE.ExtrudeBufferGeometry: amount has been renamed to depth."), c = e.amount);
						var m, g, v, y, x, b, _, w, M = !1;
						d && (m = d.getSpacedPoints(s), M = !0, h = !1, g = d.computeFrenetFrames(s, !1), v = new Ne,
							y = new Ne, x = new Ne), h || (p = 0, l = 0, u = 0);
						var S = t.extractPoints(o),
							E = S.shape,
							T = S.holes,
							A = !Za.isClockWise(E);
						if (A)
							for (E = E.reverse(), _ = 0, w = T.length; _ < w; _++) b = T[_], Za.isClockWise(b) && (T[
								_] = b.reverse());
						var L = Za.triangulateShape(E, T),
							P = E;
						for (_ = 0, w = T.length; _ < w; _++) b = T[_], E = E.concat(b);

						function C(t, e, i) {
							return e || console.error("THREE.ExtrudeGeometry: vec does not exist"), e.clone()
								.multiplyScalar(i).add(t)
						}
						var R, O, I, D, B, z, N = E.length,
							U = L.length;

						function G(t, e, i) {
							var n, r, a, o = t.x - e.x,
								s = t.y - e.y,
								c = i.x - t.x,
								h = i.y - t.y,
								l = o * o + s * s,
								u = o * h - s * c;
							if (Math.abs(u) > Number.EPSILON) {
								var p = Math.sqrt(l),
									d = Math.sqrt(c * c + h * h),
									f = e.x - s / p,
									m = e.y + o / p,
									g = i.x - h / d,
									v = i.y + c / d,
									y = ((g - f) * h - (v - m) * c) / (o * h - s * c);
								n = f + o * y - t.x, r = m + s * y - t.y;
								var x = n * n + r * r;
								if (x <= 2) return new De(n, r);
								a = Math.sqrt(x / 2)
							} else {
								var b = !1;
								o > Number.EPSILON ? c > Number.EPSILON && (b = !0) : o < -Number.EPSILON ? c < -
									Number.EPSILON && (b = !0) : Math.sign(s) === Math.sign(h) && (b = !0), b ? (n = -
										s, r = o, a = Math.sqrt(l)) : (n = o, r = s, a = Math.sqrt(l / 2))
							}
							return new De(n / a, r / a)
						}
						for (var F = [], H = 0, k = P.length, j = k - 1, V = H + 1; H < k; H++, j++, V++) j === k && (
							j = 0), V === k && (V = 0), F[H] = G(P[H], P[j], P[V]);
						var W, q, X = [],
							Y = F.concat();
						for (_ = 0, w = T.length; _ < w; _++) {
							for (b = T[_], W = [], H = 0, k = b.length, j = k - 1, V = H + 1; H < k; H++, j++, V++)
								j === k && (j = 0), V === k && (V = 0), W[H] = G(b[H], b[j], b[V]);
							X.push(W), Y = Y.concat(W)
						}
						for (R = 0; R < p; R++) {
							for (I = R / p, D = l * Math.cos(I * Math.PI / 2), O = u * Math.sin(I * Math.PI / 2), H =
								0, k = P.length; H < k; H++) Z((B = C(P[H], F[H], O)).x, B.y, -D);
							for (_ = 0, w = T.length; _ < w; _++)
								for (b = T[_], W = X[_], H = 0, k = b.length; H < k; H++) Z((B = C(b[H], W[H], O)).x,
									B.y, -D)
						}
						for (O = u, H = 0; H < N; H++) B = h ? C(E[H], Y[H], O) : E[H], M ? (y.copy(g.normals[0])
							.multiplyScalar(B.x), v.copy(g.binormals[0]).multiplyScalar(B.y), x.copy(m[0]).add(y)
							.add(v), Z(x.x, x.y, x.z)) : Z(B.x, B.y, 0);
						for (q = 1; q <= s; q++)
							for (H = 0; H < N; H++) B = h ? C(E[H], Y[H], O) : E[H], M ? (y.copy(g.normals[q])
								.multiplyScalar(B.x), v.copy(g.binormals[q]).multiplyScalar(B.y), x.copy(m[q])
								.add(y).add(v), Z(x.x, x.y, x.z)) : Z(B.x, B.y, c / s * q);
						for (R = p - 1; R >= 0; R--) {
							for (I = R / p, D = l * Math.cos(I * Math.PI / 2), O = u * Math.sin(I * Math.PI / 2), H =
								0, k = P.length; H < k; H++) Z((B = C(P[H], F[H], O)).x, B.y, c + D);
							for (_ = 0, w = T.length; _ < w; _++)
								for (b = T[_], W = X[_], H = 0, k = b.length; H < k; H++) B = C(b[H], W[H], O), M ? Z(
									B.x, B.y + m[s - 1].y, m[s - 1].x + D) : Z(B.x, B.y, c + D)
						}

						function J(t, e) {
							var i, n;
							for (H = t.length; --H >= 0;) {
								i = H, (n = H - 1) < 0 && (n = t.length - 1);
								var r = 0,
									a = s + 2 * p;
								for (r = 0; r < a; r++) {
									var o = N * r,
										c = N * (r + 1),
										h = e + i + o,
										l = e + n + o,
										u = e + n + c,
										d = e + i + c;
									K(h, l, u, d)
								}
							}
						}

						function Z(t, e, i) {
							a.push(t), a.push(e), a.push(i)
						}

						function Q(t, e, r) {
							$(t), $(e), $(r);
							var a = n.length / 3,
								o = f.generateTopUV(i, n, a - 3, a - 2, a - 1);
							tt(o[0]), tt(o[1]), tt(o[2])
						}

						function K(t, e, r, a) {
							$(t), $(e), $(a), $(e), $(r), $(a);
							var o = n.length / 3,
								s = f.generateSideWallUV(i, n, o - 6, o - 3, o - 2, o - 1);
							tt(s[0]), tt(s[1]), tt(s[3]), tt(s[1]), tt(s[2]), tt(s[3])
						}

						function $(t) {
							n.push(a[3 * t + 0]), n.push(a[3 * t + 1]), n.push(a[3 * t + 2])
						}

						function tt(t) {
							r.push(t.x), r.push(t.y)
						}! function () {
							var t = n.length / 3;
							if (h) {
								var e = 0,
									r = N * e;
								for (H = 0; H < U; H++) Q((z = L[H])[2] + r, z[1] + r, z[0] + r);
								for (r = N * (e = s + 2 * p), H = 0; H < U; H++) Q((z = L[H])[0] + r, z[1] + r, z[2] +
									r)
							} else {
								for (H = 0; H < U; H++) Q((z = L[H])[2], z[1], z[0]);
								for (H = 0; H < U; H++) Q((z = L[H])[0] + N * s, z[1] + N * s, z[2] + N * s)
							}
							i.addGroup(t, n.length / 3 - t, 0)
						}(),
						function () {
							var t = n.length / 3,
								e = 0;
							for (J(P, e), e += P.length, _ = 0, w = T.length; _ < w; _++) J(b = T[_], e), e += b
								.length;
							i.addGroup(t, n.length / 3 - t, 1)
						}()
					}
					this.addAttribute("position", new zi(n, 3)), this.addAttribute("uv", new zi(r, 2)), this
						.computeVertexNormals()
				}
				$a.prototype = Object.create(Ai.prototype), $a.prototype.constructor = $a, $a.prototype.toJSON =
					function () {
						var t = Ai.prototype.toJSON.call(this),
							e = this.parameters.shapes,
							i = this.parameters.options;
						return io(e, i, t)
					}, to.prototype = Object.create(Hi.prototype), to.prototype.constructor = to, to.prototype
					.toJSON = function () {
						var t = Hi.prototype.toJSON.call(this),
							e = this.parameters.shapes,
							i = this.parameters.options;
						return io(e, i, t)
					};
				var eo = {
					generateTopUV: function (t, e, i, n, r) {
						var a = e[3 * i],
							o = e[3 * i + 1],
							s = e[3 * n],
							c = e[3 * n + 1],
							h = e[3 * r],
							l = e[3 * r + 1];
						return [new De(a, o), new De(s, c), new De(h, l)]
					},
					generateSideWallUV: function (t, e, i, n, r, a) {
						var o = e[3 * i],
							s = e[3 * i + 1],
							c = e[3 * i + 2],
							h = e[3 * n],
							l = e[3 * n + 1],
							u = e[3 * n + 2],
							p = e[3 * r],
							d = e[3 * r + 1],
							f = e[3 * r + 2],
							m = e[3 * a],
							g = e[3 * a + 1],
							v = e[3 * a + 2];
						return Math.abs(s - l) < .01 ? [new De(o, 1 - c), new De(h, 1 - u), new De(p, 1 - f),
							new De(m, 1 - v)
						] : [new De(s, 1 - c), new De(l, 1 - u), new De(d, 1 - f), new De(g, 1 - v)]
					}
				};

				function io(t, e, i) {
					if (i.shapes = [], Array.isArray(t))
						for (var n = 0, r = t.length; n < r; n++) {
							var a = t[n];
							i.shapes.push(a.uuid)
						} else i.shapes.push(t.uuid);
					return void 0 !== e.extrudePath && (i.options.extrudePath = e.extrudePath.toJSON()), i
				}

				function no(t, e) {
					Ai.call(this), this.type = "TextGeometry", this.parameters = {
						text: t,
						parameters: e
					}, this.fromBufferGeometry(new ro(t, e)), this.mergeVertices()
				}

				function ro(t, e) {
					var i = (e = e || {}).font;
					if (!i || !i.isFont) return console.error(
						"THREE.TextGeometry: font parameter is not an instance of THREE.Font."), new Ai;
					var n = i.generateShapes(t, e.size);
					e.depth = void 0 !== e.height ? e.height : 50, void 0 === e.bevelThickness && (e.bevelThickness =
						10), void 0 === e.bevelSize && (e.bevelSize = 8), void 0 === e.bevelEnabled && (e
						.bevelEnabled = !1), to.call(this, n, e), this.type = "TextBufferGeometry"
				}

				function ao(t, e, i, n, r, a, o) {
					Ai.call(this), this.type = "SphereGeometry", this.parameters = {
						radius: t,
						widthSegments: e,
						heightSegments: i,
						phiStart: n,
						phiLength: r,
						thetaStart: a,
						thetaLength: o
					}, this.fromBufferGeometry(new oo(t, e, i, n, r, a, o)), this.mergeVertices()
				}

				function oo(t, e, i, n, r, a, o) {
					Hi.call(this), this.type = "SphereBufferGeometry", this.parameters = {
							radius: t,
							widthSegments: e,
							heightSegments: i,
							phiStart: n,
							phiLength: r,
							thetaStart: a,
							thetaLength: o
						}, t = t || 1, e = Math.max(3, Math.floor(e) || 8), i = Math.max(2, Math.floor(i) || 6), n =
						void 0 !== n ? n : 0, r = void 0 !== r ? r : 2 * Math.PI, a = void 0 !== a ? a : 0, o =
						void 0 !== o ? o : Math.PI;
					var s, c, h = a + o,
						l = 0,
						u = [],
						p = new Ne,
						d = new Ne,
						f = [],
						m = [],
						g = [],
						v = [];
					for (c = 0; c <= i; c++) {
						var y = [],
							x = c / i;
						for (s = 0; s <= e; s++) {
							var b = s / e;
							p.x = -t * Math.cos(n + b * r) * Math.sin(a + x * o), p.y = t * Math.cos(a + x * o), p.z =
								t * Math.sin(n + b * r) * Math.sin(a + x * o), m.push(p.x, p.y, p.z), d.set(p.x, p.y,
									p.z).normalize(), g.push(d.x, d.y, d.z), v.push(b, 1 - x), y.push(l++)
						}
						u.push(y)
					}
					for (c = 0; c < i; c++)
						for (s = 0; s < e; s++) {
							var _ = u[c][s + 1],
								w = u[c][s],
								M = u[c + 1][s],
								S = u[c + 1][s + 1];
							(0 !== c || a > 0) && f.push(_, w, S), (c !== i - 1 || h < Math.PI) && f.push(w, M, S)
						}
					this.setIndex(f), this.addAttribute("position", new zi(m, 3)), this.addAttribute("normal", new zi(
						g, 3)), this.addAttribute("uv", new zi(v, 2))
				}

				function so(t, e, i, n, r, a) {
					Ai.call(this), this.type = "RingGeometry", this.parameters = {
						innerRadius: t,
						outerRadius: e,
						thetaSegments: i,
						phiSegments: n,
						thetaStart: r,
						thetaLength: a
					}, this.fromBufferGeometry(new co(t, e, i, n, r, a)), this.mergeVertices()
				}

				function co(t, e, i, n, r, a) {
					Hi.call(this), this.type = "RingBufferGeometry", this.parameters = {
							innerRadius: t,
							outerRadius: e,
							thetaSegments: i,
							phiSegments: n,
							thetaStart: r,
							thetaLength: a
						}, t = t || .5, e = e || 1, r = void 0 !== r ? r : 0, a = void 0 !== a ? a : 2 * Math.PI, i =
						void 0 !== i ? Math.max(3, i) : 8, n = void 0 !== n ? Math.max(1, n) : 1;
					var o, s, c, h = [],
						l = [],
						u = [],
						p = [],
						d = t,
						f = (e - t) / n,
						m = new Ne,
						g = new De;
					for (s = 0; s <= n; s++) {
						for (c = 0; c <= i; c++) o = r + c / i * a, m.x = d * Math.cos(o), m.y = d * Math.sin(o), l
							.push(m.x, m.y, m.z), u.push(0, 0, 1), g.x = (m.x / e + 1) / 2, g.y = (m.y / e + 1) / 2, p
							.push(g.x, g.y);
						d += f
					}
					for (s = 0; s < n; s++) {
						var v = s * (i + 1);
						for (c = 0; c < i; c++) {
							var y = o = c + v,
								x = o + i + 1,
								b = o + i + 2,
								_ = o + 1;
							h.push(y, x, _), h.push(x, b, _)
						}
					}
					this.setIndex(h), this.addAttribute("position", new zi(l, 3)), this.addAttribute("normal", new zi(
						u, 3)), this.addAttribute("uv", new zi(p, 2))
				}

				function ho(t, e, i, n) {
					Ai.call(this), this.type = "LatheGeometry", this.parameters = {
						points: t,
						segments: e,
						phiStart: i,
						phiLength: n
					}, this.fromBufferGeometry(new lo(t, e, i, n)), this.mergeVertices()
				}

				function lo(t, e, i, n) {
					Hi.call(this), this.type = "LatheBufferGeometry", this.parameters = {
						points: t,
						segments: e,
						phiStart: i,
						phiLength: n
					}, e = Math.floor(e) || 12, i = i || 0, n = n || 2 * Math.PI, n = Ie.clamp(n, 0, 2 * Math.PI);
					var r, a, o, s = [],
						c = [],
						h = [],
						l = 1 / e,
						u = new Ne,
						p = new De;
					for (a = 0; a <= e; a++) {
						var d = i + a * l * n,
							f = Math.sin(d),
							m = Math.cos(d);
						for (o = 0; o <= t.length - 1; o++) u.x = t[o].x * f, u.y = t[o].y, u.z = t[o].x * m, c.push(u
							.x, u.y, u.z), p.x = a / e, p.y = o / (t.length - 1), h.push(p.x, p.y)
					}
					for (a = 0; a < e; a++)
						for (o = 0; o < t.length - 1; o++) {
							var g = r = o + a * t.length,
								v = r + t.length,
								y = r + t.length + 1,
								x = r + 1;
							s.push(g, v, x), s.push(v, y, x)
						}
					if (this.setIndex(s), this.addAttribute("position", new zi(c, 3)), this.addAttribute("uv", new zi(
							h, 2)), this.computeVertexNormals(), n === 2 * Math.PI) {
						var b = this.attributes.normal.array,
							_ = new Ne,
							w = new Ne,
							M = new Ne;
						for (r = e * t.length * 3, a = 0, o = 0; a < t.length; a++, o += 3) _.x = b[o + 0], _.y = b[
								o + 1], _.z = b[o + 2], w.x = b[r + o + 0], w.y = b[r + o + 1], w.z = b[r + o + 2], M
							.addVectors(_, w).normalize(), b[o + 0] = b[r + o + 0] = M.x, b[o + 1] = b[r + o + 1] = M
							.y, b[o + 2] = b[r + o + 2] = M.z
					}
				}

				function uo(t, e) {
					Ai.call(this), this.type = "ShapeGeometry", "object" == typeof e && (console.warn(
							"THREE.ShapeGeometry: Options parameter has been removed."), e = e.curveSegments), this
						.parameters = {
							shapes: t,
							curveSegments: e
						}, this.fromBufferGeometry(new po(t, e)), this.mergeVertices()
				}

				function po(t, e) {
					Hi.call(this), this.type = "ShapeBufferGeometry", this.parameters = {
						shapes: t,
						curveSegments: e
					}, e = e || 12;
					var i = [],
						n = [],
						r = [],
						a = [],
						o = 0,
						s = 0;
					if (!1 === Array.isArray(t)) h(t);
					else
						for (var c = 0; c < t.length; c++) h(t[c]), this.addGroup(o, s, c), o += s, s = 0;

					function h(t) {
						var o, c, h, l = n.length / 3,
							u = t.extractPoints(e),
							p = u.shape,
							d = u.holes;
						for (!1 === Za.isClockWise(p) && (p = p.reverse()), o = 0, c = d.length; o < c; o++) h = d[o],
							!0 === Za.isClockWise(h) && (d[o] = h.reverse());
						var f = Za.triangulateShape(p, d);
						for (o = 0, c = d.length; o < c; o++) h = d[o], p = p.concat(h);
						for (o = 0, c = p.length; o < c; o++) {
							var m = p[o];
							n.push(m.x, m.y, 0), r.push(0, 0, 1), a.push(m.x, m.y)
						}
						for (o = 0, c = f.length; o < c; o++) {
							var g = f[o],
								v = g[0] + l,
								y = g[1] + l,
								x = g[2] + l;
							i.push(v, y, x), s += 3
						}
					}
					this.setIndex(i), this.addAttribute("position", new zi(n, 3)), this.addAttribute("normal", new zi(
						r, 3)), this.addAttribute("uv", new zi(a, 2))
				}

				function fo(t, e) {
					if (e.shapes = [], Array.isArray(t))
						for (var i = 0, n = t.length; i < n; i++) {
							var r = t[i];
							e.shapes.push(r.uuid)
						} else e.shapes.push(t.uuid);
					return e
				}

				function mo(t, e) {
					Hi.call(this), this.type = "EdgesGeometry", this.parameters = {
						thresholdAngle: e
					}, e = void 0 !== e ? e : 1;
					var i, n, r, a, o = [],
						s = Math.cos(Ie.DEG2RAD * e),
						c = [0, 0],
						h = {},
						l = ["a", "b", "c"];
					t.isBufferGeometry ? (a = new Ai).fromBufferGeometry(t) : a = t.clone(), a.mergeVertices(), a
						.computeFaceNormals();
					for (var u = a.vertices, p = a.faces, d = 0, f = p.length; d < f; d++)
						for (var m = p[d], g = 0; g < 3; g++) i = m[l[g]], n = m[l[(g + 1) % 3]], c[0] = Math.min(i,
							n), c[1] = Math.max(i, n), r = c[0] + "," + c[1], void 0 === h[r] ? h[r] = {
							index1: c[0],
							index2: c[1],
							face1: d,
							face2: void 0
						} : h[r].face2 = d;
					for (r in h) {
						var v = h[r];
						if (void 0 === v.face2 || p[v.face1].normal.dot(p[v.face2].normal) <= s) {
							var y = u[v.index1];
							o.push(y.x, y.y, y.z), y = u[v.index2], o.push(y.x, y.y, y.z)
						}
					}
					this.addAttribute("position", new zi(o, 3))
				}

				function go(t, e, i, n, r, a, o, s) {
					Ai.call(this), this.type = "CylinderGeometry", this.parameters = {
						radiusTop: t,
						radiusBottom: e,
						height: i,
						radialSegments: n,
						heightSegments: r,
						openEnded: a,
						thetaStart: o,
						thetaLength: s
					}, this.fromBufferGeometry(new vo(t, e, i, n, r, a, o, s)), this.mergeVertices()
				}

				function vo(t, e, i, n, r, a, o, s) {
					Hi.call(this), this.type = "CylinderBufferGeometry", this.parameters = {
						radiusTop: t,
						radiusBottom: e,
						height: i,
						radialSegments: n,
						heightSegments: r,
						openEnded: a,
						thetaStart: o,
						thetaLength: s
					};
					var c = this;
					t = void 0 !== t ? t : 1, e = void 0 !== e ? e : 1, i = i || 1, n = Math.floor(n) || 8, r = Math
						.floor(r) || 1, a = void 0 !== a && a, o = void 0 !== o ? o : 0, s = void 0 !== s ? s : 2 *
						Math.PI;
					var h = [],
						l = [],
						u = [],
						p = [],
						d = 0,
						f = [],
						m = i / 2,
						g = 0;

					function v(i) {
						var r, a, f, v = new De,
							y = new Ne,
							x = 0,
							b = !0 === i ? t : e,
							_ = !0 === i ? 1 : -1;
						for (a = d, r = 1; r <= n; r++) l.push(0, m * _, 0), u.push(0, _, 0), p.push(.5, .5), d++;
						for (f = d, r = 0; r <= n; r++) {
							var w = r / n,
								M = w * s + o,
								S = Math.cos(M),
								E = Math.sin(M);
							y.x = b * E, y.y = m * _, y.z = b * S, l.push(y.x, y.y, y.z), u.push(0, _, 0), v.x = .5 *
								S + .5, v.y = .5 * E * _ + .5, p.push(v.x, v.y), d++
						}
						for (r = 0; r < n; r++) {
							var T = a + r,
								A = f + r;
							!0 === i ? h.push(A, A + 1, T) : h.push(A + 1, A, T), x += 3
						}
						c.addGroup(g, x, !0 === i ? 1 : 2), g += x
					}! function () {
						var a, v, y = new Ne,
							x = new Ne,
							b = 0,
							_ = (e - t) / i;
						for (v = 0; v <= r; v++) {
							var w = [],
								M = v / r,
								S = M * (e - t) + t;
							for (a = 0; a <= n; a++) {
								var E = a / n,
									T = E * s + o,
									A = Math.sin(T),
									L = Math.cos(T);
								x.x = S * A, x.y = -M * i + m, x.z = S * L, l.push(x.x, x.y, x.z), y.set(A, _, L)
									.normalize(), u.push(y.x, y.y, y.z), p.push(E, 1 - M), w.push(d++)
							}
							f.push(w)
						}
						for (a = 0; a < n; a++)
							for (v = 0; v < r; v++) {
								var P = f[v][a],
									C = f[v + 1][a],
									R = f[v + 1][a + 1],
									O = f[v][a + 1];
								h.push(P, C, O), h.push(C, R, O), b += 6
							}
						c.addGroup(g, b, 0), g += b
					}(), !1 === a && (t > 0 && v(!0), e > 0 && v(!1)), this.setIndex(h), this.addAttribute("position",
						new zi(l, 3)), this.addAttribute("normal", new zi(u, 3)), this.addAttribute("uv", new zi(
						p, 2))
				}

				function yo(t, e, i, n, r, a, o) {
					go.call(this, 0, t, e, i, n, r, a, o), this.type = "ConeGeometry", this.parameters = {
						radius: t,
						height: e,
						radialSegments: i,
						heightSegments: n,
						openEnded: r,
						thetaStart: a,
						thetaLength: o
					}
				}

				function xo(t, e, i, n, r, a, o) {
					vo.call(this, 0, t, e, i, n, r, a, o), this.type = "ConeBufferGeometry", this.parameters = {
						radius: t,
						height: e,
						radialSegments: i,
						heightSegments: n,
						openEnded: r,
						thetaStart: a,
						thetaLength: o
					}
				}

				function bo(t, e, i, n) {
					Ai.call(this), this.type = "CircleGeometry", this.parameters = {
						radius: t,
						segments: e,
						thetaStart: i,
						thetaLength: n
					}, this.fromBufferGeometry(new _o(t, e, i, n)), this.mergeVertices()
				}

				function _o(t, e, i, n) {
					Hi.call(this), this.type = "CircleBufferGeometry", this.parameters = {
							radius: t,
							segments: e,
							thetaStart: i,
							thetaLength: n
						}, t = t || 1, e = void 0 !== e ? Math.max(3, e) : 8, i = void 0 !== i ? i : 0, n = void 0 !==
						n ? n : 2 * Math.PI;
					var r, a, o = [],
						s = [],
						c = [],
						h = [],
						l = new Ne,
						u = new De;
					for (s.push(0, 0, 0), c.push(0, 0, 1), h.push(.5, .5), a = 0, r = 3; a <= e; a++, r += 3) {
						var p = i + a / e * n;
						l.x = t * Math.cos(p), l.y = t * Math.sin(p), s.push(l.x, l.y, l.z), c.push(0, 0, 1), u.x = (
							s[r] / t + 1) / 2, u.y = (s[r + 1] / t + 1) / 2, h.push(u.x, u.y)
					}
					for (r = 1; r <= e; r++) o.push(r, r + 1, 0);
					this.setIndex(o), this.addAttribute("position", new zi(s, 3)), this.addAttribute("normal", new zi(
						c, 3)), this.addAttribute("uv", new zi(h, 2))
				}
				no.prototype = Object.create(Ai.prototype), no.prototype.constructor = no, ro.prototype = Object
					.create(to.prototype), ro.prototype.constructor = ro, ao.prototype = Object.create(Ai.prototype),
					ao.prototype.constructor = ao, oo.prototype = Object.create(Hi.prototype), oo.prototype
					.constructor = oo, so.prototype = Object.create(Ai.prototype), so.prototype.constructor = so, co
					.prototype = Object.create(Hi.prototype), co.prototype.constructor = co, ho.prototype = Object
					.create(Ai.prototype), ho.prototype.constructor = ho, lo.prototype = Object.create(Hi.prototype),
					lo.prototype.constructor = lo, uo.prototype = Object.create(Ai.prototype), uo.prototype
					.constructor = uo, uo.prototype.toJSON = function () {
						var t = Ai.prototype.toJSON.call(this),
							e = this.parameters.shapes;
						return fo(e, t)
					}, po.prototype = Object.create(Hi.prototype), po.prototype.constructor = po, po.prototype
					.toJSON = function () {
						var t = Hi.prototype.toJSON.call(this),
							e = this.parameters.shapes;
						return fo(e, t)
					}, mo.prototype = Object.create(Hi.prototype), mo.prototype.constructor = mo, go.prototype =
					Object.create(Ai.prototype), go.prototype.constructor = go, vo.prototype = Object.create(Hi
						.prototype), vo.prototype.constructor = vo, yo.prototype = Object.create(go.prototype), yo
					.prototype.constructor = yo, xo.prototype = Object.create(vo.prototype), xo.prototype
					.constructor = xo, bo.prototype = Object.create(Ai.prototype), bo.prototype.constructor = bo, _o
					.prototype = Object.create(Hi.prototype), _o.prototype.constructor = _o;
				var wo = Object.freeze({
					WireframeGeometry: ha,
					ParametricGeometry: la,
					ParametricBufferGeometry: ua,
					TetrahedronGeometry: fa,
					TetrahedronBufferGeometry: ma,
					OctahedronGeometry: ga,
					OctahedronBufferGeometry: va,
					IcosahedronGeometry: ya,
					IcosahedronBufferGeometry: xa,
					DodecahedronGeometry: ba,
					DodecahedronBufferGeometry: _a,
					PolyhedronGeometry: pa,
					PolyhedronBufferGeometry: da,
					TubeGeometry: wa,
					TubeBufferGeometry: Ma,
					TorusKnotGeometry: Sa,
					TorusKnotBufferGeometry: Ea,
					TorusGeometry: Ta,
					TorusBufferGeometry: Aa,
					TextGeometry: no,
					TextBufferGeometry: ro,
					SphereGeometry: ao,
					SphereBufferGeometry: oo,
					RingGeometry: so,
					RingBufferGeometry: co,
					PlaneGeometry: Vi,
					PlaneBufferGeometry: Wi,
					LatheGeometry: ho,
					LatheBufferGeometry: lo,
					ShapeGeometry: uo,
					ShapeBufferGeometry: po,
					ExtrudeGeometry: $a,
					ExtrudeBufferGeometry: to,
					EdgesGeometry: mo,
					ConeGeometry: yo,
					ConeBufferGeometry: xo,
					CylinderGeometry: go,
					CylinderBufferGeometry: vo,
					CircleGeometry: bo,
					CircleBufferGeometry: _o,
					BoxGeometry: ki,
					BoxBufferGeometry: ji
				});

				function Mo(t) {
					on.call(this), this.type = "ShadowMaterial", this.color = new hi(0), this.transparent = !0, this
						.setValues(t)
				}

				function So(t) {
					sn.call(this, t), this.type = "RawShaderMaterial"
				}

				function Eo(t) {
					on.call(this), this.defines = {
							STANDARD: ""
						}, this.type = "MeshStandardMaterial", this.color = new hi(16777215), this.roughness = .5,
						this.metalness = .5, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this
						.aoMap = null, this.aoMapIntensity = 1, this.emissive = new hi(0), this.emissiveIntensity = 1,
						this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this
						.normalMapType = Re, this.normalScale = new De(1, 1), this.displacementMap = null, this
						.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this
						.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapIntensity = 1, this
						.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this
						.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this
						.morphTargets = !1, this.morphNormals = !1, this.setValues(t)
				}

				function To(t) {
					Eo.call(this), this.defines = {
							PHYSICAL: ""
						}, this.type = "MeshPhysicalMaterial", this.reflectivity = .5, this.clearCoat = 0, this
						.clearCoatRoughness = 0, this.setValues(t)
				}

				function Ao(t) {
					on.call(this), this.type = "MeshPhongMaterial", this.color = new hi(16777215), this.specular =
						new hi(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this
						.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new hi(0),
						this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1,
						this.normalMap = null, this.normalMapType = Re, this.normalScale = new De(1, 1), this
						.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this
						.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = it, this
						.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth =
						1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this
						.morphTargets = !1, this.morphNormals = !1, this.setValues(t)
				}

				function Lo(t) {
					Ao.call(this), this.defines = {
						TOON: ""
					}, this.type = "MeshToonMaterial", this.gradientMap = null, this.setValues(t)
				}

				function Po(t) {
					on.call(this), this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this
						.normalMap = null, this.normalMapType = Re, this.normalScale = new De(1, 1), this
						.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this
						.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this
						.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(t)
				}

				function Co(t) {
					on.call(this), this.type = "MeshLambertMaterial", this.color = new hi(16777215), this.map = null,
						this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1,
						this.emissive = new hi(0), this.emissiveIntensity = 1, this.emissiveMap = null, this
						.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = it, this
						.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth =
						1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this
						.morphTargets = !1, this.morphNormals = !1, this.setValues(t)
				}

				function Ro(t) {
					on.call(this), this.defines = {
							MATCAP: ""
						}, this.type = "MeshMatcapMaterial", this.color = new hi(16777215), this.matcap = null, this
						.map = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this
						.normalMapType = Re, this.normalScale = new De(1, 1), this.displacementMap = null, this
						.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.skinning = !1,
						this.morphTargets = !1, this.morphNormals = !1, this.lights = !1, this.setValues(t)
				}

				function Oo(t) {
					$r.call(this), this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize =
						1, this.setValues(t)
				}
				Mo.prototype = Object.create(on.prototype), Mo.prototype.constructor = Mo, Mo.prototype
					.isShadowMaterial = !0, Mo.prototype.copy = function (t) {
						return on.prototype.copy.call(this, t), this.color.copy(t.color), this
					}, So.prototype = Object.create(sn.prototype), So.prototype.constructor = So, So.prototype
					.isRawShaderMaterial = !0, Eo.prototype = Object.create(on.prototype), Eo.prototype.constructor =
					Eo, Eo.prototype.isMeshStandardMaterial = !0, Eo.prototype.copy = function (t) {
						return on.prototype.copy.call(this, t), this.defines = {
								STANDARD: ""
							}, this.color.copy(t.color), this.roughness = t.roughness, this.metalness = t.metalness,
							this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t
							.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this
							.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t
							.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this
							.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t
								.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t
							.displacementScale, this.displacementBias = t.displacementBias, this.roughnessMap = t
							.roughnessMap, this.metalnessMap = t.metalnessMap, this.alphaMap = t.alphaMap, this
							.envMap = t.envMap, this.envMapIntensity = t.envMapIntensity, this.refractionRatio = t
							.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t
							.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin =
							t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this
							.morphNormals = t.morphNormals, this
					}, To.prototype = Object.create(Eo.prototype), To.prototype.constructor = To, To.prototype
					.isMeshPhysicalMaterial = !0, To.prototype.copy = function (t) {
						return Eo.prototype.copy.call(this, t), this.defines = {
								PHYSICAL: ""
							}, this.reflectivity = t.reflectivity, this.clearCoat = t.clearCoat, this
							.clearCoatRoughness = t.clearCoatRoughness, this
					}, Ao.prototype = Object.create(on.prototype), Ao.prototype.constructor = Ao, Ao.prototype
					.isMeshPhongMaterial = !0, Ao.prototype.copy = function (t) {
						return on.prototype.copy.call(this, t), this.color.copy(t.color), this.specular.copy(t
								.specular), this.shininess = t.shininess, this.map = t.map, this.lightMap = t
							.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this
							.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t
							.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this
							.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t
							.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t
							.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t
							.displacementBias, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this
							.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this
							.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this
							.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap,
							this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this
							.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this
					}, Lo.prototype = Object.create(Ao.prototype), Lo.prototype.constructor = Lo, Lo.prototype
					.isMeshToonMaterial = !0, Lo.prototype.copy = function (t) {
						return Ao.prototype.copy.call(this, t), this.gradientMap = t.gradientMap, this
					}, Po.prototype = Object.create(on.prototype), Po.prototype.constructor = Po, Po.prototype
					.isMeshNormalMaterial = !0, Po.prototype.copy = function (t) {
						return on.prototype.copy.call(this, t), this.bumpMap = t.bumpMap, this.bumpScale = t
							.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this
							.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this
							.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this
							.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.skinning =
							t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this
					}, Co.prototype = Object.create(on.prototype), Co.prototype.constructor = Co, Co.prototype
					.isMeshLambertMaterial = !0, Co.prototype.copy = function (t) {
						return on.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this
							.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t
							.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this
							.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this
							.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this
							.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t
							.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t
							.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin =
							t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this
							.morphNormals = t.morphNormals, this
					}, Ro.prototype = Object.create(on.prototype), Ro.prototype.constructor = Ro, Ro.prototype
					.isMeshMatcapMaterial = !0, Ro.prototype.copy = function (t) {
						return on.prototype.copy.call(this, t), this.defines = {
								MATCAP: ""
							}, this.color.copy(t.color), this.matcap = t.matcap, this.map = t.map, this.bumpMap = t
							.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType =
							t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t
							.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t
							.displacementBias, this.alphaMap = t.alphaMap, this.skinning = t.skinning, this
							.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this
					}, Oo.prototype = Object.create($r.prototype), Oo.prototype.constructor = Oo, Oo.prototype
					.isLineDashedMaterial = !0, Oo.prototype.copy = function (t) {
						return $r.prototype.copy.call(this, t), this.scale = t.scale, this.dashSize = t.dashSize, this
							.gapSize = t.gapSize, this
					};
				var Io = Object.freeze({
						ShadowMaterial: Mo,
						SpriteMaterial: Xr,
						RawShaderMaterial: So,
						ShaderMaterial: sn,
						PointsMaterial: na,
						MeshPhysicalMaterial: To,
						MeshStandardMaterial: Eo,
						MeshPhongMaterial: Ao,
						MeshToonMaterial: Lo,
						MeshNormalMaterial: Po,
						MeshLambertMaterial: Co,
						MeshDepthMaterial: wr,
						MeshDistanceMaterial: Mr,
						MeshBasicMaterial: ln,
						MeshMatcapMaterial: Ro,
						LineDashedMaterial: Oo,
						LineBasicMaterial: $r,
						Material: on
					}),
					Do = {
						arraySlice: function (t, e, i) {
							return Do.isTypedArray(t) ? new t.constructor(t.subarray(e, void 0 !== i ? i : t
								.length)) : t.slice(e, i)
						},
						convertArray: function (t, e, i) {
							return !t || !i && t.constructor === e ? t : "number" == typeof e.BYTES_PER_ELEMENT ?
								new e(t) : Array.prototype.slice.call(t)
						},
						isTypedArray: function (t) {
							return ArrayBuffer.isView(t) && !(t instanceof DataView)
						},
						getKeyframeOrder: function (t) {
							for (var e = t.length, i = new Array(e), n = 0; n !== e; ++n) i[n] = n;
							return i.sort(function (e, i) {
								return t[e] - t[i]
							}), i
						},
						sortedArray: function (t, e, i) {
							for (var n = t.length, r = new t.constructor(n), a = 0, o = 0; o !== n; ++a)
								for (var s = i[a] * e, c = 0; c !== e; ++c) r[o++] = t[s + c];
							return r
						},
						flattenJSON: function (t, e, i, n) {
							for (var r = 1, a = t[0]; void 0 !== a && void 0 === a[n];) a = t[r++];
							if (void 0 !== a) {
								var o = a[n];
								if (void 0 !== o)
									if (Array.isArray(o))
										do {
											void 0 !== (o = a[n]) && (e.push(a.time), i.push.apply(i, o)), a = t[
												r++]
										} while (void 0 !== a);
									else if (void 0 !== o.toArray)
									do {
										void 0 !== (o = a[n]) && (e.push(a.time), o.toArray(i, i.length)), a = t[
											r++]
									} while (void 0 !== a);
								else
									do {
										void 0 !== (o = a[n]) && (e.push(a.time), i.push(o)), a = t[r++]
									} while (void 0 !== a)
							}
						}
					};

				function Bo(t, e, i, n) {
					this.parameterPositions = t, this._cachedIndex = 0, this.resultBuffer = void 0 !== n ? n : new e
						.constructor(i), this.sampleValues = e, this.valueSize = i
				}

				function zo(t, e, i, n) {
					Bo.call(this, t, e, i, n), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0,
						this._offsetNext = -0
				}

				function No(t, e, i, n) {
					Bo.call(this, t, e, i, n)
				}

				function Uo(t, e, i, n) {
					Bo.call(this, t, e, i, n)
				}

				function Go(t, e, i, n) {
					if (void 0 === t) throw new Error("THREE.KeyframeTrack: track name is undefined");
					if (void 0 === e || 0 === e.length) throw new Error(
						"THREE.KeyframeTrack: no keyframes in track named " + t);
					this.name = t, this.times = Do.convertArray(e, this.TimeBufferType), this.values = Do
						.convertArray(i, this.ValueBufferType), this.setInterpolation(n || this.DefaultInterpolation)
				}

				function Fo(t, e, i) {
					Go.call(this, t, e, i)
				}

				function Ho(t, e, i, n) {
					Go.call(this, t, e, i, n)
				}

				function ko(t, e, i, n) {
					Go.call(this, t, e, i, n)
				}

				function jo(t, e, i, n) {
					Bo.call(this, t, e, i, n)
				}

				function Vo(t, e, i, n) {
					Go.call(this, t, e, i, n)
				}

				function Wo(t, e, i, n) {
					Go.call(this, t, e, i, n)
				}

				function qo(t, e, i, n) {
					Go.call(this, t, e, i, n)
				}

				function Xo(t, e, i) {
					this.name = t, this.tracks = i, this.duration = void 0 !== e ? e : -1, this.uuid = Ie
						.generateUUID(), this.duration < 0 && this.resetDuration()
				}

				function Yo(t) {
					if (void 0 === t.type) throw new Error(
					"THREE.KeyframeTrack: track type undefined, can not parse");
					var e = function (t) {
						switch (t.toLowerCase()) {
							case "scalar":
							case "double":
							case "float":
							case "number":
							case "integer":
								return ko;
							case "vector":
							case "vector2":
							case "vector3":
							case "vector4":
								return qo;
							case "color":
								return Ho;
							case "quaternion":
								return Vo;
							case "bool":
							case "boolean":
								return Fo;
							case "string":
								return Wo
						}
						throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + t)
					}(t.type);
					if (void 0 === t.times) {
						var i = [],
							n = [];
						Do.flattenJSON(t.keys, i, n, "value"), t.times = i, t.values = n
					}
					return void 0 !== e.parse ? e.parse(t) : new e(t.name, t.times, t.values, t.interpolation)
				}
				Object.assign(Bo.prototype, {
						evaluate: function (t) {
							var e = this.parameterPositions,
								i = this._cachedIndex,
								n = e[i],
								r = e[i - 1];
							t: {
								e: {
									var a;i: {
										n: if (!(t < n)) {
											for (var o = i + 2;;) {
												if (void 0 === n) {
													if (t < r) break n;
													return i = e.length, this._cachedIndex = i, this
														.afterEnd_(i - 1, t, r)
												}
												if (i === o) break;
												if (r = n, n = e[++i], t < n) break e
											}
											a = e.length;
											break i
										}if (t >= r) break t;
										var s = e[1];t < s && (i = 2, r = s);
										for (var o = i - 2;;) {
											if (void 0 === r) return this._cachedIndex = 0, this
												.beforeStart_(0, t, n);
											if (i === o) break;
											if (n = r, r = e[--i - 1], t >= r) break e
										}
										a = i,
										i = 0
									}
									for (; i < a;) {
										var c = i + a >>> 1;
										t < e[c] ? a = c : i = c + 1
									}
									if (n = e[i], void 0 === (r = e[i - 1])) return this._cachedIndex = 0,
									this.beforeStart_(0, t, n);
									if (void 0 === n) return i = e.length,
									this._cachedIndex = i,
									this.afterEnd_(i - 1, r, t)
								}
								this._cachedIndex = i,
								this.intervalChanged_(i, r, n)
							}
							return this.interpolate_(i, r, t, n)
						},
						settings: null,
						DefaultSettings_: {},
						getSettings_: function () {
							return this.settings || this.DefaultSettings_
						},
						copySampleValue_: function (t) {
							for (var e = this.resultBuffer, i = this.sampleValues, n = this.valueSize, r = t *
									n, a = 0; a !== n; ++a) e[a] = i[r + a];
							return e
						},
						interpolate_: function () {
							throw new Error("call to abstract method")
						},
						intervalChanged_: function () {}
					}),
					//!\ DECLARE ALIAS AFTER assign prototype !
					Object.assign(Bo.prototype, {
						beforeStart_: Bo.prototype.copySampleValue_,
						afterEnd_: Bo.prototype.copySampleValue_
					}), zo.prototype = Object.assign(Object.create(Bo.prototype), {
						constructor: zo,
						DefaultSettings_: {
							endingStart: ye,
							endingEnd: ye
						},
						intervalChanged_: function (t, e, i) {
							var n = this.parameterPositions,
								r = t - 2,
								a = t + 1,
								o = n[r],
								s = n[a];
							if (void 0 === o) switch (this.getSettings_().endingStart) {
								case 2401:
									r = t, o = 2 * e - i;
									break;
								case 2402:
									r = n.length - 2, o = e + n[r] - n[r + 1];
									break;
								default:
									r = t, o = i
							}
							if (void 0 === s) switch (this.getSettings_().endingEnd) {
								case 2401:
									a = t, s = 2 * i - e;
									break;
								case 2402:
									a = 1, s = i + n[1] - n[0];
									break;
								default:
									a = t - 1, s = e
							}
							var c = .5 * (i - e),
								h = this.valueSize;
							this._weightPrev = c / (e - o), this._weightNext = c / (s - i), this._offsetPrev =
								r * h, this._offsetNext = a * h
						},
						interpolate_: function (t, e, i, n) {
							for (var r = this.resultBuffer, a = this.sampleValues, o = this.valueSize, s = t *
									o, c = s - o, h = this._offsetPrev, l = this._offsetNext, u = this
									._weightPrev, p = this._weightNext, d = (i - e) / (n - e), f = d * d, m =
									f * d, g = -u * m + 2 * u * f - u * d, v = (1 + u) * m + (-1.5 - 2 * u) *
									f + (-.5 + u) * d + 1, y = (-1 - p) * m + (1.5 + p) * f + .5 * d, x = p *
									m - p * f, b = 0; b !== o; ++b) r[b] = g * a[h + b] + v * a[c + b] + y *
								a[s + b] + x * a[l + b];
							return r
						}
					}), No.prototype = Object.assign(Object.create(Bo.prototype), {
						constructor: No,
						interpolate_: function (t, e, i, n) {
							for (var r = this.resultBuffer, a = this.sampleValues, o = this.valueSize, s = t *
									o, c = s - o, h = (i - e) / (n - e), l = 1 - h, u = 0; u !== o; ++u) r[
								u] = a[c + u] * l + a[s + u] * h;
							return r
						}
					}), Uo.prototype = Object.assign(Object.create(Bo.prototype), {
						constructor: Uo,
						interpolate_: function (t) {
							return this.copySampleValue_(t - 1)
						}
					}), Object.assign(Go, {
						toJSON: function (t) {
							var e, i = t.constructor;
							if (void 0 !== i.toJSON) e = i.toJSON(t);
							else {
								e = {
									name: t.name,
									times: Do.convertArray(t.times, Array),
									values: Do.convertArray(t.values, Array)
								};
								var n = t.getInterpolation();
								n !== t.DefaultInterpolation && (e.interpolation = n)
							}
							return e.type = t.ValueTypeName, e
						}
					}), Object.assign(Go.prototype, {
						constructor: Go,
						TimeBufferType: Float32Array,
						ValueBufferType: Float32Array,
						DefaultInterpolation: 2301,
						InterpolantFactoryMethodDiscrete: function (t) {
							return new Uo(this.times, this.values, this.getValueSize(), t)
						},
						InterpolantFactoryMethodLinear: function (t) {
							return new No(this.times, this.values, this.getValueSize(), t)
						},
						InterpolantFactoryMethodSmooth: function (t) {
							return new zo(this.times, this.values, this.getValueSize(), t)
						},
						setInterpolation: function (t) {
							var e;
							switch (t) {
								case 2300:
									e = this.InterpolantFactoryMethodDiscrete;
									break;
								case 2301:
									e = this.InterpolantFactoryMethodLinear;
									break;
								case 2302:
									e = this.InterpolantFactoryMethodSmooth
							}
							if (void 0 === e) {
								var i = "unsupported interpolation for " + this.ValueTypeName +
									" keyframe track named " + this.name;
								if (void 0 === this.createInterpolant) {
									if (t === this.DefaultInterpolation) throw new Error(i);
									this.setInterpolation(this.DefaultInterpolation)
								}
								return console.warn("THREE.KeyframeTrack:", i), this
							}
							return this.createInterpolant = e, this
						},
						getInterpolation: function () {
							switch (this.createInterpolant) {
								case this.InterpolantFactoryMethodDiscrete:
									return 2300;
								case this.InterpolantFactoryMethodLinear:
									return 2301;
								case this.InterpolantFactoryMethodSmooth:
									return 2302
							}
						},
						getValueSize: function () {
							return this.values.length / this.times.length
						},
						shift: function (t) {
							if (0 !== t)
								for (var e = this.times, i = 0, n = e.length; i !== n; ++i) e[i] += t;
							return this
						},
						scale: function (t) {
							if (1 !== t)
								for (var e = this.times, i = 0, n = e.length; i !== n; ++i) e[i] *= t;
							return this
						},
						trim: function (t, e) {
							for (var i = this.times, n = i.length, r = 0, a = n - 1; r !== n && i[r] < t;) ++
							r;
							for (; - 1 !== a && i[a] > e;) --a;
							if (++a, 0 !== r || a !== n) {
								r >= a && (a = Math.max(a, 1), r = a - 1);
								var o = this.getValueSize();
								this.times = Do.arraySlice(i, r, a), this.values = Do.arraySlice(this.values,
									r * o, a * o)
							}
							return this
						},
						validate: function () {
							var t = !0,
								e = this.getValueSize();
							e - Math.floor(e) != 0 && (console.error(
								"THREE.KeyframeTrack: Invalid value size in track.", this), t = !1);
							var i = this.times,
								n = this.values,
								r = i.length;
							0 === r && (console.error("THREE.KeyframeTrack: Track is empty.", this), t = !1);
							for (var a = null, o = 0; o !== r; o++) {
								var s = i[o];
								if ("number" == typeof s && isNaN(s)) {
									console.error("THREE.KeyframeTrack: Time is not a valid number.", this, o,
										s), t = !1;
									break
								}
								if (null !== a && a > s) {
									console.error("THREE.KeyframeTrack: Out of order keys.", this, o, s, a),
										t = !1;
									break
								}
								a = s
							}
							if (void 0 !== n && Do.isTypedArray(n))
								for (var o = 0, c = n.length; o !== c; ++o) {
									var h = n[o];
									if (isNaN(h)) {
										console.error("THREE.KeyframeTrack: Value is not a valid number.",
											this, o, h), t = !1;
										break
									}
								}
							return t
						},
						optimize: function () {
							for (var t = this.times, e = this.values, i = this.getValueSize(), n = 2302 ===
									this.getInterpolation(), r = 1, a = t.length - 1, o = 1; o < a; ++o) {
								var s = !1,
									c = t[o],
									h = t[o + 1];
								if (c !== h && (1 !== o || c !== c[0]))
									if (n) s = !0;
									else
										for (var l = o * i, u = l - i, p = l + i, d = 0; d !== i; ++d) {
											var f = e[l + d];
											if (f !== e[u + d] || f !== e[p + d]) {
												s = !0;
												break
											}
										}
								if (s) {
									if (o !== r) {
										t[r] = t[o];
										for (var m = o * i, g = r * i, d = 0; d !== i; ++d) e[g + d] = e[m +
											d]
									}++r
								}
							}
							if (a > 0) {
								t[r] = t[a];
								for (var m = a * i, g = r * i, d = 0; d !== i; ++d) e[g + d] = e[m + d];
								++r
							}
							return r !== t.length && (this.times = Do.arraySlice(t, 0, r), this.values = Do
								.arraySlice(e, 0, r * i)), this
						}
					}), Fo.prototype = Object.assign(Object.create(Go.prototype), {
						constructor: Fo,
						ValueTypeName: "bool",
						ValueBufferType: Array,
						DefaultInterpolation: 2300,
						InterpolantFactoryMethodLinear: void 0,
						InterpolantFactoryMethodSmooth: void 0
					}), Ho.prototype = Object.assign(Object.create(Go.prototype), {
						constructor: Ho,
						ValueTypeName: "color"
					}), ko.prototype = Object.assign(Object.create(Go.prototype), {
						constructor: ko,
						ValueTypeName: "number"
					}), jo.prototype = Object.assign(Object.create(Bo.prototype), {
						constructor: jo,
						interpolate_: function (t, e, i, n) {
							for (var r = this.resultBuffer, a = this.sampleValues, o = this.valueSize, s = t *
									o, c = (i - e) / (n - e), h = s + o; s !== h; s += 4) ze.slerpFlat(r, 0,
								a, s - o, a, s, c);
							return r
						}
					}), Vo.prototype = Object.assign(Object.create(Go.prototype), {
						constructor: Vo,
						ValueTypeName: "quaternion",
						DefaultInterpolation: 2301,
						InterpolantFactoryMethodLinear: function (t) {
							return new jo(this.times, this.values, this.getValueSize(), t)
						},
						InterpolantFactoryMethodSmooth: void 0
					}), Wo.prototype = Object.assign(Object.create(Go.prototype), {
						constructor: Wo,
						ValueTypeName: "string",
						ValueBufferType: Array,
						DefaultInterpolation: 2300,
						InterpolantFactoryMethodLinear: void 0,
						InterpolantFactoryMethodSmooth: void 0
					}), qo.prototype = Object.assign(Object.create(Go.prototype), {
						constructor: qo,
						ValueTypeName: "vector"
					}), Object.assign(Xo, {
						parse: function (t) {
							for (var e = [], i = t.tracks, n = 1 / (t.fps || 1), r = 0, a = i.length; r !==
								a; ++r) e.push(Yo(i[r]).scale(n));
							return new Xo(t.name, t.duration, e)
						},
						toJSON: function (t) {
							for (var e = [], i = t.tracks, n = {
									name: t.name,
									duration: t.duration,
									tracks: e,
									uuid: t.uuid
								}, r = 0, a = i.length; r !== a; ++r) e.push(Go.toJSON(i[r]));
							return n
						},
						CreateFromMorphTargetSequence: function (t, e, i, n) {
							for (var r = e.length, a = [], o = 0; o < r; o++) {
								var s = [],
									c = [];
								s.push((o + r - 1) % r, o, (o + 1) % r), c.push(0, 1, 0);
								var h = Do.getKeyframeOrder(s);
								s = Do.sortedArray(s, 1, h), c = Do.sortedArray(c, 1, h), n || 0 !== s[0] || (
									s.push(r), c.push(c[0])), a.push(new ko(".morphTargetInfluences[" + e[
									o].name + "]", s, c).scale(1 / i))
							}
							return new Xo(t, -1, a)
						},
						findByName: function (t, e) {
							var i = t;
							if (!Array.isArray(t)) {
								var n = t;
								i = n.geometry && n.geometry.animations || n.animations
							}
							for (var r = 0; r < i.length; r++)
								if (i[r].name === e) return i[r];
							return null
						},
						CreateClipsFromMorphTargetSequences: function (t, e, i) {
							for (var n = {}, r = /^([\w-]*?)([\d]+)$/, a = 0, o = t.length; a < o; a++) {
								var s = t[a],
									c = s.name.match(r);
								if (c && c.length > 1) {
									var h = c[1],
										l = n[h];
									l || (n[h] = l = []), l.push(s)
								}
							}
							var u = [];
							for (var h in n) u.push(Xo.CreateFromMorphTargetSequence(h, n[h], e, i));
							return u
						},
						parseAnimation: function (t, e) {
							if (!t) return console.error(
								"THREE.AnimationClip: No animation in JSONLoader data."), null;
							for (var i = function (t, e, i, n, r) {
										if (0 !== i.length) {
											var a = [],
												o = [];
											Do.flattenJSON(i, a, o, n), 0 !== a.length && r.push(new t(e, a,
												o))
										}
									}, n = [], r = t.name || "default", a = t.length || -1, o = t.fps || 30,
									s = t.hierarchy || [], c = 0; c < s.length; c++) {
								var h = s[c].keys;
								if (h && 0 !== h.length)
									if (h[0].morphTargets) {
										for (var l = {}, u = 0; u < h.length; u++)
											if (h[u].morphTargets)
												for (var p = 0; p < h[u].morphTargets.length; p++) l[h[u]
													.morphTargets[p]] = -1;
										for (var d in l) {
											for (var f = [], m = [], p = 0; p !== h[u].morphTargets.length; ++
												p) {
												var g = h[u];
												f.push(g.time), m.push(g.morphTarget === d ? 1 : 0)
											}
											n.push(new ko(".morphTargetInfluence[" + d + "]", f, m))
										}
										a = l.length * (o || 1)
									} else {
										var v = ".bones[" + e[c].name + "]";
										i(qo, v + ".position", h, "pos", n), i(Vo, v + ".quaternion", h,
											"rot", n), i(qo, v + ".scale", h, "scl", n)
									}
							}
							if (0 === n.length) return null;
							var y = new Xo(r, a, n);
							return y
						}
					}), Object.assign(Xo.prototype, {
						resetDuration: function () {
							for (var t = this.tracks, e = 0, i = 0, n = t.length; i !== n; ++i) {
								var r = this.tracks[i];
								e = Math.max(e, r.times[r.times.length - 1])
							}
							return this.duration = e, this
						},
						trim: function () {
							for (var t = 0; t < this.tracks.length; t++) this.tracks[t].trim(0, this
							.duration);
							return this
						},
						validate: function () {
							for (var t = !0, e = 0; e < this.tracks.length; e++) t = t && this.tracks[e]
								.validate();
							return t
						},
						optimize: function () {
							for (var t = 0; t < this.tracks.length; t++) this.tracks[t].optimize();
							return this
						}
					});
				var Jo = {
					enabled: !1,
					files: {},
					add: function (t, e) {
						!1 !== this.enabled && (this.files[t] = e)
					},
					get: function (t) {
						if (!1 !== this.enabled) return this.files[t]
					},
					remove: function (t) {
						delete this.files[t]
					},
					clear: function () {
						this.files = {}
					}
				};

				function Zo(t, e, i) {
					var n = this,
						r = !1,
						a = 0,
						o = 0,
						s = void 0;
					this.onStart = void 0, this.onLoad = t, this.onProgress = e, this.onError = i, this.itemStart =
						function (t) {
							o++, !1 === r && void 0 !== n.onStart && n.onStart(t, a, o), r = !0
						}, this.itemEnd = function (t) {
							a++, void 0 !== n.onProgress && n.onProgress(t, a, o), a === o && (r = !1, void 0 !== n
								.onLoad && n.onLoad())
						}, this.itemError = function (t) {
							void 0 !== n.onError && n.onError(t)
						}, this.resolveURL = function (t) {
							return s ? s(t) : t
						}, this.setURLModifier = function (t) {
							return s = t, this
						}
				}
				var Qo = new Zo,
					Ko = {};

				function $o(t) {
					this.manager = void 0 !== t ? t : Qo
				}

				function ts(t) {
					this.manager = void 0 !== t ? t : Qo
				}

				function es(t) {
					this.manager = void 0 !== t ? t : Qo, this._parser = null
				}

				function is(t) {
					this.manager = void 0 !== t ? t : Qo, this._parser = null
				}

				function ns(t) {
					this.manager = void 0 !== t ? t : Qo
				}

				function rs(t) {
					this.manager = void 0 !== t ? t : Qo
				}

				function as(t) {
					this.manager = void 0 !== t ? t : Qo
				}

				function os() {
					this.type = "Curve", this.arcLengthDivisions = 200
				}

				function ss(t, e, i, n, r, a, o, s) {
					os.call(this), this.type = "EllipseCurve", this.aX = t || 0, this.aY = e || 0, this.xRadius = i ||
						1, this.yRadius = n || 1, this.aStartAngle = r || 0, this.aEndAngle = a || 2 * Math.PI, this
						.aClockwise = o || !1, this.aRotation = s || 0
				}

				function cs(t, e, i, n, r, a) {
					ss.call(this, t, e, i, i, n, r, a), this.type = "ArcCurve"
				}

				function hs() {
					var t = 0,
						e = 0,
						i = 0,
						n = 0;

					function r(r, a, o, s) {
						t = r, e = o, i = -3 * r + 3 * a - 2 * o - s, n = 2 * r - 2 * a + o + s
					}
					return {
						initCatmullRom: function (t, e, i, n, a) {
							r(e, i, a * (i - t), a * (n - e))
						},
						initNonuniformCatmullRom: function (t, e, i, n, a, o, s) {
							var c = (e - t) / a - (i - t) / (a + o) + (i - e) / o,
								h = (i - e) / o - (n - e) / (o + s) + (n - i) / s;
							r(e, i, c *= o, h *= o)
						},
						calc: function (r) {
							var a = r * r,
								o = a * r;
							return t + e * r + i * a + n * o
						}
					}
				}
				Object.assign($o.prototype, {
						load: function (t, e, i, n) {
							void 0 === t && (t = ""), void 0 !== this.path && (t = this.path + t), t = this
								.manager.resolveURL(t);
							var r = this,
								a = Jo.get(t);
							if (void 0 !== a) return r.manager.itemStart(t), setTimeout(function () {
								e && e(a), r.manager.itemEnd(t)
							}, 0), a;
							if (void 0 === Ko[t]) {
								var o = t.match(/^data:(.*?)(;base64)?,(.*)$/);
								if (o) {
									var s = o[1],
										c = !!o[2],
										h = o[3];
									h = decodeURIComponent(h), c && (h = atob(h));
									try {
										var l, u = (this.responseType || "").toLowerCase();
										switch (u) {
											case "arraybuffer":
											case "blob":
												for (var p = new Uint8Array(h.length), d = 0; d < h
													.length; d++) p[d] = h.charCodeAt(d);
												l = "blob" === u ? new Blob([p.buffer], {
													type: s
												}) : p.buffer;
												break;
											case "document":
												var f = new DOMParser;
												l = f.parseFromString(h, s);
												break;
											case "json":
												l = JSON.parse(h);
												break;
											default:
												l = h
										}
										setTimeout(function () {
											e && e(l), r.manager.itemEnd(t)
										}, 0)
									} catch (e) {
										setTimeout(function () {
											n && n(e), r.manager.itemError(t), r.manager.itemEnd(t)
										}, 0)
									}
								} else {
									Ko[t] = [], Ko[t].push({
										onLoad: e,
										onProgress: i,
										onError: n
									});
									var m = new XMLHttpRequest;
									for (var g in m.open("GET", t, !0), m.addEventListener("load", function (
												e) {
												var i = this.response;
												Jo.add(t, i);
												var n = Ko[t];
												if (delete Ko[t], 200 === this.status || 0 === this
													.status) {
													0 === this.status && console.warn(
														"THREE.FileLoader: HTTP Status 0 received.");
													for (var a = 0, o = n.length; a < o; a++) {
														var s = n[a];
														s.onLoad && s.onLoad(i)
													}
													r.manager.itemEnd(t)
												} else {
													for (var a = 0, o = n.length; a < o; a++) {
														var s = n[a];
														s.onError && s.onError(e)
													}
													r.manager.itemError(t), r.manager.itemEnd(t)
												}
											}, !1), m.addEventListener("progress", function (e) {
												for (var i = Ko[t], n = 0, r = i.length; n < r; n++) {
													var a = i[n];
													a.onProgress && a.onProgress(e)
												}
											}, !1), m.addEventListener("error", function (e) {
												var i = Ko[t];
												delete Ko[t];
												for (var n = 0, a = i.length; n < a; n++) {
													var o = i[n];
													o.onError && o.onError(e)
												}
												r.manager.itemError(t), r.manager.itemEnd(t)
											}, !1), m.addEventListener("abort", function (e) {
												var i = Ko[t];
												delete Ko[t];
												for (var n = 0, a = i.length; n < a; n++) {
													var o = i[n];
													o.onError && o.onError(e)
												}
												r.manager.itemError(t), r.manager.itemEnd(t)
											}, !1), void 0 !== this.responseType && (m.responseType = this
												.responseType), void 0 !== this.withCredentials && (m
												.withCredentials = this.withCredentials), m
											.overrideMimeType && m.overrideMimeType(void 0 !== this.mimeType ?
												this.mimeType : "text/plain"), this.requestHeader) m
										.setRequestHeader(g, this.requestHeader[g]);
									m.send(null)
								}
								return r.manager.itemStart(t), m
							}
							Ko[t].push({
								onLoad: e,
								onProgress: i,
								onError: n
							})
						},
						setPath: function (t) {
							return this.path = t, this
						},
						setResponseType: function (t) {
							return this.responseType = t, this
						},
						setWithCredentials: function (t) {
							return this.withCredentials = t, this
						},
						setMimeType: function (t) {
							return this.mimeType = t, this
						},
						setRequestHeader: function (t) {
							return this.requestHeader = t, this
						}
					}), Object.assign(ts.prototype, {
						load: function (t, e, i, n) {
							var r = this,
								a = new $o(r.manager);
							a.setPath(r.path), a.load(t, function (t) {
								e(r.parse(JSON.parse(t)))
							}, i, n)
						},
						parse: function (t, e) {
							for (var i = [], n = 0; n < t.length; n++) {
								var r = Xo.parse(t[n]);
								i.push(r)
							}
							e(i)
						},
						setPath: function (t) {
							return this.path = t, this
						}
					}), Object.assign(es.prototype, {
						load: function (t, e, i, n) {
							var r = this,
								a = [],
								o = new oa;
							o.image = a;
							var s = new $o(this.manager);

							function c(c) {
								s.load(t[c], function (t) {
									var i = r._parser(t, !0);
									a[c] = {
										width: i.width,
										height: i.height,
										format: i.format,
										mipmaps: i.mipmaps
									}, 6 === (h += 1) && (1 === i.mipmapCount && (o.minFilter =
										St), o.format = i.format, o.needsUpdate = !0, e && e(
										o))
								}, i, n)
							}
							if (s.setPath(this.path), s.setResponseType("arraybuffer"), Array.isArray(t))
								for (var h = 0, l = 0, u = t.length; l < u; ++l) c(l);
							else s.load(t, function (t) {
								var i = r._parser(t, !0);
								if (i.isCubemap)
									for (var n = i.mipmaps.length / i.mipmapCount, s = 0; s <
										n; s++) {
										a[s] = {
											mipmaps: []
										};
										for (var c = 0; c < i.mipmapCount; c++) a[s].mipmaps.push(i
												.mipmaps[s * i.mipmapCount + c]), a[s].format = i
											.format, a[s].width = i.width, a[s].height = i.height
									} else o.image.width = i.width, o.image.height = i.height, o
										.mipmaps = i.mipmaps;
								1 === i.mipmapCount && (o.minFilter = St), o.format = i.format, o
									.needsUpdate = !0, e && e(o)
							}, i, n);
							return o
						},
						setPath: function (t) {
							return this.path = t, this
						}
					}), Object.assign(is.prototype, {
						load: function (t, e, i, n) {
							var r = this,
								a = new Ze,
								o = new $o(this.manager);
							return o.setResponseType("arraybuffer"), o.setPath(this.path), o.load(t,
								function (t) {
									var i = r._parser(t);
									i && (void 0 !== i.image ? a.image = i.image : void 0 !== i.data && (a
											.image.width = i.width, a.image.height = i.height, a.image
											.data = i.data), a.wrapS = void 0 !== i.wrapS ? i.wrapS :
										xt, a.wrapT = void 0 !== i.wrapT ? i.wrapT : xt, a.magFilter =
										void 0 !== i.magFilter ? i.magFilter : St, a.minFilter =
										void 0 !== i.minFilter ? i.minFilter : Tt, a.anisotropy =
										void 0 !== i.anisotropy ? i.anisotropy : 1, void 0 !== i
										.format && (a.format = i.format), void 0 !== i.type && (a
											.type = i.type), void 0 !== i.mipmaps && (a.mipmaps = i
											.mipmaps), 1 === i.mipmapCount && (a.minFilter = St), a
										.needsUpdate = !0, e && e(a, i))
								}, i, n), a
						},
						setPath: function (t) {
							return this.path = t, this
						}
					}), Object.assign(ns.prototype, {
						crossOrigin: "anonymous",
						load: function (t, e, i, n) {
							void 0 === t && (t = ""), void 0 !== this.path && (t = this.path + t), t = this
								.manager.resolveURL(t);
							var r = this,
								a = Jo.get(t);
							if (void 0 !== a) return r.manager.itemStart(t), setTimeout(function () {
								e && e(a), r.manager.itemEnd(t)
							}, 0), a;
							var o = document.createElement("img");

							function s() {
								o.removeEventListener("load", s, !1), o.removeEventListener("error", c, !1),
									Jo.add(t, this), e && e(this), r.manager.itemEnd(t)
							}

							function c(e) {
								o.removeEventListener("load", s, !1), o.removeEventListener("error", c, !1),
									n && n(e), r.manager.itemError(t), r.manager.itemEnd(t)
							}
							return o.addEventListener("load", s, !1), o.addEventListener("error", c, !1),
								"data:" !== t.substr(0, 5) && void 0 !== this.crossOrigin && (o.crossOrigin =
									this.crossOrigin), r.manager.itemStart(t), o.src = t, o
						},
						setCrossOrigin: function (t) {
							return this.crossOrigin = t, this
						},
						setPath: function (t) {
							return this.path = t, this
						}
					}), Object.assign(rs.prototype, {
						crossOrigin: "anonymous",
						load: function (t, e, i, n) {
							var r = new dn,
								a = new ns(this.manager);
							a.setCrossOrigin(this.crossOrigin), a.setPath(this.path);
							var o = 0;

							function s(i) {
								a.load(t[i], function (t) {
									r.images[i] = t, 6 == ++o && (r.needsUpdate = !0, e && e(r))
								}, void 0, n)
							}
							for (var c = 0; c < t.length; ++c) s(c);
							return r
						},
						setCrossOrigin: function (t) {
							return this.crossOrigin = t, this
						},
						setPath: function (t) {
							return this.path = t, this
						}
					}), Object.assign(as.prototype, {
						crossOrigin: "anonymous",
						load: function (t, e, i, n) {
							var r = new qe,
								a = new ns(this.manager);
							return a.setCrossOrigin(this.crossOrigin), a.setPath(this.path), a.load(t,
								function (i) {
									r.image = i;
									var n = t.search(/\.jpe?g($|\?)/i) > 0 || 0 === t.search(
										/^data\:image\/jpeg/);
									r.format = n ? Ft : Ht, r.needsUpdate = !0, void 0 !== e && e(r)
								}, i, n), r
						},
						setCrossOrigin: function (t) {
							return this.crossOrigin = t, this
						},
						setPath: function (t) {
							return this.path = t, this
						}
					}), Object.assign(os.prototype, {
						getPoint: function () {
							return console.warn("THREE.Curve: .getPoint() not implemented."), null
						},
						getPointAt: function (t, e) {
							var i = this.getUtoTmapping(t);
							return this.getPoint(i, e)
						},
						getPoints: function (t) {
							void 0 === t && (t = 5);
							for (var e = [], i = 0; i <= t; i++) e.push(this.getPoint(i / t));
							return e
						},
						getSpacedPoints: function (t) {
							void 0 === t && (t = 5);
							for (var e = [], i = 0; i <= t; i++) e.push(this.getPointAt(i / t));
							return e
						},
						getLength: function () {
							var t = this.getLengths();
							return t[t.length - 1]
						},
						getLengths: function (t) {
							if (void 0 === t && (t = this.arcLengthDivisions), this.cacheArcLengths && this
								.cacheArcLengths.length === t + 1 && !this.needsUpdate) return this
								.cacheArcLengths;
							this.needsUpdate = !1;
							var e, i, n = [],
								r = this.getPoint(0),
								a = 0;
							for (n.push(0), i = 1; i <= t; i++) e = this.getPoint(i / t), a += e.distanceTo(
								r), n.push(a), r = e;
							return this.cacheArcLengths = n, n
						},
						updateArcLengths: function () {
							this.needsUpdate = !0, this.getLengths()
						},
						getUtoTmapping: function (t, e) {
							var i, n = this.getLengths(),
								r = 0,
								a = n.length;
							i = e || t * n[a - 1];
							for (var o, s = 0, c = a - 1; s <= c;)
								if (r = Math.floor(s + (c - s) / 2), (o = n[r] - i) < 0) s = r + 1;
								else {
									if (!(o > 0)) {
										c = r;
										break
									}
									c = r - 1
								} if (n[r = c] === i) return r / (a - 1);
							var h = n[r],
								l = n[r + 1],
								u = l - h,
								p = (i - h) / u,
								d = (r + p) / (a - 1);
							return d
						},
						getTangent: function (t) {
							var e = t - 1e-4,
								i = t + 1e-4;
							e < 0 && (e = 0), i > 1 && (i = 1);
							var n = this.getPoint(e),
								r = this.getPoint(i),
								a = r.clone().sub(n);
							return a.normalize()
						},
						getTangentAt: function (t) {
							var e = this.getUtoTmapping(t);
							return this.getTangent(e)
						},
						computeFrenetFrames: function (t, e) {
							var i, n, r, a = new Ne,
								o = [],
								s = [],
								c = [],
								h = new Ne,
								l = new Be;
							for (i = 0; i <= t; i++) n = i / t, o[i] = this.getTangentAt(n), o[i].normalize();
							s[0] = new Ne, c[0] = new Ne;
							var u = Number.MAX_VALUE,
								p = Math.abs(o[0].x),
								d = Math.abs(o[0].y),
								f = Math.abs(o[0].z);
							for (p <= u && (u = p, a.set(1, 0, 0)), d <= u && (u = d, a.set(0, 1, 0)), f <=
								u && a.set(0, 0, 1), h.crossVectors(o[0], a).normalize(), s[0].crossVectors(o[
									0], h), c[0].crossVectors(o[0], s[0]), i = 1; i <= t; i++) s[i] = s[i - 1]
								.clone(), c[i] = c[i - 1].clone(), h.crossVectors(o[i - 1], o[i]), h
							.length() > Number.EPSILON && (h.normalize(), r = Math.acos(Ie.clamp(o[i - 1].dot(
									o[i]), -1, 1)), s[i].applyMatrix4(l.makeRotationAxis(h, r))), c[i]
								.crossVectors(o[i], s[i]);
							if (!0 === e)
								for (r = Math.acos(Ie.clamp(s[0].dot(s[t]), -1, 1)), r /= t, o[0].dot(h
										.crossVectors(s[0], s[t])) > 0 && (r = -r), i = 1; i <= t; i++) s[i]
									.applyMatrix4(l.makeRotationAxis(o[i], r * i)), c[i].crossVectors(o[i], s[
										i]);
							return {
								tangents: o,
								normals: s,
								binormals: c
							}
						},
						clone: function () {
							return (new this.constructor).copy(this)
						},
						copy: function (t) {
							return this.arcLengthDivisions = t.arcLengthDivisions, this
						},
						toJSON: function () {
							var t = {
								metadata: {
									version: 4.5,
									type: "Curve",
									generator: "Curve.toJSON"
								}
							};
							return t.arcLengthDivisions = this.arcLengthDivisions, t.type = this.type, t
						},
						fromJSON: function (t) {
							return this.arcLengthDivisions = t.arcLengthDivisions, this
						}
					}), ss.prototype = Object.create(os.prototype), ss.prototype.constructor = ss, ss.prototype
					.isEllipseCurve = !0, ss.prototype.getPoint = function (t, e) {
						for (var i = e || new De, n = 2 * Math.PI, r = this.aEndAngle - this.aStartAngle, a = Math
								.abs(r) < Number.EPSILON; r < 0;) r += n;
						for (; r > n;) r -= n;
						r < Number.EPSILON && (r = a ? 0 : n), !0 !== this.aClockwise || a || (r === n ? r = -n : r -=
							n);
						var o = this.aStartAngle + t * r,
							s = this.aX + this.xRadius * Math.cos(o),
							c = this.aY + this.yRadius * Math.sin(o);
						if (0 !== this.aRotation) {
							var h = Math.cos(this.aRotation),
								l = Math.sin(this.aRotation),
								u = s - this.aX,
								p = c - this.aY;
							s = u * h - p * l + this.aX, c = u * l + p * h + this.aY
						}
						return i.set(s, c)
					}, ss.prototype.copy = function (t) {
						return os.prototype.copy.call(this, t), this.aX = t.aX, this.aY = t.aY, this.xRadius = t
							.xRadius, this.yRadius = t.yRadius, this.aStartAngle = t.aStartAngle, this.aEndAngle = t
							.aEndAngle, this.aClockwise = t.aClockwise, this.aRotation = t.aRotation, this
					}, ss.prototype.toJSON = function () {
						var t = os.prototype.toJSON.call(this);
						return t.aX = this.aX, t.aY = this.aY, t.xRadius = this.xRadius, t.yRadius = this.yRadius, t
							.aStartAngle = this.aStartAngle, t.aEndAngle = this.aEndAngle, t.aClockwise = this
							.aClockwise, t.aRotation = this.aRotation, t
					}, ss.prototype.fromJSON = function (t) {
						return os.prototype.fromJSON.call(this, t), this.aX = t.aX, this.aY = t.aY, this.xRadius = t
							.xRadius, this.yRadius = t.yRadius, this.aStartAngle = t.aStartAngle, this.aEndAngle = t
							.aEndAngle, this.aClockwise = t.aClockwise, this.aRotation = t.aRotation, this
					}, cs.prototype = Object.create(ss.prototype), cs.prototype.constructor = cs, cs.prototype
					.isArcCurve = !0;
				var ls = new Ne,
					us = new hs,
					ps = new hs,
					ds = new hs;

				function fs(t, e, i, n) {
					os.call(this), this.type = "CatmullRomCurve3", this.points = t || [], this.closed = e || !1, this
						.curveType = i || "centripetal", this.tension = n || .5
				}

				function ms(t, e, i, n, r) {
					var a = .5 * (n - e),
						o = .5 * (r - i),
						s = t * t,
						c = t * s;
					return (2 * i - 2 * n + a + o) * c + (-3 * i + 3 * n - 2 * a - o) * s + a * t + i
				}

				function gs(t, e, i, n) {
					return function (t, e) {
						var i = 1 - t;
						return i * i * e
					}(t, e) + function (t, e) {
						return 2 * (1 - t) * t * e
					}(t, i) + function (t, e) {
						return t * t * e
					}(t, n)
				}

				function vs(t, e, i, n, r) {
					return function (t, e) {
						var i = 1 - t;
						return i * i * i * e
					}(t, e) + function (t, e) {
						var i = 1 - t;
						return 3 * i * i * t * e
					}(t, i) + function (t, e) {
						return 3 * (1 - t) * t * t * e
					}(t, n) + function (t, e) {
						return t * t * t * e
					}(t, r)
				}

				function ys(t, e, i, n) {
					os.call(this), this.type = "CubicBezierCurve", this.v0 = t || new De, this.v1 = e || new De, this
						.v2 = i || new De, this.v3 = n || new De
				}

				function xs(t, e, i, n) {
					os.call(this), this.type = "CubicBezierCurve3", this.v0 = t || new Ne, this.v1 = e || new Ne, this
						.v2 = i || new Ne, this.v3 = n || new Ne
				}

				function bs(t, e) {
					os.call(this), this.type = "LineCurve", this.v1 = t || new De, this.v2 = e || new De
				}

				function _s(t, e) {
					os.call(this), this.type = "LineCurve3", this.v1 = t || new Ne, this.v2 = e || new Ne
				}

				function ws(t, e, i) {
					os.call(this), this.type = "QuadraticBezierCurve", this.v0 = t || new De, this.v1 = e || new De,
						this.v2 = i || new De
				}

				function Ms(t, e, i) {
					os.call(this), this.type = "QuadraticBezierCurve3", this.v0 = t || new Ne, this.v1 = e || new Ne,
						this.v2 = i || new Ne
				}

				function Ss(t) {
					os.call(this), this.type = "SplineCurve", this.points = t || []
				}
				fs.prototype = Object.create(os.prototype), fs.prototype.constructor = fs, fs.prototype
					.isCatmullRomCurve3 = !0, fs.prototype.getPoint = function (t, e) {
						var i, n, r, a, o = e || new Ne,
							s = this.points,
							c = s.length,
							h = (c - (this.closed ? 0 : 1)) * t,
							l = Math.floor(h),
							u = h - l;
						if (this.closed ? l += l > 0 ? 0 : (Math.floor(Math.abs(l) / c) + 1) * c : 0 === u && l ===
							c - 1 && (l = c - 2, u = 1), this.closed || l > 0 ? i = s[(l - 1) % c] : (ls.subVectors(s[
								0], s[1]).add(s[0]), i = ls), n = s[l % c], r = s[(l + 1) % c], this.closed || l + 2 <
							c ? a = s[(l + 2) % c] : (ls.subVectors(s[c - 1], s[c - 2]).add(s[c - 1]), a = ls),
							"centripetal" === this.curveType || "chordal" === this.curveType) {
							var p = "chordal" === this.curveType ? .5 : .25,
								d = Math.pow(i.distanceToSquared(n), p),
								f = Math.pow(n.distanceToSquared(r), p),
								m = Math.pow(r.distanceToSquared(a), p);
							f < 1e-4 && (f = 1), d < 1e-4 && (d = f), m < 1e-4 && (m = f), us
								.initNonuniformCatmullRom(i.x, n.x, r.x, a.x, d, f, m), ps.initNonuniformCatmullRom(i
									.y, n.y, r.y, a.y, d, f, m), ds.initNonuniformCatmullRom(i.z, n.z, r.z, a.z, d, f,
									m)
						} else "catmullrom" === this.curveType && (us.initCatmullRom(i.x, n.x, r.x, a.x, this
							.tension), ps.initCatmullRom(i.y, n.y, r.y, a.y, this.tension), ds.initCatmullRom(i.z,
								n.z, r.z, a.z, this.tension));
						return o.set(us.calc(u), ps.calc(u), ds.calc(u)), o
					}, fs.prototype.copy = function (t) {
						os.prototype.copy.call(this, t), this.points = [];
						for (var e = 0, i = t.points.length; e < i; e++) {
							var n = t.points[e];
							this.points.push(n.clone())
						}
						return this.closed = t.closed, this.curveType = t.curveType, this.tension = t.tension, this
					}, fs.prototype.toJSON = function () {
						var t = os.prototype.toJSON.call(this);
						t.points = [];
						for (var e = 0, i = this.points.length; e < i; e++) {
							var n = this.points[e];
							t.points.push(n.toArray())
						}
						return t.closed = this.closed, t.curveType = this.curveType, t.tension = this.tension, t
					}, fs.prototype.fromJSON = function (t) {
						os.prototype.fromJSON.call(this, t), this.points = [];
						for (var e = 0, i = t.points.length; e < i; e++) {
							var n = t.points[e];
							this.points.push((new Ne).fromArray(n))
						}
						return this.closed = t.closed, this.curveType = t.curveType, this.tension = t.tension, this
					}, ys.prototype = Object.create(os.prototype), ys.prototype.constructor = ys, ys.prototype
					.isCubicBezierCurve = !0, ys.prototype.getPoint = function (t, e) {
						var i = e || new De,
							n = this.v0,
							r = this.v1,
							a = this.v2,
							o = this.v3;
						return i.set(vs(t, n.x, r.x, a.x, o.x), vs(t, n.y, r.y, a.y, o.y)), i
					}, ys.prototype.copy = function (t) {
						return os.prototype.copy.call(this, t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t
							.v2), this.v3.copy(t.v3), this
					}, ys.prototype.toJSON = function () {
						var t = os.prototype.toJSON.call(this);
						return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t.v3 =
							this.v3.toArray(), t
					}, ys.prototype.fromJSON = function (t) {
						return os.prototype.fromJSON.call(this, t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1),
							this.v2.fromArray(t.v2), this.v3.fromArray(t.v3), this
					}, xs.prototype = Object.create(os.prototype), xs.prototype.constructor = xs, xs.prototype
					.isCubicBezierCurve3 = !0, xs.prototype.getPoint = function (t, e) {
						var i = e || new Ne,
							n = this.v0,
							r = this.v1,
							a = this.v2,
							o = this.v3;
						return i.set(vs(t, n.x, r.x, a.x, o.x), vs(t, n.y, r.y, a.y, o.y), vs(t, n.z, r.z, a.z, o.z)),
							i
					}, xs.prototype.copy = function (t) {
						return os.prototype.copy.call(this, t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t
							.v2), this.v3.copy(t.v3), this
					}, xs.prototype.toJSON = function () {
						var t = os.prototype.toJSON.call(this);
						return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t.v3 =
							this.v3.toArray(), t
					}, xs.prototype.fromJSON = function (t) {
						return os.prototype.fromJSON.call(this, t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1),
							this.v2.fromArray(t.v2), this.v3.fromArray(t.v3), this
					}, bs.prototype = Object.create(os.prototype), bs.prototype.constructor = bs, bs.prototype
					.isLineCurve = !0, bs.prototype.getPoint = function (t, e) {
						var i = e || new De;
						return 1 === t ? i.copy(this.v2) : (i.copy(this.v2).sub(this.v1), i.multiplyScalar(t).add(this
							.v1)), i
					}, bs.prototype.getPointAt = function (t, e) {
						return this.getPoint(t, e)
					}, bs.prototype.getTangent = function () {
						var t = this.v2.clone().sub(this.v1);
						return t.normalize()
					}, bs.prototype.copy = function (t) {
						return os.prototype.copy.call(this, t), this.v1.copy(t.v1), this.v2.copy(t.v2), this
					}, bs.prototype.toJSON = function () {
						var t = os.prototype.toJSON.call(this);
						return t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
					}, bs.prototype.fromJSON = function (t) {
						return os.prototype.fromJSON.call(this, t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2),
							this
					}, _s.prototype = Object.create(os.prototype), _s.prototype.constructor = _s, _s.prototype
					.isLineCurve3 = !0, _s.prototype.getPoint = function (t, e) {
						var i = e || new Ne;
						return 1 === t ? i.copy(this.v2) : (i.copy(this.v2).sub(this.v1), i.multiplyScalar(t).add(this
							.v1)), i
					}, _s.prototype.getPointAt = function (t, e) {
						return this.getPoint(t, e)
					}, _s.prototype.copy = function (t) {
						return os.prototype.copy.call(this, t), this.v1.copy(t.v1), this.v2.copy(t.v2), this
					}, _s.prototype.toJSON = function () {
						var t = os.prototype.toJSON.call(this);
						return t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
					}, _s.prototype.fromJSON = function (t) {
						return os.prototype.fromJSON.call(this, t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2),
							this
					}, ws.prototype = Object.create(os.prototype), ws.prototype.constructor = ws, ws.prototype
					.isQuadraticBezierCurve = !0, ws.prototype.getPoint = function (t, e) {
						var i = e || new De,
							n = this.v0,
							r = this.v1,
							a = this.v2;
						return i.set(gs(t, n.x, r.x, a.x), gs(t, n.y, r.y, a.y)), i
					}, ws.prototype.copy = function (t) {
						return os.prototype.copy.call(this, t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t
							.v2), this
					}, ws.prototype.toJSON = function () {
						var t = os.prototype.toJSON.call(this);
						return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
					}, ws.prototype.fromJSON = function (t) {
						return os.prototype.fromJSON.call(this, t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1),
							this.v2.fromArray(t.v2), this
					}, Ms.prototype = Object.create(os.prototype), Ms.prototype.constructor = Ms, Ms.prototype
					.isQuadraticBezierCurve3 = !0, Ms.prototype.getPoint = function (t, e) {
						var i = e || new Ne,
							n = this.v0,
							r = this.v1,
							a = this.v2;
						return i.set(gs(t, n.x, r.x, a.x), gs(t, n.y, r.y, a.y), gs(t, n.z, r.z, a.z)), i
					}, Ms.prototype.copy = function (t) {
						return os.prototype.copy.call(this, t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t
							.v2), this
					}, Ms.prototype.toJSON = function () {
						var t = os.prototype.toJSON.call(this);
						return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
					}, Ms.prototype.fromJSON = function (t) {
						return os.prototype.fromJSON.call(this, t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1),
							this.v2.fromArray(t.v2), this
					}, Ss.prototype = Object.create(os.prototype), Ss.prototype.constructor = Ss, Ss.prototype
					.isSplineCurve = !0, Ss.prototype.getPoint = function (t, e) {
						var i = e || new De,
							n = this.points,
							r = (n.length - 1) * t,
							a = Math.floor(r),
							o = r - a,
							s = n[0 === a ? a : a - 1],
							c = n[a],
							h = n[a > n.length - 2 ? n.length - 1 : a + 1],
							l = n[a > n.length - 3 ? n.length - 1 : a + 2];
						return i.set(ms(o, s.x, c.x, h.x, l.x), ms(o, s.y, c.y, h.y, l.y)), i
					}, Ss.prototype.copy = function (t) {
						os.prototype.copy.call(this, t), this.points = [];
						for (var e = 0, i = t.points.length; e < i; e++) {
							var n = t.points[e];
							this.points.push(n.clone())
						}
						return this
					}, Ss.prototype.toJSON = function () {
						var t = os.prototype.toJSON.call(this);
						t.points = [];
						for (var e = 0, i = this.points.length; e < i; e++) {
							var n = this.points[e];
							t.points.push(n.toArray())
						}
						return t
					}, Ss.prototype.fromJSON = function (t) {
						os.prototype.fromJSON.call(this, t), this.points = [];
						for (var e = 0, i = t.points.length; e < i; e++) {
							var n = t.points[e];
							this.points.push((new De).fromArray(n))
						}
						return this
					};
				var Es = Object.freeze({
					ArcCurve: cs,
					CatmullRomCurve3: fs,
					CubicBezierCurve: ys,
					CubicBezierCurve3: xs,
					EllipseCurve: ss,
					LineCurve: bs,
					LineCurve3: _s,
					QuadraticBezierCurve: ws,
					QuadraticBezierCurve3: Ms,
					SplineCurve: Ss
				});

				function Ts() {
					os.call(this), this.type = "CurvePath", this.curves = [], this.autoClose = !1
				}

				function As(t) {
					Ts.call(this), this.type = "Path", this.currentPoint = new De, t && this.setFromPoints(t)
				}

				function Ls(t) {
					As.call(this, t), this.uuid = Ie.generateUUID(), this.type = "Shape", this.holes = []
				}

				function Ps(t, e) {
					Mi.call(this), this.type = "Light", this.color = new hi(t), this.intensity = void 0 !== e ? e : 1,
						this.receiveShadow = void 0
				}

				function Cs(t, e, i) {
					Ps.call(this, t, i), this.type = "HemisphereLight", this.castShadow = void 0, this.position.copy(
						Mi.DefaultUp), this.updateMatrix(), this.groundColor = new hi(e)
				}

				function Rs(t) {
					this.camera = t, this.bias = 0, this.radius = 1, this.mapSize = new De(512, 512), this.map = null,
						this.matrix = new Be
				}

				function Os() {
					Rs.call(this, new Pr(50, 1, .5, 500))
				}

				function Is(t, e, i, n, r, a) {
					Ps.call(this, t, e), this.type = "SpotLight", this.position.copy(Mi.DefaultUp), this
						.updateMatrix(), this.target = new Mi, Object.defineProperty(this, "power", {
							get: function () {
								return this.intensity * Math.PI
							},
							set: function (t) {
								this.intensity = t / Math.PI
							}
						}), this.distance = void 0 !== i ? i : 0, this.angle = void 0 !== n ? n : Math.PI / 3, this
						.penumbra = void 0 !== r ? r : 0, this.decay = void 0 !== a ? a : 1, this.shadow = new Os
				}

				function Ds(t, e, i, n) {
					Ps.call(this, t, e), this.type = "PointLight", Object.defineProperty(this, "power", {
							get: function () {
								return 4 * this.intensity * Math.PI
							},
							set: function (t) {
								this.intensity = t / (4 * Math.PI)
							}
						}), this.distance = void 0 !== i ? i : 0, this.decay = void 0 !== n ? n : 1, this.shadow =
						new Rs(new Pr(90, 1, .5, 500))
				}

				function Bs(t, e, i, n, r, a) {
					Lr.call(this), this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left =
						void 0 !== t ? t : -1, this.right = void 0 !== e ? e : 1, this.top = void 0 !== i ? i : 1,
						this.bottom = void 0 !== n ? n : -1, this.near = void 0 !== r ? r : .1, this.far = void 0 !==
						a ? a : 2e3, this.updateProjectionMatrix()
				}

				function zs() {
					Rs.call(this, new Bs(-5, 5, 5, -5, .5, 500))
				}

				function Ns(t, e) {
					Ps.call(this, t, e), this.type = "DirectionalLight", this.position.copy(Mi.DefaultUp), this
						.updateMatrix(), this.target = new Mi, this.shadow = new zs
				}

				function Us(t, e) {
					Ps.call(this, t, e), this.type = "AmbientLight", this.castShadow = void 0
				}

				function Gs(t, e, i, n) {
					Ps.call(this, t, e), this.type = "RectAreaLight", this.width = void 0 !== i ? i : 10, this
						.height = void 0 !== n ? n : 10
				}

				function Fs(t) {
					this.manager = void 0 !== t ? t : Qo, this.textures = {}
				}
				Ts.prototype = Object.assign(Object.create(os.prototype), {
					constructor: Ts,
					add: function (t) {
						this.curves.push(t)
					},
					closePath: function () {
						var t = this.curves[0].getPoint(0),
							e = this.curves[this.curves.length - 1].getPoint(1);
						t.equals(e) || this.curves.push(new bs(e, t))
					},
					getPoint: function (t) {
						for (var e = t * this.getLength(), i = this.getCurveLengths(), n = 0; n < i
							.length;) {
							if (i[n] >= e) {
								var r = i[n] - e,
									a = this.curves[n],
									o = a.getLength(),
									s = 0 === o ? 0 : 1 - r / o;
								return a.getPointAt(s)
							}
							n++
						}
						return null
					},
					getLength: function () {
						var t = this.getCurveLengths();
						return t[t.length - 1]
					},
					updateArcLengths: function () {
						this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths()
					},
					getCurveLengths: function () {
						if (this.cacheLengths && this.cacheLengths.length === this.curves.length)
						return this.cacheLengths;
						for (var t = [], e = 0, i = 0, n = this.curves.length; i < n; i++) e += this
							.curves[i].getLength(), t.push(e);
						return this.cacheLengths = t, t
					},
					getSpacedPoints: function (t) {
						void 0 === t && (t = 40);
						for (var e = [], i = 0; i <= t; i++) e.push(this.getPoint(i / t));
						return this.autoClose && e.push(e[0]), e
					},
					getPoints: function (t) {
						t = t || 12;
						for (var e, i = [], n = 0, r = this.curves; n < r.length; n++)
							for (var a = r[n], o = a && a.isEllipseCurve ? 2 * t : a && (a.isLineCurve ||
										a.isLineCurve3) ? 1 : a && a.isSplineCurve ? t * a.points.length :
									t, s = a.getPoints(o), c = 0; c < s.length; c++) {
								var h = s[c];
								e && e.equals(h) || (i.push(h), e = h)
							}
						return this.autoClose && i.length > 1 && !i[i.length - 1].equals(i[0]) && i.push(
							i[0]), i
					},
					copy: function (t) {
						os.prototype.copy.call(this, t), this.curves = [];
						for (var e = 0, i = t.curves.length; e < i; e++) {
							var n = t.curves[e];
							this.curves.push(n.clone())
						}
						return this.autoClose = t.autoClose, this
					},
					toJSON: function () {
						var t = os.prototype.toJSON.call(this);
						t.autoClose = this.autoClose, t.curves = [];
						for (var e = 0, i = this.curves.length; e < i; e++) {
							var n = this.curves[e];
							t.curves.push(n.toJSON())
						}
						return t
					},
					fromJSON: function (t) {
						os.prototype.fromJSON.call(this, t), this.autoClose = t.autoClose, this
						.curves = [];
						for (var e = 0, i = t.curves.length; e < i; e++) {
							var n = t.curves[e];
							this.curves.push((new Es[n.type]).fromJSON(n))
						}
						return this
					}
				}), As.prototype = Object.assign(Object.create(Ts.prototype), {
					constructor: As,
					setFromPoints: function (t) {
						this.moveTo(t[0].x, t[0].y);
						for (var e = 1, i = t.length; e < i; e++) this.lineTo(t[e].x, t[e].y)
					},
					moveTo: function (t, e) {
						this.currentPoint.set(t, e)
					},
					lineTo: function (t, e) {
						var i = new bs(this.currentPoint.clone(), new De(t, e));
						this.curves.push(i), this.currentPoint.set(t, e)
					},
					quadraticCurveTo: function (t, e, i, n) {
						var r = new ws(this.currentPoint.clone(), new De(t, e), new De(i, n));
						this.curves.push(r), this.currentPoint.set(i, n)
					},
					bezierCurveTo: function (t, e, i, n, r, a) {
						var o = new ys(this.currentPoint.clone(), new De(t, e), new De(i, n), new De(r,
							a));
						this.curves.push(o), this.currentPoint.set(r, a)
					},
					splineThru: function (t) {
						var e = [this.currentPoint.clone()].concat(t),
							i = new Ss(e);
						this.curves.push(i), this.currentPoint.copy(t[t.length - 1])
					},
					arc: function (t, e, i, n, r, a) {
						var o = this.currentPoint.x,
							s = this.currentPoint.y;
						this.absarc(t + o, e + s, i, n, r, a)
					},
					absarc: function (t, e, i, n, r, a) {
						this.absellipse(t, e, i, i, n, r, a)
					},
					ellipse: function (t, e, i, n, r, a, o, s) {
						var c = this.currentPoint.x,
							h = this.currentPoint.y;
						this.absellipse(t + c, e + h, i, n, r, a, o, s)
					},
					absellipse: function (t, e, i, n, r, a, o, s) {
						var c = new ss(t, e, i, n, r, a, o, s);
						if (this.curves.length > 0) {
							var h = c.getPoint(0);
							h.equals(this.currentPoint) || this.lineTo(h.x, h.y)
						}
						this.curves.push(c);
						var l = c.getPoint(1);
						this.currentPoint.copy(l)
					},
					copy: function (t) {
						return Ts.prototype.copy.call(this, t), this.currentPoint.copy(t.currentPoint),
							this
					},
					toJSON: function () {
						var t = Ts.prototype.toJSON.call(this);
						return t.currentPoint = this.currentPoint.toArray(), t
					},
					fromJSON: function (t) {
						return Ts.prototype.fromJSON.call(this, t), this.currentPoint.fromArray(t
							.currentPoint), this
					}
				}), Ls.prototype = Object.assign(Object.create(As.prototype), {
					constructor: Ls,
					getPointsHoles: function (t) {
						for (var e = [], i = 0, n = this.holes.length; i < n; i++) e[i] = this.holes[i]
							.getPoints(t);
						return e
					},
					extractPoints: function (t) {
						return {
							shape: this.getPoints(t),
							holes: this.getPointsHoles(t)
						}
					},
					copy: function (t) {
						As.prototype.copy.call(this, t), this.holes = [];
						for (var e = 0, i = t.holes.length; e < i; e++) {
							var n = t.holes[e];
							this.holes.push(n.clone())
						}
						return this
					},
					toJSON: function () {
						var t = As.prototype.toJSON.call(this);
						t.uuid = this.uuid, t.holes = [];
						for (var e = 0, i = this.holes.length; e < i; e++) {
							var n = this.holes[e];
							t.holes.push(n.toJSON())
						}
						return t
					},
					fromJSON: function (t) {
						As.prototype.fromJSON.call(this, t), this.uuid = t.uuid, this.holes = [];
						for (var e = 0, i = t.holes.length; e < i; e++) {
							var n = t.holes[e];
							this.holes.push((new As).fromJSON(n))
						}
						return this
					}
				}), Ps.prototype = Object.assign(Object.create(Mi.prototype), {
					constructor: Ps,
					isLight: !0,
					copy: function (t) {
						return Mi.prototype.copy.call(this, t), this.color.copy(t.color), this.intensity =
							t.intensity, this
					},
					toJSON: function (t) {
						var e = Mi.prototype.toJSON.call(this, t);
						return e.object.color = this.color.getHex(), e.object.intensity = this.intensity,
							void 0 !== this.groundColor && (e.object.groundColor = this.groundColor
								.getHex()), void 0 !== this.distance && (e.object.distance = this
								.distance), void 0 !== this.angle && (e.object.angle = this.angle),
							void 0 !== this.decay && (e.object.decay = this.decay), void 0 !== this
							.penumbra && (e.object.penumbra = this.penumbra), void 0 !== this.shadow && (e
								.object.shadow = this.shadow.toJSON()), e
					}
				}), Cs.prototype = Object.assign(Object.create(Ps.prototype), {
					constructor: Cs,
					isHemisphereLight: !0,
					copy: function (t) {
						return Ps.prototype.copy.call(this, t), this.groundColor.copy(t.groundColor), this
					}
				}), Object.assign(Rs.prototype, {
					copy: function (t) {
						return this.camera = t.camera.clone(), this.bias = t.bias, this.radius = t.radius,
							this.mapSize.copy(t.mapSize), this
					},
					clone: function () {
						return (new this.constructor).copy(this)
					},
					toJSON: function () {
						var t = {};
						return 0 !== this.bias && (t.bias = this.bias), 1 !== this.radius && (t.radius =
								this.radius), 512 === this.mapSize.x && 512 === this.mapSize.y || (t
								.mapSize = this.mapSize.toArray()), t.camera = this.camera.toJSON(!1)
							.object, delete t.camera.matrix, t
					}
				}), Os.prototype = Object.assign(Object.create(Rs.prototype), {
					constructor: Os,
					isSpotLightShadow: !0,
					update: function (t) {
						var e = this.camera,
							i = 2 * Ie.RAD2DEG * t.angle,
							n = this.mapSize.width / this.mapSize.height,
							r = t.distance || e.far;
						i === e.fov && n === e.aspect && r === e.far || (e.fov = i, e.aspect = n, e.far =
							r, e.updateProjectionMatrix())
					}
				}), Is.prototype = Object.assign(Object.create(Ps.prototype), {
					constructor: Is,
					isSpotLight: !0,
					copy: function (t) {
						return Ps.prototype.copy.call(this, t), this.distance = t.distance, this.angle = t
							.angle, this.penumbra = t.penumbra, this.decay = t.decay, this.target = t
							.target.clone(), this.shadow = t.shadow.clone(), this
					}
				}), Ds.prototype = Object.assign(Object.create(Ps.prototype), {
					constructor: Ds,
					isPointLight: !0,
					copy: function (t) {
						return Ps.prototype.copy.call(this, t), this.distance = t.distance, this.decay = t
							.decay, this.shadow = t.shadow.clone(), this
					}
				}), Bs.prototype = Object.assign(Object.create(Lr.prototype), {
					constructor: Bs,
					isOrthographicCamera: !0,
					copy: function (t, e) {
						return Lr.prototype.copy.call(this, t, e), this.left = t.left, this.right = t
							.right, this.top = t.top, this.bottom = t.bottom, this.near = t.near, this
							.far = t.far, this.zoom = t.zoom, this.view = null === t.view ? null : Object
							.assign({}, t.view), this
					},
					setViewOffset: function (t, e, i, n, r, a) {
						null === this.view && (this.view = {
								enabled: !0,
								fullWidth: 1,
								fullHeight: 1,
								offsetX: 0,
								offsetY: 0,
								width: 1,
								height: 1
							}), this.view.enabled = !0, this.view.fullWidth = t, this.view.fullHeight = e,
							this.view.offsetX = i, this.view.offsetY = n, this.view.width = r, this.view
							.height = a, this.updateProjectionMatrix()
					},
					clearViewOffset: function () {
						null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
					},
					updateProjectionMatrix: function () {
						var t = (this.right - this.left) / (2 * this.zoom),
							e = (this.top - this.bottom) / (2 * this.zoom),
							i = (this.right + this.left) / 2,
							n = (this.top + this.bottom) / 2,
							r = i - t,
							a = i + t,
							o = n + e,
							s = n - e;
						if (null !== this.view && this.view.enabled) {
							var c = this.zoom / (this.view.width / this.view.fullWidth),
								h = this.zoom / (this.view.height / this.view.fullHeight),
								l = (this.right - this.left) / this.view.width,
								u = (this.top - this.bottom) / this.view.height;
							r += l * (this.view.offsetX / c), a = r + l * (this.view.width / c), o -= u *
								(this.view.offsetY / h), s = o - u * (this.view.height / h)
						}
						this.projectionMatrix.makeOrthographic(r, a, o, s, this.near, this.far), this
							.projectionMatrixInverse.getInverse(this.projectionMatrix)
					},
					toJSON: function (t) {
						var e = Mi.prototype.toJSON.call(this, t);
						return e.object.zoom = this.zoom, e.object.left = this.left, e.object.right = this
							.right, e.object.top = this.top, e.object.bottom = this.bottom, e.object
							.near = this.near, e.object.far = this.far, null !== this.view && (e.object
								.view = Object.assign({}, this.view)), e
					}
				}), zs.prototype = Object.assign(Object.create(Rs.prototype), {
					constructor: zs
				}), Ns.prototype = Object.assign(Object.create(Ps.prototype), {
					constructor: Ns,
					isDirectionalLight: !0,
					copy: function (t) {
						return Ps.prototype.copy.call(this, t), this.target = t.target.clone(), this
							.shadow = t.shadow.clone(), this
					}
				}), Us.prototype = Object.assign(Object.create(Ps.prototype), {
					constructor: Us,
					isAmbientLight: !0
				}), Gs.prototype = Object.assign(Object.create(Ps.prototype), {
					constructor: Gs,
					isRectAreaLight: !0,
					copy: function (t) {
						return Ps.prototype.copy.call(this, t), this.width = t.width, this.height = t
							.height, this
					},
					toJSON: function (t) {
						var e = Ps.prototype.toJSON.call(this, t);
						return e.object.width = this.width, e.object.height = this.height, e
					}
				}), Object.assign(Fs.prototype, {
					load: function (t, e, i, n) {
						var r = this,
							a = new $o(r.manager);
						a.setPath(r.path), a.load(t, function (t) {
							e(r.parse(JSON.parse(t)))
						}, i, n)
					},
					parse: function (t) {
						var e = this.textures;

						function i(t) {
							return void 0 === e[t] && console.warn(
								"THREE.MaterialLoader: Undefined texture", t), e[t]
						}
						var n = new Io[t.type];
						if (void 0 !== t.uuid && (n.uuid = t.uuid), void 0 !== t.name && (n.name = t
							.name), void 0 !== t.color && n.color.setHex(t.color), void 0 !== t
							.roughness && (n.roughness = t.roughness), void 0 !== t.metalness && (n
								.metalness = t.metalness), void 0 !== t.emissive && n.emissive.setHex(t
								.emissive), void 0 !== t.specular && n.specular.setHex(t.specular),
							void 0 !== t.shininess && (n.shininess = t.shininess), void 0 !== t
							.clearCoat && (n.clearCoat = t.clearCoat), void 0 !== t.clearCoatRoughness &&
							(n.clearCoatRoughness = t.clearCoatRoughness), void 0 !== t.vertexColors && (n
								.vertexColors = t.vertexColors), void 0 !== t.fog && (n.fog = t.fog),
							void 0 !== t.flatShading && (n.flatShading = t.flatShading), void 0 !== t
							.blending && (n.blending = t.blending), void 0 !== t.combine && (n.combine = t
								.combine), void 0 !== t.side && (n.side = t.side), void 0 !== t.opacity &&
							(n.opacity = t.opacity), void 0 !== t.transparent && (n.transparent = t
								.transparent), void 0 !== t.alphaTest && (n.alphaTest = t.alphaTest),
							void 0 !== t.depthTest && (n.depthTest = t.depthTest), void 0 !== t
							.depthWrite && (n.depthWrite = t.depthWrite), void 0 !== t.colorWrite && (n
								.colorWrite = t.colorWrite), void 0 !== t.wireframe && (n.wireframe = t
								.wireframe), void 0 !== t.wireframeLinewidth && (n.wireframeLinewidth = t
								.wireframeLinewidth), void 0 !== t.wireframeLinecap && (n
								.wireframeLinecap = t.wireframeLinecap), void 0 !== t.wireframeLinejoin &&
							(n.wireframeLinejoin = t.wireframeLinejoin), void 0 !== t.rotation && (n
								.rotation = t.rotation), 1 !== t.linewidth && (n.linewidth = t.linewidth),
							void 0 !== t.dashSize && (n.dashSize = t.dashSize), void 0 !== t.gapSize && (n
								.gapSize = t.gapSize), void 0 !== t.scale && (n.scale = t.scale),
							void 0 !== t.polygonOffset && (n.polygonOffset = t.polygonOffset), void 0 !==
							t.polygonOffsetFactor && (n.polygonOffsetFactor = t.polygonOffsetFactor),
							void 0 !== t.polygonOffsetUnits && (n.polygonOffsetUnits = t
								.polygonOffsetUnits), void 0 !== t.skinning && (n.skinning = t.skinning),
							void 0 !== t.morphTargets && (n.morphTargets = t.morphTargets), void 0 !== t
							.dithering && (n.dithering = t.dithering), void 0 !== t.visible && (n
								.visible = t.visible), void 0 !== t.userData && (n.userData = t.userData),
							void 0 !== t.uniforms)
							for (var r in t.uniforms) {
								var a = t.uniforms[r];
								switch (n.uniforms[r] = {}, a.type) {
									case "t":
										n.uniforms[r].value = i(a.value);
										break;
									case "c":
										n.uniforms[r].value = (new hi).setHex(a.value);
										break;
									case "v2":
										n.uniforms[r].value = (new De).fromArray(a.value);
										break;
									case "v3":
										n.uniforms[r].value = (new Ne).fromArray(a.value);
										break;
									case "v4":
										n.uniforms[r].value = (new Xe).fromArray(a.value);
										break;
									case "m4":
										n.uniforms[r].value = (new Be).fromArray(a.value);
										break;
									default:
										n.uniforms[r].value = a.value
								}
							}
						if (void 0 !== t.defines && (n.defines = t.defines), void 0 !== t.vertexShader &&
							(n.vertexShader = t.vertexShader), void 0 !== t.fragmentShader && (n
								.fragmentShader = t.fragmentShader), void 0 !== t.extensions)
							for (var o in t.extensions) n.extensions[o] = t.extensions[o];
						if (void 0 !== t.shading && (n.flatShading = 1 === t.shading), void 0 !== t
							.size && (n.size = t.size), void 0 !== t.sizeAttenuation && (n
								.sizeAttenuation = t.sizeAttenuation), void 0 !== t.map && (n.map = i(t
								.map)), void 0 !== t.alphaMap && (n.alphaMap = i(t.alphaMap), n
								.transparent = !0), void 0 !== t.bumpMap && (n.bumpMap = i(t.bumpMap)),
							void 0 !== t.bumpScale && (n.bumpScale = t.bumpScale), void 0 !== t
							.normalMap && (n.normalMap = i(t.normalMap)), void 0 !== t.normalMapType && (n
								.normalMapType = t.normalMapType), void 0 !== t.normalScale) {
							var s = t.normalScale;
							!1 === Array.isArray(s) && (s = [s, s]), n.normalScale = (new De).fromArray(s)
						}
						return void 0 !== t.displacementMap && (n.displacementMap = i(t.displacementMap)),
							void 0 !== t.displacementScale && (n.displacementScale = t.displacementScale),
							void 0 !== t.displacementBias && (n.displacementBias = t.displacementBias),
							void 0 !== t.roughnessMap && (n.roughnessMap = i(t.roughnessMap)), void 0 !==
							t.metalnessMap && (n.metalnessMap = i(t.metalnessMap)), void 0 !== t
							.emissiveMap && (n.emissiveMap = i(t.emissiveMap)), void 0 !== t
							.emissiveIntensity && (n.emissiveIntensity = t.emissiveIntensity), void 0 !==
							t.specularMap && (n.specularMap = i(t.specularMap)), void 0 !== t.envMap && (n
								.envMap = i(t.envMap)), void 0 !== t.envMapIntensity && (n
								.envMapIntensity = t.envMapIntensity), void 0 !== t.reflectivity && (n
								.reflectivity = t.reflectivity), void 0 !== t.lightMap && (n.lightMap = i(
								t.lightMap)), void 0 !== t.lightMapIntensity && (n.lightMapIntensity = t
								.lightMapIntensity), void 0 !== t.aoMap && (n.aoMap = i(t.aoMap)),
							void 0 !== t.aoMapIntensity && (n.aoMapIntensity = t.aoMapIntensity),
							void 0 !== t.gradientMap && (n.gradientMap = i(t.gradientMap)), n
					},
					setPath: function (t) {
						return this.path = t, this
					},
					setTextures: function (t) {
						return this.textures = t, this
					}
				});
				var Hs = {
					decodeText: function (t) {
						if ("undefined" != typeof TextDecoder) return (new TextDecoder).decode(t);
						for (var e = "", i = 0, n = t.length; i < n; i++) e += String.fromCharCode(t[i]);
						return decodeURIComponent(escape(e))
					},
					extractUrlBase: function (t) {
						var e = t.lastIndexOf("/");
						return -1 === e ? "./" : t.substr(0, e + 1)
					}
				};

				function ks(t) {
					this.manager = void 0 !== t ? t : Qo
				}
				Object.assign(ks.prototype, {
					load: function (t, e, i, n) {
						var r = this,
							a = new $o(r.manager);
						a.setPath(r.path), a.load(t, function (t) {
							e(r.parse(JSON.parse(t)))
						}, i, n)
					},
					parse: function (t) {
						var e = new Hi,
							i = t.data.index;
						if (void 0 !== i) {
							var n = new js[i.type](i.array);
							e.setIndex(new Li(n, 1))
						}
						var r = t.data.attributes;
						for (var a in r) {
							var o = r[a],
								n = new js[o.type](o.array);
							e.addAttribute(a, new Li(n, o.itemSize, o.normalized))
						}
						var s = t.data.groups || t.data.drawcalls || t.data.offsets;
						if (void 0 !== s)
							for (var c = 0, h = s.length; c !== h; ++c) {
								var l = s[c];
								e.addGroup(l.start, l.count, l.materialIndex)
							}
						var u = t.data.boundingSphere;
						if (void 0 !== u) {
							var p = new Ne;
							void 0 !== u.center && p.fromArray(u.center), e.boundingSphere = new Ke(p, u
								.radius)
						}
						return t.name && (e.name = t.name), t.userData && (e.userData = t.userData), e
					},
					setPath: function (t) {
						return this.path = t, this
					}
				});
				var js = {
					Int8Array: Int8Array,
					Uint8Array: Uint8Array,
					Uint8ClampedArray: "undefined" != typeof Uint8ClampedArray ? Uint8ClampedArray : Uint8Array,
					Int16Array: Int16Array,
					Uint16Array: Uint16Array,
					Int32Array: Int32Array,
					Uint32Array: Uint32Array,
					Float32Array: Float32Array,
					Float64Array: Float64Array
				};

				function Vs(t) {
					this.manager = void 0 !== t ? t : Qo, this.resourcePath = ""
				}
				Object.assign(Vs.prototype, {
					crossOrigin: "anonymous",
					load: function (t, e, i, n) {
						var r = this,
							a = void 0 === this.path ? Hs.extractUrlBase(t) : this.path;
						this.resourcePath = this.resourcePath || a;
						var o = new $o(r.manager);
						o.setPath(this.path), o.load(t, function (i) {
							var a = null;
							try {
								a = JSON.parse(i)
							} catch (e) {
								return void 0 !== n && n(e), void console.error(
									"THREE:ObjectLoader: Can't parse " + t + ".", e.message)
							}
							var o = a.metadata;
							void 0 !== o && void 0 !== o.type && "geometry" !== o.type
								.toLowerCase() ? r.parse(a, e) : console.error(
									"THREE.ObjectLoader: Can't load " + t)
						}, i, n)
					},
					setPath: function (t) {
						return this.path = t, this
					},
					setResourcePath: function (t) {
						return this.resourcePath = t, this
					},
					setCrossOrigin: function (t) {
						return this.crossOrigin = t, this
					},
					parse: function (t, e) {
						var i = this.parseShape(t.shapes),
							n = this.parseGeometries(t.geometries, i),
							r = this.parseImages(t.images, function () {
								void 0 !== e && e(s)
							}),
							a = this.parseTextures(t.textures, r),
							o = this.parseMaterials(t.materials, a),
							s = this.parseObject(t.object, n, o);
						return t.animations && (s.animations = this.parseAnimations(t.animations)),
							void 0 !== t.images && 0 !== t.images.length || void 0 !== e && e(s), s
					},
					parseShape: function (t) {
						var e = {};
						if (void 0 !== t)
							for (var i = 0, n = t.length; i < n; i++) {
								var r = (new Ls).fromJSON(t[i]);
								e[r.uuid] = r
							}
						return e
					},
					parseGeometries: function (t, e) {
						var i = {};
						if (void 0 !== t)
							for (var n = new ks, r = 0, a = t.length; r < a; r++) {
								var o, s = t[r];
								switch (s.type) {
									case "PlaneGeometry":
									case "PlaneBufferGeometry":
										o = new wo[s.type](s.width, s.height, s.widthSegments, s
											.heightSegments);
										break;
									case "BoxGeometry":
									case "BoxBufferGeometry":
									case "CubeGeometry":
										o = new wo[s.type](s.width, s.height, s.depth, s.widthSegments, s
											.heightSegments, s.depthSegments);
										break;
									case "CircleGeometry":
									case "CircleBufferGeometry":
										o = new wo[s.type](s.radius, s.segments, s.thetaStart, s
											.thetaLength);
										break;
									case "CylinderGeometry":
									case "CylinderBufferGeometry":
										o = new wo[s.type](s.radiusTop, s.radiusBottom, s.height, s
											.radialSegments, s.heightSegments, s.openEnded, s
											.thetaStart, s.thetaLength);
										break;
									case "ConeGeometry":
									case "ConeBufferGeometry":
										o = new wo[s.type](s.radius, s.height, s.radialSegments, s
											.heightSegments, s.openEnded, s.thetaStart, s.thetaLength);
										break;
									case "SphereGeometry":
									case "SphereBufferGeometry":
										o = new wo[s.type](s.radius, s.widthSegments, s.heightSegments, s
											.phiStart, s.phiLength, s.thetaStart, s.thetaLength);
										break;
									case "DodecahedronGeometry":
									case "DodecahedronBufferGeometry":
									case "IcosahedronGeometry":
									case "IcosahedronBufferGeometry":
									case "OctahedronGeometry":
									case "OctahedronBufferGeometry":
									case "TetrahedronGeometry":
									case "TetrahedronBufferGeometry":
										o = new wo[s.type](s.radius, s.detail);
										break;
									case "RingGeometry":
									case "RingBufferGeometry":
										o = new wo[s.type](s.innerRadius, s.outerRadius, s.thetaSegments,
											s.phiSegments, s.thetaStart, s.thetaLength);
										break;
									case "TorusGeometry":
									case "TorusBufferGeometry":
										o = new wo[s.type](s.radius, s.tube, s.radialSegments, s
											.tubularSegments, s.arc);
										break;
									case "TorusKnotGeometry":
									case "TorusKnotBufferGeometry":
										o = new wo[s.type](s.radius, s.tube, s.tubularSegments, s
											.radialSegments, s.p, s.q);
										break;
									case "LatheGeometry":
									case "LatheBufferGeometry":
										o = new wo[s.type](s.points, s.segments, s.phiStart, s.phiLength);
										break;
									case "PolyhedronGeometry":
									case "PolyhedronBufferGeometry":
										o = new wo[s.type](s.vertices, s.indices, s.radius, s.details);
										break;
									case "ShapeGeometry":
									case "ShapeBufferGeometry":
										for (var c = [], h = 0, l = s.shapes.length; h < l; h++) {
											var u = e[s.shapes[h]];
											c.push(u)
										}
										o = new wo[s.type](c, s.curveSegments);
										break;
									case "ExtrudeGeometry":
									case "ExtrudeBufferGeometry":
										for (var c = [], h = 0, l = s.shapes.length; h < l; h++) {
											var u = e[s.shapes[h]];
											c.push(u)
										}
										var p = s.options.extrudePath;
										void 0 !== p && (s.options.extrudePath = (new Es[p.type])
											.fromJSON(p)), o = new wo[s.type](c, s.options);
										break;
									case "BufferGeometry":
										o = n.parse(s);
										break;
									case "Geometry":
										if ("THREE" in window && "LegacyJSONLoader" in THREE) {
											var d = new THREE.LegacyJSONLoader;
											o = d.parse(s, this.resourcePath).geometry
										} else console.error(
											'THREE.ObjectLoader: You have to import LegacyJSONLoader in order load geometry data of type "Geometry".'
											);
										break;
									default:
										console.warn('THREE.ObjectLoader: Unsupported geometry type "' + s
											.type + '"');
										continue
								}
								o.uuid = s.uuid, void 0 !== s.name && (o.name = s.name), !0 === o
									.isBufferGeometry && void 0 !== s.userData && (o.userData = s
										.userData), i[s.uuid] = o
							}
						return i
					},
					parseMaterials: function (t, e) {
						var i = {},
							n = {};
						if (void 0 !== t) {
							var r = new Fs;
							r.setTextures(e);
							for (var a = 0, o = t.length; a < o; a++) {
								var s = t[a];
								if ("MultiMaterial" === s.type) {
									for (var c = [], h = 0; h < s.materials.length; h++) {
										var l = s.materials[h];
										void 0 === i[l.uuid] && (i[l.uuid] = r.parse(l)), c.push(i[l
											.uuid])
									}
									n[s.uuid] = c
								} else n[s.uuid] = r.parse(s), i[s.uuid] = n[s.uuid]
							}
						}
						return n
					},
					parseAnimations: function (t) {
						for (var e = [], i = 0; i < t.length; i++) {
							var n = t[i],
								r = Xo.parse(n);
							void 0 !== n.uuid && (r.uuid = n.uuid), e.push(r)
						}
						return e
					},
					parseImages: function (t, e) {
						var i = this,
							n = {};

						function r(t) {
							return i.manager.itemStart(t), o.load(t, function () {
								i.manager.itemEnd(t)
							}, void 0, function () {
								i.manager.itemError(t), i.manager.itemEnd(t)
							})
						}
						if (void 0 !== t && t.length > 0) {
							var a = new Zo(e),
								o = new ns(a);
							o.setCrossOrigin(this.crossOrigin);
							for (var s = 0, c = t.length; s < c; s++) {
								var h = t[s],
									l = h.url;
								if (Array.isArray(l)) {
									n[h.uuid] = [];
									for (var u = 0, p = l.length; u < p; u++) {
										var d = l[u],
											f = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(d) ? d : i.resourcePath +
											d;
										n[h.uuid].push(r(f))
									}
								} else {
									var f = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(h.url) ? h.url : i
										.resourcePath + h.url;
									n[h.uuid] = r(f)
								}
							}
						}
						return n
					},
					parseTextures: function (t, e) {
						function i(t, e) {
							return "number" == typeof t ? t : (console.warn(
								"THREE.ObjectLoader.parseTexture: Constant should be in numeric form.",
								t), e[t])
						}
						var n = {};
						if (void 0 !== t)
							for (var r = 0, a = t.length; r < a; r++) {
								var o, s = t[r];
								void 0 === s.image && console.warn(
										'THREE.ObjectLoader: No "image" specified for', s.uuid),
									void 0 === e[s.image] && console.warn(
										"THREE.ObjectLoader: Undefined image", s.image), (o = Array
										.isArray(e[s.image]) ? new dn(e[s.image]) : new qe(e[s.image]))
									.needsUpdate = !0, o.uuid = s.uuid, void 0 !== s.name && (o.name = s
										.name), void 0 !== s.mapping && (o.mapping = i(s.mapping, Zs)),
									void 0 !== s.offset && o.offset.fromArray(s.offset), void 0 !== s
									.repeat && o.repeat.fromArray(s.repeat), void 0 !== s.center && o
									.center.fromArray(s.center), void 0 !== s.rotation && (o.rotation = s
										.rotation), void 0 !== s.wrap && (o.wrapS = i(s.wrap[0], Qs), o
										.wrapT = i(s.wrap[1], Qs)), void 0 !== s.format && (o.format = s
										.format), void 0 !== s.type && (o.type = s.type), void 0 !== s
									.encoding && (o.encoding = s.encoding), void 0 !== s.minFilter && (o
										.minFilter = i(s.minFilter, Ks)), void 0 !== s.magFilter && (o
										.magFilter = i(s.magFilter, Ks)), void 0 !== s.anisotropy && (o
										.anisotropy = s.anisotropy), void 0 !== s.flipY && (o.flipY = s
										.flipY), void 0 !== s.premultiplyAlpha && (o.premultiplyAlpha = s
										.premultiplyAlpha), void 0 !== s.unpackAlignment && (o
										.unpackAlignment = s.unpackAlignment), n[s.uuid] = o
							}
						return n
					},
					parseObject: function (t, e, i) {
						var n;

						function r(t) {
							return void 0 === e[t] && console.warn(
								"THREE.ObjectLoader: Undefined geometry", t), e[t]
						}

						function a(t) {
							if (void 0 !== t) {
								if (Array.isArray(t)) {
									for (var e = [], n = 0, r = t.length; n < r; n++) {
										var a = t[n];
										void 0 === i[a] && console.warn(
											"THREE.ObjectLoader: Undefined material", a), e.push(i[a])
									}
									return e
								}
								return void 0 === i[t] && console.warn(
									"THREE.ObjectLoader: Undefined material", t), i[t]
							}
						}
						switch (t.type) {
							case "Scene":
								n = new Vr, void 0 !== t.background && Number.isInteger(t.background) && (
									n.background = new hi(t.background)), void 0 !== t.fog && (
									"Fog" === t.fog.type ? n.fog = new jr(t.fog.color, t.fog.near, t
										.fog.far) : "FogExp2" === t.fog.type && (n.fog = new kr(t.fog
										.color, t.fog.density)));
								break;
							case "PerspectiveCamera":
								n = new Pr(t.fov, t.aspect, t.near, t.far), void 0 !== t.focus && (n
										.focus = t.focus), void 0 !== t.zoom && (n.zoom = t.zoom),
									void 0 !== t.filmGauge && (n.filmGauge = t.filmGauge), void 0 !== t
									.filmOffset && (n.filmOffset = t.filmOffset), void 0 !== t.view && (n
										.view = Object.assign({}, t.view));
								break;
							case "OrthographicCamera":
								n = new Bs(t.left, t.right, t.top, t.bottom, t.near, t.far), void 0 !== t
									.zoom && (n.zoom = t.zoom), void 0 !== t.view && (n.view = Object
										.assign({}, t.view));
								break;
							case "AmbientLight":
								n = new Us(t.color, t.intensity);
								break;
							case "DirectionalLight":
								n = new Ns(t.color, t.intensity);
								break;
							case "PointLight":
								n = new Ds(t.color, t.intensity, t.distance, t.decay);
								break;
							case "RectAreaLight":
								n = new Gs(t.color, t.intensity, t.width, t.height);
								break;
							case "SpotLight":
								n = new Is(t.color, t.intensity, t.distance, t.angle, t.penumbra, t
								.decay);
								break;
							case "HemisphereLight":
								n = new Cs(t.color, t.groundColor, t.intensity);
								break;
							case "SkinnedMesh":
								console.warn(
									"THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet."
									);
							case "Mesh":
								var o = r(t.geometry),
									s = a(t.material);
								n = o.bones && o.bones.length > 0 ? new Zr(o, s) : new un(o, s);
								break;
							case "LOD":
								n = new Jr;
								break;
							case "Line":
								n = new ta(r(t.geometry), a(t.material), t.mode);
								break;
							case "LineLoop":
								n = new ia(r(t.geometry), a(t.material));
								break;
							case "LineSegments":
								n = new ea(r(t.geometry), a(t.material));
								break;
							case "PointCloud":
							case "Points":
								n = new ra(r(t.geometry), a(t.material));
								break;
							case "Sprite":
								n = new Yr(a(t.material));
								break;
							case "Group":
								n = new Ar;
								break;
							default:
								n = new Mi
						}
						if (n.uuid = t.uuid, void 0 !== t.name && (n.name = t.name), void 0 !== t.matrix ?
							(n.matrix.fromArray(t.matrix), void 0 !== t.matrixAutoUpdate && (n
									.matrixAutoUpdate = t.matrixAutoUpdate), n.matrixAutoUpdate && n
								.matrix.decompose(n.position, n.quaternion, n.scale)) : (void 0 !== t
								.position && n.position.fromArray(t.position), void 0 !== t.rotation && n
								.rotation.fromArray(t.rotation), void 0 !== t.quaternion && n.quaternion
								.fromArray(t.quaternion), void 0 !== t.scale && n.scale.fromArray(t.scale)
								), void 0 !== t.castShadow && (n.castShadow = t.castShadow), void 0 !== t
							.receiveShadow && (n.receiveShadow = t.receiveShadow), t.shadow && (void 0 !==
								t.shadow.bias && (n.shadow.bias = t.shadow.bias), void 0 !== t.shadow
								.radius && (n.shadow.radius = t.shadow.radius), void 0 !== t.shadow
								.mapSize && n.shadow.mapSize.fromArray(t.shadow.mapSize), void 0 !== t
								.shadow.camera && (n.shadow.camera = this.parseObject(t.shadow.camera))),
							void 0 !== t.visible && (n.visible = t.visible), void 0 !== t.frustumCulled &&
							(n.frustumCulled = t.frustumCulled), void 0 !== t.renderOrder && (n
								.renderOrder = t.renderOrder), void 0 !== t.userData && (n.userData = t
								.userData), void 0 !== t.layers && (n.layers.mask = t.layers), void 0 !==
							t.children)
							for (var c = t.children, h = 0; h < c.length; h++) n.add(this.parseObject(c[
								h], e, i));
						if ("LOD" === t.type)
							for (var l = t.levels, u = 0; u < l.length; u++) {
								var p = l[u],
									d = n.getObjectByProperty("uuid", p.object);
								void 0 !== d && n.addLevel(d, p.distance)
							}
						return n
					}
				});
				var Ws, qs, Xs, Ys, Js, Zs = {
						UVMapping: 300,
						CubeReflectionMapping: ut,
						CubeRefractionMapping: pt,
						EquirectangularReflectionMapping: dt,
						EquirectangularRefractionMapping: ft,
						SphericalReflectionMapping: mt,
						CubeUVReflectionMapping: gt,
						CubeUVRefractionMapping: vt
					},
					Qs = {
						RepeatWrapping: yt,
						ClampToEdgeWrapping: xt,
						MirroredRepeatWrapping: bt
					},
					Ks = {
						NearestFilter: _t,
						NearestMipMapNearestFilter: wt,
						NearestMipMapLinearFilter: Mt,
						LinearFilter: St,
						LinearMipMapNearestFilter: Et,
						LinearMipMapLinearFilter: Tt
					};

				function $s(t) {
					"undefined" == typeof createImageBitmap && console.warn(
							"THREE.ImageBitmapLoader: createImageBitmap() not supported."), "undefined" ==
						typeof fetch && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), this
						.manager = void 0 !== t ? t : Qo, this.options = void 0
				}

				function tc() {
					this.type = "ShapePath", this.color = new hi, this.subPaths = [], this.currentPath = null
				}

				function ec(t) {
					this.type = "Font", this.data = t
				}

				function ic(t, e, i, n, r) {
					var a = r.glyphs[t] || r.glyphs["?"];
					if (a) {
						var o, s, c, h, l, u, p, d, f = new tc;
						if (a.o)
							for (var m = a._cachedOutline || (a._cachedOutline = a.o.split(" ")), g = 0, v = m
								.length; g < v;) {
								var y = m[g++];
								switch (y) {
									case "m":
										o = m[g++] * e + i, s = m[g++] * e + n, f.moveTo(o, s);
										break;
									case "l":
										o = m[g++] * e + i, s = m[g++] * e + n, f.lineTo(o, s);
										break;
									case "q":
										c = m[g++] * e + i, h = m[g++] * e + n, l = m[g++] * e + i, u = m[g++] * e +
											n, f.quadraticCurveTo(l, u, c, h);
										break;
									case "b":
										c = m[g++] * e + i, h = m[g++] * e + n, l = m[g++] * e + i, u = m[g++] * e +
											n, p = m[g++] * e + i, d = m[g++] * e + n, f.bezierCurveTo(l, u, p, d, c,
												h)
								}
							}
						return {
							offsetX: a.ha * e,
							path: f
						}
					}
				}

				function nc(t) {
					this.manager = void 0 !== t ? t : Qo
				}

				function rc() {}
				$s.prototype = {
					constructor: $s,
					setOptions: function (t) {
						return this.options = t, this
					},
					load: function (t, e, i, n) {
						void 0 === t && (t = ""), void 0 !== this.path && (t = this.path + t), t = this
							.manager.resolveURL(t);
						var r = this,
							a = Jo.get(t);
						if (void 0 !== a) return r.manager.itemStart(t), setTimeout(function () {
							e && e(a), r.manager.itemEnd(t)
						}, 0), a;
						fetch(t).then(function (t) {
							return t.blob()
						}).then(function (t) {
							return createImageBitmap(t, r.options)
						}).then(function (i) {
							Jo.add(t, i), e && e(i), r.manager.itemEnd(t)
						}).catch(function (e) {
							n && n(e), r.manager.itemError(t), r.manager.itemEnd(t)
						})
					},
					setCrossOrigin: function () {
						return this
					},
					setPath: function (t) {
						return this.path = t, this
					}
				}, Object.assign(tc.prototype, {
					moveTo: function (t, e) {
						this.currentPath = new As, this.subPaths.push(this.currentPath), this.currentPath
							.moveTo(t, e)
					},
					lineTo: function (t, e) {
						this.currentPath.lineTo(t, e)
					},
					quadraticCurveTo: function (t, e, i, n) {
						this.currentPath.quadraticCurveTo(t, e, i, n)
					},
					bezierCurveTo: function (t, e, i, n, r, a) {
						this.currentPath.bezierCurveTo(t, e, i, n, r, a)
					},
					splineThru: function (t) {
						this.currentPath.splineThru(t)
					},
					toShapes: function (t, e) {
						function i(t) {
							for (var e = [], i = 0, n = t.length; i < n; i++) {
								var r = t[i],
									a = new Ls;
								a.curves = r.curves, e.push(a)
							}
							return e
						}

						function n(t, e) {
							for (var i = e.length, n = !1, r = i - 1, a = 0; a < i; r = a++) {
								var o = e[r],
									s = e[a],
									c = s.x - o.x,
									h = s.y - o.y;
								if (Math.abs(h) > Number.EPSILON) {
									if (h < 0 && (o = e[a], c = -c, s = e[r], h = -h), t.y < o.y || t.y >
										s.y) continue;
									if (t.y === o.y) {
										if (t.x === o.x) return !0
									} else {
										var l = h * (t.x - o.x) - c * (t.y - o.y);
										if (0 === l) return !0;
										if (l < 0) continue;
										n = !n
									}
								} else {
									if (t.y !== o.y) continue;
									if (s.x <= t.x && t.x <= o.x || o.x <= t.x && t.x <= s.x) return !0
								}
							}
							return n
						}
						var r = Za.isClockWise,
							a = this.subPaths;
						if (0 === a.length) return [];
						if (!0 === e) return i(a);
						var o, s, c, h = [];
						if (1 === a.length) return s = a[0], (c = new Ls).curves = s.curves, h.push(c), h;
						var l = !r(a[0].getPoints());
						l = t ? !l : l;
						var u, p, d = [],
							f = [],
							m = [],
							g = 0;
						f[g] = void 0, m[g] = [];
						for (var v = 0, y = a.length; v < y; v++) s = a[v], u = s.getPoints(), o = r(u), (
							o = t ? !o : o) ? (!l && f[g] && g++, f[g] = {
							s: new Ls,
							p: u
						}, f[g].s.curves = s.curves, l && g++, m[g] = []) : m[g].push({
							h: s,
							p: u[0]
						});
						if (!f[0]) return i(a);
						if (f.length > 1) {
							for (var x = !1, b = [], _ = 0, w = f.length; _ < w; _++) d[_] = [];
							for (var _ = 0, w = f.length; _ < w; _++)
								for (var M = m[_], S = 0; S < M.length; S++) {
									for (var E = M[S], T = !0, A = 0; A < f.length; A++) n(E.p, f[A].p) &&
										(_ !== A && b.push({
											froms: _,
											tos: A,
											hole: S
										}), T ? (T = !1, d[A].push(E)) : x = !0);
									T && d[_].push(E)
								}
							b.length > 0 && (x || (m = d))
						}
						for (var v = 0, L = f.length; v < L; v++) {
							c = f[v].s, h.push(c), p = m[v];
							for (var P = 0, C = p.length; P < C; P++) c.holes.push(p[P].h)
						}
						return h
					}
				}), Object.assign(ec.prototype, {
					isFont: !0,
					generateShapes: function (t, e) {
						void 0 === e && (e = 100);
						for (var i = [], n = function (t, e, i) {
								for (var n = Array.from ? Array.from(t) : String(t).split(""), r = e /
										i.resolution, a = (i.boundingBox.yMax - i.boundingBox.yMin + i
											.underlineThickness) * r, o = [], s = 0, c = 0, h = 0; h <
									n.length; h++) {
									var l = n[h];
									if ("\n" === l) s = 0, c -= a;
									else {
										var u = ic(l, r, s, c, i);
										s += u.offsetX, o.push(u.path)
									}
								}
								return o
							}(t, e, this.data), r = 0, a = n.length; r < a; r++) Array.prototype.push
							.apply(i, n[r].toShapes());
						return i
					}
				}), Object.assign(nc.prototype, {
					load: function (t, e, i, n) {
						var r = this,
							a = new $o(this.manager);
						a.setPath(this.path), a.load(t, function (t) {
							var i;
							try {
								i = JSON.parse(t)
							} catch (e) {
								console.warn(
									"THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."
									), i = JSON.parse(t.substring(65, t.length - 2))
							}
							var n = r.parse(i);
							e && e(n)
						}, i, n)
					},
					parse: function (t) {
						return new ec(t)
					},
					setPath: function (t) {
						return this.path = t, this
					}
				}), rc.Handlers = {
					handlers: [],
					add: function (t, e) {
						this.handlers.push(t, e)
					},
					get: function (t) {
						for (var e = this.handlers, i = 0, n = e.length; i < n; i += 2) {
							var r = e[i],
								a = e[i + 1];
							if (r.test(t)) return a
						}
						return null
					}
				}, Object.assign(rc.prototype, {
					crossOrigin: "anonymous",
					onLoadStart: function () {},
					onLoadProgress: function () {},
					onLoadComplete: function () {},
					initMaterials: function (t, e, i) {
						for (var n = [], r = 0; r < t.length; ++r) n[r] = this.createMaterial(t[r], e, i);
						return n
					},
					createMaterial: (qs = {
						NoBlending: T,
						NormalBlending: A,
						AdditiveBlending: L,
						SubtractiveBlending: P,
						MultiplyBlending: C,
						CustomBlending: R
					}, Xs = new hi, Ys = new as, Js = new Fs, function (t, e, i) {
						var n = {};

						function r(t, r, a, o, s) {
							var c, h = e + t,
								l = rc.Handlers.get(h);
							null !== l ? c = l.load(h) : (Ys.setCrossOrigin(i), c = Ys.load(h)),
								void 0 !== r && (c.repeat.fromArray(r), 1 !== r[0] && (c.wrapS = yt),
									1 !== r[1] && (c.wrapT = yt)), void 0 !== a && c.offset.fromArray(
									a), void 0 !== o && ("repeat" === o[0] && (c.wrapS = yt),
									"mirror" === o[0] && (c.wrapS = bt), "repeat" === o[1] && (c
										.wrapT = yt), "mirror" === o[1] && (c.wrapT = bt)), void 0 !==
								s && (c.anisotropy = s);
							var u = Ie.generateUUID();
							return n[u] = c, u
						}
						var a = {
							uuid: Ie.generateUUID(),
							type: "MeshLambertMaterial"
						};
						for (var o in t) {
							var s = t[o];
							switch (o) {
								case "DbgColor":
								case "DbgIndex":
								case "opticalDensity":
								case "illumination":
									break;
								case "DbgName":
									a.name = s;
									break;
								case "blending":
									a.blending = qs[s];
									break;
								case "colorAmbient":
								case "mapAmbient":
									console.warn("THREE.Loader.createMaterial:", o,
										"is no longer supported.");
									break;
								case "colorDiffuse":
									a.color = Xs.fromArray(s).getHex();
									break;
								case "colorSpecular":
									a.specular = Xs.fromArray(s).getHex();
									break;
								case "colorEmissive":
									a.emissive = Xs.fromArray(s).getHex();
									break;
								case "specularCoef":
									a.shininess = s;
									break;
								case "shading":
									"basic" === s.toLowerCase() && (a.type = "MeshBasicMaterial"),
										"phong" === s.toLowerCase() && (a.type = "MeshPhongMaterial"),
										"standard" === s.toLowerCase() && (a.type =
											"MeshStandardMaterial");
									break;
								case "mapDiffuse":
									a.map = r(s, t.mapDiffuseRepeat, t.mapDiffuseOffset, t
										.mapDiffuseWrap, t.mapDiffuseAnisotropy);
									break;
								case "mapDiffuseRepeat":
								case "mapDiffuseOffset":
								case "mapDiffuseWrap":
								case "mapDiffuseAnisotropy":
									break;
								case "mapEmissive":
									a.emissiveMap = r(s, t.mapEmissiveRepeat, t.mapEmissiveOffset, t
										.mapEmissiveWrap, t.mapEmissiveAnisotropy);
									break;
								case "mapEmissiveRepeat":
								case "mapEmissiveOffset":
								case "mapEmissiveWrap":
								case "mapEmissiveAnisotropy":
									break;
								case "mapLight":
									a.lightMap = r(s, t.mapLightRepeat, t.mapLightOffset, t
										.mapLightWrap, t.mapLightAnisotropy);
									break;
								case "mapLightRepeat":
								case "mapLightOffset":
								case "mapLightWrap":
								case "mapLightAnisotropy":
									break;
								case "mapAO":
									a.aoMap = r(s, t.mapAORepeat, t.mapAOOffset, t.mapAOWrap, t
										.mapAOAnisotropy);
									break;
								case "mapAORepeat":
								case "mapAOOffset":
								case "mapAOWrap":
								case "mapAOAnisotropy":
									break;
								case "mapBump":
									a.bumpMap = r(s, t.mapBumpRepeat, t.mapBumpOffset, t.mapBumpWrap,
										t.mapBumpAnisotropy);
									break;
								case "mapBumpScale":
									a.bumpScale = s;
									break;
								case "mapBumpRepeat":
								case "mapBumpOffset":
								case "mapBumpWrap":
								case "mapBumpAnisotropy":
									break;
								case "mapNormal":
									a.normalMap = r(s, t.mapNormalRepeat, t.mapNormalOffset, t
										.mapNormalWrap, t.mapNormalAnisotropy);
									break;
								case "mapNormalFactor":
									a.normalScale = s;
									break;
								case "mapNormalRepeat":
								case "mapNormalOffset":
								case "mapNormalWrap":
								case "mapNormalAnisotropy":
									break;
								case "mapSpecular":
									a.specularMap = r(s, t.mapSpecularRepeat, t.mapSpecularOffset, t
										.mapSpecularWrap, t.mapSpecularAnisotropy);
									break;
								case "mapSpecularRepeat":
								case "mapSpecularOffset":
								case "mapSpecularWrap":
								case "mapSpecularAnisotropy":
									break;
								case "mapMetalness":
									a.metalnessMap = r(s, t.mapMetalnessRepeat, t.mapMetalnessOffset,
										t.mapMetalnessWrap, t.mapMetalnessAnisotropy);
									break;
								case "mapMetalnessRepeat":
								case "mapMetalnessOffset":
								case "mapMetalnessWrap":
								case "mapMetalnessAnisotropy":
									break;
								case "mapRoughness":
									a.roughnessMap = r(s, t.mapRoughnessRepeat, t.mapRoughnessOffset,
										t.mapRoughnessWrap, t.mapRoughnessAnisotropy);
									break;
								case "mapRoughnessRepeat":
								case "mapRoughnessOffset":
								case "mapRoughnessWrap":
								case "mapRoughnessAnisotropy":
									break;
								case "mapAlpha":
									a.alphaMap = r(s, t.mapAlphaRepeat, t.mapAlphaOffset, t
										.mapAlphaWrap, t.mapAlphaAnisotropy);
									break;
								case "mapAlphaRepeat":
								case "mapAlphaOffset":
								case "mapAlphaWrap":
								case "mapAlphaAnisotropy":
									break;
								case "flipSided":
									a.side = _;
									break;
								case "doubleSided":
									a.side = w;
									break;
								case "transparency":
									console.warn(
										"THREE.Loader.createMaterial: transparency has been renamed to opacity"
										), a.opacity = s;
									break;
								case "depthTest":
								case "depthWrite":
								case "colorWrite":
								case "opacity":
								case "reflectivity":
								case "transparent":
								case "visible":
								case "wireframe":
									a[o] = s;
									break;
								case "vertexColors":
									!0 === s && (a.vertexColors = E), "face" === s && (a
										.vertexColors = S);
									break;
								default:
									console.error("THREE.Loader.createMaterial: Unsupported", o, s)
							}
						}
						return "MeshBasicMaterial" === a.type && delete a.emissive,
							"MeshPhongMaterial" !== a.type && delete a.specular, a.opacity < 1 && (a
								.transparent = !0), Js.setTextures(n), Js.parse(a)
					})
				});
				var ac, oc, sc, cc, hc, lc, uc, pc, dc, fc, mc, gc, vc, yc, xc, bc, _c, wc, Mc, Sc, Ec, Tc, Ac, Lc,
					Pc, Cc = {
						getContext: function () {
							return void 0 === Ws && (Ws = new(window.AudioContext || window.webkitAudioContext)),
								Ws
						},
						setContext: function (t) {
							Ws = t
						}
					};

				function Rc(t) {
					this.manager = void 0 !== t ? t : Qo
				}

				function Oc() {
					this.type = "StereoCamera", this.aspect = 1, this.eyeSep = .064, this.cameraL = new Pr, this
						.cameraL.layers.enable(1), this.cameraL.matrixAutoUpdate = !1, this.cameraR = new Pr, this
						.cameraR.layers.enable(2), this.cameraR.matrixAutoUpdate = !1
				}

				function Ic(t, e, i, n) {
					Mi.call(this), this.type = "CubeCamera";
					var r = new Pr(90, 1, t, e);
					r.up.set(0, -1, 0), r.lookAt(new Ne(1, 0, 0)), this.add(r);
					var a = new Pr(90, 1, t, e);
					a.up.set(0, -1, 0), a.lookAt(new Ne(-1, 0, 0)), this.add(a);
					var o = new Pr(90, 1, t, e);
					o.up.set(0, 0, 1), o.lookAt(new Ne(0, 1, 0)), this.add(o);
					var s = new Pr(90, 1, t, e);
					s.up.set(0, 0, -1), s.lookAt(new Ne(0, -1, 0)), this.add(s);
					var c = new Pr(90, 1, t, e);
					c.up.set(0, -1, 0), c.lookAt(new Ne(0, 0, 1)), this.add(c);
					var h = new Pr(90, 1, t, e);
					h.up.set(0, -1, 0), h.lookAt(new Ne(0, 0, -1)), this.add(h), n = n || {
							format: Ft,
							magFilter: St,
							minFilter: St
						}, this.renderTarget = new Je(i, i, n), this.renderTarget.texture.name = "CubeCamera", this
						.update = function (t, e) {
							null === this.parent && this.updateMatrixWorld();
							var i = this.renderTarget,
								n = i.texture.generateMipmaps;
							i.texture.generateMipmaps = !1, i.activeCubeFace = 0, t.render(e, r, i), i
								.activeCubeFace = 1, t.render(e, a, i), i.activeCubeFace = 2, t.render(e, o, i), i
								.activeCubeFace = 3, t.render(e, s, i), i.activeCubeFace = 4, t.render(e, c, i), i
								.texture.generateMipmaps = n, i.activeCubeFace = 5, t.render(e, h, i), t
								.setRenderTarget(null)
						}, this.clear = function (t, e, i, n) {
							for (var r = this.renderTarget, a = 0; a < 6; a++) r.activeCubeFace = a, t
								.setRenderTarget(r), t.clear(e, i, n);
							t.setRenderTarget(null)
						}
				}

				function Dc(t) {
					this.autoStart = void 0 === t || t, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0,
						this.running = !1
				}

				function Bc() {
					Mi.call(this), this.type = "AudioListener", this.context = Cc.getContext(), this.gain = this
						.context.createGain(), this.gain.connect(this.context.destination), this.filter = null, this
						.timeDelta = 0
				}

				function zc(t) {
					Mi.call(this), this.type = "Audio", this.listener = t, this.context = t.context, this.gain = this
						.context.createGain(), this.gain.connect(t.getInput()), this.autoplay = !1, this.buffer =
						null, this.detune = 0, this.loop = !1, this.startTime = 0, this.offset = 0, this
						.playbackRate = 1, this.isPlaying = !1, this.hasPlaybackControl = !0, this.sourceType =
						"empty", this.filters = []
				}

				function Nc(t) {
					zc.call(this, t), this.panner = this.context.createPanner(), this.panner.connect(this.gain)
				}

				function Uc(t, e) {
					this.analyser = t.context.createAnalyser(), this.analyser.fftSize = void 0 !== e ? e : 2048, this
						.data = new Uint8Array(this.analyser.frequencyBinCount), t.getOutput().connect(this.analyser)
				}

				function Gc(t, e, i) {
					this.binding = t, this.valueSize = i;
					var n, r = Float64Array;
					switch (e) {
						case "quaternion":
							n = this._slerp;
							break;
						case "string":
						case "bool":
							r = Array, n = this._select;
							break;
						default:
							n = this._lerp
					}
					this.buffer = new r(4 * i), this._mixBufferRegion = n, this.cumulativeWeight = 0, this.useCount =
						0, this.referenceCount = 0
				}

				function Fc(t, e, i) {
					var n = i || Hc.parseTrackName(e);
					this._targetGroup = t, this._bindings = t.subscribe_(e, n)
				}

				function Hc(t, e, i) {
					this.path = e, this.parsedPath = i || Hc.parseTrackName(e), this.node = Hc.findNode(t, this
						.parsedPath.nodeName) || t, this.rootNode = t
				}

				function kc() {
					this.uuid = Ie.generateUUID(), this._objects = Array.prototype.slice.call(arguments), this
						.nCachedObjects_ = 0;
					var t = {};
					this._indicesByUUID = t;
					for (var e = 0, i = arguments.length; e !== i; ++e) t[arguments[e].uuid] = e;
					this._paths = [], this._parsedPaths = [], this._bindings = [], this._bindingsIndicesByPath = {};
					var n = this;
					this.stats = {
						objects: {
							get total() {
								return n._objects.length
							},
							get inUse() {
								return this.total - n.nCachedObjects_
							}
						},
						get bindingsPerObject() {
							return n._bindings.length
						}
					}
				}

				function jc(t, e, i) {
					this._mixer = t, this._clip = e, this._localRoot = i || null;
					for (var n = e.tracks, r = n.length, a = new Array(r), o = {
							endingStart: ye,
							endingEnd: ye
						}, s = 0; s !== r; ++s) {
						var c = n[s].createInterpolant(null);
						a[s] = c, c.settings = o
					}
					this._interpolantSettings = o, this._interpolants = a, this._propertyBindings = new Array(r), this
						._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this
						._weightInterpolant = null, this.loop = ve, this._loopCount = -1, this._startTime = null, this
						.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this
						._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this
						.clampWhenFinished = !1, this.zeroSlopeAtStart = !0, this.zeroSlopeAtEnd = !0
				}

				function Vc(t) {
					this._root = t, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1
				}

				function Wc(t) {
					"string" == typeof t && (console.warn("THREE.Uniform: Type parameter is no longer needed."), t =
						arguments[1]), this.value = t
				}

				function qc() {
					Hi.call(this), this.type = "InstancedBufferGeometry", this.maxInstancedCount = void 0
				}

				function Xc(t, e, i) {
					Wr.call(this, t, e), this.meshPerAttribute = i || 1
				}

				function Yc(t, e, i, n) {
					"number" == typeof i && (n = i, i = !1, console.error(
						"THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument."
						)), Li.call(this, t, e, i), this.meshPerAttribute = n || 1
				}

				function Jc(t, e, i, n) {
					this.ray = new cn(t, e), this.near = i || 0, this.far = n || 1 / 0, this.params = {
						Mesh: {},
						Line: {},
						LOD: {},
						Points: {
							threshold: 1
						},
						Sprite: {}
					}, Object.defineProperties(this.params, {
						PointCloud: {
							get: function () {
								return console.warn(
									"THREE.Raycaster: params.PointCloud has been renamed to params.Points."
									), this.Points
							}
						}
					})
				}

				function Zc(t, e) {
					return t.distance - e.distance
				}

				function Qc(t, e, i, n) {
					if (!1 !== t.visible && (t.raycast(e, i), !0 === n))
						for (var r = t.children, a = 0, o = r.length; a < o; a++) Qc(r[a], e, i, !0)
				}

				function Kc(t, e, i) {
					return this.radius = void 0 !== t ? t : 1, this.phi = void 0 !== e ? e : 0, this.theta =
						void 0 !== i ? i : 0, this
				}

				function $c(t, e, i) {
					return this.radius = void 0 !== t ? t : 1, this.theta = void 0 !== e ? e : 0, this.y = void 0 !==
						i ? i : 0, this
				}

				function th(t, e) {
					this.min = void 0 !== t ? t : new De(1 / 0, 1 / 0), this.max = void 0 !== e ? e : new De(-1 / 0, -
						1 / 0)
				}

				function eh(t, e) {
					this.start = void 0 !== t ? t : new Ne, this.end = void 0 !== e ? e : new Ne
				}

				function ih(t) {
					Mi.call(this), this.material = t, this.render = function () {}
				}

				function nh(t, e, i, n) {
					this.object = t, this.size = void 0 !== e ? e : 1;
					var r = void 0 !== i ? i : 16711680,
						a = void 0 !== n ? n : 1,
						o = 0,
						s = this.object.geometry;
					s && s.isGeometry ? o = 3 * s.faces.length : s && s.isBufferGeometry && (o = s.attributes.normal
						.count);
					var c = new Hi,
						h = new zi(2 * o * 3, 3);
					c.addAttribute("position", h), ea.call(this, c, new $r({
						color: r,
						linewidth: a
					})), this.matrixAutoUpdate = !1, this.update()
				}

				function rh(t, e) {
					Mi.call(this), this.light = t, this.light.updateMatrixWorld(), this.matrix = t.matrixWorld, this
						.matrixAutoUpdate = !1, this.color = e;
					for (var i = new Hi, n = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1,
							0, 0, 0, 0, -1, 1
						], r = 0, a = 1; r < 32; r++, a++) {
						var o = r / 32 * Math.PI * 2,
							s = a / 32 * Math.PI * 2;
						n.push(Math.cos(o), Math.sin(o), 1, Math.cos(s), Math.sin(s), 1)
					}
					i.addAttribute("position", new zi(n, 3));
					var c = new $r({
						fog: !1
					});
					this.cone = new ea(i, c), this.add(this.cone), this.update()
				}

				function ah(t) {
					for (var e = function t(e) {
							var i = [];
							e && e.isBone && i.push(e);
							for (var n = 0; n < e.children.length; n++) i.push.apply(i, t(e.children[n]));
							return i
						}(t), i = new Hi, n = [], r = [], a = new hi(0, 0, 1), o = new hi(0, 1, 0), s = 0; s < e
						.length; s++) {
						var c = e[s];
						c.parent && c.parent.isBone && (n.push(0, 0, 0), n.push(0, 0, 0), r.push(a.r, a.g, a.b), r
							.push(o.r, o.g, o.b))
					}
					i.addAttribute("position", new zi(n, 3)), i.addAttribute("color", new zi(r, 3));
					var h = new $r({
						vertexColors: E,
						depthTest: !1,
						depthWrite: !1,
						transparent: !0
					});
					ea.call(this, i, h), this.root = t, this.bones = e, this.matrix = t.matrixWorld, this
						.matrixAutoUpdate = !1
				}

				function oh(t, e, i) {
					this.light = t, this.light.updateMatrixWorld(), this.color = i;
					var n = new oo(e, 4, 2),
						r = new ln({
							wireframe: !0,
							fog: !1
						});
					un.call(this, n, r), this.matrix = this.light.matrixWorld, this.matrixAutoUpdate = !1, this
						.update()
				}

				function sh(t, e) {
					this.type = "RectAreaLightHelper", this.light = t, this.color = e;
					var i = new Hi;
					i.addAttribute("position", new zi([1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0, 1, 1, 0], 3)), i
						.computeBoundingSphere();
					var n = new $r({
						fog: !1
					});
					ta.call(this, i, n);
					var r = new Hi;
					r.addAttribute("position", new zi([1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0],
						3)), r.computeBoundingSphere(), this.add(new un(r, new ln({
						side: THREE.BackSide,
						fog: !1
					}))), this.update()
				}

				function ch(t, e, i) {
					Mi.call(this), this.light = t, this.light.updateMatrixWorld(), this.matrix = t.matrixWorld, this
						.matrixAutoUpdate = !1, this.color = i;
					var n = new va(e);
					n.rotateY(.5 * Math.PI), this.material = new ln({
						wireframe: !0,
						fog: !1
					}), void 0 === this.color && (this.material.vertexColors = E);
					var r = n.getAttribute("position"),
						a = new Float32Array(3 * r.count);
					n.addAttribute("color", new Li(a, 3)), this.add(new un(n, this.material)), this.update()
				}

				function hh(t, e, i, n) {
					t = t || 10, e = e || 10, i = new hi(void 0 !== i ? i : 4473924), n = new hi(void 0 !== n ? n :
						8947848);
					for (var r = e / 2, a = t / e, o = t / 2, s = [], c = [], h = 0, l = 0, u = -o; h <= e; h++, u +=
						a) {
						s.push(-o, 0, u, o, 0, u), s.push(u, 0, -o, u, 0, o);
						var p = h === r ? i : n;
						p.toArray(c, l), l += 3, p.toArray(c, l), l += 3, p.toArray(c, l), l += 3, p.toArray(c, l),
							l += 3
					}
					var d = new Hi;
					d.addAttribute("position", new zi(s, 3)), d.addAttribute("color", new zi(c, 3));
					var f = new $r({
						vertexColors: E
					});
					ea.call(this, d, f)
				}

				function lh(t, e, i, n, r, a) {
					t = t || 10, e = e || 16, i = i || 8, n = n || 64, r = new hi(void 0 !== r ? r : 4473924), a =
						new hi(void 0 !== a ? a : 8947848);
					var o, s, c, h, l, u, p, d = [],
						f = [];
					for (h = 0; h <= e; h++) c = h / e * (2 * Math.PI), o = Math.sin(c) * t, s = Math.cos(c) * t, d
						.push(0, 0, 0), d.push(o, 0, s), p = 1 & h ? r : a, f.push(p.r, p.g, p.b), f.push(p.r, p.g, p
							.b);
					for (h = 0; h <= i; h++)
						for (p = 1 & h ? r : a, u = t - t / i * h, l = 0; l < n; l++) c = l / n * (2 * Math.PI), o =
							Math.sin(c) * u, s = Math.cos(c) * u, d.push(o, 0, s), f.push(p.r, p.g, p.b), c = (l +
							1) / n * (2 * Math.PI), o = Math.sin(c) * u, s = Math.cos(c) * u, d.push(o, 0, s), f.push(
								p.r, p.g, p.b);
					var m = new Hi;
					m.addAttribute("position", new zi(d, 3)), m.addAttribute("color", new zi(f, 3));
					var g = new $r({
						vertexColors: E
					});
					ea.call(this, m, g)
				}

				function uh(t, e, i, n) {
					this.object = t, this.size = void 0 !== e ? e : 1;
					var r = void 0 !== i ? i : 16776960,
						a = void 0 !== n ? n : 1,
						o = 0,
						s = this.object.geometry;
					s && s.isGeometry ? o = s.faces.length : console.warn(
						"THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead."
						);
					var c = new Hi,
						h = new zi(2 * o * 3, 3);
					c.addAttribute("position", h), ea.call(this, c, new $r({
						color: r,
						linewidth: a
					})), this.matrixAutoUpdate = !1, this.update()
				}

				function ph(t, e, i) {
					Mi.call(this), this.light = t, this.light.updateMatrixWorld(), this.matrix = t.matrixWorld, this
						.matrixAutoUpdate = !1, this.color = i, void 0 === e && (e = 1);
					var n = new Hi;
					n.addAttribute("position", new zi([-e, e, 0, e, e, 0, e, -e, 0, -e, -e, 0, -e, e, 0], 3));
					var r = new $r({
						fog: !1
					});
					this.lightPlane = new ta(n, r), this.add(this.lightPlane), (n = new Hi).addAttribute("position",
							new zi([0, 0, 0, 0, 0, 1], 3)), this.targetLine = new ta(n, r), this.add(this.targetLine),
						this.update()
				}

				function dh(t) {
					var e = new Hi,
						i = new $r({
							color: 16777215,
							vertexColors: S
						}),
						n = [],
						r = [],
						a = {},
						o = new hi(16755200),
						s = new hi(16711680),
						c = new hi(43775),
						h = new hi(16777215),
						l = new hi(3355443);

					function u(t, e, i) {
						p(t, i), p(e, i)
					}

					function p(t, e) {
						n.push(0, 0, 0), r.push(e.r, e.g, e.b), void 0 === a[t] && (a[t] = []), a[t].push(n.length /
							3 - 1)
					}
					u("n1", "n2", o), u("n2", "n4", o), u("n4", "n3", o), u("n3", "n1", o), u("f1", "f2", o), u("f2",
							"f4", o), u("f4", "f3", o), u("f3", "f1", o), u("n1", "f1", o), u("n2", "f2", o), u("n3",
							"f3", o), u("n4", "f4", o), u("p", "n1", s), u("p", "n2", s), u("p", "n3", s), u("p",
							"n4", s), u("u1", "u2", c), u("u2", "u3", c), u("u3", "u1", c), u("c", "t", h), u("p",
							"c", l), u("cn1", "cn2", l), u("cn3", "cn4", l), u("cf1", "cf2", l), u("cf3", "cf4", l), e
						.addAttribute("position", new zi(n, 3)), e.addAttribute("color", new zi(r, 3)), ea.call(this,
							e, i), this.camera = t, this.camera.updateProjectionMatrix && this.camera
						.updateProjectionMatrix(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this
						.pointMap = a, this.update()
				}

				function fh(t, e) {
					this.object = t, void 0 === e && (e = 16776960);
					var i = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]),
						n = new Float32Array(24),
						r = new Hi;
					r.setIndex(new Li(i, 1)), r.addAttribute("position", new Li(n, 3)), ea.call(this, r, new $r({
						color: e
					})), this.matrixAutoUpdate = !1, this.update()
				}

				function mh(t, e) {
					this.type = "Box3Helper", this.box = t;
					var i = void 0 !== e ? e : 16776960,
						n = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]),
						r = new Hi;
					r.setIndex(new Li(n, 1)), r.addAttribute("position", new zi([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1,
						1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1
					], 3)), ea.call(this, r, new $r({
						color: i
					})), this.geometry.computeBoundingSphere()
				}

				function gh(t, e, i) {
					this.type = "PlaneHelper", this.plane = t, this.size = void 0 === e ? 1 : e;
					var n = void 0 !== i ? i : 16776960,
						r = new Hi;
					r.addAttribute("position", new zi([1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1,
						-1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0
					], 3)), r.computeBoundingSphere(), ta.call(this, r, new $r({
						color: n
					}));
					var a = new Hi;
					a.addAttribute("position", new zi([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1],
						3)), a.computeBoundingSphere(), this.add(new un(a, new ln({
						color: n,
						opacity: .2,
						transparent: !0,
						depthWrite: !1
					})))
				}

				function vh(t, e, i, n, r, a) {
					Mi.call(this), void 0 === t && (t = new THREE.Vector3(0, 0, 1)), void 0 === e && (e = new THREE
							.Vector3(0, 0, 0)), void 0 === i && (i = 1), void 0 === n && (n = 16776960), void 0 ===
						r && (r = .2 * i), void 0 === a && (a = .2 * r), void 0 === mc && ((mc = new Hi).addAttribute(
							"position", new zi([0, 0, 0, 0, 1, 0], 3)), (gc = new vo(0, .5, 1, 5, 1)).translate(0,
							-.5, 0)), this.position.copy(e), this.line = new ta(mc, new $r({
							color: n
						})), this.line.matrixAutoUpdate = !1, this.add(this.line), this.cone = new un(gc, new ln({
							color: n
						})), this.cone.matrixAutoUpdate = !1, this.add(this.cone), this.setDirection(t), this
						.setLength(i, r, a)
				}

				function yh(t) {
					var e = [0, 0, 0, t = t || 1, 0, 0, 0, 0, 0, 0, t, 0, 0, 0, 0, 0, 0, t],
						i = new Hi;
					i.addAttribute("position", new zi(e, 3)), i.addAttribute("color", new zi([1, 0, 0, 1, .6, 0, 0, 1,
						0, .6, 1, 0, 0, 0, 1, 0, .6, 1
					], 3));
					var n = new $r({
						vertexColors: E
					});
					ea.call(this, i, n)
				}

				function xh(t) {
					console.warn("THREE.ClosedSplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."),
						fs.call(this, t), this.type = "catmullrom", this.closed = !0
				}

				function bh(t) {
					console.warn("THREE.SplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."), fs
						.call(this, t), this.type = "catmullrom"
				}

				function _h(t) {
					console.warn("THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead."), fs.call(this,
						t), this.type = "catmullrom"
				}
				Object.assign(Rc.prototype, {
						load: function (t, e, i, n) {
							var r = new $o(this.manager);
							r.setResponseType("arraybuffer"), r.setPath(this.path), r.load(t, function (t) {
								var i = t.slice(0),
									n = Cc.getContext();
								n.decodeAudioData(i, function (t) {
									e(t)
								})
							}, i, n)
						},
						setPath: function (t) {
							return this.path = t, this
						}
					}), Object.assign(Oc.prototype, {
						update: (dc = new Be, fc = new Be, function (t) {
							var e = ac !== this || oc !== t.focus || sc !== t.fov || cc !== t.aspect *
								this.aspect || hc !== t.near || lc !== t.far || uc !== t.zoom || pc !==
								this.eyeSep;
							if (e) {
								ac = this, oc = t.focus, sc = t.fov, cc = t.aspect * this.aspect, hc = t
									.near, lc = t.far, uc = t.zoom;
								var i, n, r = t.projectionMatrix.clone(),
									a = (pc = this.eyeSep / 2) * hc / oc,
									o = hc * Math.tan(Ie.DEG2RAD * sc * .5) / uc;
								fc.elements[12] = -pc, dc.elements[12] = pc, i = -o * cc + a, n = o * cc +
									a, r.elements[0] = 2 * hc / (n - i), r.elements[8] = (n + i) / (n -
									i), this.cameraL.projectionMatrix.copy(r), i = -o * cc - a, n = o *
									cc - a, r.elements[0] = 2 * hc / (n - i), r.elements[8] = (n + i) / (
										n - i), this.cameraR.projectionMatrix.copy(r)
							}
							this.cameraL.matrixWorld.copy(t.matrixWorld).multiply(fc), this.cameraR
								.matrixWorld.copy(t.matrixWorld).multiply(dc)
						})
					}), Ic.prototype = Object.create(Mi.prototype), Ic.prototype.constructor = Ic, Object.assign(Dc
						.prototype, {
							start: function () {
								this.startTime = ("undefined" == typeof performance ? Date : performance).now(),
									this.oldTime = this.startTime, this.elapsedTime = 0, this.running = !0
							},
							stop: function () {
								this.getElapsedTime(), this.running = !1, this.autoStart = !1
							},
							getElapsedTime: function () {
								return this.getDelta(), this.elapsedTime
							},
							getDelta: function () {
								var t = 0;
								if (this.autoStart && !this.running) return this.start(), 0;
								if (this.running) {
									var e = ("undefined" == typeof performance ? Date : performance).now();
									t = (e - this.oldTime) / 1e3, this.oldTime = e, this.elapsedTime += t
								}
								return t
							}
						}), Bc.prototype = Object.assign(Object.create(Mi.prototype), {
						constructor: Bc,
						getInput: function () {
							return this.gain
						},
						removeFilter: function () {
							return null !== this.filter && (this.gain.disconnect(this.filter), this.filter
								.disconnect(this.context.destination), this.gain.connect(this.context
									.destination), this.filter = null), this
						},
						getFilter: function () {
							return this.filter
						},
						setFilter: function (t) {
							return null !== this.filter ? (this.gain.disconnect(this.filter), this.filter
									.disconnect(this.context.destination)) : this.gain.disconnect(this.context
									.destination), this.filter = t, this.gain.connect(this.filter), this
								.filter.connect(this.context.destination), this
						},
						getMasterVolume: function () {
							return this.gain.gain.value
						},
						setMasterVolume: function (t) {
							return this.gain.gain.setTargetAtTime(t, this.context.currentTime, .01), this
						},
						updateMatrixWorld: function () {
							var t = new Ne,
								e = new ze,
								i = new Ne,
								n = new Ne,
								r = new Dc;
							return function (a) {
								Mi.prototype.updateMatrixWorld.call(this, a);
								var o = this.context.listener,
									s = this.up;
								if (this.timeDelta = r.getDelta(), this.matrixWorld.decompose(t, e, i), n
									.set(0, 0, -1).applyQuaternion(e), o.positionX) {
									var c = this.context.currentTime + this.timeDelta;
									o.positionX.linearRampToValueAtTime(t.x, c), o.positionY
										.linearRampToValueAtTime(t.y, c), o.positionZ
										.linearRampToValueAtTime(t.z, c), o.forwardX
										.linearRampToValueAtTime(n.x, c), o.forwardY
										.linearRampToValueAtTime(n.y, c), o.forwardZ
										.linearRampToValueAtTime(n.z, c), o.upX.linearRampToValueAtTime(s
											.x, c), o.upY.linearRampToValueAtTime(s.y, c), o.upZ
										.linearRampToValueAtTime(s.z, c)
								} else o.setPosition(t.x, t.y, t.z), o.setOrientation(n.x, n.y, n.z, s.x,
									s.y, s.z)
							}
						}()
					}), zc.prototype = Object.assign(Object.create(Mi.prototype), {
						constructor: zc,
						getOutput: function () {
							return this.gain
						},
						setNodeSource: function (t) {
							return this.hasPlaybackControl = !1, this.sourceType = "audioNode", this.source =
								t, this.connect(), this
						},
						setMediaElementSource: function (t) {
							return this.hasPlaybackControl = !1, this.sourceType = "mediaNode", this.source =
								this.context.createMediaElementSource(t), this.connect(), this
						},
						setBuffer: function (t) {
							return this.buffer = t, this.sourceType = "buffer", this.autoplay && this.play(),
								this
						},
						play: function () {
							if (!0 !== this.isPlaying) {
								if (!1 !== this.hasPlaybackControl) {
									var t = this.context.createBufferSource();
									return t.buffer = this.buffer, t.detune.value = this.detune, t.loop = this
										.loop, t.onended = this.onEnded.bind(this), t.playbackRate
										.setValueAtTime(this.playbackRate, this.startTime), this.startTime =
										this.context.currentTime, t.start(this.startTime, this.offset), this
										.isPlaying = !0, this.source = t, this.connect()
								}
								console.warn("THREE.Audio: this Audio has no playback control.")
							} else console.warn("THREE.Audio: Audio is already playing.")
						},
						pause: function () {
							if (!1 !== this.hasPlaybackControl) return !0 === this.isPlaying && (this.source
								.stop(), this.source.onended = null, this.offset += (this.context
									.currentTime - this.startTime) * this.playbackRate, this
								.isPlaying = !1), this;
							console.warn("THREE.Audio: this Audio has no playback control.")
						},
						stop: function () {
							if (!1 !== this.hasPlaybackControl) return this.source.stop(), this.source
								.onended = null, this.offset = 0, this.isPlaying = !1, this;
							console.warn("THREE.Audio: this Audio has no playback control.")
						},
						connect: function () {
							if (this.filters.length > 0) {
								this.source.connect(this.filters[0]);
								for (var t = 1, e = this.filters.length; t < e; t++) this.filters[t - 1]
									.connect(this.filters[t]);
								this.filters[this.filters.length - 1].connect(this.getOutput())
							} else this.source.connect(this.getOutput());
							return this
						},
						disconnect: function () {
							if (this.filters.length > 0) {
								this.source.disconnect(this.filters[0]);
								for (var t = 1, e = this.filters.length; t < e; t++) this.filters[t - 1]
									.disconnect(this.filters[t]);
								this.filters[this.filters.length - 1].disconnect(this.getOutput())
							} else this.source.disconnect(this.getOutput());
							return this
						},
						getFilters: function () {
							return this.filters
						},
						setFilters: function (t) {
							return t || (t = []), !0 === this.isPlaying ? (this.disconnect(), this.filters =
								t, this.connect()) : this.filters = t, this
						},
						setDetune: function (t) {
							return this.detune = t, !0 === this.isPlaying && this.source.detune
								.setTargetAtTime(this.detune, this.context.currentTime, .01), this
						},
						getDetune: function () {
							return this.detune
						},
						getFilter: function () {
							return this.getFilters()[0]
						},
						setFilter: function (t) {
							return this.setFilters(t ? [t] : [])
						},
						setPlaybackRate: function (t) {
							if (!1 !== this.hasPlaybackControl) return this.playbackRate = t, !0 === this
								.isPlaying && this.source.playbackRate.setTargetAtTime(this.playbackRate,
									this.context.currentTime, .01), this;
							console.warn("THREE.Audio: this Audio has no playback control.")
						},
						getPlaybackRate: function () {
							return this.playbackRate
						},
						onEnded: function () {
							this.isPlaying = !1
						},
						getLoop: function () {
							return !1 === this.hasPlaybackControl ? (console.warn(
								"THREE.Audio: this Audio has no playback control."), !1) : this.loop
						},
						setLoop: function (t) {
							if (!1 !== this.hasPlaybackControl) return this.loop = t, !0 === this.isPlaying &&
								(this.source.loop = this.loop), this;
							console.warn("THREE.Audio: this Audio has no playback control.")
						},
						getVolume: function () {
							return this.gain.gain.value
						},
						setVolume: function (t) {
							return this.gain.gain.setTargetAtTime(t, this.context.currentTime, .01), this
						}
					}), Nc.prototype = Object.assign(Object.create(zc.prototype), {
						constructor: Nc,
						getOutput: function () {
							return this.panner
						},
						getRefDistance: function () {
							return this.panner.refDistance
						},
						setRefDistance: function (t) {
							return this.panner.refDistance = t, this
						},
						getRolloffFactor: function () {
							return this.panner.rolloffFactor
						},
						setRolloffFactor: function (t) {
							return this.panner.rolloffFactor = t, this
						},
						getDistanceModel: function () {
							return this.panner.distanceModel
						},
						setDistanceModel: function (t) {
							return this.panner.distanceModel = t, this
						},
						getMaxDistance: function () {
							return this.panner.maxDistance
						},
						setMaxDistance: function (t) {
							return this.panner.maxDistance = t, this
						},
						setDirectionalCone: function (t, e, i) {
							return this.panner.coneInnerAngle = t, this.panner.coneOuterAngle = e, this.panner
								.coneOuterGain = i, this
						},
						updateMatrixWorld: function () {
							var t = new Ne,
								e = new ze,
								i = new Ne,
								n = new Ne;
							return function (r) {
								if (Mi.prototype.updateMatrixWorld.call(this, r), !1 !== this.isPlaying) {
									this.matrixWorld.decompose(t, e, i), n.set(0, 0, 1).applyQuaternion(
									e);
									var a = this.panner;
									if (a.positionX) {
										var o = this.context.currentTime + this.listener.timeDelta;
										a.positionX.linearRampToValueAtTime(t.x, o), a.positionY
											.linearRampToValueAtTime(t.y, o), a.positionZ
											.linearRampToValueAtTime(t.z, o), a.orientationX
											.linearRampToValueAtTime(n.x, o), a.orientationY
											.linearRampToValueAtTime(n.y, o), a.orientationZ
											.linearRampToValueAtTime(n.z, o)
									} else a.setPosition(t.x, t.y, t.z), a.setOrientation(n.x, n.y, n.z)
								}
							}
						}()
					}), Object.assign(Uc.prototype, {
						getFrequencyData: function () {
							return this.analyser.getByteFrequencyData(this.data), this.data
						},
						getAverageFrequency: function () {
							for (var t = 0, e = this.getFrequencyData(), i = 0; i < e.length; i++) t += e[i];
							return t / e.length
						}
					}), Object.assign(Gc.prototype, {
						accumulate: function (t, e) {
							var i = this.buffer,
								n = this.valueSize,
								r = t * n + n,
								a = this.cumulativeWeight;
							if (0 === a) {
								for (var o = 0; o !== n; ++o) i[r + o] = i[o];
								a = e
							} else {
								var s = e / (a += e);
								this._mixBufferRegion(i, r, 0, s, n)
							}
							this.cumulativeWeight = a
						},
						apply: function (t) {
							var e = this.valueSize,
								i = this.buffer,
								n = t * e + e,
								r = this.cumulativeWeight,
								a = this.binding;
							if (this.cumulativeWeight = 0, r < 1) {
								var o = 3 * e;
								this._mixBufferRegion(i, n, o, 1 - r, e)
							}
							for (var s = e, c = e + e; s !== c; ++s)
								if (i[s] !== i[s + e]) {
									a.setValue(i, n);
									break
								}
						},
						saveOriginalState: function () {
							var t = this.binding,
								e = this.buffer,
								i = this.valueSize,
								n = 3 * i;
							t.getValue(e, n);
							for (var r = i, a = n; r !== a; ++r) e[r] = e[n + r % i];
							this.cumulativeWeight = 0
						},
						restoreOriginalState: function () {
							var t = 3 * this.valueSize;
							this.binding.setValue(this.buffer, t)
						},
						_select: function (t, e, i, n, r) {
							if (n >= .5)
								for (var a = 0; a !== r; ++a) t[e + a] = t[i + a]
						},
						_slerp: function (t, e, i, n) {
							ze.slerpFlat(t, e, t, e, t, i, n)
						},
						_lerp: function (t, e, i, n, r) {
							for (var a = 1 - n, o = 0; o !== r; ++o) {
								var s = e + o;
								t[s] = t[s] * a + t[i + o] * n
							}
						}
					}), Object.assign(Fc.prototype, {
						getValue: function (t, e) {
							this.bind();
							var i = this._targetGroup.nCachedObjects_,
								n = this._bindings[i];
							void 0 !== n && n.getValue(t, e)
						},
						setValue: function (t, e) {
							for (var i = this._bindings, n = this._targetGroup.nCachedObjects_, r = i
								.length; n !== r; ++n) i[n].setValue(t, e)
						},
						bind: function () {
							for (var t = this._bindings, e = this._targetGroup.nCachedObjects_, i = t
								.length; e !== i; ++e) t[e].bind()
						},
						unbind: function () {
							for (var t = this._bindings, e = this._targetGroup.nCachedObjects_, i = t
								.length; e !== i; ++e) t[e].unbind()
						}
					}), Object.assign(Hc, {
						Composite: Fc,
						create: function (t, e, i) {
							return t && t.isAnimationObjectGroup ? new Hc.Composite(t, e, i) : new Hc(t, e, i)
						},
						sanitizeNodeName: (Pc = new RegExp("[\\[\\]\\.:\\/]", "g"), function (t) {
							return t.replace(/\s/g, "_").replace(Pc, "")
						}),
						parseTrackName: (_c = "[^\\[\\]\\.:\\/]", wc = "[^" + "\\[\\]\\.:\\/".replace("\\.", "") +
							"]", Mc = /((?:WC+[\/:])*)/.source.replace("WC", _c), Sc = /(WCOD+)?/.source
							.replace("WCOD", wc), Ec = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", _c),
							Tc = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", _c), Ac = new RegExp("^" + Mc +
								Sc + Ec + Tc + "$"), Lc = ["material", "materials", "bones"],
							function (t) {
								var e = Ac.exec(t);
								if (!e) throw new Error("PropertyBinding: Cannot parse trackName: " + t);
								var i = {
										nodeName: e[2],
										objectName: e[3],
										objectIndex: e[4],
										propertyName: e[5],
										propertyIndex: e[6]
									},
									n = i.nodeName && i.nodeName.lastIndexOf(".");
								if (void 0 !== n && -1 !== n) {
									var r = i.nodeName.substring(n + 1); - 1 !== Lc.indexOf(r) && (i
										.nodeName = i.nodeName.substring(0, n), i.objectName = r)
								}
								if (null === i.propertyName || 0 === i.propertyName.length) throw new Error(
									"PropertyBinding: can not parse propertyName from trackName: " + t
									);
								return i
							}),
						findNode: function (t, e) {
							if (!e || "" === e || "root" === e || "." === e || -1 === e || e === t.name ||
								e === t.uuid) return t;
							if (t.skeleton) {
								var i = t.skeleton.getBoneByName(e);
								if (void 0 !== i) return i
							}
							if (t.children) {
								var n = function (t) {
										for (var i = 0; i < t.length; i++) {
											var r = t[i];
											if (r.name === e || r.uuid === e) return r;
											var a = n(r.children);
											if (a) return a
										}
										return null
									},
									r = n(t.children);
								if (r) return r
							}
							return null
						}
					}), Object.assign(Hc.prototype, {
						_getValue_unavailable: function () {},
						_setValue_unavailable: function () {},
						BindingType: {
							Direct: 0,
							EntireArray: 1,
							ArrayElement: 2,
							HasFromToArray: 3
						},
						Versioning: {
							None: 0,
							NeedsUpdate: 1,
							MatrixWorldNeedsUpdate: 2
						},
						GetterByBindingType: [function (t, e) {
							t[e] = this.node[this.propertyName]
						}, function (t, e) {
							for (var i = this.resolvedProperty, n = 0, r = i.length; n !== r; ++n) t[
								e++] = i[n]
						}, function (t, e) {
							t[e] = this.resolvedProperty[this.propertyIndex]
						}, function (t, e) {
							this.resolvedProperty.toArray(t, e)
						}],
						SetterByBindingTypeAndVersioning: [
							[function (t, e) {
								this.targetObject[this.propertyName] = t[e]
							}, function (t, e) {
								this.targetObject[this.propertyName] = t[e], this.targetObject
									.needsUpdate = !0
							}, function (t, e) {
								this.targetObject[this.propertyName] = t[e], this.targetObject
									.matrixWorldNeedsUpdate = !0
							}],
							[function (t, e) {
								for (var i = this.resolvedProperty, n = 0, r = i.length; n !== r; ++n) i[
									n] = t[e++]
							}, function (t, e) {
								for (var i = this.resolvedProperty, n = 0, r = i.length; n !== r; ++n) i[
									n] = t[e++];
								this.targetObject.needsUpdate = !0
							}, function (t, e) {
								for (var i = this.resolvedProperty, n = 0, r = i.length; n !== r; ++n) i[
									n] = t[e++];
								this.targetObject.matrixWorldNeedsUpdate = !0
							}],
							[function (t, e) {
								this.resolvedProperty[this.propertyIndex] = t[e]
							}, function (t, e) {
								this.resolvedProperty[this.propertyIndex] = t[e], this.targetObject
									.needsUpdate = !0
							}, function (t, e) {
								this.resolvedProperty[this.propertyIndex] = t[e], this.targetObject
									.matrixWorldNeedsUpdate = !0
							}],
							[function (t, e) {
								this.resolvedProperty.fromArray(t, e)
							}, function (t, e) {
								this.resolvedProperty.fromArray(t, e), this.targetObject.needsUpdate = !0
							}, function (t, e) {
								this.resolvedProperty.fromArray(t, e), this.targetObject
									.matrixWorldNeedsUpdate = !0
							}]
						],
						getValue: function (t, e) {
							this.bind(), this.getValue(t, e)
						},
						setValue: function (t, e) {
							this.bind(), this.setValue(t, e)
						},
						bind: function () {
							var t = this.node,
								e = this.parsedPath,
								i = e.objectName,
								n = e.propertyName,
								r = e.propertyIndex;
							if (t || (t = Hc.findNode(this.rootNode, e.nodeName) || this.rootNode, this.node =
									t), this.getValue = this._getValue_unavailable, this.setValue = this
								._setValue_unavailable, t) {
								if (i) {
									var a = e.objectIndex;
									switch (i) {
										case "materials":
											if (!t.material) return void console.error(
												"THREE.PropertyBinding: Can not bind to material as node does not have a material.",
												this);
											if (!t.material.materials) return void console.error(
												"THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",
												this);
											t = t.material.materials;
											break;
										case "bones":
											if (!t.skeleton) return void console.error(
												"THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",
												this);
											t = t.skeleton.bones;
											for (var o = 0; o < t.length; o++)
												if (t[o].name === a) {
													a = o;
													break
												} break;
										default:
											if (void 0 === t[i]) return void console.error(
												"THREE.PropertyBinding: Can not bind to objectName of node undefined.",
												this);
											t = t[i]
									}
									if (void 0 !== a) {
										if (void 0 === t[a]) return void console.error(
											"THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",
											this, t);
										t = t[a]
									}
								}
								var s = t[n];
								if (void 0 !== s) {
									var c = this.Versioning.None;
									this.targetObject = t, void 0 !== t.needsUpdate ? c = this.Versioning
										.NeedsUpdate : void 0 !== t.matrixWorldNeedsUpdate && (c = this
											.Versioning.MatrixWorldNeedsUpdate);
									var h = this.BindingType.Direct;
									if (void 0 !== r) {
										if ("morphTargetInfluences" === n) {
											if (!t.geometry) return void console.error(
												"THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",
												this);
											if (t.geometry.isBufferGeometry) {
												if (!t.geometry.morphAttributes) return void console.error(
													"THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",
													this);
												for (var o = 0; o < this.node.geometry.morphAttributes
													.position.length; o++)
													if (t.geometry.morphAttributes.position[o].name === r) {
														r = o;
														break
													}
											} else {
												if (!t.geometry.morphTargets) return void console.error(
													"THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphTargets.",
													this);
												for (var o = 0; o < this.node.geometry.morphTargets
													.length; o++)
													if (t.geometry.morphTargets[o].name === r) {
														r = o;
														break
													}
											}
										}
										h = this.BindingType.ArrayElement, this.resolvedProperty = s, this
											.propertyIndex = r
									} else void 0 !== s.fromArray && void 0 !== s.toArray ? (h = this
											.BindingType.HasFromToArray, this.resolvedProperty = s) : Array
										.isArray(s) ? (h = this.BindingType.EntireArray, this
											.resolvedProperty = s) : this.propertyName = n;
									this.getValue = this.GetterByBindingType[h], this.setValue = this
										.SetterByBindingTypeAndVersioning[h][c]
								} else {
									var l = e.nodeName;
									console.error(
										"THREE.PropertyBinding: Trying to update property for track: " +
										l + "." + n + " but it wasn't found.", t)
								}
							} else console.error("THREE.PropertyBinding: Trying to update node for track: " +
								this.path + " but it wasn't found.")
						},
						unbind: function () {
							this.node = null, this.getValue = this._getValue_unbound, this.setValue = this
								._setValue_unbound
						}
					}),
					//!\ DECLARE ALIAS AFTER assign prototype !
					Object.assign(Hc.prototype, {
						_getValue_unbound: Hc.prototype.getValue,
						_setValue_unbound: Hc.prototype.setValue
					}), Object.assign(kc.prototype, {
						isAnimationObjectGroup: !0,
						add: function () {
							for (var t = this._objects, e = t.length, i = this.nCachedObjects_, n = this
									._indicesByUUID, r = this._paths, a = this._parsedPaths, o = this
									._bindings, s = o.length, c = void 0, h = 0, l = arguments.length; h !==
								l; ++h) {
								var u = arguments[h],
									p = u.uuid,
									d = n[p];
								if (void 0 === d) {
									d = e++, n[p] = d, t.push(u);
									for (var f = 0, m = s; f !== m; ++f) o[f].push(new Hc(u, r[f], a[f]))
								} else if (d < i) {
									c = t[d];
									var g = --i,
										v = t[g];
									n[v.uuid] = d, t[d] = v, n[p] = g, t[g] = u;
									for (var f = 0, m = s; f !== m; ++f) {
										var y = o[f],
											x = y[g],
											b = y[d];
										y[d] = x, void 0 === b && (b = new Hc(u, r[f], a[f])), y[g] = b
									}
								} else t[d] !== c && console.error(
									"THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes."
									)
							}
							this.nCachedObjects_ = i
						},
						remove: function () {
							for (var t = this._objects, e = this.nCachedObjects_, i = this._indicesByUUID, n =
									this._bindings, r = n.length, a = 0, o = arguments.length; a !== o; ++a) {
								var s = arguments[a],
									c = s.uuid,
									h = i[c];
								if (void 0 !== h && h >= e) {
									var l = e++,
										u = t[l];
									i[u.uuid] = h, t[h] = u, i[c] = l, t[l] = s;
									for (var p = 0, d = r; p !== d; ++p) {
										var f = n[p],
											m = f[l],
											g = f[h];
										f[h] = m, f[l] = g
									}
								}
							}
							this.nCachedObjects_ = e
						},
						uncache: function () {
							for (var t = this._objects, e = t.length, i = this.nCachedObjects_, n = this
									._indicesByUUID, r = this._bindings, a = r.length, o = 0, s = arguments
									.length; o !== s; ++o) {
								var c = arguments[o],
									h = c.uuid,
									l = n[h];
								if (void 0 !== l)
									if (delete n[h], l < i) {
										var u = --i,
											p = t[u],
											d = --e,
											f = t[d];
										n[p.uuid] = l, t[l] = p, n[f.uuid] = u, t[u] = f, t.pop();
										for (var m = 0, g = a; m !== g; ++m) {
											var v = r[m],
												y = v[u],
												x = v[d];
											v[l] = y, v[u] = x, v.pop()
										}
									} else {
										var d = --e,
											f = t[d];
										n[f.uuid] = l, t[l] = f, t.pop();
										for (var m = 0, g = a; m !== g; ++m) {
											var v = r[m];
											v[l] = v[d], v.pop()
										}
									}
							}
							this.nCachedObjects_ = i
						},
						subscribe_: function (t, e) {
							var i = this._bindingsIndicesByPath,
								n = i[t],
								r = this._bindings;
							if (void 0 !== n) return r[n];
							var a = this._paths,
								o = this._parsedPaths,
								s = this._objects,
								c = s.length,
								h = this.nCachedObjects_,
								l = new Array(c);
							n = r.length, i[t] = n, a.push(t), o.push(e), r.push(l);
							for (var u = h, p = s.length; u !== p; ++u) {
								var d = s[u];
								l[u] = new Hc(d, t, e)
							}
							return l
						},
						unsubscribe_: function (t) {
							var e = this._bindingsIndicesByPath,
								i = e[t];
							if (void 0 !== i) {
								var n = this._paths,
									r = this._parsedPaths,
									a = this._bindings,
									o = a.length - 1,
									s = a[o],
									c = t[o];
								e[c] = i, a[i] = s, a.pop(), r[i] = r[o], r.pop(), n[i] = n[o], n.pop()
							}
						}
					}), Object.assign(jc.prototype, {
						play: function () {
							return this._mixer._activateAction(this), this
						},
						stop: function () {
							return this._mixer._deactivateAction(this), this.reset()
						},
						reset: function () {
							return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1,
								this._startTime = null, this.stopFading().stopWarping()
						},
						isRunning: function () {
							return this.enabled && !this.paused && 0 !== this.timeScale && null === this
								._startTime && this._mixer._isActiveAction(this)
						},
						isScheduled: function () {
							return this._mixer._isActiveAction(this)
						},
						startAt: function (t) {
							return this._startTime = t, this
						},
						setLoop: function (t, e) {
							return this.loop = t, this.repetitions = e, this
						},
						setEffectiveWeight: function (t) {
							return this.weight = t, this._effectiveWeight = this.enabled ? t : 0, this
								.stopFading()
						},
						getEffectiveWeight: function () {
							return this._effectiveWeight
						},
						fadeIn: function (t) {
							return this._scheduleFading(t, 0, 1)
						},
						fadeOut: function (t) {
							return this._scheduleFading(t, 1, 0)
						},
						crossFadeFrom: function (t, e, i) {
							if (t.fadeOut(e), this.fadeIn(e), i) {
								var n = this._clip.duration,
									r = t._clip.duration,
									a = r / n,
									o = n / r;
								t.warp(1, a, e), this.warp(o, 1, e)
							}
							return this
						},
						crossFadeTo: function (t, e, i) {
							return t.crossFadeFrom(this, e, i)
						},
						stopFading: function () {
							var t = this._weightInterpolant;
							return null !== t && (this._weightInterpolant = null, this._mixer
								._takeBackControlInterpolant(t)), this
						},
						setEffectiveTimeScale: function (t) {
							return this.timeScale = t, this._effectiveTimeScale = this.paused ? 0 : t, this
								.stopWarping()
						},
						getEffectiveTimeScale: function () {
							return this._effectiveTimeScale
						},
						setDuration: function (t) {
							return this.timeScale = this._clip.duration / t, this.stopWarping()
						},
						syncWith: function (t) {
							return this.time = t.time, this.timeScale = t.timeScale, this.stopWarping()
						},
						halt: function (t) {
							return this.warp(this._effectiveTimeScale, 0, t)
						},
						warp: function (t, e, i) {
							var n = this._mixer,
								r = n.time,
								a = this._timeScaleInterpolant,
								o = this.timeScale;
							null === a && (a = n._lendControlInterpolant(), this._timeScaleInterpolant = a);
							var s = a.parameterPositions,
								c = a.sampleValues;
							return s[0] = r, s[1] = r + i, c[0] = t / o, c[1] = e / o, this
						},
						stopWarping: function () {
							var t = this._timeScaleInterpolant;
							return null !== t && (this._timeScaleInterpolant = null, this._mixer
								._takeBackControlInterpolant(t)), this
						},
						getMixer: function () {
							return this._mixer
						},
						getClip: function () {
							return this._clip
						},
						getRoot: function () {
							return this._localRoot || this._mixer._root
						},
						_update: function (t, e, i, n) {
							if (this.enabled) {
								var r = this._startTime;
								if (null !== r) {
									var a = (t - r) * i;
									if (a < 0 || 0 === i) return;
									this._startTime = null, e = i * a
								}
								e *= this._updateTimeScale(t);
								var o = this._updateTime(e),
									s = this._updateWeight(t);
								if (s > 0)
									for (var c = this._interpolants, h = this._propertyBindings, l = 0, u = c
											.length; l !== u; ++l) c[l].evaluate(o), h[l].accumulate(n, s)
							} else this._updateWeight(t)
						},
						_updateWeight: function (t) {
							var e = 0;
							if (this.enabled) {
								e = this.weight;
								var i = this._weightInterpolant;
								if (null !== i) {
									var n = i.evaluate(t)[0];
									e *= n, t > i.parameterPositions[1] && (this.stopFading(), 0 === n && (
										this.enabled = !1))
								}
							}
							return this._effectiveWeight = e, e
						},
						_updateTimeScale: function (t) {
							var e = 0;
							if (!this.paused) {
								e = this.timeScale;
								var i = this._timeScaleInterpolant;
								if (null !== i) {
									var n = i.evaluate(t)[0];
									e *= n, t > i.parameterPositions[1] && (this.stopWarping(), 0 === e ? this
										.paused = !0 : this.timeScale = e)
								}
							}
							return this._effectiveTimeScale = e, e
						},
						_updateTime: function (t) {
							var e = this.time + t,
								i = this._clip.duration,
								n = this.loop,
								r = this._loopCount,
								a = 2202 === n;
							if (0 === t) return -1 === r ? e : a && 1 == (1 & r) ? i - e : e;
							if (2200 === n) {
								-1 === r && (this._loopCount = 0, this._setEndings(!0, !0, !1));
								t: {
									if (e >= i) e = i;
									else {
										if (!(e < 0)) break t;
										e = 0
									}
									this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
									this._mixer.dispatchEvent({
										type: "finished",
										action: this,
										direction: t < 0 ? -1 : 1
									})
								}
							} else {
								if (-1 === r && (t >= 0 ? (r = 0, this._setEndings(!0, 0 === this.repetitions,
										a)) : this._setEndings(0 === this.repetitions, !0, a)), e >= i || e <
									0) {
									var o = Math.floor(e / i);
									e -= i * o, r += Math.abs(o);
									var s = this.repetitions - r;
									if (s <= 0) this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
										e = t > 0 ? i : 0, this._mixer.dispatchEvent({
											type: "finished",
											action: this,
											direction: t > 0 ? 1 : -1
										});
									else {
										if (1 === s) {
											var c = t < 0;
											this._setEndings(c, !c, a)
										} else this._setEndings(!1, !1, a);
										this._loopCount = r, this._mixer.dispatchEvent({
											type: "loop",
											action: this,
											loopDelta: o
										})
									}
								}
								if (a && 1 == (1 & r)) return this.time = e, i - e
							}
							return this.time = e, e
						},
						_setEndings: function (t, e, i) {
							var n = this._interpolantSettings;
							i ? (n.endingStart = 2401, n.endingEnd = 2401) : (n.endingStart = t ? this
								.zeroSlopeAtStart ? 2401 : ye : 2402, n.endingEnd = e ? this
								.zeroSlopeAtEnd ? 2401 : ye : 2402)
						},
						_scheduleFading: function (t, e, i) {
							var n = this._mixer,
								r = n.time,
								a = this._weightInterpolant;
							null === a && (a = n._lendControlInterpolant(), this._weightInterpolant = a);
							var o = a.parameterPositions,
								s = a.sampleValues;
							return o[0] = r, s[0] = e, o[1] = r + t, s[1] = i, this
						}
					}), Vc.prototype = Object.assign(Object.create(e.prototype), {
						constructor: Vc,
						_bindAction: function (t, e) {
							var i = t._localRoot || this._root,
								n = t._clip.tracks,
								r = n.length,
								a = t._propertyBindings,
								o = t._interpolants,
								s = i.uuid,
								c = this._bindingsByRootAndName,
								h = c[s];
							void 0 === h && (h = {}, c[s] = h);
							for (var l = 0; l !== r; ++l) {
								var u = n[l],
									p = u.name,
									d = h[p];
								if (void 0 !== d) a[l] = d;
								else {
									if (void 0 !== (d = a[l])) {
										null === d._cacheIndex && (++d.referenceCount, this
											._addInactiveBinding(d, s, p));
										continue
									}
									var f = e && e._propertyBindings[l].binding.parsedPath;
									++(d = new Gc(Hc.create(i, p, f), u.ValueTypeName, u.getValueSize()))
									.referenceCount, this._addInactiveBinding(d, s, p), a[l] = d
								}
								o[l].resultBuffer = d.buffer
							}
						},
						_activateAction: function (t) {
							if (!this._isActiveAction(t)) {
								if (null === t._cacheIndex) {
									var e = (t._localRoot || this._root).uuid,
										i = t._clip.uuid,
										n = this._actionsByClip[i];
									this._bindAction(t, n && n.knownActions[0]), this._addInactiveAction(t, i,
										e)
								}
								for (var r = t._propertyBindings, a = 0, o = r.length; a !== o; ++a) {
									var s = r[a];
									0 == s.useCount++ && (this._lendBinding(s), s.saveOriginalState())
								}
								this._lendAction(t)
							}
						},
						_deactivateAction: function (t) {
							if (this._isActiveAction(t)) {
								for (var e = t._propertyBindings, i = 0, n = e.length; i !== n; ++i) {
									var r = e[i];
									0 == --r.useCount && (r.restoreOriginalState(), this._takeBackBinding(r))
								}
								this._takeBackAction(t)
							}
						},
						_initMemoryManager: function () {
							this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this
								._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {},
								this._controlInterpolants = [], this._nActiveControlInterpolants = 0;
							var t = this;
							this.stats = {
								actions: {
									get total() {
										return t._actions.length
									},
									get inUse() {
										return t._nActiveActions
									}
								},
								bindings: {
									get total() {
										return t._bindings.length
									},
									get inUse() {
										return t._nActiveBindings
									}
								},
								controlInterpolants: {
									get total() {
										return t._controlInterpolants.length
									},
									get inUse() {
										return t._nActiveControlInterpolants
									}
								}
							}
						},
						_isActiveAction: function (t) {
							var e = t._cacheIndex;
							return null !== e && e < this._nActiveActions
						},
						_addInactiveAction: function (t, e, i) {
							var n = this._actions,
								r = this._actionsByClip,
								a = r[e];
							if (void 0 === a) a = {
								knownActions: [t],
								actionByRoot: {}
							}, t._byClipCacheIndex = 0, r[e] = a;
							else {
								var o = a.knownActions;
								t._byClipCacheIndex = o.length, o.push(t)
							}
							t._cacheIndex = n.length, n.push(t), a.actionByRoot[i] = t
						},
						_removeInactiveAction: function (t) {
							var e = this._actions,
								i = e[e.length - 1],
								n = t._cacheIndex;
							i._cacheIndex = n, e[n] = i, e.pop(), t._cacheIndex = null;
							var r = t._clip.uuid,
								a = this._actionsByClip,
								o = a[r],
								s = o.knownActions,
								c = s[s.length - 1],
								h = t._byClipCacheIndex;
							c._byClipCacheIndex = h, s[h] = c, s.pop(), t._byClipCacheIndex = null;
							var l = o.actionByRoot,
								u = (t._localRoot || this._root).uuid;
							delete l[u], 0 === s.length && delete a[r], this._removeInactiveBindingsForAction(
								t)
						},
						_removeInactiveBindingsForAction: function (t) {
							for (var e = t._propertyBindings, i = 0, n = e.length; i !== n; ++i) {
								var r = e[i];
								0 == --r.referenceCount && this._removeInactiveBinding(r)
							}
						},
						_lendAction: function (t) {
							var e = this._actions,
								i = t._cacheIndex,
								n = this._nActiveActions++,
								r = e[n];
							t._cacheIndex = n, e[n] = t, r._cacheIndex = i, e[i] = r
						},
						_takeBackAction: function (t) {
							var e = this._actions,
								i = t._cacheIndex,
								n = --this._nActiveActions,
								r = e[n];
							t._cacheIndex = n, e[n] = t, r._cacheIndex = i, e[i] = r
						},
						_addInactiveBinding: function (t, e, i) {
							var n = this._bindingsByRootAndName,
								r = n[e],
								a = this._bindings;
							void 0 === r && (r = {}, n[e] = r), r[i] = t, t._cacheIndex = a.length, a.push(t)
						},
						_removeInactiveBinding: function (t) {
							var e = this._bindings,
								i = t.binding,
								n = i.rootNode.uuid,
								r = i.path,
								a = this._bindingsByRootAndName,
								o = a[n],
								s = e[e.length - 1],
								c = t._cacheIndex;
							s._cacheIndex = c, e[c] = s, e.pop(), delete o[r];
							t: {
								for (var h in o) break t;delete a[n]
							}
						},
						_lendBinding: function (t) {
							var e = this._bindings,
								i = t._cacheIndex,
								n = this._nActiveBindings++,
								r = e[n];
							t._cacheIndex = n, e[n] = t, r._cacheIndex = i, e[i] = r
						},
						_takeBackBinding: function (t) {
							var e = this._bindings,
								i = t._cacheIndex,
								n = --this._nActiveBindings,
								r = e[n];
							t._cacheIndex = n, e[n] = t, r._cacheIndex = i, e[i] = r
						},
						_lendControlInterpolant: function () {
							var t = this._controlInterpolants,
								e = this._nActiveControlInterpolants++,
								i = t[e];
							return void 0 === i && ((i = new No(new Float32Array(2), new Float32Array(2), 1,
								this._controlInterpolantsResultBuffer)).__cacheIndex = e, t[e] = i), i
						},
						_takeBackControlInterpolant: function (t) {
							var e = this._controlInterpolants,
								i = t.__cacheIndex,
								n = --this._nActiveControlInterpolants,
								r = e[n];
							t.__cacheIndex = n, e[n] = t, r.__cacheIndex = i, e[i] = r
						},
						_controlInterpolantsResultBuffer: new Float32Array(1),
						clipAction: function (t, e) {
							var i = e || this._root,
								n = i.uuid,
								r = "string" == typeof t ? Xo.findByName(i, t) : t,
								a = null !== r ? r.uuid : t,
								o = this._actionsByClip[a],
								s = null;
							if (void 0 !== o) {
								var c = o.actionByRoot[n];
								if (void 0 !== c) return c;
								s = o.knownActions[0], null === r && (r = s._clip)
							}
							if (null === r) return null;
							var h = new jc(this, r, e);
							return this._bindAction(h, s), this._addInactiveAction(h, a, n), h
						},
						existingAction: function (t, e) {
							var i = e || this._root,
								n = i.uuid,
								r = "string" == typeof t ? Xo.findByName(i, t) : t,
								a = r ? r.uuid : t,
								o = this._actionsByClip[a];
							return void 0 !== o && o.actionByRoot[n] || null
						},
						stopAllAction: function () {
							var t = this._actions,
								e = this._nActiveActions,
								i = this._bindings,
								n = this._nActiveBindings;
							this._nActiveActions = 0, this._nActiveBindings = 0;
							for (var r = 0; r !== e; ++r) t[r].reset();
							for (var r = 0; r !== n; ++r) i[r].useCount = 0;
							return this
						},
						update: function (t) {
							t *= this.timeScale;
							for (var e = this._actions, i = this._nActiveActions, n = this.time += t, r = Math
									.sign(t), a = this._accuIndex ^= 1, o = 0; o !== i; ++o) {
								var s = e[o];
								s._update(n, t, r, a)
							}
							for (var c = this._bindings, h = this._nActiveBindings, o = 0; o !== h; ++o) c[o]
								.apply(a);
							return this
						},
						getRoot: function () {
							return this._root
						},
						uncacheClip: function (t) {
							var e = this._actions,
								i = t.uuid,
								n = this._actionsByClip,
								r = n[i];
							if (void 0 !== r) {
								for (var a = r.knownActions, o = 0, s = a.length; o !== s; ++o) {
									var c = a[o];
									this._deactivateAction(c);
									var h = c._cacheIndex,
										l = e[e.length - 1];
									c._cacheIndex = null, c._byClipCacheIndex = null, l._cacheIndex = h, e[
										h] = l, e.pop(), this._removeInactiveBindingsForAction(c)
								}
								delete n[i]
							}
						},
						uncacheRoot: function (t) {
							var e = t.uuid,
								i = this._actionsByClip;
							for (var n in i) {
								var r = i[n].actionByRoot,
									a = r[e];
								void 0 !== a && (this._deactivateAction(a), this._removeInactiveAction(a))
							}
							var o = this._bindingsByRootAndName,
								s = o[e];
							if (void 0 !== s)
								for (var c in s) {
									var h = s[c];
									h.restoreOriginalState(), this._removeInactiveBinding(h)
								}
						},
						uncacheAction: function (t, e) {
							var i = this.existingAction(t, e);
							null !== i && (this._deactivateAction(i), this._removeInactiveAction(i))
						}
					}), Wc.prototype.clone = function () {
						return new Wc(void 0 === this.value.clone ? this.value : this.value.clone())
					}, qc.prototype = Object.assign(Object.create(Hi.prototype), {
						constructor: qc,
						isInstancedBufferGeometry: !0,
						copy: function (t) {
							return Hi.prototype.copy.call(this, t), this.maxInstancedCount = t
								.maxInstancedCount, this
						},
						clone: function () {
							return (new this.constructor).copy(this)
						}
					}), Xc.prototype = Object.assign(Object.create(Wr.prototype), {
						constructor: Xc,
						isInstancedInterleavedBuffer: !0,
						copy: function (t) {
							return Wr.prototype.copy.call(this, t), this.meshPerAttribute = t
								.meshPerAttribute, this
						}
					}), Yc.prototype = Object.assign(Object.create(Li.prototype), {
						constructor: Yc,
						isInstancedBufferAttribute: !0,
						copy: function (t) {
							return Li.prototype.copy.call(this, t), this.meshPerAttribute = t
								.meshPerAttribute, this
						}
					}), Object.assign(Jc.prototype, {
						linePrecision: 1,
						set: function (t, e) {
							this.ray.set(t, e)
						},
						setFromCamera: function (t, e) {
							e && e.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(e
									.matrixWorld), this.ray.direction.set(t.x, t.y, .5).unproject(e).sub(this
										.ray.origin).normalize()) : e && e.isOrthographicCamera ? (this.ray
									.origin.set(t.x, t.y, (e.near + e.far) / (e.near - e.far)).unproject(e),
									this.ray.direction.set(0, 0, -1).transformDirection(e.matrixWorld)) :
								console.error("THREE.Raycaster: Unsupported camera type.")
						},
						intersectObject: function (t, e, i) {
							var n = i || [];
							return Qc(t, this, n, e), n.sort(Zc), n
						},
						intersectObjects: function (t, e, i) {
							var n = i || [];
							if (!1 === Array.isArray(t)) return console.warn(
								"THREE.Raycaster.intersectObjects: objects is not an Array."), n;
							for (var r = 0, a = t.length; r < a; r++) Qc(t[r], this, n, e);
							return n.sort(Zc), n
						}
					}), Object.assign(Kc.prototype, {
						set: function (t, e, i) {
							return this.radius = t, this.phi = e, this.theta = i, this
						},
						clone: function () {
							return (new this.constructor).copy(this)
						},
						copy: function (t) {
							return this.radius = t.radius, this.phi = t.phi, this.theta = t.theta, this
						},
						makeSafe: function () {
							return this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi)), this
						},
						setFromVector3: function (t) {
							return this.setFromCartesianCoords(t.x, t.y, t.z)
						},
						setFromCartesianCoords: function (t, e, i) {
							return this.radius = Math.sqrt(t * t + e * e + i * i), 0 === this.radius ? (this
								.theta = 0, this.phi = 0) : (this.theta = Math.atan2(t, i), this.phi =
								Math.acos(Ie.clamp(e / this.radius, -1, 1))), this
						}
					}), Object.assign($c.prototype, {
						set: function (t, e, i) {
							return this.radius = t, this.theta = e, this.y = i, this
						},
						clone: function () {
							return (new this.constructor).copy(this)
						},
						copy: function (t) {
							return this.radius = t.radius, this.theta = t.theta, this.y = t.y, this
						},
						setFromVector3: function (t) {
							return this.setFromCartesianCoords(t.x, t.y, t.z)
						},
						setFromCartesianCoords: function (t, e, i) {
							return this.radius = Math.sqrt(t * t + i * i), this.theta = Math.atan2(t, i), this
								.y = e, this
						}
					}), Object.assign(th.prototype, {
						set: function (t, e) {
							return this.min.copy(t), this.max.copy(e), this
						},
						setFromPoints: function (t) {
							this.makeEmpty();
							for (var e = 0, i = t.length; e < i; e++) this.expandByPoint(t[e]);
							return this
						},
						setFromCenterAndSize: function () {
							var t = new De;
							return function (e, i) {
								var n = t.copy(i).multiplyScalar(.5);
								return this.min.copy(e).sub(n), this.max.copy(e).add(n), this
							}
						}(),
						clone: function () {
							return (new this.constructor).copy(this)
						},
						copy: function (t) {
							return this.min.copy(t.min), this.max.copy(t.max), this
						},
						makeEmpty: function () {
							return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this
						},
						isEmpty: function () {
							return this.max.x < this.min.x || this.max.y < this.min.y
						},
						getCenter: function (t) {
							return void 0 === t && (console.warn(
									"THREE.Box2: .getCenter() target is now required"), t = new De), this
								.isEmpty() ? t.set(0, 0) : t.addVectors(this.min, this.max).multiplyScalar(.5)
						},
						getSize: function (t) {
							return void 0 === t && (console.warn(
									"THREE.Box2: .getSize() target is now required"), t = new De), this
								.isEmpty() ? t.set(0, 0) : t.subVectors(this.max, this.min)
						},
						expandByPoint: function (t) {
							return this.min.min(t), this.max.max(t), this
						},
						expandByVector: function (t) {
							return this.min.sub(t), this.max.add(t), this
						},
						expandByScalar: function (t) {
							return this.min.addScalar(-t), this.max.addScalar(t), this
						},
						containsPoint: function (t) {
							return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this
								.max.y)
						},
						containsBox: function (t) {
							return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y &&
								t.max.y <= this.max.y
						},
						getParameter: function (t, e) {
							return void 0 === e && (console.warn(
								"THREE.Box2: .getParameter() target is now required"), e = new De), e.set(
								(t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this
									.max.y - this.min.y))
						},
						intersectsBox: function (t) {
							return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t
								.min.y > this.max.y)
						},
						clampPoint: function (t, e) {
							return void 0 === e && (console.warn(
								"THREE.Box2: .clampPoint() target is now required"), e = new De), e.copy(
								t).clamp(this.min, this.max)
						},
						distanceToPoint: function () {
							var t = new De;
							return function (e) {
								var i = t.copy(e).clamp(this.min, this.max);
								return i.sub(e).length()
							}
						}(),
						intersect: function (t) {
							return this.min.max(t.min), this.max.min(t.max), this
						},
						union: function (t) {
							return this.min.min(t.min), this.max.max(t.max), this
						},
						translate: function (t) {
							return this.min.add(t), this.max.add(t), this
						},
						equals: function (t) {
							return t.min.equals(this.min) && t.max.equals(this.max)
						}
					}), Object.assign(eh.prototype, {
						set: function (t, e) {
							return this.start.copy(t), this.end.copy(e), this
						},
						clone: function () {
							return (new this.constructor).copy(this)
						},
						copy: function (t) {
							return this.start.copy(t.start), this.end.copy(t.end), this
						},
						getCenter: function (t) {
							return void 0 === t && (console.warn(
									"THREE.Line3: .getCenter() target is now required"), t = new Ne), t
								.addVectors(this.start, this.end).multiplyScalar(.5)
						},
						delta: function (t) {
							return void 0 === t && (console.warn(
									"THREE.Line3: .delta() target is now required"), t = new Ne), t
								.subVectors(this.end, this.start)
						},
						distanceSq: function () {
							return this.start.distanceToSquared(this.end)
						},
						distance: function () {
							return this.start.distanceTo(this.end)
						},
						at: function (t, e) {
							return void 0 === e && (console.warn("THREE.Line3: .at() target is now required"),
								e = new Ne), this.delta(e).multiplyScalar(t).add(this.start)
						},
						closestPointToPointParameter: (xc = new Ne, bc = new Ne, function (t, e) {
							xc.subVectors(t, this.start), bc.subVectors(this.end, this.start);
							var i = bc.dot(bc),
								n = bc.dot(xc),
								r = n / i;
							return e && (r = Ie.clamp(r, 0, 1)), r
						}),
						closestPointToPoint: function (t, e, i) {
							var n = this.closestPointToPointParameter(t, e);
							return void 0 === i && (console.warn(
									"THREE.Line3: .closestPointToPoint() target is now required"), i =
								new Ne), this.delta(i).multiplyScalar(n).add(this.start)
						},
						applyMatrix4: function (t) {
							return this.start.applyMatrix4(t), this.end.applyMatrix4(t), this
						},
						equals: function (t) {
							return t.start.equals(this.start) && t.end.equals(this.end)
						}
					}), ih.prototype = Object.create(Mi.prototype), ih.prototype.constructor = ih, ih.prototype
					.isImmediateRenderObject = !0, nh.prototype = Object.create(ea.prototype), nh.prototype
					.constructor = nh, nh.prototype.update = function () {
						var t = new Ne,
							e = new Ne,
							i = new Ue;
						return function () {
							var n = ["a", "b", "c"];
							this.object.updateMatrixWorld(!0), i.getNormalMatrix(this.object.matrixWorld);
							var r = this.object.matrixWorld,
								a = this.geometry.attributes.position,
								o = this.object.geometry;
							if (o && o.isGeometry)
								for (var s = o.vertices, c = o.faces, h = 0, l = 0, u = c.length; l < u; l++)
									for (var p = c[l], d = 0, f = p.vertexNormals.length; d < f; d++) {
										var m = s[p[n[d]]],
											g = p.vertexNormals[d];
										t.copy(m).applyMatrix4(r), e.copy(g).applyMatrix3(i).normalize()
											.multiplyScalar(this.size).add(t), a.setXYZ(h, t.x, t.y, t.z), h += 1,
											a.setXYZ(h, e.x, e.y, e.z), h += 1
									} else if (o && o.isBufferGeometry)
										for (var v = o.attributes.position, y = o.attributes.normal, h = 0, d = 0,
												f = v.count; d < f; d++) t.set(v.getX(d), v.getY(d), v.getZ(d))
											.applyMatrix4(r), e.set(y.getX(d), y.getY(d), y.getZ(d)), e
											.applyMatrix3(i).normalize().multiplyScalar(this.size).add(t), a
											.setXYZ(h, t.x, t.y, t.z), h += 1, a.setXYZ(h, e.x, e.y, e.z), h += 1;
							a.needsUpdate = !0
						}
					}(), rh.prototype = Object.create(Mi.prototype), rh.prototype.constructor = rh, rh.prototype
					.dispose = function () {
						this.cone.geometry.dispose(), this.cone.material.dispose()
					}, rh.prototype.update = function () {
						var t = new Ne;
						return function () {
							this.light.updateMatrixWorld();
							var e = this.light.distance ? this.light.distance : 1e3,
								i = e * Math.tan(this.light.angle);
							this.cone.scale.set(i, i, e), t.setFromMatrixPosition(this.light.target.matrixWorld),
								this.cone.lookAt(t), void 0 !== this.color ? this.cone.material.color.set(this
									.color) : this.cone.material.color.copy(this.light.color)
						}
					}(), ah.prototype = Object.create(ea.prototype), ah.prototype.constructor = ah, ah.prototype
					.updateMatrixWorld = function () {
						var t = new Ne,
							e = new Be,
							i = new Be;
						return function (n) {
							var r = this.bones,
								a = this.geometry,
								o = a.getAttribute("position");
							i.getInverse(this.root.matrixWorld);
							for (var s = 0, c = 0; s < r.length; s++) {
								var h = r[s];
								h.parent && h.parent.isBone && (e.multiplyMatrices(i, h.matrixWorld), t
									.setFromMatrixPosition(e), o.setXYZ(c, t.x, t.y, t.z), e.multiplyMatrices(
										i, h.parent.matrixWorld), t.setFromMatrixPosition(e), o.setXYZ(c + 1,
										t.x, t.y, t.z), c += 2)
							}
							a.getAttribute("position").needsUpdate = !0, Mi.prototype.updateMatrixWorld.call(this,
								n)
						}
					}(), oh.prototype = Object.create(un.prototype), oh.prototype.constructor = oh, oh.prototype
					.dispose = function () {
						this.geometry.dispose(), this.material.dispose()
					}, oh.prototype.update = function () {
						void 0 !== this.color ? this.material.color.set(this.color) : this.material.color.copy(this
							.light.color)
					}, sh.prototype = Object.create(ta.prototype), sh.prototype.constructor = sh, sh.prototype
					.update = function () {
						if (this.scale.set(.5 * this.light.width, .5 * this.light.height, 1), void 0 !== this.color)
							this.material.color.set(this.color), this.children[0].material.color.set(this.color);
						else {
							this.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
							var t = this.material.color,
								e = Math.max(t.r, t.g, t.b);
							e > 1 && t.multiplyScalar(1 / e), this.children[0].material.color.copy(this.material
								.color)
						}
					}, sh.prototype.dispose = function () {
						this.geometry.dispose(), this.material.dispose(), this.children[0].geometry.dispose(), this
							.children[0].material.dispose()
					}, ch.prototype = Object.create(Mi.prototype), ch.prototype.constructor = ch, ch.prototype
					.dispose = function () {
						this.children[0].geometry.dispose(), this.children[0].material.dispose()
					}, ch.prototype.update = function () {
						var t = new Ne,
							e = new hi,
							i = new hi;
						return function () {
							var n = this.children[0];
							if (void 0 !== this.color) this.material.color.set(this.color);
							else {
								var r = n.geometry.getAttribute("color");
								e.copy(this.light.color), i.copy(this.light.groundColor);
								for (var a = 0, o = r.count; a < o; a++) {
									var s = a < o / 2 ? e : i;
									r.setXYZ(a, s.r, s.g, s.b)
								}
								r.needsUpdate = !0
							}
							n.lookAt(t.setFromMatrixPosition(this.light.matrixWorld).negate())
						}
					}(), hh.prototype = Object.create(ea.prototype), hh.prototype.constructor = hh, lh.prototype =
					Object.create(ea.prototype), lh.prototype.constructor = lh, uh.prototype = Object.create(ea
						.prototype), uh.prototype.constructor = uh, uh.prototype.update = function () {
						var t = new Ne,
							e = new Ne,
							i = new Ue;
						return function () {
							this.object.updateMatrixWorld(!0), i.getNormalMatrix(this.object.matrixWorld);
							for (var n = this.object.matrixWorld, r = this.geometry.attributes.position, a = this
									.object.geometry, o = a.vertices, s = a.faces, c = 0, h = 0, l = s.length; h <
								l; h++) {
								var u = s[h],
									p = u.normal;
								t.copy(o[u.a]).add(o[u.b]).add(o[u.c]).divideScalar(3).applyMatrix4(n), e.copy(p)
									.applyMatrix3(i).normalize().multiplyScalar(this.size).add(t), r.setXYZ(c, t
										.x, t.y, t.z), c += 1, r.setXYZ(c, e.x, e.y, e.z), c += 1
							}
							r.needsUpdate = !0
						}
					}(), ph.prototype = Object.create(Mi.prototype), ph.prototype.constructor = ph, ph.prototype
					.dispose = function () {
						this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine
							.geometry.dispose(), this.targetLine.material.dispose()
					}, ph.prototype.update = function () {
						var t = new Ne,
							e = new Ne,
							i = new Ne;
						return function () {
							t.setFromMatrixPosition(this.light.matrixWorld), e.setFromMatrixPosition(this.light
									.target.matrixWorld), i.subVectors(e, t), this.lightPlane.lookAt(e),
								void 0 !== this.color ? (this.lightPlane.material.color.set(this.color), this
									.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color
									.copy(this.light.color), this.targetLine.material.color.copy(this.light.color)
									), this.targetLine.lookAt(e), this.targetLine.scale.z = i.length()
						}
					}(), dh.prototype = Object.create(ea.prototype), dh.prototype.constructor = dh, dh.prototype
					.update = function () {
						var t, e, i = new Ne,
							n = new Lr;

						function r(r, a, o, s) {
							i.set(a, o, s).unproject(n);
							var c = e[r];
							if (void 0 !== c)
								for (var h = t.getAttribute("position"), l = 0, u = c.length; l < u; l++) h.setXYZ(c[
									l], i.x, i.y, i.z)
						}
						return function () {
							t = this.geometry, e = this.pointMap, n.projectionMatrix.copy(this.camera
									.projectionMatrix), r("c", 0, 0, -1), r("t", 0, 0, 1), r("n1", -1, -1, -1), r(
									"n2", 1, -1, -1), r("n3", -1, 1, -1), r("n4", 1, 1, -1), r("f1", -1, -1, 1),
								r("f2", 1, -1, 1), r("f3", -1, 1, 1), r("f4", 1, 1, 1), r("u1", .7, 1.1, -1), r(
									"u2", -.7, 1.1, -1), r("u3", 0, 2, -1), r("cf1", -1, 0, 1), r("cf2", 1, 0, 1),
								r("cf3", 0, -1, 1), r("cf4", 0, 1, 1), r("cn1", -1, 0, -1), r("cn2", 1, 0, -1), r(
									"cn3", 0, -1, -1), r("cn4", 0, 1, -1), t.getAttribute("position")
								.needsUpdate = !0
						}
					}(), fh.prototype = Object.create(ea.prototype), fh.prototype.constructor = fh, fh.prototype
					.update = function () {
						var t = new Qe;
						return function (e) {
							if (void 0 !== e && console.warn(
									"THREE.BoxHelper: .update() has no longer arguments."), void 0 !== this
								.object && t.setFromObject(this.object), !t.isEmpty()) {
								var i = t.min,
									n = t.max,
									r = this.geometry.attributes.position,
									a = r.array;
								a[0] = n.x, a[1] = n.y, a[2] = n.z, a[3] = i.x, a[4] = n.y, a[5] = n.z, a[6] = i
									.x, a[7] = i.y, a[8] = n.z, a[9] = n.x, a[10] = i.y, a[11] = n.z, a[12] = n.x,
									a[13] = n.y, a[14] = i.z, a[15] = i.x, a[16] = n.y, a[17] = i.z, a[18] = i.x,
									a[19] = i.y, a[20] = i.z, a[21] = n.x, a[22] = i.y, a[23] = i.z, r
									.needsUpdate = !0, this.geometry.computeBoundingSphere()
							}
						}
					}(), fh.prototype.setFromObject = function (t) {
						return this.object = t, this.update(), this
					}, fh.prototype.copy = function (t) {
						return ea.prototype.copy.call(this, t), this.object = t.object, this
					}, fh.prototype.clone = function () {
						return (new this.constructor).copy(this)
					}, mh.prototype = Object.create(ea.prototype), mh.prototype.constructor = mh, mh.prototype
					.updateMatrixWorld = function (t) {
						var e = this.box;
						e.isEmpty() || (e.getCenter(this.position), e.getSize(this.scale), this.scale.multiplyScalar(
							.5), Mi.prototype.updateMatrixWorld.call(this, t))
					}, gh.prototype = Object.create(ta.prototype), gh.prototype.constructor = gh, gh.prototype
					.updateMatrixWorld = function (t) {
						var e = -this.plane.constant;
						Math.abs(e) < 1e-8 && (e = 1e-8), this.scale.set(.5 * this.size, .5 * this.size, e), this
							.children[0].material.side = e < 0 ? _ : b, this.lookAt(this.plane.normal), Mi.prototype
							.updateMatrixWorld.call(this, t)
					}, vh.prototype = Object.create(Mi.prototype), vh.prototype.constructor = vh, vh.prototype
					.setDirection = (yc = new Ne, function (t) {
						t.y > .99999 ? this.quaternion.set(0, 0, 0, 1) : t.y < -.99999 ? this.quaternion.set(1, 0,
							0, 0) : (yc.set(t.z, 0, -t.x).normalize(), vc = Math.acos(t.y), this.quaternion
							.setFromAxisAngle(yc, vc))
					}), vh.prototype.setLength = function (t, e, i) {
						void 0 === e && (e = .2 * t), void 0 === i && (i = .2 * e), this.line.scale.set(1, Math.max(0,
								t - e), 1), this.line.updateMatrix(), this.cone.scale.set(i, e, i), this.cone.position
							.y = t, this.cone.updateMatrix()
					}, vh.prototype.setColor = function (t) {
						this.line.material.color.copy(t), this.cone.material.color.copy(t)
					}, vh.prototype.copy = function (t) {
						return Mi.prototype.copy.call(this, t, !1), this.line.copy(t.line), this.cone.copy(t.cone),
							this
					}, vh.prototype.clone = function () {
						return (new this.constructor).copy(this)
					}, yh.prototype = Object.create(ea.prototype), yh.prototype.constructor = yh, os.create =
					function (t, e) {
						return console.log("THREE.Curve.create() has been deprecated"), t.prototype = Object.create(os
							.prototype), t.prototype.constructor = t, t.prototype.getPoint = e, t
					}, Object.assign(Ts.prototype, {
						createPointsGeometry: function (t) {
							console.warn(
								"THREE.CurvePath: .createPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead."
								);
							var e = this.getPoints(t);
							return this.createGeometry(e)
						},
						createSpacedPointsGeometry: function (t) {
							console.warn(
								"THREE.CurvePath: .createSpacedPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead."
								);
							var e = this.getSpacedPoints(t);
							return this.createGeometry(e)
						},
						createGeometry: function (t) {
							console.warn(
								"THREE.CurvePath: .createGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead."
								);
							for (var e = new Ai, i = 0, n = t.length; i < n; i++) {
								var r = t[i];
								e.vertices.push(new Ne(r.x, r.y, r.z || 0))
							}
							return e
						}
					}), Object.assign(As.prototype, {
						fromPoints: function (t) {
							console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."),
								this.setFromPoints(t)
						}
					}), xh.prototype = Object.create(fs.prototype), bh.prototype = Object.create(fs.prototype), _h
					.prototype = Object.create(fs.prototype), Object.assign(_h.prototype, {
						initFromArray: function () {
							console.error("THREE.Spline: .initFromArray() has been removed.")
						},
						getControlPointsArray: function () {
							console.error("THREE.Spline: .getControlPointsArray() has been removed.")
						},
						reparametrizeByArcLength: function () {
							console.error("THREE.Spline: .reparametrizeByArcLength() has been removed.")
						}
					}), hh.prototype.setColors = function () {
						console.error(
							"THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead."
							)
					}, ah.prototype.update = function () {
						console.error("THREE.SkeletonHelper: update() no longer needs to be called.")
					}, Object.assign(rc.prototype, {
						extractUrlBase: function (t) {
							return console.warn(
								"THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."
								), Hs.extractUrlBase(t)
						}
					}), Object.assign(Vs.prototype, {
						setTexturePath: function (t) {
							return console.warn(
								"THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath()."
								), this.setResourcePath(t)
						}
					}), Object.assign(th.prototype, {
						center: function (t) {
							return console.warn("THREE.Box2: .center() has been renamed to .getCenter()."),
								this.getCenter(t)
						},
						empty: function () {
							return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."), this
								.isEmpty()
						},
						isIntersectionBox: function (t) {
							return console.warn(
									"THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."),
								this.intersectsBox(t)
						},
						size: function (t) {
							return console.warn("THREE.Box2: .size() has been renamed to .getSize()."), this
								.getSize(t)
						}
					}), Object.assign(Qe.prototype, {
						center: function (t) {
							return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."),
								this.getCenter(t)
						},
						empty: function () {
							return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."), this
								.isEmpty()
						},
						isIntersectionBox: function (t) {
							return console.warn(
									"THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."),
								this.intersectsBox(t)
						},
						isIntersectionSphere: function (t) {
							return console.warn(
								"THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."
								), this.intersectsSphere(t)
						},
						size: function (t) {
							return console.warn("THREE.Box3: .size() has been renamed to .getSize()."), this
								.getSize(t)
						}
					}), eh.prototype.center = function (t) {
						return console.warn("THREE.Line3: .center() has been renamed to .getCenter()."), this
							.getCenter(t)
					}, Object.assign(Ie, {
						random16: function () {
							return console.warn(
									"THREE.Math: .random16() has been deprecated. Use Math.random() instead."
									), Math.random()
						},
						nearestPowerOfTwo: function (t) {
							return console.warn(
								"THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo()."
								), Ie.floorPowerOfTwo(t)
						},
						nextPowerOfTwo: function (t) {
							return console.warn(
									"THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo()."),
								Ie.ceilPowerOfTwo(t)
						}
					}), Object.assign(Ue.prototype, {
						flattenToArrayOffset: function (t, e) {
							return console.warn(
								"THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."
								), this.toArray(t, e)
						},
						multiplyVector3: function (t) {
							return console.warn(
								"THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."
								), t.applyMatrix3(this)
						},
						multiplyVector3Array: function () {
							console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.")
						},
						applyToBuffer: function (t) {
							return console.warn(
								"THREE.Matrix3: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead."
								), this.applyToBufferAttribute(t)
						},
						applyToVector3Array: function () {
							console.error("THREE.Matrix3: .applyToVector3Array() has been removed.")
						}
					}), Object.assign(Be.prototype, {
						extractPosition: function (t) {
							return console.warn(
									"THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."),
								this.copyPosition(t)
						},
						flattenToArrayOffset: function (t, e) {
							return console.warn(
								"THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."
								), this.toArray(t, e)
						},
						getPosition: function () {
							var t;
							return function () {
								return void 0 === t && (t = new Ne), console.warn(
									"THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."
									), t.setFromMatrixColumn(this, 3)
							}
						}(),
						setRotationFromQuaternion: function (t) {
							return console.warn(
								"THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."
								), this.makeRotationFromQuaternion(t)
						},
						multiplyToArray: function () {
							console.warn("THREE.Matrix4: .multiplyToArray() has been removed.")
						},
						multiplyVector3: function (t) {
							return console.warn(
								"THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."
								), t.applyMatrix4(this)
						},
						multiplyVector4: function (t) {
							return console.warn(
								"THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."
								), t.applyMatrix4(this)
						},
						multiplyVector3Array: function () {
							console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.")
						},
						rotateAxis: function (t) {
							console.warn(
								"THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."
								), t.transformDirection(this)
						},
						crossVector: function (t) {
							return console.warn(
								"THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."
								), t.applyMatrix4(this)
						},
						translate: function () {
							console.error("THREE.Matrix4: .translate() has been removed.")
						},
						rotateX: function () {
							console.error("THREE.Matrix4: .rotateX() has been removed.")
						},
						rotateY: function () {
							console.error("THREE.Matrix4: .rotateY() has been removed.")
						},
						rotateZ: function () {
							console.error("THREE.Matrix4: .rotateZ() has been removed.")
						},
						rotateByAxis: function () {
							console.error("THREE.Matrix4: .rotateByAxis() has been removed.")
						},
						applyToBuffer: function (t) {
							return console.warn(
								"THREE.Matrix4: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead."
								), this.applyToBufferAttribute(t)
						},
						applyToVector3Array: function () {
							console.error("THREE.Matrix4: .applyToVector3Array() has been removed.")
						},
						makeFrustum: function (t, e, i, n, r, a) {
							return console.warn(
								"THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."
								), this.makePerspective(t, e, n, i, r, a)
						}
					}), $e.prototype.isIntersectionLine = function (t) {
						return console.warn(
								"THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."), this
							.intersectsLine(t)
					}, ze.prototype.multiplyVector3 = function (t) {
						return console.warn(
							"THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."
							), t.applyQuaternion(this)
					}, Object.assign(cn.prototype, {
						isIntersectionBox: function (t) {
							return console.warn(
									"THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."),
								this.intersectsBox(t)
						},
						isIntersectionPlane: function (t) {
							return console.warn(
								"THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."
								), this.intersectsPlane(t)
						},
						isIntersectionSphere: function (t) {
							return console.warn(
								"THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."
								), this.intersectsSphere(t)
						}
					}), Object.assign(hn.prototype, {
						area: function () {
							return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."),
								this.getArea()
						},
						barycoordFromPoint: function (t, e) {
							return console.warn(
								"THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."
								), this.getBarycoord(t, e)
						},
						midpoint: function (t) {
							return console.warn(
									"THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."), this
								.getMidpoint(t)
						},
						normal: function (t) {
							return console.warn(
								"THREE.Triangle: .normal() has been renamed to .getNormal()."), this
								.getNormal(t)
						},
						plane: function (t) {
							return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."),
								this.getPlane(t)
						}
					}), Object.assign(hn, {
						barycoordFromPoint: function (t, e, i, n, r) {
							return console.warn(
								"THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."
								), hn.getBarycoord(t, e, i, n, r)
						},
						normal: function (t, e, i, n) {
							return console.warn(
								"THREE.Triangle: .normal() has been renamed to .getNormal()."), hn.getNormal(
									t, e, i, n)
						}
					}), Object.assign(Ls.prototype, {
						extractAllPoints: function (t) {
							return console.warn(
								"THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."
								), this.extractPoints(t)
						},
						extrude: function (t) {
							return console.warn(
								"THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."
								), new $a(this, t)
						},
						makeGeometry: function (t) {
							return console.warn(
								"THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."
								), new uo(this, t)
						}
					}), Object.assign(De.prototype, {
						fromAttribute: function (t, e, i) {
							return console.warn(
								"THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."
								), this.fromBufferAttribute(t, e, i)
						},
						distanceToManhattan: function (t) {
							return console.warn(
								"THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."
								), this.manhattanDistanceTo(t)
						},
						lengthManhattan: function () {
							return console.warn(
								"THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."
								), this.manhattanLength()
						}
					}), Object.assign(Ne.prototype, {
						setEulerFromRotationMatrix: function () {
							console.error(
								"THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead."
								)
						},
						setEulerFromQuaternion: function () {
							console.error(
								"THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead."
								)
						},
						getPositionFromMatrix: function (t) {
							return console.warn(
								"THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."
								), this.setFromMatrixPosition(t)
						},
						getScaleFromMatrix: function (t) {
							return console.warn(
								"THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."
								), this.setFromMatrixScale(t)
						},
						getColumnFromMatrix: function (t, e) {
							return console.warn(
								"THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."
								), this.setFromMatrixColumn(e, t)
						},
						applyProjection: function (t) {
							return console.warn(
								"THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."
								), this.applyMatrix4(t)
						},
						fromAttribute: function (t, e, i) {
							return console.warn(
								"THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."
								), this.fromBufferAttribute(t, e, i)
						},
						distanceToManhattan: function (t) {
							return console.warn(
								"THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."
								), this.manhattanDistanceTo(t)
						},
						lengthManhattan: function () {
							return console.warn(
								"THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."
								), this.manhattanLength()
						}
					}), Object.assign(Xe.prototype, {
						fromAttribute: function (t, e, i) {
							return console.warn(
								"THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."
								), this.fromBufferAttribute(t, e, i)
						},
						lengthManhattan: function () {
							return console.warn(
								"THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."
								), this.manhattanLength()
						}
					}), Object.assign(Ai.prototype, {
						computeTangents: function () {
							console.error("THREE.Geometry: .computeTangents() has been removed.")
						},
						computeLineDistances: function () {
							console.error(
								"THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead."
								)
						}
					}), Object.assign(Mi.prototype, {
						getChildByName: function (t) {
							return console.warn(
								"THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."
								), this.getObjectByName(t)
						},
						renderDepth: function () {
							console.warn(
								"THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead."
								)
						},
						translate: function (t, e) {
							return console.warn(
								"THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."
								), this.translateOnAxis(e, t)
						},
						getWorldRotation: function () {
							console.error(
								"THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead."
								)
						}
					}), Object.defineProperties(Mi.prototype, {
						eulerOrder: {
							get: function () {
								return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),
									this.rotation.order
							},
							set: function (t) {
								console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this
									.rotation.order = t
							}
						},
						useQuaternion: {
							get: function () {
								console.warn(
									"THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default."
									)
							},
							set: function () {
								console.warn(
									"THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default."
									)
							}
						}
					}), Object.defineProperties(Jr.prototype, {
						objects: {
							get: function () {
								return console.warn("THREE.LOD: .objects has been renamed to .levels."), this
									.levels
							}
						}
					}), Object.defineProperty(Qr.prototype, "useVertexTexture", {
						get: function () {
							console.warn("THREE.Skeleton: useVertexTexture has been removed.")
						},
						set: function () {
							console.warn("THREE.Skeleton: useVertexTexture has been removed.")
						}
					}), Zr.prototype.initBones = function () {
						console.error("THREE.SkinnedMesh: initBones() has been removed.")
					}, Object.defineProperty(os.prototype, "__arcLengthDivisions", {
						get: function () {
							return console.warn(
									"THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."), this
								.arcLengthDivisions
						},
						set: function (t) {
							console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."),
								this.arcLengthDivisions = t
						}
					}), Pr.prototype.setLens = function (t, e) {
						console.warn(
							"THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."
							), void 0 !== e && (this.filmGauge = e), this.setFocalLength(t)
					}, Object.defineProperties(Ps.prototype, {
						onlyShadow: {
							set: function () {
								console.warn("THREE.Light: .onlyShadow has been removed.")
							}
						},
						shadowCameraFov: {
							set: function (t) {
								console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."), this
									.shadow.camera.fov = t
							}
						},
						shadowCameraLeft: {
							set: function (t) {
								console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."),
									this.shadow.camera.left = t
							}
						},
						shadowCameraRight: {
							set: function (t) {
								console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."),
									this.shadow.camera.right = t
							}
						},
						shadowCameraTop: {
							set: function (t) {
								console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."), this
									.shadow.camera.top = t
							}
						},
						shadowCameraBottom: {
							set: function (t) {
								console.warn(
									"THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."), this
									.shadow.camera.bottom = t
							}
						},
						shadowCameraNear: {
							set: function (t) {
								console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."),
									this.shadow.camera.near = t
							}
						},
						shadowCameraFar: {
							set: function (t) {
								console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."), this
									.shadow.camera.far = t
							}
						},
						shadowCameraVisible: {
							set: function () {
								console.warn(
									"THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead."
									)
							}
						},
						shadowBias: {
							set: function (t) {
								console.warn("THREE.Light: .shadowBias is now .shadow.bias."), this.shadow
									.bias = t
							}
						},
						shadowDarkness: {
							set: function () {
								console.warn("THREE.Light: .shadowDarkness has been removed.")
							}
						},
						shadowMapWidth: {
							set: function (t) {
								console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."),
									this.shadow.mapSize.width = t
							}
						},
						shadowMapHeight: {
							set: function (t) {
								console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."),
									this.shadow.mapSize.height = t
							}
						}
					}), Object.defineProperties(Li.prototype, {
						length: {
							get: function () {
								return console.warn(
									"THREE.BufferAttribute: .length has been deprecated. Use .count instead."
									), this.array.length
							}
						},
						copyIndicesArray: function () {
							console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.")
						}
					}), Object.assign(Hi.prototype, {
						addIndex: function (t) {
							console.warn(
								"THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."), this
								.setIndex(t)
						},
						addDrawCall: function (t, e, i) {
							void 0 !== i && console.warn(
									"THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."),
								console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."), this
								.addGroup(t, e)
						},
						clearDrawCalls: function () {
							console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."),
								this.clearGroups()
						},
						computeTangents: function () {
							console.warn("THREE.BufferGeometry: .computeTangents() has been removed.")
						},
						computeOffsets: function () {
							console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.")
						}
					}), Object.defineProperties(Hi.prototype, {
						drawcalls: {
							get: function () {
								return console.error(
										"THREE.BufferGeometry: .drawcalls has been renamed to .groups."), this
									.groups
							}
						},
						offsets: {
							get: function () {
								return console.warn(
										"THREE.BufferGeometry: .offsets has been renamed to .groups."), this
									.groups
							}
						}
					}), Object.assign(to.prototype, {
						getArrays: function () {
							console.error("THREE.ExtrudeBufferGeometry: .getArrays() has been removed.")
						},
						addShapeList: function () {
							console.error("THREE.ExtrudeBufferGeometry: .addShapeList() has been removed.")
						},
						addShape: function () {
							console.error("THREE.ExtrudeBufferGeometry: .addShape() has been removed.")
						}
					}), Object.defineProperties(Wc.prototype, {
						dynamic: {
							set: function () {
								console.warn(
									"THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead."
									)
							}
						},
						onUpdate: {
							value: function () {
								return console.warn(
									"THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."
									), this
							}
						}
					}), Object.defineProperties(on.prototype, {
						wrapAround: {
							get: function () {
								console.warn("THREE.Material: .wrapAround has been removed.")
							},
							set: function () {
								console.warn("THREE.Material: .wrapAround has been removed.")
							}
						},
						overdraw: {
							get: function () {
								console.warn("THREE.Material: .overdraw has been removed.")
							},
							set: function () {
								console.warn("THREE.Material: .overdraw has been removed.")
							}
						},
						wrapRGB: {
							get: function () {
								return console.warn("THREE.Material: .wrapRGB has been removed."), new hi
							}
						},
						shading: {
							get: function () {
								console.error("THREE." + this.type +
									": .shading has been removed. Use the boolean .flatShading instead.")
							},
							set: function (t) {
								console.warn("THREE." + this.type +
										": .shading has been removed. Use the boolean .flatShading instead."),
									this.flatShading = 1 === t
							}
						}
					}), Object.defineProperties(Ao.prototype, {
						metal: {
							get: function () {
								return console.warn(
									"THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead."
									), !1
							},
							set: function () {
								console.warn(
									"THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead"
									)
							}
						}
					}), Object.defineProperties(sn.prototype, {
						derivatives: {
							get: function () {
								return console.warn(
									"THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."
									), this.extensions.derivatives
							},
							set: function (t) {
								console.warn(
									"THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."
									), this.extensions.derivatives = t
							}
						}
					}), Object.assign(Hr.prototype, {
						clearTarget: function (t, e, i, n) {
							console.warn(
								"THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."
								), this.setRenderTarget(t), this.clear(e, i, n)
						},
						animate: function (t) {
							console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."), this
								.setAnimationLoop(t)
						},
						getCurrentRenderTarget: function () {
							return console.warn(
								"THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."
								), this.getRenderTarget()
						},
						getMaxAnisotropy: function () {
							return console.warn(
								"THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."
								), this.capabilities.getMaxAnisotropy()
						},
						getPrecision: function () {
							return console.warn(
									"THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."),
								this.capabilities.precision
						},
						resetGLState: function () {
							return console.warn(
								"THREE.WebGLRenderer: .resetGLState() is now .state.reset()."), this.state
								.reset()
						},
						supportsFloatTextures: function () {
							return console.warn(
								"THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."
								), this.extensions.get("OES_texture_float")
						},
						supportsHalfFloatTextures: function () {
							return console.warn(
								"THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."
								), this.extensions.get("OES_texture_half_float")
						},
						supportsStandardDerivatives: function () {
							return console.warn(
								"THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."
								), this.extensions.get("OES_standard_derivatives")
						},
						supportsCompressedTextureS3TC: function () {
							return console.warn(
								"THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."
								), this.extensions.get("WEBGL_compressed_texture_s3tc")
						},
						supportsCompressedTexturePVRTC: function () {
							return console.warn(
								"THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."
								), this.extensions.get("WEBGL_compressed_texture_pvrtc")
						},
						supportsBlendMinMax: function () {
							return console.warn(
								"THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."
								), this.extensions.get("EXT_blend_minmax")
						},
						supportsVertexTextures: function () {
							return console.warn(
								"THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."
								), this.capabilities.vertexTextures
						},
						supportsInstancedArrays: function () {
							return console.warn(
								"THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."
								), this.extensions.get("ANGLE_instanced_arrays")
						},
						enableScissorTest: function (t) {
							console.warn(
									"THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."),
								this.setScissorTest(t)
						},
						initMaterial: function () {
							console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.")
						},
						addPrePlugin: function () {
							console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.")
						},
						addPostPlugin: function () {
							console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.")
						},
						updateShadowMap: function () {
							console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.")
						},
						setFaceCulling: function () {
							console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.")
						}
					}), Object.defineProperties(Hr.prototype, {
						shadowMapEnabled: {
							get: function () {
								return this.shadowMap.enabled
							},
							set: function (t) {
								console.warn(
										"THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."),
									this.shadowMap.enabled = t
							}
						},
						shadowMapType: {
							get: function () {
								return this.shadowMap.type
							},
							set: function (t) {
								console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."),
									this.shadowMap.type = t
							}
						},
						shadowMapCullFace: {
							get: function () {
								console.warn(
									"THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead."
									)
							},
							set: function () {
								console.warn(
									"THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead."
									)
							}
						}
					}), Object.defineProperties(Sr.prototype, {
						cullFace: {
							get: function () {
								console.warn(
									"THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead."
									)
							},
							set: function () {
								console.warn(
									"THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead."
									)
							}
						},
						renderReverseSided: {
							get: function () {
								console.warn(
									"THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead."
									)
							},
							set: function () {
								console.warn(
									"THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead."
									)
							}
						},
						renderSingleSided: {
							get: function () {
								console.warn(
									"THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead."
									)
							},
							set: function () {
								console.warn(
									"THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead."
									)
							}
						}
					}), Object.defineProperties(Ye.prototype, {
						wrapS: {
							get: function () {
								return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."),
									this.texture.wrapS
							},
							set: function (t) {
								console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this
									.texture.wrapS = t
							}
						},
						wrapT: {
							get: function () {
								return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."),
									this.texture.wrapT
							},
							set: function (t) {
								console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this
									.texture.wrapT = t
							}
						},
						magFilter: {
							get: function () {
								return console.warn(
										"THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."),
									this.texture.magFilter
							},
							set: function (t) {
								console.warn(
									"THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this
									.texture.magFilter = t
							}
						},
						minFilter: {
							get: function () {
								return console.warn(
										"THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."),
									this.texture.minFilter
							},
							set: function (t) {
								console.warn(
									"THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this
									.texture.minFilter = t
							}
						},
						anisotropy: {
							get: function () {
								return console.warn(
										"THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."),
									this.texture.anisotropy
							},
							set: function (t) {
								console.warn(
										"THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."),
									this.texture.anisotropy = t
							}
						},
						offset: {
							get: function () {
								return console.warn(
										"THREE.WebGLRenderTarget: .offset is now .texture.offset."), this
									.texture.offset
							},
							set: function (t) {
								console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this
									.texture.offset = t
							}
						},
						repeat: {
							get: function () {
								return console.warn(
										"THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this
									.texture.repeat
							},
							set: function (t) {
								console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this
									.texture.repeat = t
							}
						},
						format: {
							get: function () {
								return console.warn(
										"THREE.WebGLRenderTarget: .format is now .texture.format."), this
									.texture.format
							},
							set: function (t) {
								console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this
									.texture.format = t
							}
						},
						type: {
							get: function () {
								return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."),
									this.texture.type
							},
							set: function (t) {
								console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this
									.texture.type = t
							}
						},
						generateMipmaps: {
							get: function () {
								return console.warn(
									"THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."
									), this.texture.generateMipmaps
							},
							set: function (t) {
								console.warn(
									"THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."
									), this.texture.generateMipmaps = t
							}
						}
					}), Object.defineProperties(Fr.prototype, {
						standing: {
							set: function () {
								console.warn("THREE.WebVRManager: .standing has been removed.")
							}
						},
						userHeight: {
							set: function () {
								console.warn("THREE.WebVRManager: .userHeight has been removed.")
							}
						}
					}), zc.prototype.load = function (t) {
						console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");
						var e = this,
							i = new Rc;
						return i.load(t, function (t) {
							e.setBuffer(t)
						}), this
					}, Uc.prototype.getData = function () {
						return console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData()."), this
							.getFrequencyData()
					}, Ic.prototype.updateCubeMap = function (t, e) {
						return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."), this.update(t, e)
					};
				var wh = {
					merge: function (t, e, i) {
						var n;
						console.warn(
							"THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead."
							), e.isMesh && (e.matrixAutoUpdate && e.updateMatrix(), n = e.matrix, e = e
							.geometry), t.merge(e, n, i)
					},
					center: function (t) {
						return console.warn(
							"THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead."
							), t.center()
					}
				};
				Ve.crossOrigin = void 0, Ve.loadTexture = function (t, e, i, n) {
					console.warn(
						"THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead."
						);
					var r = new as;
					r.setCrossOrigin(this.crossOrigin);
					var a = r.load(t, i, void 0, n);
					return e && (a.mapping = e), a
				}, Ve.loadTextureCube = function (t, e, i, n) {
					console.warn(
						"THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead."
						);
					var r = new rs;
					r.setCrossOrigin(this.crossOrigin);
					var a = r.load(t, i, void 0, n);
					return e && (a.mapping = e), a
				}, Ve.loadCompressedTexture = function () {
					console.error(
						"THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead."
						)
				}, Ve.loadCompressedTextureCube = function () {
					console.error(
						"THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead."
						)
				};
				var Mh = {
					createMultiMaterialObject: function () {
						console.error("THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js")
					},
					detach: function () {
						console.error("THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js")
					},
					attach: function () {
						console.error("THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js")
					}
				};
				t.WebGLRenderTargetCube = Je, t.WebGLRenderTarget = Ye, t.WebGLRenderer = Hr, t.ShaderLib = pi, t
					.UniformsLib = ui, t.UniformsUtils = si, t.ShaderChunk = ei, t.FogExp2 = kr, t.Fog = jr, t.Scene =
					Vr, t.Sprite = Yr, t.LOD = Jr, t.SkinnedMesh = Zr, t.Skeleton = Qr, t.Bone = Kr, t.Mesh = un, t
					.LineSegments = ea, t.LineLoop = ia, t.Line = ta, t.Points = ra, t.Group = Ar, t.VideoTexture =
					aa, t.DataTexture = Ze, t.DataTexture3D = fn, t.CompressedTexture = oa, t.CubeTexture = dn, t
					.CanvasTexture = sa, t.DepthTexture = ca, t.Texture = qe, t.AnimationLoader = ts, t
					.CompressedTextureLoader = es, t.DataTextureLoader = is, t.CubeTextureLoader = rs, t
					.TextureLoader = as, t.ObjectLoader = Vs, t.MaterialLoader = Fs, t.BufferGeometryLoader = ks, t
					.DefaultLoadingManager = Qo, t.LoadingManager = Zo, t.ImageLoader = ns, t.ImageBitmapLoader = $s,
					t.FontLoader = nc, t.FileLoader = $o, t.Loader = rc, t.LoaderUtils = Hs, t.Cache = Jo, t
					.AudioLoader = Rc, t.SpotLightShadow = Os, t.SpotLight = Is, t.PointLight = Ds, t.RectAreaLight =
					Gs, t.HemisphereLight = Cs, t.DirectionalLightShadow = zs, t.DirectionalLight = Ns, t
					.AmbientLight = Us, t.LightShadow = Rs, t.Light = Ps, t.StereoCamera = Oc, t.PerspectiveCamera =
					Pr, t.OrthographicCamera = Bs, t.CubeCamera = Ic, t.ArrayCamera = Cr, t.Camera = Lr, t
					.AudioListener = Bc, t.PositionalAudio = Nc, t.AudioContext = Cc, t.AudioAnalyser = Uc, t.Audio =
					zc, t.VectorKeyframeTrack = qo, t.StringKeyframeTrack = Wo, t.QuaternionKeyframeTrack = Vo, t
					.NumberKeyframeTrack = ko, t.ColorKeyframeTrack = Ho, t.BooleanKeyframeTrack = Fo, t
					.PropertyMixer = Gc, t.PropertyBinding = Hc, t.KeyframeTrack = Go, t.AnimationUtils = Do, t
					.AnimationObjectGroup = kc, t.AnimationMixer = Vc, t.AnimationClip = Xo, t.Uniform = Wc, t
					.InstancedBufferGeometry = qc, t.BufferGeometry = Hi, t.Geometry = Ai, t
					.InterleavedBufferAttribute = qr, t.InstancedInterleavedBuffer = Xc, t.InterleavedBuffer = Wr, t
					.InstancedBufferAttribute = Yc, t.Face3 = mi, t.Object3D = Mi, t.Raycaster = Jc, t.Layers = vi, t
					.EventDispatcher = e, t.Clock = Dc, t.QuaternionLinearInterpolant = jo, t.LinearInterpolant = No,
					t.DiscreteInterpolant = Uo, t.CubicInterpolant = zo, t.Interpolant = Bo, t.Triangle = hn, t.Math =
					Ie, t.Spherical = Kc, t.Cylindrical = $c, t.Plane = $e, t.Frustum = ti, t.Sphere = Ke, t.Ray = cn,
					t.Matrix4 = Be, t.Matrix3 = Ue, t.Box3 = Qe, t.Box2 = th, t.Line3 = eh, t.Euler = gi, t.Vector4 =
					Xe, t.Vector3 = Ne, t.Vector2 = De, t.Quaternion = ze, t.Color = hi, t.ImmediateRenderObject = ih,
					t.VertexNormalsHelper = nh, t.SpotLightHelper = rh, t.SkeletonHelper = ah, t.PointLightHelper =
					oh, t.RectAreaLightHelper = sh, t.HemisphereLightHelper = ch, t.GridHelper = hh, t
					.PolarGridHelper = lh, t.FaceNormalsHelper = uh, t.DirectionalLightHelper = ph, t.CameraHelper =
					dh, t.BoxHelper = fh, t.Box3Helper = mh, t.PlaneHelper = gh, t.ArrowHelper = vh, t.AxesHelper =
					yh, t.Shape = Ls, t.Path = As, t.ShapePath = tc, t.Font = ec, t.CurvePath = Ts, t.Curve = os, t
					.ImageUtils = Ve, t.ShapeUtils = Za, t.WebGLUtils = Tr, t.WireframeGeometry = ha, t
					.ParametricGeometry = la, t.ParametricBufferGeometry = ua, t.TetrahedronGeometry = fa, t
					.TetrahedronBufferGeometry = ma, t.OctahedronGeometry = ga, t.OctahedronBufferGeometry = va, t
					.IcosahedronGeometry = ya, t.IcosahedronBufferGeometry = xa, t.DodecahedronGeometry = ba, t
					.DodecahedronBufferGeometry = _a, t.PolyhedronGeometry = pa, t.PolyhedronBufferGeometry = da, t
					.TubeGeometry = wa, t.TubeBufferGeometry = Ma, t.TorusKnotGeometry = Sa, t
					.TorusKnotBufferGeometry = Ea, t.TorusGeometry = Ta, t.TorusBufferGeometry = Aa, t.TextGeometry =
					no, t.TextBufferGeometry = ro, t.SphereGeometry = ao, t.SphereBufferGeometry = oo, t
					.RingGeometry = so, t.RingBufferGeometry = co, t.PlaneGeometry = Vi, t.PlaneBufferGeometry = Wi, t
					.LatheGeometry = ho, t.LatheBufferGeometry = lo, t.ShapeGeometry = uo, t.ShapeBufferGeometry = po,
					t.ExtrudeGeometry = $a, t.ExtrudeBufferGeometry = to, t.EdgesGeometry = mo, t.ConeGeometry = yo, t
					.ConeBufferGeometry = xo, t.CylinderGeometry = go, t.CylinderBufferGeometry = vo, t
					.CircleGeometry = bo, t.CircleBufferGeometry = _o, t.BoxGeometry = ki, t.BoxBufferGeometry = ji, t
					.ShadowMaterial = Mo, t.SpriteMaterial = Xr, t.RawShaderMaterial = So, t.ShaderMaterial = sn, t
					.PointsMaterial = na, t.MeshPhysicalMaterial = To, t.MeshStandardMaterial = Eo, t
					.MeshPhongMaterial = Ao, t.MeshToonMaterial = Lo, t.MeshNormalMaterial = Po, t
					.MeshLambertMaterial = Co, t.MeshDepthMaterial = wr, t.MeshDistanceMaterial = Mr, t
					.MeshBasicMaterial = ln, t.MeshMatcapMaterial = Ro, t.LineDashedMaterial = Oo, t
					.LineBasicMaterial = $r, t.Material = on, t.Float64BufferAttribute = Ni, t
					.Float32BufferAttribute = zi, t.Uint32BufferAttribute = Bi, t.Int32BufferAttribute = Di, t
					.Uint16BufferAttribute = Ii, t.Int16BufferAttribute = Oi, t.Uint8ClampedBufferAttribute = Ri, t
					.Uint8BufferAttribute = Ci, t.Int8BufferAttribute = Pi, t.BufferAttribute = Li, t.ArcCurve = cs, t
					.CatmullRomCurve3 = fs, t.CubicBezierCurve = ys, t.CubicBezierCurve3 = xs, t.EllipseCurve = ss, t
					.LineCurve = bs, t.LineCurve3 = _s, t.QuadraticBezierCurve = ws, t.QuadraticBezierCurve3 = Ms, t
					.SplineCurve = Ss, t.REVISION = f, t.MOUSE = {
						LEFT: 0,
						MIDDLE: 1,
						RIGHT: 2
					}, t.CullFaceNone = m, t.CullFaceBack = g, t.CullFaceFront = v, t.CullFaceFrontBack = 3, t
					.FrontFaceDirectionCW = 0, t.FrontFaceDirectionCCW = 1, t.BasicShadowMap = 0, t.PCFShadowMap = y,
					t.PCFSoftShadowMap = x, t.FrontSide = b, t.BackSide = _, t.DoubleSide = w, t.FlatShading = 1, t
					.SmoothShading = 2, t.NoColors = M, t.FaceColors = S, t.VertexColors = E, t.NoBlending = T, t
					.NormalBlending = A, t.AdditiveBlending = L, t.SubtractiveBlending = P, t.MultiplyBlending = C, t
					.CustomBlending = R, t.AddEquation = O, t.SubtractEquation = I, t.ReverseSubtractEquation = D, t
					.MinEquation = B, t.MaxEquation = z, t.ZeroFactor = N, t.OneFactor = U, t.SrcColorFactor = G, t
					.OneMinusSrcColorFactor = F, t.SrcAlphaFactor = H, t.OneMinusSrcAlphaFactor = k, t
					.DstAlphaFactor = j, t.OneMinusDstAlphaFactor = V, t.DstColorFactor = W, t
					.OneMinusDstColorFactor = q, t.SrcAlphaSaturateFactor = X, t.NeverDepth = Y, t.AlwaysDepth = J, t
					.LessDepth = Z, t.LessEqualDepth = Q, t.EqualDepth = K, t.GreaterEqualDepth = $, t.GreaterDepth =
					tt, t.NotEqualDepth = et, t.MultiplyOperation = it, t.MixOperation = nt, t.AddOperation = rt, t
					.NoToneMapping = at, t.LinearToneMapping = ot, t.ReinhardToneMapping = st, t
					.Uncharted2ToneMapping = ct, t.CineonToneMapping = ht, t.ACESFilmicToneMapping = lt, t.UVMapping =
					300, t.CubeReflectionMapping = ut, t.CubeRefractionMapping = pt, t
					.EquirectangularReflectionMapping = dt, t.EquirectangularRefractionMapping = ft, t
					.SphericalReflectionMapping = mt, t.CubeUVReflectionMapping = gt, t.CubeUVRefractionMapping = vt,
					t.RepeatWrapping = yt, t.ClampToEdgeWrapping = xt, t.MirroredRepeatWrapping = bt, t
					.NearestFilter = _t, t.NearestMipMapNearestFilter = wt, t.NearestMipMapLinearFilter = Mt, t
					.LinearFilter = St, t.LinearMipMapNearestFilter = Et, t.LinearMipMapLinearFilter = Tt, t
					.UnsignedByteType = At, t.ByteType = Lt, t.ShortType = Pt, t.UnsignedShortType = Ct, t.IntType =
					Rt, t.UnsignedIntType = Ot, t.FloatType = It, t.HalfFloatType = Dt, t.UnsignedShort4444Type = Bt,
					t.UnsignedShort5551Type = zt, t.UnsignedShort565Type = Nt, t.UnsignedInt248Type = Ut, t
					.AlphaFormat = Gt, t.RGBFormat = Ft, t.RGBAFormat = Ht, t.LuminanceFormat = kt, t
					.LuminanceAlphaFormat = jt, t.RGBEFormat = Vt, t.DepthFormat = Wt, t.DepthStencilFormat = qt, t
					.RedFormat = Xt, t.RGB_S3TC_DXT1_Format = Yt, t.RGBA_S3TC_DXT1_Format = Jt, t
					.RGBA_S3TC_DXT3_Format = Zt, t.RGBA_S3TC_DXT5_Format = Qt, t.RGB_PVRTC_4BPPV1_Format = Kt, t
					.RGB_PVRTC_2BPPV1_Format = $t, t.RGBA_PVRTC_4BPPV1_Format = te, t.RGBA_PVRTC_2BPPV1_Format = ee, t
					.RGB_ETC1_Format = ie, t.RGBA_ASTC_4x4_Format = ne, t.RGBA_ASTC_5x4_Format = re, t
					.RGBA_ASTC_5x5_Format = ae, t.RGBA_ASTC_6x5_Format = oe, t.RGBA_ASTC_6x6_Format = se, t
					.RGBA_ASTC_8x5_Format = ce, t.RGBA_ASTC_8x6_Format = he, t.RGBA_ASTC_8x8_Format = le, t
					.RGBA_ASTC_10x5_Format = ue, t.RGBA_ASTC_10x6_Format = pe, t.RGBA_ASTC_10x8_Format = de, t
					.RGBA_ASTC_10x10_Format = fe, t.RGBA_ASTC_12x10_Format = me, t.RGBA_ASTC_12x12_Format = ge, t
					.LoopOnce = 2200, t.LoopRepeat = ve, t.LoopPingPong = 2202, t.InterpolateDiscrete = 2300, t
					.InterpolateLinear = 2301, t.InterpolateSmooth = 2302, t.ZeroCurvatureEnding = ye, t
					.ZeroSlopeEnding = 2401, t.WrapAroundEnding = 2402, t.TrianglesDrawMode = xe, t
					.TriangleStripDrawMode = be, t.TriangleFanDrawMode = _e, t.LinearEncoding = we, t.sRGBEncoding =
					Me, t.GammaEncoding = Se, t.RGBEEncoding = Ee, t.LogLuvEncoding = 3003, t.RGBM7Encoding = Te, t
					.RGBM16Encoding = Ae, t.RGBDEncoding = Le, t.BasicDepthPacking = Pe, t.RGBADepthPacking = Ce, t
					.TangentSpaceNormalMap = Re, t.ObjectSpaceNormalMap = Oe, t.CubeGeometry = ki, t.Face4 =
					function (t, e, i, n, r, a, o) {
						return console.warn("THREE.Face4 has been removed. A THREE.Face3 will be created instead."),
							new mi(t, e, i, r, a, o)
					}, t.LineStrip = 0, t.LinePieces = 1, t.MeshFaceMaterial = function (t) {
						return console.warn("THREE.MeshFaceMaterial has been removed. Use an Array instead."), t
					}, t.MultiMaterial = function (t) {
						return void 0 === t && (t = []), console.warn(
								"THREE.MultiMaterial has been removed. Use an Array instead."), t.isMultiMaterial = !
							0, t.materials = t, t.clone = function () {
								return t.slice()
							}, t
					}, t.PointCloud = function (t, e) {
						return console.warn("THREE.PointCloud has been renamed to THREE.Points."), new ra(t, e)
					}, t.Particle = function (t) {
						return console.warn("THREE.Particle has been renamed to THREE.Sprite."), new Yr(t)
					}, t.ParticleSystem = function (t, e) {
						return console.warn("THREE.ParticleSystem has been renamed to THREE.Points."), new ra(t, e)
					}, t.PointCloudMaterial = function (t) {
						return console.warn("THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial."),
							new na(t)
					}, t.ParticleBasicMaterial = function (t) {
						return console.warn("THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial."),
							new na(t)
					}, t.ParticleSystemMaterial = function (t) {
						return console.warn("THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial."),
							new na(t)
					}, t.Vertex = function (t, e, i) {
						return console.warn("THREE.Vertex has been removed. Use THREE.Vector3 instead."), new Ne(t, e,
							i)
					}, t.DynamicBufferAttribute = function (t, e) {
						return console.warn(
							"THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead."
							), new Li(t, e).setDynamic(!0)
					}, t.Int8Attribute = function (t, e) {
						return console.warn(
								"THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead."),
							new Pi(t, e)
					}, t.Uint8Attribute = function (t, e) {
						return console.warn(
							"THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead."
							), new Ci(t, e)
					}, t.Uint8ClampedAttribute = function (t, e) {
						return console.warn(
							"THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead."
							), new Ri(t, e)
					}, t.Int16Attribute = function (t, e) {
						return console.warn(
							"THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead."
							), new Oi(t, e)
					}, t.Uint16Attribute = function (t, e) {
						return console.warn(
							"THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead."
							), new Ii(t, e)
					}, t.Int32Attribute = function (t, e) {
						return console.warn(
							"THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead."
							), new Di(t, e)
					}, t.Uint32Attribute = function (t, e) {
						return console.warn(
							"THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead."
							), new Bi(t, e)
					}, t.Float32Attribute = function (t, e) {
						return console.warn(
							"THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead."
							), new zi(t, e)
					}, t.Float64Attribute = function (t, e) {
						return console.warn(
							"THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead."
							), new Ni(t, e)
					}, t.ClosedSplineCurve3 = xh, t.SplineCurve3 = bh, t.Spline = _h, t.AxisHelper = function (t) {
						return console.warn("THREE.AxisHelper has been renamed to THREE.AxesHelper."), new yh(t)
					}, t.BoundingBoxHelper = function (t, e) {
						return console.warn(
								"THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead."),
							new fh(t, e)
					}, t.EdgesHelper = function (t, e) {
						return console.warn("THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead."),
							new ea(new mo(t.geometry), new $r({
								color: void 0 !== e ? e : 16777215
							}))
					}, t.WireframeHelper = function (t, e) {
						return console.warn(
								"THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead."),
							new ea(new ha(t.geometry), new $r({
								color: void 0 !== e ? e : 16777215
							}))
					}, t.XHRLoader = function (t) {
						return console.warn("THREE.XHRLoader has been renamed to THREE.FileLoader."), new $o(t)
					}, t.BinaryTextureLoader = function (t) {
						return console.warn("THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader."),
							new is(t)
					}, t.GeometryUtils = wh, t.Projector = function () {
						console.error("THREE.Projector has been moved to /examples/js/renderers/Projector.js."), this
							.projectVector = function (t, e) {
								console.warn("THREE.Projector: .projectVector() is now vector.project()."), t.project(
									e)
							}, this.unprojectVector = function (t, e) {
								console.warn("THREE.Projector: .unprojectVector() is now vector.unproject()."), t
									.unproject(e)
							}, this.pickingRay = function () {
								console.error("THREE.Projector: .pickingRay() is now raycaster.setFromCamera().")
							}
					}, t.CanvasRenderer = function () {
						console.error("THREE.CanvasRenderer has been removed")
					}, t.JSONLoader = function () {
						console.error("THREE.JSONLoader has been removed.")
					}, t.SceneUtils = Mh, t.LensFlare = function () {
						console.error("THREE.LensFlare has been moved to /examples/js/objects/Lensflare.js")
					}, Object.defineProperty(t, "__esModule", {
						value: !0
					})
			}(e)
		}, function (t, e, i) {
			"use strict";
			i.r(e);
			var n = i(5);

			function r(t) {
				n.default.call(this, t);
				var e, i = this,
					r = this.getEvents();
				for (this._congratText = this._screens.game.querySelectorAll(".congrat"), this._bossInfos = this
					._screens.game.querySelector(".boss-infos"), this._text = this._screens.game.querySelectorAll(
					"p"), this._progress = this._screens.game.querySelector(".progress"), this._progressFrom = this
					._progress.querySelector(".from"), this._progressBar = this._progress.querySelector(".bar div"),
					this._progressTo = this._progress.querySelector(".to"), this._screens.start.addEventListener(r
						.pointerdown,
						function (t) {
							i._settings.onClickStartScreen.call(i._screens.start, t)
						}), e = 0; e < this._text.length; e++) this._text[e].addEventListener("transitionend",
					function (t) {
						o.call(t.target, t, i._classes.hidden, i._classes.visible)
					})
			}

			function a(t, e) {
				var i = this._classes.visible,
					n = this._classes.hidden;
				t.classList.add(i), setTimeout(function () {
					t.classList.add(n), e && e()
				}, 1e3)
			}

			function o(t, e, i) {
				this.classList.contains(e) && this.classList.remove(i, e)
			}
			Object.assign(r.prototype, n.default.prototype, {
				setProgress: function (t) {
					return this._progressFrom.innerHTML = t.from, this._progressBar.style.width = t
						.progress, this._progressTo.innerHTML = t.to, this
				},
				showRandomWord() {
					var t = Math.floor(Math.random() * this._congratText.length),
						e = this._congratText[t];
					return a.call(this, e), this
				},
				showBossInfos: function (t, e) {
					this._bossInfos.querySelector(".name").innerHTML = t.name, this._bossInfos
						.querySelector(".sub").innerHTML = t.sub, this._bossInfos.style.color = t.color, a
						.call(this, this._bossInfos, e)
				}
			}), e.default = r
		}, function (t, e, i) {
			"use strict";

			function n(t) {
				var e, i, n = this;
				this._settings = Object.assign({
						app: "#App",
						onResize: function () {},
						onClickRetry: function () {}
					}, t), this._body = document.body, this._app = (e = "App", (i || document).getElementById(e)),
					this._header = a("obj-header"), this._screens = {
						loading: a("screen-loading"),
						start: a("screen-start"),
						game: a("screen-game"),
						end: a("screen-end")
					}, this._banner = a("obj-banner"), this._classes = {
						hidden: "is-hidden",
						visible: "is-visible",
						landscape: "landscape",
						portrait: "portrait"
					}, this._retry = r("retry"), this._height = 0, this._width = 0, window.onresize = function (t) {
						var e = this._app,
							i = this._classes,
							n = i.landscape,
							r = i.portrait,
							a = document.body.clientHeight,
							c = document.body.clientWidth;
						this._height = a, this._width = c, c > a ? (this._body.style.fontSize = a / 540 * 16 + "px",
							o(e, n), s(e, r)) : (this._body.style.fontSize = c / 360 * 16 + "px", o(e, r), s(e,
							n));
						this._settings.onResize(t, c, a)
					}.bind(this),
					function (t, e) {
						var i;
						for (i = 0; i < t.length; i++) e(t[i])
					}(this._retry, function (t) {
						t.addEventListener("click", function (e) {
							n._settings.onClickRetry.call(t, e)
						})
					}), this._screens.end.addEventListener("click", function () {
						n._banner.click()
					})
			}

			function r(t, e) {
				return (e || document).getElementsByClassName(t)
			}

			function a(t, e) {
				return r(t, e)[0]
			}

			function o(t, e) {
				t.classList.add(e)
			}

			function s(t, e) {
				t.classList.remove(e)
			}
			i.r(e), n.prototype = {
				getEvents: function () {
					return this.isMobile() ? {
						pointerdown: "touchstart",
						pointermove: "touchmove",
						pointerup: "touchend"
					} : {
						pointerdown: "pointerdown",
						pointermove: "pointermove",
						pointerup: "pointerup"
					}
				},
				triggerResize: function () {
					return window.dispatchEvent(new Event("resize")), this
				},
				switchScreen: function (t, e) {
					return this.hideScreen(t).showScreen(e)
				},
				showScreen: function (t) {
					return this.showElement(this._screens[t])
				},
				hideScreen: function (t) {
					return this.hideElement(this._screens[t])
				},
				showElement: function (t) {
					return o(t, this._classes.visible), this
				},
				hideElement: function (t) {
					return s(t, this._classes.visible), this
				},
				isMobile: function () {
					return c()
				},
				getHeight: function () {
					return this._height
				},
				getWidth: function () {
					return this._width
				}
			};
			var c = function () {
				var t = /iPad|iPhone|iPod|Android/i.test(navigator.userAgent);
				return c = function () {
					return t
				}, t
			};
			e.default = n
		}, function (t, e, i) {
			"use strict";
			i.r(e);
			var n = i(3),
				r = i(7);

			function a(t) {
				r.default.call(this, t);
				this._camera = new n.PerspectiveCamera(75, 1, .1, 400), this._camera.position.z = 30, this._object
					.position.y = -12, this._object.rotation.z = Math.PI, this._startMoveX = 0
			}
			Object.assign(a.prototype, r.default.prototype, {
				getCamera: function () {
					return this._camera
				},
				updateCamera: function (t) {
					return this._camera.aspect = t, this._camera.updateProjectionMatrix(), this
				},
				startMoveX: function () {
					return this._startMoveX = this._object.position.x, this
				},
				moveX: function (t) {
					this._object.position.x = this._startMoveX + t
				},
				update: function (t, e) {
					r.default.prototype.update.call(this, t, e)
				},
				isColliding: function (t) {
					var e = this.getPosition(),
						i = this._width / 2,
						n = this._height / 2;
					return e.y - n <= t.y && t.y <= e.y + n && e.x - i <= t.x && t.x <= e.x + i
				},
				isCollidingWithBall: function (t) {
					var e = this.getPosition(),
						i = this._width / 3,
						n = !1;
					return this.isColliding(t) && (t.x <= e.x - i / 2 ? (this._collisionResponse = "left",
						this._catchingHand = this._handLeft) : t.x >= e.x + i / 2 ? (this
						._collisionResponse = "right", this._catchingHand = this._handRight) : (
						this._collisionResponse = "head", this._isAlive = !1), n = !0), n
				}
			}), e.default = a
		}, function (t, e, i) {
			"use strict";
			i.r(e);
			var n = i(3),
				r = i(8);

			function a(t) {
				r.default.call(this, t);
				var e, i, a = this,
					o = this._settings.scale || 1;
				this._scale = o, this._width = 9 * o, this._height = 3 * o, this._object = new n.Group, this._head =
					new n.Mesh(new n.PlaneBufferGeometry(3 * o, 3 * o), new n.MeshBasicMaterial({
						map: this.base64ToTexture(this._settings.head),
						opacity: 0,
						transparent: !0
					})), this._handRight = new n.Mesh(new n.PlaneBufferGeometry(2.5 * o, 2.5 * o), new n
						.MeshBasicMaterial({
							map: this.base64ToTexture(this._settings.hand),
							opacity: 0,
							transparent: !0
						})), this._handLeft = new n.Mesh(new n.PlaneBufferGeometry(2.5 * o, 2.5 * o), new n
						.MeshBasicMaterial({
							map: this.base64ToTexture(this._settings.hand, function (t) {
								t.wrapS = n.RepeatWrapping, t.repeat.x = -1
							}),
							opacity: 0,
							transparent: !0
						})), this._mask = new n.Mesh(new n.CircleBufferGeometry(1, 32), new n.MeshBasicMaterial({
						color: this._settings.color,
						opacity: 0,
						transparent: !0
					})), this._isAlive = !0, this._mask.position.y = -2, this._mask.position.z = 1, this._handRight
					.position.x = -3 * o, this._handRight.position.y = -.75 * o, this._handRight.rotation.z = Math
					.PI / 4, this._handLeft.position.x = 3 * o, this._handLeft.position.y = -.75 * o, this._handLeft
					.rotation.z = -Math.PI / 4, this._ticks = 0, this._collisionResponse = null, this._catchingHand =
					this._handRight, this._catchingHandPosition = new n.Vector3, new n.Mesh(new n.PlaneBufferGeometry(
						this._width, this._height, 3), new n.MeshBasicMaterial({
						color: 0,
						wireframe: !0
					})).position.y = -.25, this._object.add(this._mask, this._head, this._handRight, this._handLeft),
					this.addAnimation("show", {
						duration: 1e3,
						easing: "easeInOutQuad",
						onUpdate: function (t) {
							a._mask.scale.set(1 + 20 * t, 1 + 20 * t, 1), t <= .5 ? a._mask.material.opacity =
								2 * t : (0 === a._head.material.opacity && (a._head.material.opacity = 1, a
										._handLeft.material.opacity = 1, a._handRight.material.opacity = 1), a
									._mask.material.opacity = 1 - 2 * (t - .5))
						}
					}), this.addAnimation("destroy", {
						duration: 1e3,
						easing: "easeInOutQuad",
						onStart: function () {
							var t;
							for (a._mask.position.y = 0, a._mask.scale.set(.5, .5, 1), t = 0; t < 100; t++);
						},
						onUpdate: function (t) {
							a._mask.scale.set(1 + 40 * t, 1 + 40 * t, 1), t <= .125 ? a._mask.material
								.opacity = 8 * t : t <= .25 && (1 === a._head.material.opacity && (a._head
									.material.opacity = 0, a._handLeft.material.opacity = 0, a._handRight
									.material.opacity = 0), a._mask.material.opacity = 1 - 8 * (t - .125))
						}
					}), this.addAnimation("rotateLeft", {
						duration: 750,
						easing: "easeInOutQuad",
						onStart: function () {
							e = a._object.rotation.z
						},
						onUpdate: function (t) {
							a._object.rotation.z = e + t * Math.PI * 2
						}
					}), this.addAnimation("rotateRight", function () {
						var t;
						return {
							duration: 750,
							easing: "easeInOutQuad",
							onStart: function () {
								t = a._object.rotation.z
							},
							onUpdate: function (e) {
								a._object.rotation.z = t - e * Math.PI * 2
							}
						}
					}()), this.addAnimation("firstShot", function () {
						var t, e = Math.PI / 4;
						return {
							duration: 750,
							easing: "easeInOutQuad",
							onStart: function () {
								t = a._object.rotation.z
							},
							onUpdate: function (i) {
								a._object.rotation.z = i <= .25 ? t - i * e * 4 : i <= .75 ? t - e + (i -
									.25) * e * 4 : t + e - (i - .75) * e * 4
							}
						}
					}()), this.addAnimation("replace", {
						duration: 1e3,
						easing: "easeInOutQuad",
						onStart: function () {
							i = a._object.position.x
						},
						onUpdate: function (t) {
							a._object.position.x = i - i * t
						}
					})
			}
			Object.assign(a.prototype, r.default.prototype, {
				replace: function (t) {
					return this.playAnimation("replace", t), this
				},
				isAlive: function () {
					return this._isAlive
				},
				getHandPosition() {
					return this._catchingHand.getWorldPosition(this._catchingHandPosition), this
						._catchingHandPosition
				},
				show: function (t) {
					return this.playAnimation("show", t), this
				},
				destroy: function (t) {
					return this.playAnimation("destroy", t), this
				},
				rotateLeft: function (t) {
					return this.playAnimation("rotateLeft", t), this
				},
				rotateRight: function (t) {
					return this.playAnimation("rotateRight", t), this
				},
				firstShot: function (t) {
					return this.playAnimation("firstShot", t), this
				},
				isColliding: function (t) {
					var e = this.getPosition(),
						i = this._width / 2,
						n = this._height / 2;
					return e.y + n >= t.y && t.y >= e.y - n && e.x - i <= t.x && t.x <= e.x + i
				},
				isCollidingWithBall: function (t) {
					var e = this.getPosition(),
						i = this._width / 3,
						n = !1;
					return this.isColliding(t) && (t.x <= e.x - i / 2 ? (this._collisionResponse =
						"right", this._catchingHand = this._handRight) : t.x >= e.x + i / 2 ? (
						this._collisionResponse = "left", this._catchingHand = this._handLeft) : (
						this._collisionResponse = "head", this._isAlive = !1), n = !0), n
				},
				getCollisionResponse() {
					return this._collisionResponse
				},
				update: function (t, e) {
					var i, n;
					this._animate(t), this._ticks += e, i = 1 + Math.cos(this._ticks / 10) / 8, n = 1 +
						Math.sin(this._ticks / 10) / 8, this._handLeft.scale.set(i, i, 1), this._handRight
						.scale.set(n, n, 1), this._head.position.x = Math.cos(this._ticks / 8) / 4
				}
			}), e.default = a
		}, function (t, e, i) {
			"use strict";
			i.r(e);
			var n = i(3),
				r = i(9);

			function a(t) {
				this._settings = t, this._animations = {}, this._runningAnimations = []
			}
			a.prototype = {
				removeAnimation: function (t) {
					var e;
					if (arguments.length > 1)
						for (e = 0; e < arguments.length; e++) this.removeAnimation(arguments[e]);
					return delete this._animations[t], this
				},
				addAnimation: function (t, e) {
					return this._animations[t] ? console.error("[Object3dWrapper] Animation" + t +
						" already exists", this) : this._animations[t] = new r.default(t, e), this
				},
				playAnimation: function (t) {
					var e, i = Array.prototype.slice.call(arguments),
						n = i[i.length - 1],
						r = this._runningAnimations.indexOf(this._animations[t]);
					if ("string" != typeof n ? i.splice(-1, 1) : n = void 0, i.length > 1)
						for (e = 0; e < i.length; e++) this.playAnimation(i[e], n);
					return r >= 0 && !this._animations[t].isMultiple() ? this._animations[t].kill().play(n) :
						(this._runningAnimations.push(this._animations[t]), this._animations[t].play(n)), this
				},
				_animate: function (t) {
					var e, i;
					for (i = 0; i < this._runningAnimations.length; i++)(e = this._runningAnimations[i])
						.update(t), e.isAlive() || (this._runningAnimations.splice(i, 1), i--);
					return this
				},
				getPosition: function (t) {
					return t ? this._object.position.clone() : this._object.position
				},
				getObject: function () {
					return this._object
				},
				update: function () {
					return this
				},
				base64ToTexture: function (t, e) {
					var i = new Image,
						r = new n.Texture;
					return i.src = t, r.image = i, i.onload = function () {
						r.needsUpdate = !0, e && e(r)
					}, r
				}
			}, e.default = a
		}, function (t, e, i) {
			"use strict";

			function n(t, e) {
				this._settings = Object.assign({
					duration: 1e3,
					easing: "linear",
					completeOnKill: !0,
					multiple: !1,
					onStart: r,
					onUpdate: r,
					onComplete: r
				}, e), this._start = null, this._isAlive = !1, this._name = t
			}
			i.r(e), n.prototype = {
				isMultiple: function () {
					return this._settings.multiple
				},
				kill: function () {
					return this._start = null, this._isAlive = !1, this._settings.completeOnKill && (this
						._settings.onUpdate(1), this._settings.onComplete(1)), this
				},
				isAlive: function () {
					return this._isAlive
				},
				play: function (t) {
					return this._playOptions = Object.assign({
						onStart: r,
						onUpdate: r,
						onComplete: r
					}, t), this._isAlive = !0, this
				},
				update: function (t) {
					var e, i;
					this.isAlive() && (null === this._start && (this._start = t, this._settings.onStart(0),
						this._playOptions.onStart(0)), e = t - this._start, i = Math.min(n.easing[this
						._settings.easing](e / this._settings.duration), 1), this._settings.onUpdate(
						i), this._playOptions.onUpdate(i), e >= this._settings.duration && (this
						._isAlive = !1, this._start = null, this._settings.onUpdate(1), this
						._playOptions.onUpdate(1), this._settings.onComplete(1), this._playOptions
						.onComplete(1)))
				}
			}, n.easing = {
				linear: function (t) {
					return t
				},
				easeInQuad: function (t) {
					return t * t
				},
				easeOutQuad: function (t) {
					return t * (2 - t)
				},
				easeInOutQuad: function (t) {
					return t < .5 ? 2 * t * t : (4 - 2 * t) * t - 1
				},
				easeInCubic: function (t) {
					return t * t * t
				},
				easeOutCubic: function (t) {
					return --t * t * t + 1
				},
				easeInOutCubic: function (t) {
					return t < .5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1
				},
				easeInQuart: function (t) {
					return t * t * t * t
				},
				easeOutQuart: function (t) {
					return 1 - --t * t * t * t
				},
				easeInOutQuart: function (t) {
					return t < .5 ? 8 * t * t * t * t : 1 - 8 * --t * t * t * t
				},
				easeInQuint: function (t) {
					return t * t * t * t * t
				},
				easeOutQuint: function (t) {
					return 1 + --t * t * t * t * t
				},
				easeInOutQuint: function (t) {
					return t < .5 ? 16 * t * t * t * t * t : 1 + 16 * --t * t * t * t * t
				}
			};
			var r = function () {};
			e.default = n
		}, function (t, e, i) {
			"use strict";
			i.r(e);
			var n = i(3),
				r = i(8),
				a = i(11),
				o = i(12);

			function s(t) {
				r.default.call(this, t), this._object = new n.Group, this._player = this._settings.player, this
					._lastCollider = null, this._isReady = !1, this._currentMatch = 0, this._currentLevel = 1, this
					._currentOpponentIndex = -1, this._currentBossIndex = -1, this._isBallCatched = !1, this
					._maxBallPositionY = 17, this._minBallPositionY = -17
			}
			Object.assign(s.prototype, r.default.prototype, {
				initialize: function (t) {
					return this._currentMatch++, this._isBossMatch = this._currentMatch % this._settings
						.nbMatchByLevel == 0 && 0 !== this._currentMatch, this._isBossMatch ? (this
							._currentBossIndex = ++this._currentBossIndex % this._settings.boss.length,
							this._currentLevel++) : this._currentOpponentIndex = ++this
						._currentOpponentIndex % this._settings.opponent.length, this._isOpponentDead = !
						1, this._isPlayerDead = !1, this._playerShootFirst = !1, this._isReady = !1, this
						._ball = new o.default(this._settings.ball), this._opponent = this._isBossMatch ?
						new a.default(this._settings.boss[this._currentBossIndex]) : new a.default(this
							._settings.opponent[this._currentOpponentIndex]), this._firstPlayer = this
						._playerShootFirst ? this._player : this._opponent, this._secondPlayer = this
						._playerShootFirst ? this._opponent : this._player, this._lastCollider = this
						._opponent, this._object.add(this._opponent.getObject(), this._ball.getObject()),
						this._object.updateMatrixWorld(), this._ball.catch().setPosition(this._firstPlayer
							.getHandPosition()), this._opponent.show(), this
				},
				getBossInfos: function () {
					var t = this._settings.boss[this._currentBossIndex];
					return {
						name: t.name,
						sub: t.sub,
						color: t.color
					}
				},
				hasReachedMaxLevel: function () {
					return this._currentLevel === this._settings.maxLevel + 1
				},
				getProgress: function () {
					return {
						from: this._currentLevel,
						progress: this._currentMatch % this._settings.nbMatchByLevel / this._settings
							.nbMatchByLevel * 100 + "%",
						to: this._currentLevel + 1
					}
				},
				restart: function () {
					var t = this;
					return this._player.replace({
						onComplete: function () {
							t._ball = new o.default(t._settings.ball), t._object.add(t._ball
								.getObject()), t._ball.catch().setPosition(t._firstPlayer
								.getHandPosition()), t.start()
						}
					}), this._opponent.replace(), this
				},
				start: function (t) {
					var e = this,
						i = function () {
							e._firstPlayer.firstShot({
								onUpdate: function (t) {
									t >= .65 && e._ball.isCatched() ? e._ball.to(e
											._secondPlayer.getPosition(!0)).release() : e
										._ball.isCatched() && e._ball.setPosition(e
											._firstPlayer.getHandPosition())
								},
								onComplete: function () {
									e._isReady = !0
								}
							})
						};
					return t ? setTimeout(i, t) : i(), this
				},
				isOpponentDead: function () {
					return !this._opponent.isAlive()
				},
				isPlayerDead: function () {
					return !this._player.isAlive()
				},
				isBallCatched: function () {
					var t = this._isBallCatched;
					return this._isBallCatched = !1, t
				},
				isBossMatch: function () {
					return this._isBossMatch
				},
				update: function (t, e) {
					var i, n = this,
						r = this._ball,
						a = r.getPosition(),
						o = null,
						s = null,
						c = this._player,
						h = this._opponent,
						l = function () {},
						u = l,
						p = l;
					return this._isReady && (c !== this._lastCollider && c.isCollidingWithBall(a) ? (o =
						c, s = h, u = function () {
							h[function () {
								var t = "moveToCatch",
									e = 100 * Math.random(),
									i = this._isBossMatch ? 90 : 66;
								e > i && (t = "moveToDie");
								return t
							}.call(this)]()
						}) : h !== this._lastCollider && h.isCollidingWithBall(a) && (o = h, s =
						c, u = function () {
							h.move()
						}), o && (this._lastCollider = o, this._isBallCatched = !0, i = o
						.getCollisionResponse(), r.catch(), "head" !== i ? o["right" === i ?
							"rotateRight" : "rotateLeft"]({
							onStart: p,
							onUpdate: function (t) {
								t >= .65 && r.isCatched() ? r.to(s.getPosition(!0))
									.release() : r.isCatched() && r.setPosition(o
										.getHandPosition())
							},
							onComplete: u
						}) : (this._isReady = !1, o !== c ? o.destroy({
							onComplete: function () {
								console.log("[Match] - update - remove opponent"), n
									._object.remove(o.getObject())
							}
						}) : o.destroy(), r.explode({
							onComplete: function () {
								n._object.remove(n._ball.getObject())
							}
						}))), a.y < this._minBallPositionY && (this._isReady = !1, r.explode({
						onComplete: function () {
							n._object.remove(n._ball.getObject()), n.restart()
						}
					}))), r.update(t, e), this._opponent.update(t, e), this
				}
			}), e.default = s
		}, function (t, e, i) {
			"use strict";
			i.r(e);
			var n = i(7);

			function r(t) {
				n.default.call(this, t), this._object.position.y = 12
			}
			Object.assign(r.prototype, n.default.prototype, {
				move: function (t, e, i) {
					var n = this,
						r = this._object.position.x,
						a = void 0 !== e ? e : 10 * Math.random() - 5;
					return this.addAnimation("move", {
						duration: t || 500,
						easing: "easeInOutQuad",
						onUpdate: function (t) {
							n._object.position.x = (a - r) * t + r
						},
						onComplete: function () {
							n.removeAnimation("move"), i && i()
						}
					}).playAnimation("move"), this
				},
				moveToCatch: function () {
					var t = this,
						e = 2 * Math.random() - 1;
					return setTimeout(function () {
						t.move(150, t._object.position.x + (e < 0 ? -3.5 : 3.5))
					}, 150 * Math.random()), this
				},
				moveToDie: function () {
					var t = this,
						e = this._object.position.x,
						i = 8 * Math.random() - 4;
					return this.move(100, e + i, function () {
						t.move(100, e)
					}), this
				},
				moveToLost: function () {
					var t = this,
						e = 2 * Math.random() - 1,
						i = (3 * Math.random() + 3.5) * (e < 0 ? -1 : 1);
					return setTimeout(function () {
						t.move(150, t._object.position.x + i)
					}, 150 * Math.random()), this
				},
				update: function (t, e) {
					n.default.prototype.update.call(this, t, e)
				}
			}), e.default = r
		}, function (t, e, i) {
			"use strict";
			i.r(e);
			var n = i(3),
				r = i(8);

			function a(t) {
				r.default.call(this, t);
				var e, i = this,
					a = this._settings;
				this._ball = new n.Mesh(new n.PlaneBufferGeometry(2, 2), new n.MeshBasicMaterial({
						map: this.base64ToTexture(this._settings.texture),
						transparent: !0
					})), this._ball.position.z = -.25, this._object = new n.Group, this._object.add(this._ball), this
					._speed = .3, this._velocity = new n.Vector3(0, 0, 0), this._isCatched = !1, this._isAlive = !0,
					this._ballPositions = [], this._ballPositionsMaxLength = 20, this._tail, this._tailGeometry =
					new n.Geometry, this._tailMaterial = new n.LineBasicMaterial({
						color: this._settings.color,
						linewidth: 10
					}), this.addAnimation("explode", (e = [], {
						duration: 1e3,
						easing: "easeInOutQuad",
						onStart: function () {
							var t, r, o, s = [a.particle1, a.particle2, a.particle3, a.particle4];
							for (o = 0; o < 100; o++) r = 2 * Math.random(), (t = new n.Mesh(new n
									.PlaneBufferGeometry(r, r), new n.MeshBasicMaterial({
										color: s[Math.floor(Math.random() * s.length)],
										transparent: !0
									}))).userData.position = new n.Vector2(40 * Math.random() - 20, 40 *
									Math.random() - 20).normalize().multiplyScalar(20 * Math.random()), t
								.userData.rotation = Math.random() / 2, e.push(t), i._object.add(t)
						},
						onUpdate: function (t) {
							var n, r;
							for (t < .25 && (i._ball.scale.set(40 * t + 1, 40 * t + 1, 1), i._ball
									.material.opacity = 1 - 4 * t), r = 0; r < e.length; r++)(n = e[r])
								.position.x = n.userData.position.x * t, n.position.y = n.userData
								.position.y * t, n.userData.position.y -= .1 * t * 2, n.rotation.z += n
								.userData.rotation, n.material.opacity = 1 - t
						}
					}))
			}
			Object.assign(a.prototype, r.default.prototype, {
				_trackPositions: function () {
					return this._ballPositions.unshift(this._object.position.clone()), this._ballPositions
						.length > this._ballPositionsMaxLength && this._ballPositions.pop(), this
				},
				_drawTail: function () {
					var t, e = new n.Geometry;
					for (t = 1; t < this._ballPositions.length; t++) e.vertices.push(this._ballPositions[
						t].clone().sub(this._object.position));
					return this._object.remove(this._tail), this._tail = new n.Line(e, this
						._tailMaterial), this._object.add(this._tail), this
				},
				explode: function (t) {
					return this.playAnimation("explode", t), this._isAlive = !1, this
				},
				setPosition: function (t) {
					return this._object.position.copy(t), this
				},
				catch: function () {
					return this._isCatched = !0, this
				},
				release: function () {
					return this._isCatched = !1, this
				},
				isCatched: function () {
					return this._isCatched
				},
				to: function (t) {
					var e = this._object.position;
					return this._velocity.y = t.y, this._velocity.x = (t.x - e.x) / 2, this._velocity
						.normalize(), this
				},
				update: function (t, e) {
					return this._animate(t), !this.isCatched() && this._isAlive && this._object.position
						.add(this._velocity.clone().multiplyScalar(this._speed * e)), this
				}
			}), e.default = a
		}, function (t, e, i) {
			"use strict";

			function n() {
				this._time = 0, this._timeScale = 1, this._gameTime = 0, this._prevTime = 0, this._prevGameTime = 0,
					this._raf
			}
			i.r(e), n.prototype = {
				setTimeScale: function (t) {
					return this._timeScale = t, this
				},
				getTimeScale: function () {
					return this._timeScale
				},
				start: function (t) {
					var e = this,
						i = function (n) {
							e._raf = requestAnimationFrame(i);
							var r = n - e._prevTime,
								a = r / (1e3 / 60) * e._timeScale;
							e._time = n, e._gameTime += r * e._timeScale, t(e._gameTime, a), e._prevTime = n
						};
					return this._raf = requestAnimationFrame(i), this
				},
				stop: function () {
					return cancelAnimationFrame(this._raf), this
				}
			}, e.default = n
		}, function (t, e, i) {
			"use strict";
			i.r(e);
			var n = i(3),
				r = i(8);

			function a(t) {
				r.default.call(this, t), this._object = new n.Group, this._sprites = [], this._settings
					.particlesEnabled ? this._generateParticles() : this._settings.fixedBackgroundEnabled && this
					._generateBackground()
			}
			Object.assign(a.prototype, r.default.prototype, {
				_generateBackground: function () {
					var t = new n.Mesh(new n.PlaneBufferGeometry(32, 64), new n.MeshBasicMaterial({
						color: this._settings.backgroundColor,
						map: this.base64ToTexture(this._settings.backgroundMap)
					}));
					return t.position.z = -2, this._object.add(t), this
				},
				_generateParticles: function () {
					var t, e, i, r = this._settings,
						a = [r.particle1, r.particle2, r.particle3],
						o = r.particleMap ? this.base64ToTexture(r.particleMap) : void 0;
					for (i = 0; i < r.nbParticle; i++) t = new n.Sprite(new n.SpriteMaterial({
							color: a[Math.round(Math.random() * a.length - 1)],
							map: o,
							transparent: !0
						})), e = Math.random() * (r.maxMinSize - r.minMinSize) + r.minMinSize, t.userData
						.angle = Math.random() * Math.PI * 2, t.userData.amplitude = .5 + .25 * Math
						.random(), t.userData.speed = Math.random() / 100, t.userData.cx = 40 * Math
						.random() - 20, t.userData.cy = 70 * Math.random() - 35, t.userData.x = 10 * Math
						.random(), t.userData.y = 10 * Math.random(), t.userData.scale1 = e, t.userData
						.scale2 = Math.random() * (r.maxMaxSize - r.minMaxSize) + r.minMaxSize, t.scale
						.set(e, e, 1), t.position.x = t.userData.x, t.position.y = t.userData.y, t
						.position.z = -10, this._object.add(t), this._sprites.push(t);
					return this
				},
				update: function (t, e) {
					var i, n, r, a;
					for (a = 0; a < this._sprites.length; a++) n = (i = this._sprites[a]).userData, r = i
						.userData.scale1 + Math.cos(n.angle) * i.userData.scale2, i.position.x = n.cx + n
						.x * Math.cos(n.angle) * n.amplitude, i.position.y = n.cy + n.y * Math.sin(n
							.angle) * n.amplitude, i.scale.x = r, i.scale.y = r, n.angle += n.speed * e;
					return this
				}
			}), e.default = a
		}, function (t, e, i) {
			"use strict";
			i.r(e);
			var n = i(3);

			function r(t) {
				this._settings = Object.assign({
						width: 1,
						height: 1,
						depth: 1,
						visible: !1
					}, t), this._object = new n.Group, this._box = new n.Mesh(new n.BoxBufferGeometry(this._settings
						.width, this._settings.height, this._settings.depth), new n.MeshBasicMaterial({
						color: 0,
						wireframe: !0,
						visible: this._settings.visible
					})), this._object.add(this._box), this._particlesDirectory = {}, this._particlesStorage = [], this
					._livingParticles = []
			}

			function a(t) {
				var e, i;
				return t[0] > t[1] ? (e = t[1], i = t[0]) : t[0] < t[1] && (e = t[0], i = t[1]), Math.random() * (i -
					e) + e
			}

			function o(t) {
				var e, i;
				for (e in t) i = t[e], Array.isArray(i) && Array.isArray(i[0])
			}

			function s(t, e) {
				this._settings = e
			}
			r.prototype = {
				getBoundingBox: function () {
					this._settings, this._box.position
				},
				setVisibility: function (t) {
					return this._settings.visible = t, this._box.material.visivle = t, this
				},
				getObject: function () {
					return this._object
				},
				addParticle: function (t, e) {
					return this._particlesDirectory[t] = e, this._particlesStorage.push(e), this
				},
				removeParticle: function (t) {
					var e = this._particlesStorage.indexOf(this._particlesDirectory[t]);
					return this._particlesStorage.splice(e, 1), delete this._particlesDirectory[t], this
				},
				emit: function (t, e) {
					var i, n = this._particlesStorage.length - 1;
					for (i = 0; i < e; i++) this._livingParticles.push(new s(o(this._particlesStorage[a([0,
						n])])));
					return this
				},
				update: function (t, e) {}
			}, s.prototype = {
				update: function (t, e) {}
			}, e.default = r
		}, function (t, e, i) {
			"use strict";

			function n(t) {
				this._currentState = t.currentState || 0, this._states = t.states, this._debug = t.debug
			}
			i.r(e), n.prototype = {
				set: function (t) {
					var e = this._states.indexOf(t);
					return -1 === e && console.error("[StatesManager] set : state " + t + " doesn't exist"),
						this._currentState !== t && this._debug && console.log("[StatesManager] set : " + t),
						this._currentState = e, this
				},
				is: function (t) {
					return this._currentState === this._states.indexOf(t)
				}
			}, e.default = n
		}]);
	</script>


</body>

</html>